(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/testing"],{

/***/ "./Animations/43444-trophy-animation.json":
/*!************************************************!*\
  !*** ./Animations/43444-trophy-animation.json ***!
  \************************************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"v":"5.3.3","fr":30,"ip":0,"op":90,"w":1920,"h":1920,"nm":"trophy-edit","ddd":1,"assets":[{"id":"comp_0","layers":[{"ddd":0,"ind":1,"ty":0,"nm":"trophy-animation","refId":"comp_1","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0],"y":[1.011]},"o":{"x":[0.333],"y":[0]},"n":["0_1p011_0p333_0"],"t":209.79,"s":[100],"e":[0]},{"t":226.023759206136}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":0,"op":231.018759409587,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":0,"nm":"ribbon","refId":"comp_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":0,"s":[728,511,0],"e":[728,1315,0],"to":[0,134,0],"ti":[0,-134,0]},{"t":136.113755544027}],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[68,68,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":0,"op":136.113755544027,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":0,"nm":"color-paper-bg","refId":"comp_3","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[1],"y":[-0.011]},"n":["0p667_1_1_-0p011"],"t":0,"s":[0],"e":[100]},{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":16.234,"s":[100],"e":[100]},{"i":{"x":[0],"y":[1.011]},"o":{"x":[0.333],"y":[0]},"n":["0_1p011_0p333_0"],"t":209.79,"s":[100],"e":[0]},{"t":226.023759206136}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":0,"op":299.700012207031,"st":0,"bm":0}]},{"id":"comp_1","layers":[{"ddd":0,"ind":1,"ty":4,"nm":"star","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0_1_0p333_0"],"t":42.458,"s":[-130],"e":[0]},{"t":67.432502746582}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.333,"y":0},"n":"0_1_0p333_0","t":42.458,"s":[1028.089,685.954,0],"e":[1028.089,651.954,0],"to":[0,-5.66666650772095,0],"ti":[0,5.66666650772095,0]},{"t":67.432502746582}],"ix":2},"a":{"a":0,"k":[19.645,21.169,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0,0,0.667],"y":[1,1,1]},"o":{"x":[0.333,0.333,0.333],"y":[0,0,0]},"n":["0_1_0p333_0","0_1_0p333_0","0p667_1_0p333_0"],"t":42.458,"s":[0,0,100],"e":[100,100,100]},{"t":67.432502746582}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[19.395,10.394],[5.603,9.411],[-3.055,20.919],[-6.47,6.633],[-19.395,1.572],[-7.666,-6.257],[-7.126,-20.919],[3.571,-11.549],[16.848,-15.52],[11.737,-1.843]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":1,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[19.645,21.169],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":42.4575017293294,"op":299.700012207031,"st":11.2387504577637,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"r flower mask","td":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1049,543,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"rc","d":1,"s":{"a":0,"k":[89,169.926],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"r":{"a":0,"k":0,"ix":4},"nm":"Rectangle Path 1","mn":"ADBE Vector Shape - Rect","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":5,"ix":5},"lc":1,"lj":1,"ml":4,"ml2":{"a":0,"k":4,"ix":8},"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"g":{"p":3,"k":{"a":0,"k":[0,0.965,0.592,0.141,0.5,0.971,0.637,0.186,1,0.976,0.682,0.231],"ix":9}},"s":{"a":0,"k":[0,0],"ix":5},"e":{"a":0,"k":[100,0],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[21.5,151.963],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Rectangle 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":11.2387504577637,"op":299.700012207031,"st":11.2387504577637,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"r flower","tt":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0],"y":[0.976]},"o":{"x":[0.333],"y":[0]},"n":["0_0p976_0p333_0"],"t":39.96,"s":[118],"e":[0]},{"t":71.1787528991699}],"ix":10},"p":{"a":0,"k":[1026,666,0],"ix":2},"a":{"a":0,"k":[-10.229,26.648,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.093,0.492],[1.157,-0.964],[1.828,-3.361],[-0.654,-2.593],[-1.929,0.632],[-1.375,2.462],[-0.053,4.937]],"o":[[-1.38,0.991],[-2.937,2.447],[-1.207,2.219],[0.506,2.013],[2.838,-0.928],[2.406,-4.309],[0.002,-0.179]],"v":[[6.437,-10.452],[2.616,-7.686],[-4.628,0.993],[-5.941,8.187],[-3.026,9.82],[3.01,4.328],[6.593,-9.602]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[55.745,28.025],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.211,0.003],[1.472,-2.962],[0.232,-3.174],[-1.528,-1.876],[-0.755,0.361],[-0.942,1.609],[0.181,4.217],[0.286,2.643]],"o":[[-2.474,2.249],[-1.39,2.798],[-0.17,2.316],[0.494,0.606],[1.703,-0.815],[2.183,-3.732],[-0.113,-2.649],[-0.211,-0.003]],"v":[[3.495,-12.002],[-2.16,-3.984],[-4.965,4.865],[-3.295,11.234],[-1.572,11.641],[2.368,7.993],[4.954,-4.064],[4.127,-11.992]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[40.254,41.244],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":3,"cix":2,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.457,0.429],[0.44,-1.88],[-0.901,-4.214],[-1.964,-1.492],[-0.833,1.017],[0.006,2.444],[3.317,4.987]],"o":[[-0.663,2.078],[-0.972,4.144],[0.494,2.308],[1.083,0.823],[1.594,-1.946],[-0.015,-6.055],[-0.123,-0.186]],"v":[[-1.536,-12.485],[-3.351,-6.709],[-3.773,5.848],[-0.326,11.662],[2.322,11.377],[4.669,4.719],[-0.751,-11.738]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[48.344,12.735],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":3,"cix":2,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.534,1.642],[0.131,-0.014],[3.465,-5.699],[-0.507,-2.089],[-0.435,-0.201],[-2.205,1.741],[-1.519,3.899]],"o":[[-0.497,-0.128],[-6.463,0.645],[-1.086,1.784],[0.113,0.465],[2.704,1.256],[3.332,-2.63],[0.584,-1.502]],"v":[[8.703,-8.501],[7.935,-8.693],[-7.376,0.236],[-8.196,6.242],[-7.203,7.451],[0.199,6.272],[7.157,-3.793]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[23.758,61.238],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":3,"cix":2,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.195,0.844],[1.558,-0.548],[3.734,-4.68],[-0.153,-2.336],[-0.908,-0.175],[-2.435,1.575],[-2.671,5.916]],"o":[[-1.888,0.49],[-5.496,1.932],[-1.406,1.761],[0.055,0.825],[2.976,0.575],[5.542,-3.586],[0.153,-0.341]],"v":[[10.846,-9.312],[5.756,-7.969],[-8.603,1.208],[-10.693,7.328],[-9.433,8.738],[-1.34,6.972],[10.471,-7.728]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[55.465,46.602],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":3,"cix":2,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.065,0.171],[1.783,0.98],[5.284,0.188],[2.137,-2.149],[-0.521,-0.827],[-3.218,-0.747],[-6.424,2.266]],"o":[[-1.705,-1.122],[-4.581,-2.52],[-2.85,-0.101],[-0.707,0.711],[1.838,2.909],[6.751,1.565],[0.067,-0.172]],"v":[[14.142,2.101],[9.013,-1.239],[-5.71,-5.695],[-13.376,-3.075],[-13.621,-0.932],[-5.789,4.231],[13.943,2.615]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[14.391,77.639],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":3,"cix":2,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.095,0.219],[1.12,0.101],[6.56,-3.149],[1.021,-3.088],[-0.913,-0.597],[-2.531,0.142],[-4.498,3.208],[-2.48,2.076]],"o":[[-1.111,-0.193],[-7.131,-0.642],[-2.816,1.352],[-0.314,0.948],[2.189,1.431],[5.674,-0.316],[2.626,-1.872],[-0.095,-0.219]],"v":[[15.023,-5.898],[11.687,-6.465],[-8.973,-3.385],[-14.993,3.053],[-14.332,5.219],[-7.198,6.965],[7.84,0.948],[15.307,-5.242]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[42.266,67.454],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":3,"cix":2,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":11.2387504577637,"op":299.700012207031,"st":11.2387504577637,"bm":0},{"ddd":0,"ind":4,"ty":4,"nm":"l flower mask","td":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"rc","d":1,"s":{"a":0,"k":[89,169.926],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"r":{"a":0,"k":0,"ix":4},"nm":"Rectangle Path 1","mn":"ADBE Vector Shape - Rect","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":5,"ix":5},"lc":1,"lj":1,"ml":4,"ml2":{"a":0,"k":4,"ix":8},"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"g":{"p":3,"k":{"a":0,"k":[0,0.965,0.592,0.141,0.5,0.971,0.637,0.186,1,0.976,0.682,0.231],"ix":9}},"s":{"a":0,"k":[0,0],"ix":5},"e":{"a":0,"k":[100,0],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[21.5,151.963],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Rectangle 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":11.2387504577637,"op":299.700012207031,"st":11.2387504577637,"bm":0},{"ddd":0,"ind":5,"ty":4,"nm":"l flower","tt":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0],"y":[1.024]},"o":{"x":[0.333],"y":[0]},"n":["0_1p024_0p333_0"],"t":39.96,"s":[-118],"e":[0]},{"t":71.1787528991699}],"ix":10},"p":{"a":0,"k":[1026,666,0],"ix":2},"a":{"a":0,"k":[73.716,26.648,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.093,0.492],[-1.156,-0.964],[-1.828,-3.361],[0.653,-2.593],[1.929,0.632],[1.375,2.462],[0.053,4.937]],"o":[[1.38,0.991],[2.938,2.447],[1.207,2.219],[-0.507,2.013],[-2.838,-0.928],[-2.406,-4.309],[-0.002,-0.179]],"v":[[-6.436,-10.452],[-2.616,-7.686],[4.629,0.993],[5.942,8.187],[3.027,9.82],[-3.009,4.328],[-6.593,-9.602]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[10.815,28.025],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.211,0.003],[-1.472,-2.962],[-0.232,-3.174],[1.528,-1.876],[0.755,0.361],[0.943,1.609],[-0.181,4.217],[-0.286,2.643]],"o":[[2.474,2.249],[1.39,2.798],[0.17,2.316],[-0.494,0.606],[-1.703,-0.815],[-2.183,-3.732],[0.113,-2.649],[0.211,-0.003]],"v":[[-3.495,-12.002],[2.16,-3.984],[4.965,4.865],[3.295,11.234],[1.572,11.641],[-2.368,7.993],[-4.954,-4.064],[-4.127,-11.992]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[26.306,41.244],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":3,"cix":2,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.457,0.429],[-0.44,-1.88],[0.901,-4.214],[1.964,-1.492],[0.833,1.017],[-0.006,2.444],[-3.317,4.987]],"o":[[0.663,2.078],[0.972,4.144],[-0.494,2.308],[-1.083,0.823],[-1.594,-1.946],[0.015,-6.055],[0.124,-0.186]],"v":[[1.537,-12.485],[3.351,-6.709],[3.774,5.848],[0.327,11.662],[-2.322,11.377],[-4.668,4.719],[0.751,-11.738]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[18.217,12.735],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":3,"cix":2,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.534,1.642],[-0.13,-0.014],[-3.465,-5.699],[0.507,-2.089],[0.434,-0.201],[2.205,1.741],[1.518,3.899]],"o":[[0.498,-0.128],[6.463,0.645],[1.085,1.784],[-0.113,0.465],[-2.705,1.256],[-3.333,-2.63],[-0.585,-1.502]],"v":[[-8.703,-8.501],[-7.936,-8.693],[7.376,0.236],[8.196,6.242],[7.203,7.451],[-0.199,6.272],[-7.156,-3.793]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[42.803,61.238],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":3,"cix":2,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.195,0.844],[-1.558,-0.548],[-3.734,-4.68],[0.153,-2.336],[0.908,-0.175],[2.435,1.575],[2.671,5.916]],"o":[[1.888,0.49],[5.496,1.932],[1.406,1.761],[-0.055,0.825],[-2.976,0.575],[-5.542,-3.586],[-0.153,-0.341]],"v":[[-10.846,-9.312],[-5.756,-7.969],[8.603,1.208],[10.693,7.328],[9.433,8.738],[1.34,6.972],[-10.471,-7.728]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[11.096,46.602],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":3,"cix":2,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.066,0.171],[-1.782,0.98],[-5.285,0.188],[-2.138,-2.149],[0.522,-0.827],[3.217,-0.747],[6.425,2.266]],"o":[[1.706,-1.122],[4.582,-2.52],[2.849,-0.101],[0.707,0.711],[-1.838,2.909],[-6.752,1.565],[-0.066,-0.172]],"v":[[-14.142,2.101],[-9.013,-1.239],[5.71,-5.695],[13.376,-3.075],[13.62,-0.932],[5.789,4.231],[-13.944,2.615]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[52.169,77.639],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":3,"cix":2,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.095,0.219],[-1.12,0.101],[-6.559,-3.149],[-1.022,-3.088],[0.913,-0.597],[2.531,0.142],[4.498,3.208],[2.48,2.076]],"o":[[1.112,-0.193],[7.132,-0.642],[2.816,1.352],[0.313,0.948],[-2.189,1.431],[-5.674,-0.316],[-2.625,-1.872],[0.095,-0.219]],"v":[[-15.023,-5.898],[-11.687,-6.465],[8.973,-3.385],[14.994,3.053],[14.332,5.219],[7.198,6.965],[-7.84,0.948],[-15.307,-5.242]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.611764705882,0.137254901961,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[24.294,67.454],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":3,"cix":2,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":11.2387504577637,"op":299.700012207031,"st":11.2387504577637,"bm":0},{"ddd":0,"ind":6,"ty":4,"nm":"body mask","td":1,"sr":1,"ks":{"o":{"a":0,"k":99,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[906,559,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"rc","d":1,"s":{"a":0,"k":[707.453,481.766],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"r":{"a":0,"k":0,"ix":4},"nm":"Rectangle Path 1","mn":"ADBE Vector Shape - Rect","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":5,"ix":5},"lc":1,"lj":1,"ml":4,"ml2":{"a":0,"k":4,"ix":8},"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"g":{"p":3,"k":{"a":0,"k":[0,0.965,0.592,0.141,0.5,0.971,0.637,0.186,1,0.976,0.682,0.231],"ix":9}},"s":{"a":0,"k":[0,0],"ix":5},"e":{"a":0,"k":[100,0],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[153.727,16.117],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Rectangle 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":11.2387504577637,"op":299.700012207031,"st":11.2387504577637,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"body Outlines","tt":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.209,"y":0.826},"o":{"x":0.396,"y":0},"n":"0p209_0p826_0p396_0","t":27.473,"s":[1027.237,905.212,0],"e":[1026,816.145,0],"to":[0,-14.1596021652222,0],"ti":[0,18.6528034210205,0]},{"i":{"x":0.618,"y":1},"o":{"x":0.283,"y":1},"n":"0p618_1_0p283_1","t":38.711,"s":[1026,816.145,0],"e":[1027.237,815.212,0],"to":[0,-1.10707783699036,0],"ti":[0,0.84039813280106,0]},{"t":42.4575017293294}],"ix":2},"a":{"a":0,"k":[177.793,308.05,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.117,0.117,0.667],"y":[1,1,1]},"o":{"x":[0.333,0.333,0.333],"y":[0,0,0]},"n":["0p117_1_0p333_0","0p117_1_0p333_0","0p667_1_0p333_0"],"t":27.473,"s":[25,25,100],"e":[100,100,100]},{"t":42.4575017293294}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,-10.986],[-10.985,0],[0,0],[0,10.984],[10.984,0]],"o":[[-10.985,0],[0,10.984],[0,0],[10.984,0],[0,-10.986],[0,0]],"v":[[-157.654,-19.89],[-177.543,0.001],[-157.654,19.89],[157.653,19.89],[177.543,0.001],[157.653,-19.89]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":1,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[0.972549079446,0.713725490196,0.298039215686,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[177.793,20.14],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[-4.272,-0.884]],"o":[[0,0],[0,0],[0,0],[0,0],[4.274,-0.884],[0,0]],"v":[[155.693,-6.999],[154.13,8.177],[-154.132,8.177],[-155.693,-6.999],[-154.132,-7.294],[154.13,-7.294]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.788235353956,0.321568627451,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[177.66,45.115],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":3,"cix":2,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.545,-4.651],[1.126,-4.926],[-1.055,4.617],[-0.665,5.676]],"o":[[-0.588,5.02],[-1.053,4.606],[1.274,-5.573],[0.549,-4.69]],"v":[[-2.122,-8.397],[-4.726,6.515],[2.363,8.47],[5.23,-8.397]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.933333393172,0.635294117647,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[297.851,180.185],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":3,"cix":2,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[2.011,-4.284],[29.898,-13.663],[-4.277,1.954],[-14.434,30.742]],"o":[[-13.974,29.76],[-4.298,1.964],[30.887,-14.115],[1.999,-4.257]],"v":[[31.743,-35.406],[-35.792,31.387],[-32.081,37.736],[38.09,-31.696]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.933333393172,0.635294117647,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[252.818,247.335],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":3,"cix":2,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[3.448,3.257],[5.059,6.924],[-2.797,-3.828],[-6.695,-6.325]],"o":[[-6.231,-5.886],[-2.763,-3.782],[5.432,7.434],[3.439,3.248]],"v":[[11.344,7.259],[-5.647,-11.925],[-11.995,-8.214],[6.145,12.458]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.819607902976,0.360784313725,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[93.423,250.712],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":3,"cix":2,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[1.914,4.288],[2.539,21.132],[1.714,14.268],[-0.565,-4.696],[-1.822,-15.167],[-8.992,-20.144]],"o":[[-8.813,-19.743],[-1.714,-14.269],[-0.558,-4.64],[1.821,15.166],[2.591,21.571],[1.925,4.312]],"v":[[12.401,50.474],[-1.255,-10.996],[-6.397,-53.801],[-13.749,-53.801],[-8.283,-8.301],[6.053,54.185]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.933000033509,0.635000011968,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[61.817,165.042],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":3,"cix":2,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[2.698,-0.544],[0,0],[0,0],[-69.951,0],[0,0],[-7.847,69.509],[0,0],[0,0],[75.564,0]],"o":[[0,0],[0,0],[7.846,69.509],[0,0],[69.951,0],[0,0],[0,0],[-2.698,-0.544],[-75.564,0]],"v":[[-153.825,-133.798],[-155.379,-133.485],[-137.832,12.572],[-1.24,134.613],[1.241,134.613],[137.833,12.572],[155.38,-133.485],[153.827,-133.798],[0.001,-134.614]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":1,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.819607902976,0.360784313725,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[177.326,173.437],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":3,"cix":2,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":11.2387504577637,"op":299.700012207031,"st":11.2387504577637,"bm":0},{"ddd":0,"ind":8,"ty":4,"nm":"shadow Outlines 2","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0_1_0p333_0"],"t":27.473,"s":[0],"e":[100]},{"t":42.4575017293294}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1026.77,833.835,0],"ix":2},"a":{"a":0,"k":[31.735,10.483,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[31.485,10.234],[28.428,-10.234],[-28.428,-10.234],[-31.485,10.234]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.945098099054,0.329411764706,0.247058838489,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[31.735,10.483],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":27.4725011189779,"op":299.700012207031,"st":11.2387504577637,"bm":0},{"ddd":0,"ind":9,"ty":4,"nm":"left handle","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":38.711,"s":[44],"e":[-5]},{"i":{"x":[0.833],"y":[1]},"o":{"x":[0.167],"y":[0]},"n":["0p833_1_0p167_0"],"t":49.95,"s":[-5],"e":[2]},{"i":{"x":[0.833],"y":[1]},"o":{"x":[0.167],"y":[0]},"n":["0p833_1_0p167_0"],"t":53.696,"s":[2],"e":[0]},{"t":57.442502339681}],"ix":10},"p":{"a":0,"k":[933.802,776.555,0],"ix":2},"a":{"a":0,"k":[124.697,206.698,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.667,0.667,0.667],"y":[1,1,1]},"o":{"x":[0.333,0.333,0.333],"y":[0,0,0]},"n":["0p667_1_0p333_0","0p667_1_0p333_0","0p667_1_0p333_0"],"t":38.711,"s":[83,83,100],"e":[100,100,100]},{"t":49.9500020345052}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-69.833,-7.324],[0,0],[0,54.185],[0,0]],"o":[[0,0],[0,71.741],[0,0],[-52.253,-7.151],[0,0],[0,0]],"v":[[-62.224,-87.152],[-62.224,-51.131],[62.224,87.152],[62.224,55.105],[-30.425,-51.131],[-30.425,-87.152]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":1,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[0.972549079446,0.713725490196,0.298039215686,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[62.474,119.546],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,54.185],[0,0],[0,0],[0,0],[0,0],[0,0],[-69.833,-7.324]],"o":[[-52.253,-7.15],[0,0],[0,0],[0,0],[0,0],[0,0],[0,71.741],[0,0]],"v":[[62.224,71.176],[-30.426,-35.059],[-30.426,-71.426],[62.224,-71.426],[62.224,-103.224],[-62.224,-103.224],[-62.224,-35.059],[62.224,103.224]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[0.972549079446,0.713725490196,0.298039215686,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[62.474,103.474],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":3,"cix":2,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":37.4625015258789,"op":299.700012207031,"st":11.2387504577637,"bm":0},{"ddd":0,"ind":10,"ty":4,"nm":"right handle","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":37.463,"s":[-44],"e":[5]},{"i":{"x":[0.833],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p833_1_0p333_0"],"t":48.701,"s":[5],"e":[-2]},{"i":{"x":[0.833],"y":[1]},"o":{"x":[0.167],"y":[0]},"n":["0p833_1_0p167_0"],"t":52.448,"s":[-2],"e":[0]},{"t":56.1937522888184}],"ix":10},"p":{"a":0,"k":[1120.213,776.555,0],"ix":2},"a":{"a":0,"k":[0.25,206.698,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.667,0.667,0.667],"y":[1,1,1]},"o":{"x":[0.333,0.333,0.333],"y":[0,0,0]},"n":["0p667_1_0p333_0","0p667_1_0p333_0","0p667_1_0p333_0"],"t":37.463,"s":[83,83,100],"e":[100,100,100]},{"t":48.7012519836426}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[52.252,-7.151],[0,0],[0,71.741],[0,0]],"o":[[0,0],[0,54.185],[0,0],[69.834,-7.324],[0,0],[0,0]],"v":[[30.426,-87.152],[30.426,-51.131],[-62.223,55.105],[-62.223,87.152],[62.223,-51.131],[62.223,-87.152]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":1,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[0.972549079446,0.713725490196,0.298039215686,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[62.473,119.546],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,54.185],[0,0],[0,0],[0,0],[0,0],[0,0],[69.833,-7.324]],"o":[[52.252,-7.15],[0,0],[0,0],[0,0],[0,0],[0,0],[0,71.741],[0,0]],"v":[[-62.223,71.176],[30.425,-35.059],[30.425,-71.426],[-62.223,-71.426],[-62.223,-103.224],[62.223,-103.224],[62.223,-35.059],[-62.223,103.224]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[0.972549079446,0.713725490196,0.298039215686,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[62.473,103.474],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":3,"cix":2,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":37.4625015258789,"op":299.700012207031,"st":11.2387504577637,"bm":0},{"ddd":0,"ind":11,"ty":4,"nm":"coin","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.333,"y":0},"n":"0_1_0p333_0","t":42.458,"s":[1029.094,592.214,0],"e":[1029.094,467.214,0],"to":[0,-20.8333339691162,0],"ti":[0,20.8333339691162,0]},{"t":71.1787528991699}],"ix":2},"a":{"a":0,"k":[76.333,76.332,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-26.824,36.202],[35.893,36.202],[35.893,23.245],[-10.139,23.245],[-6.883,-0.156],[11.461,-13.358],[11.461,-22.315],[-5.497,-10.115],[-1.868,-36.203],[-18.889,-36.203],[-23.139,2.579],[-35.893,11.756],[-35.893,20.724],[-24.206,12.311]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[38.961,39.271],[-30.247,39.271],[-28.008,18.827],[-38.961,26.711],[-38.961,10.183],[-26.042,0.888],[-21.641,-39.271],[1.658,-39.271],[-1.471,-16.793],[14.529,-28.302],[14.529,-11.786],[-4.026,1.566],[-6.613,20.178],[38.961,20.178]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":1,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 2","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[82.064,70.933],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":5,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-8.376,21.711],[-5.453,0.706],[12.994,-12.571],[12.994,-25.31],[-3.483,-13.453],[-0.105,-37.737],[-20.265,-37.737],[-24.591,1.734],[-37.428,10.97],[-37.428,23.716],[-26.107,15.57],[-28.536,37.737],[-8.376,37.737],[37.428,37.737],[37.428,21.711]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[82.064,70.934],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":3,"cix":2,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.886,12.941],[0,0],[-9.893,9.893]],"o":[[0,0],[12.942,-0.886],[9.893,-9.893]],"v":[[25.841,-25.839],[-25.837,25.839],[9.689,9.687]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[105.991,105.993],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":3,"cix":2,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[1.363,3.625],[0,0],[-3.787,-0.58]],"o":[[-0.58,-3.788],[0,0],[3.625,1.362],[0,0]],"v":[[37.302,-26.154],[34.381,-37.301],[-37.302,34.382],[-26.154,37.301]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[94.024,94.025],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":3,"cix":2,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[9.457,-9.457],[1.226,-12.345]],"o":[[-12.346,1.226],[-9.458,9.457],[0,0]],"v":[[24.919,-24.919],[-8.898,-8.898],[-24.919,24.919]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[45.883,45.883],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":3,"cix":2,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[3.861,0.492],[0,0],[-1.302,-3.71]],"o":[[-3.709,-1.301],[0,0],[0.492,3.861],[0,0]],"v":[[36.824,-34.147],[25.433,-36.824],[-36.824,25.433],[-34.146,36.824]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.973,57.974],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":3,"cix":2,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.905,1.634],[0,0],[-2.197,-2.634]],"o":[[-2.634,-2.197],[0,0],[1.634,2.905],[0,0]],"v":[[42.048,-36.307],[33.72,-42.048],[-42.048,33.72],[-36.307,42.048]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[69.87,69.871],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":3,"cix":2,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.24,2.581],[0,0],[-2.856,-1.686]],"o":[[-1.687,-2.855],[0,0],[2.58,2.24],[0,0]],"v":[[42.19,-34.026],[36.285,-42.19],[-42.19,36.286],[-34.026,42.19]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[82.088,82.088],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 8","np":3,"cix":2,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-37.216,0],[0,-37.217],[37.216,0],[0,37.215]],"o":[[37.216,0],[0,37.215],[-37.216,0],[0,-37.217]],"v":[[0,-67.493],[67.494,0.001],[0,67.493],[-67.494,0.001]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[76.332,76.332],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 9","np":3,"cix":2,"ix":9,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-41.952,0],[0,-41.953],[41.952,0],[0,41.951]],"o":[[41.952,0],[0,41.951],[-41.952,0],[0,-41.953]],"v":[[0,-76.083],[76.082,0],[0,76.083],[-76.082,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[76.332,76.332],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 10","np":3,"cix":2,"ix":10,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[42.02,0],[0,-42.02],[-42.019,0],[0,42.019]],"o":[[-42.019,0],[0,42.019],[42.02,0],[0,-42.02]],"v":[[0,-76.083],[-76.082,0],[0,76.083],[76.082,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[76.332,76.332],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 11","np":3,"cix":2,"ix":11,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[8.131,-20.084],[7.277,20.085],[-8.128,-7.531]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[61.52,92.164],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 12","np":3,"cix":2,"ix":12,"mn":"ADBE Vector Group","hd":false}],"ip":42.4575017293294,"op":299.700012207031,"st":11.2387504577637,"bm":0},{"ddd":0,"ind":12,"ty":4,"nm":"bottom","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.333,"y":0},"n":"0_1_0p333_0","t":6.244,"s":[1033.896,1139.739,0],"e":[1033.896,1037.739,0],"to":[0,-17,0],"ti":[0,17,0]},{"t":29.9700012207031}],"ix":2},"a":{"a":0,"k":[274.896,49.733,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-2.209,0],[0,0],[0,-2.209]],"o":[[0,0],[0,0],[0,-2.209],[0,0],[2.209,0],[0,0]],"v":[[274.646,50.134],[-274.646,50.134],[-274.646,-44.832],[-270.646,-48.832],[270.646,-48.832],[274.646,-44.832]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[0.2549019607843137,0.4588235294117647,0.0196078431372549,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[274.896,49.082],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":299.700012207031,"st":0,"bm":0},{"ddd":0,"ind":13,"ty":4,"nm":"up ","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":180,"ix":10},"p":{"a":0,"k":[1033.897,956.04,0],"ix":2},"a":{"a":0,"k":[184.454,49.733,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0,0.667,0.667],"y":[1,1,1]},"o":{"x":[0.333,0.333,0.333],"y":[0,0,0]},"n":["0_1_0p333_0","0p667_1_0p333_0","0p667_1_0p333_0"],"t":14.985,"s":[0,100,100],"e":[100,100,100]},{"t":29.9700012207031}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-2.209,0],[0,0],[0,-2.209]],"o":[[0,0],[0,0],[0,-2.209],[0,0],[2.209,0],[0,0]],"v":[[184.204,49.483],[-184.204,49.483],[-184.204,-45.483],[-180.204,-49.483],[180.204,-49.483],[184.204,-45.483]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.819607902976,0.360784313725,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[184.453,49.733],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"rd","nm":"Round Corners 1","r":{"a":0,"k":49,"ix":1},"ix":2,"mn":"ADBE Vector Filter - RC","hd":false}],"ip":0,"op":299.700012207031,"st":0,"bm":0},{"ddd":0,"ind":14,"ty":4,"nm":"neck","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.667,"y":1},"o":{"x":0.333,"y":0},"n":"0p667_1_0p333_0","t":24.975,"s":[1026.771,961.62,0],"e":[1026.771,854.62,0],"to":[0,-17.8333339691162,0],"ti":[0,17.8333339691162,0]},{"t":32.4675013224284}],"ix":2},"a":{"a":0,"k":[71.479,52.187,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[4.231,-2.092],[3.73,-3.909],[-3.274,3.431],[-4.333,2.142]],"o":[[-4.844,2.395],[-3.267,3.423],[3.337,-3.497],[4.241,-2.097]],"v":[[4.128,-8.042],[-8.812,1.504],[-3.614,6.703],[7.839,-1.694]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.62992589614,0.567815563725,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[25.896,78.989],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,-5.573],[-5.573,0],[0,0],[0,0],[0,-21.175],[0,0],[0,0],[0,0],[20.57,2.27],[0,0],[0,0],[0,5.572],[5.573,0]],"o":[[-5.573,0],[0,5.572],[0,0],[0,0],[-20.572,2.27],[0,0],[0,0],[0,0],[0,-21.175],[0,0],[0,0],[5.573,0],[0,-5.573],[0,0]],"v":[[-29.678,-51.937],[-39.769,-41.846],[-29.678,-31.756],[-28.318,-31.756],[-34.65,10.654],[-71.228,51.522],[-71.228,51.937],[71.229,51.937],[71.229,51.522],[34.653,10.654],[28.319,-31.756],[29.679,-31.756],[39.77,-41.846],[29.679,-51.937]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":1,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"mm","mm":4,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.439215716194,0.345098039216,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[71.478,52.187],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":3,"cix":2,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":24.9750010172526,"op":299.700012207031,"st":11.2387504577637,"bm":0}]},{"id":"comp_2","layers":[{"ddd":0,"ind":1,"ty":4,"nm":"Shape Layer 7","td":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-1.5,-36.5],[23,-18.5],[0,0]],"o":[[0,0],[1.5,36.5],[-23,18.5],[0,0]],"v":[[614,-159.5],[597.5,-110.5],[569,-31.5],[466.5,40.5]],"c":false},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.5,0.5,0.5,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":22,"ix":5},"lc":1,"lj":1,"ml":4,"ml2":{"a":0,"k":4,"ix":8},"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":true},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"tm","s":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":42.458,"s":[0],"e":[0]},{"t":51.1987520853678}],"ix":1},"e":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":42.458,"s":[0],"e":[100]},{"t":51.1987520853678}],"ix":2},"o":{"a":0,"k":0,"ix":3},"m":1,"ix":2,"nm":"Trim Paths 1","mn":"ADBE Vector Filter - Trim","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"Layer 23 Outlines","tt":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1499.224,486.765,0],"ix":2},"a":{"a":0,"k":[69.367,96.854,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[1.295,-0.727],[1.372,-2.221],[0.136,-0.235],[0.069,-0.119],[0.158,-0.283],[0.437,-0.895],[0.157,-0.339],[0.168,-0.389],[0.108,-0.263],[0.11,-0.306],[0.106,-0.308],[0.1,-0.314],[0.216,-0.751],[0.052,-0.224],[0.056,-0.232],[0.047,-0.206],[0.051,-0.225],[0.061,-0.327],[0.059,-0.354],[-0.667,-10.2],[1.581,-9.894],[1.686,-4.187],[1.253,-2.107],[0.508,-0.715],[0.006,-0.007],[0.096,-0.136],[0.313,-0.309],[0.762,-0.694],[11.139,-7.063],[17.916,-17.487],[1.133,-0.99],[0,-0.001],[0.709,-0.562],[0.081,-0.064],[0.753,-0.52],[0.058,-0.04],[0.685,-0.409],[0.194,-0.111],[0.806,-0.383],[0.856,-1.013],[-0.354,0.111],[-3.444,3.125],[-2.77,2.339],[0.011,-0.005],[-1.916,1.463],[-10.945,6.803],[-15.648,16.378],[0,0],[-1.573,1.864],[-2.668,9.85],[0.262,9.306],[-0.234,10.407],[-1.808,5.219],[-0.1,0.27],[-0.361,0.774],[-0.558,0.986]],"o":[[-1.67,2.079],[-0.147,0.236],[-0.067,0.109],[-0.166,0.275],[-0.487,0.86],[-0.158,0.341],[-0.18,0.389],[-0.107,0.261],[-0.126,0.302],[-0.124,0.302],[-0.116,0.301],[-0.252,0.728],[-0.063,0.224],[-0.068,0.232],[-0.054,0.199],[-0.05,0.224],[-0.07,0.321],[-0.079,0.346],[-1.774,10.145],[0.653,9.97],[-0.709,4.469],[-0.912,2.277],[-0.454,0.767],[-0.007,0.004],[-0.095,0.136],[-0.188,0.19],[-0.742,0.711],[-9.73,8.964],[-21.01,13.326],[-1.088,1.063],[-0.001,0],[-0.684,0.597],[-0.08,0.064],[-0.72,0.564],[-0.057,0.04],[-0.655,0.447],[-0.192,0.114],[-0.762,0.437],[-1.24,0.597],[-0.185,0.212],[4.496,-1.437],[2.715,-2.461],[-0.011,0.005],[1.815,-1.537],[10.255,-7.823],[19.131,-11.886],[0,0],[1.677,-1.756],[6.538,-7.732],[2.46,-9.026],[-0.289,-10.412],[0.125,-5.538],[0.096,-0.272],[0.302,-0.795],[0.48,-1.038],[-1.34,0.616]],"v":[[65.15,-94.604],[60.573,-88.167],[60.148,-87.464],[59.946,-87.117],[59.456,-86.273],[58.068,-83.635],[57.587,-82.622],[57.069,-81.459],[56.738,-80.668],[56.384,-79.751],[56.041,-78.826],[55.72,-77.911],[55.027,-75.688],[54.85,-75.014],[54.671,-74.319],[54.52,-73.711],[54.368,-73.036],[54.174,-72.071],[53.974,-71.021],[54.451,-40.154],[53.902,-10.227],[50.248,2.776],[46.95,9.333],[45.49,11.542],[45.478,11.565],[45.193,11.965],[44.449,12.711],[42.19,14.828],[10.106,38.127],[-51.119,81.352],[-54.447,84.434],[-54.449,84.435],[-56.538,86.171],[-56.779,86.364],[-58.986,87.993],[-59.162,88.111],[-61.175,89.391],[-61.753,89.73],[-64.096,90.969],[-67.334,94.257],[-68.763,96.493],[-57.428,89.083],[-49.247,81.878],[-49.28,81.891],[-43.71,77.375],[-11.316,56.185],[43.15,16.193],[43.155,16.19],[48.028,10.776],[62.398,-15.044],[64.804,-42.935],[63.303,-74.181],[66.257,-90.397],[66.551,-91.211],[67.545,-93.573],[69.117,-96.604]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.976000019148,0.681999954523,0.231000010173,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[69.367,96.855],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"Shape Layer 6","td":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[24.5,-1],[8,-20]],"o":[[0,0],[-24.5,1],[-8,20]],"v":[[717.5,-190],[679.5,-168],[603,-148]],"c":false},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.5,0.5,0.5,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":22,"ix":5},"lc":1,"lj":1,"ml":4,"ml2":{"a":0,"k":4,"ix":8},"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":true},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"tm","s":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":36.214,"s":[0],"e":[0]},{"t":42.4575017293294}],"ix":1},"e":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":36.214,"s":[1],"e":[100]},{"t":42.4575017293294}],"ix":2},"o":{"a":0,"k":0,"ix":3},"m":1,"ix":2,"nm":"Trim Paths 1","mn":"ADBE Vector Filter - Trim","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":4,"nm":"Layer 21 Outlines","tt":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1618.64,375.452,0],"ix":2},"a":{"a":0,"k":[54.517,16.959,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-1.514,1.624],[-11.026,1.727],[-18.542,5.298],[-4.325,2.801],[-1.841,1.713],[1.007,-1.553],[0,0],[15.529,-1.138],[17.669,-9.33],[1.386,-1.06],[0.006,-0.018],[1.296,-0.726]],"o":[[7.499,-8.011],[18.885,-2.945],[4.944,-1.403],[2.108,-1.364],[-0.54,1.662],[0,0],[-10.457,10.56],[-19,1.392],[-1.544,0.809],[-0.004,0.019],[-1.34,0.617],[1.344,-1.68]],"v":[[-49.967,11.771],[-23.109,-3.584],[34.167,-5.903],[48.217,-12.175],[54.266,-16.709],[51.867,-11.829],[51.862,-11.822],[13.104,7.577],[-45.766,11.943],[-50.271,14.655],[-50.299,14.708],[-54.266,16.709]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.941000007181,0.635000011968,0.238999998803,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[54.516,16.959],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":4,"nm":"Shape Layer 5","td":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[39,-113.5]],"o":[[0,0],[-32.349,94.143]],"v":[[691.5,-257.5],[713,-183]],"c":false},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.5,0.5,0.5,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":22,"ix":5},"lc":1,"lj":1,"ml":4,"ml2":{"a":0,"k":4,"ix":8},"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":true},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"tm","s":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":27.473,"s":[0],"e":[0]},{"t":36.2137514750163}],"ix":1},"e":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":27.473,"s":[0],"e":[100]},{"t":36.2137514750163}],"ix":2},"o":{"a":0,"k":0,"ix":3},"m":1,"ix":2,"nm":"Trim Paths 1","mn":"ADBE Vector Filter - Trim","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":4,"nm":"Layer 22 Outlines","tt":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1673.844,315.342,0],"ix":2},"a":{"a":0,"k":[20.865,48.53,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[4.854,-7.452],[0.228,-0.571],[-3.545,-1.471],[0.026,0.055],[-1.437,-0.872],[-2.028,-4.342],[-0.247,-0.575],[-0.591,-3.301],[0.204,-3.517],[-0.029,-0.002],[0.074,-2.364],[5.415,-9.081],[0.704,-0.986],[0.018,-0.029],[0.024,-0.012],[0,0],[1.007,-1.553],[-3.445,4.841],[-1.374,10.926],[-0.019,-0.007],[-0.117,0.392],[-0.062,1.578],[0.096,1.678],[0.028,0.655],[1.056,4.042],[9.534,3.787]],"o":[[-0.355,0.551],[2.939,-2.92],[-0.021,-0.064],[1.965,0.649],[4.238,2.565],[0.266,0.568],[1.554,2.625],[0.595,3.353],[0.027,0.02],[0.169,2.385],[-0.319,10.599],[-0.624,1.049],[-0.023,0.035],[-0.011,0.013],[0,0],[-0.54,1.662],[4.144,-4.174],[6.536,-9.178],[0.027,-0.002],[-0.025,-0.34],[0.456,-1.489],[0.066,-1.677],[-0.032,-0.659],[-0.29,-4.107],[-2.449,-9.405],[-9.879,-3.917]],"v":[[-19.752,-31.473],[-20.615,-29.797],[-9.519,-32.824],[-9.592,-33.003],[-4.314,-30.517],[4.632,-18.779],[5.395,-17.063],[8.28,-8.295],[9.856,2.685],[9.944,2.712],[10.083,9.851],[1.177,40.215],[-0.822,43.268],[-0.885,43.357],[-0.931,43.393],[-0.937,43.4],[-3.337,48.28],[8.025,34.648],[19.981,4],[20.043,3.999],[20.158,2.902],[20.444,-2.176],[20.441,-7.197],[20.339,-9.158],[18.328,-21.41],[1.967,-44.363]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.976000019148,0.681999954523,0.231000010173,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[20.864,48.53],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"Shape Layer 4","td":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[12,59.5]],"o":[[0,0],[-12,-59.5]],"v":[[760,-241.5],[698,-267]],"c":false},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.5,0.5,0.5,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":19,"ix":5},"lc":1,"lj":1,"ml":4,"ml2":{"a":0,"k":4,"ix":8},"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":true},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"tm","s":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":19.98,"s":[0],"e":[0]},{"t":27.4725011189779}],"ix":1},"e":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":19.98,"s":[0],"e":[100]},{"t":27.4725011189779}],"ix":2},"o":{"a":0,"k":0,"ix":3},"m":1,"ix":2,"nm":"Trim Paths 1","mn":"ADBE Vector Filter - Trim","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":8,"ty":4,"nm":"Layer 20 Outlines","tt":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1684.09,300.194,0],"ix":2},"a":{"a":0,"k":[33.701,19.397,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[3.2,1.077],[0.088,0.027],[6.033,6.553],[-2.59,6.564],[-3.545,-1.471],[-0.369,-0.688],[-2.969,-2.775],[-2.61,-1.673],[-6.683,-1.233],[-0.623,-0.129],[-4.395,0.728],[-2.003,0.88],[-0.596,0.336],[-0.01,0.047],[0.022,-0.059],[0.262,-0.425],[0.259,-0.469],[0.014,-0.03],[0.718,-1.167],[0,0],[4.691,-0.027]],"o":[[-0.097,-0.021],[-8.518,-2.332],[-4.212,-4.578],[2.939,-2.92],[0.27,0.717],[1.894,3.581],[2.25,2.099],[0,0],[0.616,0.16],[4.347,0.866],[2.152,-0.356],[0.65,-0.279],[0.017,-0.041],[-0.017,0.051],[-0.146,0.477],[-0.17,0.508],[-0.018,0.032],[-0.468,1.252],[-1.893,2.798],[-4.274,2.055],[0,0]],"v":[[-0.389,17.833],[-0.668,17.766],[-23.491,4.426],[-30.861,-14.649],[-19.764,-17.676],[-18.814,-15.567],[-11.495,-5.922],[-4.175,-0.227],[10.093,5.99],[11.946,6.41],[25.233,6.951],[31.536,5.223],[33.406,4.331],[33.451,4.201],[33.403,4.371],[32.786,5.725],[32.181,7.198],[32.132,7.278],[30.304,10.959],[23.415,16.102],[9.797,19.147]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.941000007181,0.635000011968,0.238999998803,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[33.7,19.397],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"tm","s":{"a":0,"k":0,"ix":1},"e":{"a":0,"k":100,"ix":2},"o":{"a":0,"k":0,"ix":3},"m":1,"ix":2,"nm":"Trim Paths 1","mn":"ADBE Vector Filter - Trim","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":9,"ty":4,"nm":"Shape Layer 3","td":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-18,-25],[2.5,-4.5]],"o":[[0,0],[18,25],[-2.5,4.5]],"v":[[756,-322],[758,-277],[753.5,-233]],"c":false},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.5,0.5,0.5,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":19,"ix":5},"lc":1,"lj":1,"ml":4,"ml2":{"a":0,"k":4,"ix":8},"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":true},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"tm","s":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":11.239,"s":[0],"e":[0]},{"t":19.9800008138021}],"ix":1},"e":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":11.239,"s":[7],"e":[100]},{"t":19.9800008138021}],"ix":2},"o":{"a":0,"k":0,"ix":3},"m":1,"ix":2,"nm":"Trim Paths 1","mn":"ADBE Vector Filter - Trim","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":10,"ty":4,"nm":"Layer 19 Outlines","tt":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1717.075,269.571,0],"ix":2},"a":{"a":0,"k":[14.612,41.832,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.207,0.26],[-0.216,0.036],[-1.39,0.207],[0.044,-0.014],[-0.214,-2.482],[-3.818,-10.541],[3.039,-8.312],[3.582,-4.022],[0.481,-0.537],[0.09,-0.1],[1.205,-1.177],[-0.468,1.252],[-0.017,0.032],[-0.17,0.508],[-0.146,0.477],[-0.017,0.052],[0,0],[-0.038,0.102],[-0.042,0.142],[-0.167,0.752],[-0.011,0.024],[-0.005,0.017],[-0.061,0.317],[-0.041,0.336],[-0.036,0.332],[0.019,1.29],[0.029,0.516],[0.005,0.127],[0.042,0.393],[0.082,0.51],[0.094,0.509],[0.108,0.479],[0.026,0.116],[0.102,0.413],[0.699,1.928],[0.963,11.233],[-4.465,5.759]],"o":[[0.209,0.006],[1.411,-0.233],[-0.042,0.018],[-0.566,2.401],[0.984,11.47],[2.912,8.022],[-1.867,5.111],[-0.456,0.511],[-0.077,0.097],[-1.086,1.208],[0.718,-1.166],[0.015,-0.03],[0.259,-0.469],[0.261,-0.425],[0.022,-0.058],[0,0],[0.044,-0.106],[0.055,-0.143],[0.256,-0.727],[0.003,-0.02],[0.001,-0.01],[0.072,-0.307],[0.071,-0.319],[0.055,-0.336],[0.161,-1.265],[-0.006,-0.517],[-0.01,-0.121],[-0.025,-0.389],[-0.044,-0.527],[-0.059,-0.52],[-0.077,-0.491],[-0.022,-0.112],[-0.084,-0.42],[-0.494,-2.029],[-3.763,-10.388],[-0.634,-7.355],[0.194,-0.257]],"v":[[-7.41,-40.749],[-6.772,-40.785],[-2.657,-41.582],[-2.778,-41.537],[-3.265,-34.169],[9.227,-3.162],[11.323,22.717],[2.42,36.092],[1.007,37.672],[0.75,37.964],[-2.681,41.582],[-0.854,37.901],[-0.804,37.821],[-0.198,36.348],[0.418,34.994],[0.465,34.824],[0.471,34.817],[0.583,34.503],[0.726,34.07],[1.36,31.847],[1.381,31.776],[1.385,31.734],[1.589,30.789],[1.758,29.803],[1.893,28.804],[2.096,24.964],[2.048,23.409],[2.029,23.042],[1.931,21.867],[1.748,20.322],[1.507,18.781],[1.23,17.326],[1.158,16.988],[0.869,15.728],[-0.944,9.771],[-13.728,-21.35],[-8.021,-39.971]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.976000019148,0.681999954523,0.231000010173,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[14.612,41.832],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":11,"ty":4,"nm":"Shape Layer 2","td":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[59.5,-13.5]],"o":[[0,0],[-59.5,13.5]],"v":[[787,-287],[746.75,-318.75]],"c":false},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.5,0.5,0.5,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":19,"ix":5},"lc":1,"lj":1,"ml":4,"ml2":{"a":0,"k":4,"ix":8},"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":true},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"tm","s":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":3.746,"s":[0],"e":[0]},{"t":11.2387504577637}],"ix":1},"e":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":3.746,"s":[0],"e":[100]},{"t":11.2387504577637}],"ix":2},"o":{"a":0,"k":0,"ix":3},"m":1,"ix":2,"nm":"Trim Paths 1","mn":"ADBE Vector Filter - Trim","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":12,"ty":4,"nm":"Layer 18 Outlines","tt":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1735.417,233.866,0],"ix":2},"a":{"a":0,"k":[26.614,19.627,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-7.335,1.686],[-5.228,-2.023],[4.502,-11.457],[2.136,-1.829],[1.417,-0.465],[0.125,2.673],[0.032,0.242],[0.736,1.052],[0.645,0.707],[-0.027,-0.027],[5.147,1.749],[5.377,-1.781],[0.145,-0.056],[0,0],[1.411,-0.233],[0.209,0.005],[0.195,-0.256]],"o":[[5.475,-1.256],[10.254,3.973],[-1.084,2.766],[-0.925,0.791],[1.261,-2.576],[-0.018,-0.254],[-0.37,-1.236],[-0.56,-0.799],[0.03,0.028],[-3.11,-4.337],[-5.256,-1.782],[-0.139,0.052],[0,0],[-1.391,0.206],[-0.215,0.035],[-0.207,0.26],[4.4,-5.669]],"v":[[-9.138,-18.121],[7.45,-16.708],[21.862,8.162],[16.429,15.978],[11.894,19.377],[13.049,10.603],[12.973,9.866],[11.329,6.391],[9.466,4.223],[9.553,4.295],[-3.731,-5.112],[-20.559,-6.031],[-20.987,-5.877],[-20.999,-5.876],[-25.115,-5.079],[-25.753,-5.043],[-26.364,-4.266]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.941000007181,0.635000011968,0.238999998803,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[26.614,19.627],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":13,"ty":4,"nm":"Shape Layer 1","td":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-5.5,-0.5]],"o":[[0,0],[5.5,0.5]],"v":[[777,-304.5],[794,-291.5]],"c":false},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.5,0.5,0.5,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":19,"ix":5},"lc":1,"lj":1,"ml":4,"ml2":{"a":0,"k":4,"ix":8},"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":true},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"tm","s":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":0,"s":[0],"e":[0]},{"t":3.74625015258789}],"ix":1},"e":{"a":1,"k":[{"i":{"x":[0.667],"y":[1]},"o":{"x":[0.333],"y":[0]},"n":["0p667_1_0p333_0"],"t":0,"s":[15],"e":[100]},{"t":3.74625015258789}],"ix":2},"o":{"a":0,"k":0,"ix":3},"m":1,"ix":2,"nm":"Trim Paths 1","mn":"ADBE Vector Filter - Trim","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":0,"ind":14,"ty":4,"nm":"Layer 17 Outlines","tt":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1741.513,245.545,0],"ix":2},"a":{"a":0,"k":[7.327,8.582,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.382,-0.359],[-0.199,-0.167],[-0.56,-0.799],[-0.37,-1.236],[-0.017,-0.253],[1.261,-2.575],[0.111,-0.008],[2.875,4.546]],"o":[[0.186,0.176],[0.645,0.707],[0.736,1.052],[0.032,0.243],[0.125,2.674],[-0.11,0.047],[-5.305,0.554],[-0.806,-1.279]],"v":[[2.783,-7.973],[3.37,-7.456],[5.233,-5.288],[6.877,-1.814],[6.952,-1.077],[5.798,7.697],[5.46,7.778],[-6.271,2.193]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.976000019148,0.681999954523,0.231000010173,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[7.327,8.582],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0}]},{"id":"comp_3","layers":[{"ddd":0,"ind":1,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1164,511,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":149.850006103516,"op":270.978761037191,"st":121.128754933675,"bm":0},{"ddd":0,"ind":2,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1396,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":270.978761037191,"op":299.700012207031,"st":270.978761037191,"bm":0},{"ddd":0,"ind":3,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":149.850006103516,"op":264.735010782878,"st":114.885004679362,"bm":0},{"ddd":0,"ind":4,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":264.735010782878,"op":299.700012207031,"st":264.735010782878,"bm":0},{"ddd":0,"ind":5,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[647,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":149.850006103516,"op":229.770009358724,"st":79.9200032552083,"bm":0},{"ddd":0,"ind":6,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[647,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":229.770009358724,"op":299.700012207031,"st":229.770009358724,"bm":0},{"ddd":0,"ind":7,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":149.850006103516,"op":299.700012207031,"st":149.850006103516,"bm":0},{"ddd":0,"ind":8,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1396,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":0,"op":121.128754933675,"st":-28.7212511698405,"bm":0},{"ddd":0,"ind":9,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[1396,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":121.128754933675,"op":149.850006103516,"st":121.128754933675,"bm":0},{"ddd":0,"ind":10,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":0,"op":114.885004679362,"st":-34.9650014241536,"bm":0},{"ddd":0,"ind":11,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":114.885004679362,"op":149.850006103516,"st":114.885004679362,"bm":0},{"ddd":0,"ind":12,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[647,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":0,"op":79.9200032552083,"st":-69.9300028483073,"bm":0},{"ddd":0,"ind":13,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[647,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":79.9200032552083,"op":149.850006103516,"st":79.9200032552083,"bm":0},{"ddd":0,"ind":14,"ty":0,"nm":"trophy-bg","refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,543,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":0,"op":149.850006103516,"st":0,"bm":0}]},{"id":"comp_4","layers":[{"ddd":1,"ind":1,"ty":4,"nm":"blue Outlines 3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":0,"k":0,"ix":8},"ry":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":-77.423,"s":[0],"e":[630]},{"t":42.4575017293294}],"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":-77.423,"s":[699.151,-29.138,0],"e":[699.151,1112.862,0],"to":[0,190.33332824707,0],"ti":[0,-190.33332824707,0]},{"t":42.4575017293294}],"ix":2},"a":{"a":0,"k":[18.579,26.554,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[18.329,6.006],[5.524,26.304],[-18.329,4.893],[0.831,-26.304]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.105999995213,0.458999992819,0.725,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[18.579,26.554],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":42.4575017293294,"st":-77.4225031534831,"bm":0},{"ddd":1,"ind":2,"ty":4,"nm":"blue Outlines 2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":0,"k":0,"ix":8},"ry":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":73.676,"s":[0],"e":[630]},{"t":193.556257883708}],"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":73.676,"s":[699.151,-29.138,0],"e":[699.151,1112.862,0],"to":[0,190.33332824707,0],"ti":[0,-190.33332824707,0]},{"t":193.556257883708}],"ix":2},"a":{"a":0,"k":[18.579,26.554,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[18.329,6.006],[5.524,26.304],[-18.329,4.893],[0.831,-26.304]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.105999995213,0.458999992819,0.725,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[18.579,26.554],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":73.6762530008952,"op":149.850006103516,"st":73.6762530008952,"bm":0},{"ddd":1,"ind":3,"ty":4,"nm":"rose Outlines 5","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":-29.97,"s":[0],"e":[1424]},{"t":89.9100036621094}],"ix":8},"ry":{"a":0,"k":0,"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":-29.97,"s":[865.267,-29.078,0],"e":[865.267,1140.922,0],"to":[0,195,0],"ti":[112,-281.5,0]},{"t":89.9100036621094}],"ix":2},"a":{"a":0,"k":[15.226,23.714,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[14.976,-1.235],[13.969,23.464],[-14.976,9.296],[-13.704,-23.464]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.913999968884,0,0.536999990426,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[15.226,23.714],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":89.9100036621094,"st":-46.2037518819173,"bm":0},{"ddd":1,"ind":4,"ty":4,"nm":"rose Outlines 4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":119.88,"s":[0],"e":[1424]},{"t":239.760009765625}],"ix":8},"ry":{"a":0,"k":0,"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":119.88,"s":[865.267,-29.078,0],"e":[865.267,1140.922,0],"to":[0,195,0],"ti":[112,-281.5,0]},{"t":239.760009765625}],"ix":2},"a":{"a":0,"k":[15.226,23.714,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[14.976,-1.235],[13.969,23.464],[-14.976,9.296],[-13.704,-23.464]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.913999968884,0,0.536999990426,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[15.226,23.714],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":119.880004882812,"op":149.850006103516,"st":103.646254221598,"bm":0},{"ddd":1,"ind":5,"ty":4,"nm":"cyan Outlines 3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":-87.413,"s":[0],"e":[872]},{"t":61.1887524922689}],"ix":8},"ry":{"a":0,"k":0,"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":-87.413,"s":[1003.537,-19.035,0],"e":[1003.537,1113.965,0],"to":[0,188.83332824707,0],"ti":[0,-188.83332824707,0]},{"t":61.1887524922689}],"ix":2},"a":{"a":0,"k":[8.836,8.544,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[8.586,7.234],[-6.939,8.295],[-8.586,-1.071],[2.361,-8.295]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.136999990426,0.725,0.713999968884,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[8.835,8.545],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":61.1887524922689,"st":-87.4125035603841,"bm":0},{"ddd":1,"ind":6,"ty":4,"nm":"cyan Outlines 2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":62.438,"s":[0],"e":[872]},{"t":211.038758595785}],"ix":8},"ry":{"a":0,"k":0,"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":62.438,"s":[1003.537,-19.035,0],"e":[1003.537,1113.965,0],"to":[0,188.83332824707,0],"ti":[0,-188.83332824707,0]},{"t":211.038758595785}],"ix":2},"a":{"a":0,"k":[8.836,8.544,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[8.586,7.234],[-6.939,8.295],[-8.586,-1.071],[2.361,-8.295]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.136999990426,0.725,0.713999968884,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[8.835,8.545],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":62.4375025431315,"op":149.850006103516,"st":62.4375025431315,"bm":0},{"ddd":1,"ind":7,"ty":4,"nm":"yellow Outlines 3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":-28.721,"s":[0],"e":[769]},{"t":91.158753712972}],"ix":8},"ry":{"a":0,"k":0,"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":-28.721,"s":[370.371,-15.238,0],"e":[370.371,1105.762,0],"to":[-134,233.83332824707,0],"ti":[0,-186.83332824707,0]},{"t":91.158753712972}],"ix":2},"a":{"a":0,"k":[10.208,11.089,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[9.958,5.755],[-5.534,10.839],[-9.958,-4.892],[8.752,-10.839]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.192156862745,0.788235294118,0.674509803922,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[10.208,11.089],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":-28.7212511698405,"bm":0},{"ddd":1,"ind":8,"ty":4,"nm":"yellow Outlines 2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":121.129,"s":[0],"e":[769]},{"t":241.008759816488}],"ix":8},"ry":{"a":0,"k":0,"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":121.129,"s":[370.371,-15.238,0],"e":[370.371,1105.762,0],"to":[-134,233.83332824707,0],"ti":[0,-186.83332824707,0]},{"t":241.008759816488}],"ix":2},"a":{"a":0,"k":[10.208,11.089,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[9.958,5.755],[-5.534,10.839],[-9.958,-4.892],[8.752,-10.839]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.192156862745,0.788235294118,0.674509803922,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[10.208,11.089],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":121.128754933675,"op":149.850006103516,"st":121.128754933675,"bm":0},{"ddd":1,"ind":9,"ty":4,"nm":"yellow Outlines","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[769]},{"t":119.880004882812}],"ix":8},"ry":{"a":0,"k":0,"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":0,"s":[871.371,-15.238,0],"e":[871.371,1105.762,0],"to":[-134,233.83332824707,0],"ti":[0,-186.83332824707,0]},{"t":119.880004882812}],"ix":2},"a":{"a":0,"k":[10.208,11.089,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[9.958,5.755],[-5.534,10.839],[-9.958,-4.892],[8.752,-10.839]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.192156862745,0.788235294118,0.674509803922,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[10.208,11.089],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":1,"ind":10,"ty":4,"nm":"cyan Outlines","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[872]},{"t":148.601256052653}],"ix":8},"ry":{"a":0,"k":0,"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":0,"s":[1003.537,-19.035,0],"e":[1003.537,1113.965,0],"to":[0,188.83332824707,0],"ti":[0,-188.83332824707,0]},{"t":148.601256052653}],"ix":2},"a":{"a":0,"k":[8.836,8.544,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[8.586,7.234],[-6.939,8.295],[-8.586,-1.071],[2.361,-8.295]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.136999990426,0.725,0.713999968884,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[8.835,8.545],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":1,"ind":11,"ty":4,"nm":"blue Outlines 5","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":0,"k":0,"ix":8},"ry":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":-76.174,"s":[0],"e":[630]},{"t":43.7062517801921}],"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":-76.174,"s":[1442.151,-29.138,0],"e":[1442.151,1112.862,0],"to":[0,190.33332824707,0],"ti":[0,-190.33332824707,0]},{"t":43.7062517801921}],"ix":2},"a":{"a":0,"k":[18.579,26.554,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[18.329,6.006],[5.524,26.304],[-18.329,4.893],[0.831,-26.304]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.105999995213,0.458999992819,0.725,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[18.579,26.554],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":-76.1737531026204,"bm":0},{"ddd":1,"ind":12,"ty":4,"nm":"blue Outlines 4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":0,"k":0,"ix":8},"ry":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":74.925,"s":[0],"e":[630]},{"t":194.80500793457}],"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":74.925,"s":[1442.151,-29.138,0],"e":[1442.151,1112.862,0],"to":[0,190.33332824707,0],"ti":[0,-190.33332824707,0]},{"t":194.80500793457}],"ix":2},"a":{"a":0,"k":[18.579,26.554,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[18.329,6.006],[5.524,26.304],[-18.329,4.893],[0.831,-26.304]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.105999995213,0.458999992819,0.725,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[18.579,26.554],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":74.9250030517578,"op":149.850006103516,"st":74.9250030517578,"bm":0},{"ddd":1,"ind":13,"ty":4,"nm":"blue Outlines","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":0,"k":0,"ix":8},"ry":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[630]},{"t":119.880004882812}],"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":0,"s":[1442.151,-29.138,0],"e":[1442.151,1112.862,0],"to":[0,190.33332824707,0],"ti":[0,-190.33332824707,0]},{"t":119.880004882812}],"ix":2},"a":{"a":0,"k":[18.579,26.554,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[18.329,6.006],[5.524,26.304],[-18.329,4.893],[0.831,-26.304]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.105999995213,0.458999992819,0.725,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[18.579,26.554],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":1,"ind":14,"ty":4,"nm":"rose Outlines 2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":16.234,"s":[0],"e":[1424]},{"t":136.113755544027}],"ix":8},"ry":{"a":0,"k":0,"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":16.234,"s":[444.267,-29.078,0],"e":[444.267,1140.922,0],"to":[0,195,0],"ti":[112,-281.5,0]},{"t":136.113755544027}],"ix":2},"a":{"a":0,"k":[15.226,23.714,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[14.976,-1.235],[13.969,23.464],[-14.976,9.296],[-13.704,-23.464]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.913999968884,0,0.536999990426,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[15.226,23.714],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0},{"ddd":1,"ind":15,"ty":4,"nm":"rose Outlines","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"rx":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":29.97,"s":[0],"e":[1424]},{"t":149.850006103516}],"ix":8},"ry":{"a":0,"k":0,"ix":9},"rz":{"a":0,"k":0,"ix":10},"or":{"a":0,"k":[0,0,0],"ix":7},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"n":"0p833_0p833_0p167_0p167","t":29.97,"s":[1228.267,-29.078,0],"e":[1228.267,1140.922,0],"to":[0,195,0],"ti":[112,-281.5,0]},{"t":149.850006103516}],"ix":2},"a":{"a":0,"k":[15.226,23.714,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[14.976,-1.235],[13.969,23.464],[-14.976,9.296],[-13.704,-23.464]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.913999968884,0,0.536999990426,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[15.226,23.714],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":149.850006103516,"st":0,"bm":0}]}],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"Shape Layer 1","td":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,960,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[79.75,79.75,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[1920,1920],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"ml2":{"a":0,"k":4,"ix":8},"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0.8,0.839215985466,0.901961023667,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":300.00001221925,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":0,"nm":"trophy&ribbon","tt":1,"refId":"comp_0","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[849.8,815,0],"ix":2},"a":{"a":0,"k":[960,543,0],"ix":1},"s":{"a":0,"k":[169.65,169.65,100],"ix":6}},"ao":0,"w":1920,"h":1086,"ip":0,"op":299.700012207031,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"Shape Layer 3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[960,960,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[79.75,79.75,100],"ix":6}},"ao":0,"ef":[{"ty":25,"nm":"Drop Shadow","np":9,"mn":"ADBE Drop Shadow","ix":1,"en":1,"ef":[{"ty":2,"nm":"Shadow Color","mn":"ADBE Drop Shadow-0001","ix":1,"v":{"a":0,"k":[0.168627455831,0.168627455831,0.168627455831,1],"ix":1}},{"ty":0,"nm":"Opacity","mn":"ADBE Drop Shadow-0002","ix":2,"v":{"a":0,"k":57.5,"ix":2}},{"ty":0,"nm":"Direction","mn":"ADBE Drop Shadow-0003","ix":3,"v":{"a":0,"k":177,"ix":3}},{"ty":0,"nm":"Distance","mn":"ADBE Drop Shadow-0004","ix":4,"v":{"a":0,"k":33,"ix":4}},{"ty":0,"nm":"Softness","mn":"ADBE Drop Shadow-0005","ix":5,"v":{"a":0,"k":112,"ix":5}},{"ty":7,"nm":"Shadow Only","mn":"ADBE Drop Shadow-0006","ix":6,"v":{"a":0,"k":0,"ix":6}},{"ty":7,"nm":"GPU Rendering","mn":"ADBE Force CPU GPU","ix":7,"v":{"a":0,"k":1,"ix":7}}]}],"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[1920,1920],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":1,"ml":4,"ml2":{"a":0,"k":4,"ix":8},"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[0.16862745098,0.16862745098,0.16862745098,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":300.00001221925,"op":300.00001221925,"st":0,"bm":0,"hidden":0}],"markers":[]}');

/***/ }),

/***/ "./Animations/65509-3-2-1-go.json":
/*!****************************************!*\
  !*** ./Animations/65509-3-2-1-go.json ***!
  \****************************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"v":"5.5.7","meta":{"g":"LottieFiles AE 0.1.21","a":"","k":"","d":"","tc":"#f7be1e"},"fr":30,"ip":0,"op":150,"w":300,"h":300,"nm":"3 2 1 GO","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"GO","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":90,"s":[0]},{"t":93,"s":[100]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.221,"y":0},"t":92,"s":[206.031,130.716,0],"to":[-8.776,2.234,0],"ti":[8.776,-2.234,0]},{"t":112,"s":[153.376,144.118,0]}],"ix":2},"a":{"a":0,"k":[87.285,73.283,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.395,-5.593],[-1.178,-3.312],[-2.188,-1.208],[-3.594,0.681],[-2.187,2.044],[-1.179,3.759],[-0.393,5.743],[0,8.08],[0.392,5.539],[1.178,3.37],[2.19,1.213],[3.589,-0.682],[2.189,-2.041],[1.177,-3.813],[0.392,-5.684],[0,-8.08]],"o":[[0.392,5.592],[1.177,3.312],[2.189,1.214],[3.589,-0.683],[2.19,-2.042],[1.178,-3.759],[0.392,-5.741],[0,-8.08],[-0.393,-5.536],[-1.179,-3.365],[-2.187,-1.209],[-3.594,0.684],[-2.188,2.045],[-1.178,3.818],[-0.395,5.689],[0,8.079]],"v":[[-16.077,23.931],[-13.721,37.286],[-8.671,44.07],[-0.001,44.865],[8.668,40.777],[13.72,32.073],[16.076,17.821],[16.666,-2.913],[16.076,-23.34],[13.72,-36.697],[8.668,-43.566],[-0.001,-44.359],[-8.671,-40.271],[-13.721,-31.483],[-16.077,-17.231],[-16.667,3.42]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[-0.843,7.848],[-2.862,6.044],[-5.388,4.111],[-9.09,1.727],[-5.388,-2.063],[-2.86,-4.954],[-0.843,-7.525],[0,-9.092],[0.84,-7.792],[2.863,-6.042],[5.386,-3.94],[9.091,-1.727],[5.387,1.894],[2.863,4.956],[0.841,7.475],[0,9.204]],"o":[[0.841,-7.846],[2.863,-6.042],[5.387,-4.11],[9.091,-1.728],[5.386,2.065],[2.863,4.957],[0.84,7.528],[0,9.203],[-0.843,7.794],[-2.86,6.045],[-5.388,3.94],[-9.09,1.728],[-5.388,-1.892],[-2.862,-4.954],[-0.843,-7.47],[0,-9.09]],"v":[[-39.646,-17.382],[-34.09,-38.218],[-21.717,-53.447],[-0.001,-62.204],[21.716,-61.7],[34.089,-51.173],[39.646,-32.448],[40.908,-7.519],[39.646,17.973],[34.089,38.724],[21.716,53.701],[-0.001,62.204],[-21.717,61.953],[-34.09,51.679],[-39.646,33.037],[-40.908,8.025]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":1,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[0.922000002394,0.243000000598,0.149000010771,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[133.413,64.182],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.505,2.261],[1.12,1.753],[1.738,0.959],[2.467,-0.469],[2.583,-6.998],[0,-15.039],[-0.449,-5.749],[-1.178,-3.871],[-2.188,-1.774],[-3.479,0.66],[-1.743,1.118],[-1.514,1.862],[-1.009,2.607],[0,3.257],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[4.097,-2.741],[5.723,-1.088],[4.655,1.697],[2.634,4.886],[0.896,7.742],[0,10.437],[-1.292,7.879],[-3.141,5.706],[-5.164,3.563],[-7.743,1.472],[-5.838,-5.457],[0,-12.231],[0,0]],"o":[[-0.504,-2.26],[-1.122,-1.749],[-1.742,-0.959],[-5.837,1.11],[-2.582,7.002],[0,7.182],[0.447,5.752],[1.178,3.875],[2.189,1.771],[1.457,-0.278],[1.738,-1.114],[1.515,-1.858],[1.01,-2.603],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-2.921,5.269],[-4.097,2.741],[-7.408,1.407],[-4.658,-1.695],[-2.639,-4.885],[-0.898,-7.743],[0,-10.101],[1.288,-7.876],[3.141,-5.703],[5.16,-3.562],[13.241,-2.515],[5.833,5.457],[0,0],[0,-2.244]],"v":[[14.226,-33.497],[11.785,-39.515],[7.493,-43.58],[1.18,-44.317],[-11.448,-32.154],[-15.318,0.904],[-14.646,20.304],[-12.204,34.739],[-7.154,43.207],[1.347,44.875],[6.146,42.784],[11.027,38.32],[14.815,31.625],[16.33,22.836],[16.33,10.546],[0.338,13.585],[0.338,-4.26],[39.561,-11.712],[39.561,53.101],[21.717,56.492],[21.717,45.381],[21.382,45.444],[10.858,57.461],[-3.87,63.207],[-21.968,62.771],[-32.91,52.898],[-38.214,33.957],[-39.561,6.688],[-37.625,-20.278],[-30.976,-40.648],[-18.517,-54.547],[0.842,-62.099],[29.462,-57.687],[38.216,-31.153],[14.984,-26.739]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.922000002394,0.243000000598,0.149000010771,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[39.811,81.701],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":90,"op":150.15015015015,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"GO light","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":90,"s":[0]},{"t":93,"s":[100]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.221,"y":0},"t":91,"s":[206.031,130.716,0],"to":[-8.776,2.234,0],"ti":[8.776,-2.234,0]},{"t":111,"s":[153.376,144.118,0]}],"ix":2},"a":{"a":0,"k":[87.285,73.283,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.395,-5.593],[-1.178,-3.312],[-2.188,-1.208],[-3.594,0.681],[-2.187,2.044],[-1.179,3.759],[-0.393,5.743],[0,8.08],[0.392,5.539],[1.178,3.37],[2.19,1.213],[3.589,-0.682],[2.189,-2.041],[1.177,-3.813],[0.392,-5.684],[0,-8.08]],"o":[[0.392,5.592],[1.177,3.312],[2.189,1.214],[3.589,-0.683],[2.19,-2.042],[1.178,-3.759],[0.392,-5.741],[0,-8.08],[-0.393,-5.536],[-1.179,-3.365],[-2.187,-1.209],[-3.594,0.684],[-2.188,2.045],[-1.178,3.818],[-0.395,5.689],[0,8.079]],"v":[[-16.077,23.931],[-13.721,37.286],[-8.671,44.07],[-0.001,44.865],[8.668,40.777],[13.72,32.073],[16.076,17.821],[16.666,-2.913],[16.076,-23.34],[13.72,-36.697],[8.668,-43.566],[-0.001,-44.359],[-8.671,-40.271],[-13.721,-31.483],[-16.077,-17.231],[-16.667,3.42]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[-0.843,7.848],[-2.862,6.044],[-5.388,4.111],[-9.09,1.727],[-5.388,-2.063],[-2.86,-4.954],[-0.843,-7.525],[0,-9.092],[0.84,-7.792],[2.863,-6.042],[5.386,-3.94],[9.091,-1.727],[5.387,1.894],[2.863,4.956],[0.841,7.475],[0,9.204]],"o":[[0.841,-7.846],[2.863,-6.042],[5.387,-4.11],[9.091,-1.728],[5.386,2.065],[2.863,4.957],[0.84,7.528],[0,9.203],[-0.843,7.794],[-2.86,6.045],[-5.388,3.94],[-9.09,1.728],[-5.388,-1.892],[-2.862,-4.954],[-0.843,-7.47],[0,-9.09]],"v":[[-39.646,-17.382],[-34.09,-38.218],[-21.717,-53.447],[-0.001,-62.204],[21.716,-61.7],[34.089,-51.173],[39.646,-32.448],[40.908,-7.519],[39.646,17.973],[34.089,38.724],[21.716,53.701],[-0.001,62.204],[-21.717,61.953],[-34.09,51.679],[-39.646,33.037],[-40.908,8.025]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":1,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[126.413,69.182],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.505,2.261],[1.12,1.753],[1.738,0.959],[2.467,-0.469],[2.583,-6.998],[0,-15.039],[-0.449,-5.749],[-1.178,-3.871],[-2.188,-1.774],[-3.479,0.66],[-1.743,1.118],[-1.514,1.862],[-1.009,2.607],[0,3.257],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[4.097,-2.741],[5.723,-1.088],[4.655,1.697],[2.634,4.886],[0.896,7.742],[0,10.437],[-1.292,7.879],[-3.141,5.706],[-5.164,3.563],[-7.743,1.472],[-5.838,-5.457],[0,-12.231],[0,0]],"o":[[-0.504,-2.26],[-1.122,-1.749],[-1.742,-0.959],[-5.837,1.11],[-2.582,7.002],[0,7.182],[0.447,5.752],[1.178,3.875],[2.189,1.771],[1.457,-0.278],[1.738,-1.114],[1.515,-1.858],[1.01,-2.603],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-2.921,5.269],[-4.097,2.741],[-7.408,1.407],[-4.658,-1.695],[-2.639,-4.885],[-0.898,-7.743],[0,-10.101],[1.288,-7.876],[3.141,-5.703],[5.16,-3.562],[13.241,-2.515],[5.833,5.457],[0,0],[0,-2.244]],"v":[[14.226,-33.497],[11.785,-39.515],[7.493,-43.58],[1.18,-44.317],[-11.448,-32.154],[-15.318,0.904],[-14.646,20.304],[-12.204,34.739],[-7.154,43.207],[1.347,44.875],[6.146,42.784],[11.027,38.32],[14.815,31.625],[16.33,22.836],[16.33,10.546],[0.338,13.585],[0.338,-4.26],[39.561,-11.712],[39.561,53.101],[21.717,56.492],[21.717,45.381],[21.382,45.444],[10.858,57.461],[-3.87,63.207],[-21.968,62.771],[-32.91,52.898],[-38.214,33.957],[-39.561,6.688],[-37.625,-20.278],[-30.976,-40.648],[-18.517,-54.547],[0.842,-62.099],[29.462,-57.687],[38.216,-31.153],[14.984,-26.739]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[32.811,86.701],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":90,"op":150.15015015015,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"GO dark","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":90,"s":[0]},{"t":93,"s":[100]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.221,"y":0},"t":90,"s":[206.031,130.716,0],"to":[-8.776,2.234,0],"ti":[8.776,-2.234,0]},{"t":110,"s":[153.376,144.118,0]}],"ix":2},"a":{"a":0,"k":[87.285,73.283,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.395,-5.593],[-1.178,-3.312],[-2.188,-1.208],[-3.594,0.681],[-2.187,2.044],[-1.179,3.759],[-0.393,5.743],[0,8.08],[0.392,5.539],[1.178,3.37],[2.19,1.213],[3.589,-0.682],[2.189,-2.041],[1.177,-3.813],[0.392,-5.684],[0,-8.08]],"o":[[0.392,5.592],[1.177,3.312],[2.189,1.214],[3.589,-0.683],[2.19,-2.042],[1.178,-3.759],[0.392,-5.741],[0,-8.08],[-0.393,-5.536],[-1.179,-3.365],[-2.187,-1.209],[-3.594,0.684],[-2.188,2.045],[-1.178,3.818],[-0.395,5.689],[0,8.079]],"v":[[-16.077,23.931],[-13.721,37.286],[-8.671,44.07],[-0.001,44.865],[8.668,40.777],[13.72,32.073],[16.076,17.821],[16.666,-2.913],[16.076,-23.34],[13.72,-36.697],[8.668,-43.566],[-0.001,-44.359],[-8.671,-40.271],[-13.721,-31.483],[-16.077,-17.231],[-16.667,3.42]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[-0.843,7.848],[-2.862,6.044],[-5.388,4.111],[-9.09,1.727],[-5.388,-2.063],[-2.86,-4.954],[-0.843,-7.525],[0,-9.092],[0.84,-7.792],[2.863,-6.042],[5.386,-3.94],[9.091,-1.727],[5.387,1.894],[2.863,4.956],[0.841,7.475],[0,9.204]],"o":[[0.841,-7.846],[2.863,-6.042],[5.387,-4.11],[9.091,-1.728],[5.386,2.065],[2.863,4.957],[0.84,7.528],[0,9.203],[-0.843,7.794],[-2.86,6.045],[-5.388,3.94],[-9.09,1.728],[-5.388,-1.892],[-2.862,-4.954],[-0.843,-7.47],[0,-9.09]],"v":[[-39.646,-17.382],[-34.09,-38.218],[-21.717,-53.447],[-0.001,-62.204],[21.716,-61.7],[34.089,-51.173],[39.646,-32.448],[40.908,-7.519],[39.646,17.973],[34.089,38.724],[21.716,53.701],[-0.001,62.204],[-21.717,61.953],[-34.09,51.679],[-39.646,33.037],[-40.908,8.025]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"mm","mm":1,"nm":"Merge Paths 1","mn":"ADBE Vector Filter - Merge","hd":false},{"ty":"fl","c":{"a":0,"k":[0.949019667682,0.643137254902,0.149019607843,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[119.413,74.182],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.505,2.261],[1.12,1.753],[1.738,0.959],[2.467,-0.469],[2.583,-6.998],[0,-15.039],[-0.449,-5.749],[-1.178,-3.871],[-2.188,-1.774],[-3.479,0.66],[-1.743,1.118],[-1.514,1.862],[-1.009,2.607],[0,3.257],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[4.097,-2.741],[5.723,-1.088],[4.655,1.697],[2.634,4.886],[0.896,7.742],[0,10.437],[-1.292,7.879],[-3.141,5.706],[-5.164,3.563],[-7.743,1.472],[-5.838,-5.457],[0,-12.231],[0,0]],"o":[[-0.504,-2.26],[-1.122,-1.749],[-1.742,-0.959],[-5.837,1.11],[-2.582,7.002],[0,7.182],[0.447,5.752],[1.178,3.875],[2.189,1.771],[1.457,-0.278],[1.738,-1.114],[1.515,-1.858],[1.01,-2.603],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-2.921,5.269],[-4.097,2.741],[-7.408,1.407],[-4.658,-1.695],[-2.639,-4.885],[-0.898,-7.743],[0,-10.101],[1.288,-7.876],[3.141,-5.703],[5.16,-3.562],[13.241,-2.515],[5.833,5.457],[0,0],[0,-2.244]],"v":[[14.226,-33.497],[11.785,-39.515],[7.493,-43.58],[1.18,-44.317],[-11.448,-32.154],[-15.318,0.904],[-14.646,20.304],[-12.204,34.739],[-7.154,43.207],[1.347,44.875],[6.146,42.784],[11.027,38.32],[14.815,31.625],[16.33,22.836],[16.33,10.546],[0.338,13.585],[0.338,-4.26],[39.561,-11.712],[39.561,53.101],[21.717,56.492],[21.717,45.381],[21.382,45.444],[10.858,57.461],[-3.87,63.207],[-21.968,62.771],[-32.91,52.898],[-38.214,33.957],[-39.561,6.688],[-37.625,-20.278],[-30.976,-40.648],[-18.517,-54.547],[0.842,-62.099],[29.462,-57.687],[38.216,-31.153],[14.984,-26.739]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.949019667682,0.643137254902,0.149019607843,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[25.811,91.701],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":90,"op":150.15015015015,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":4,"nm":"path 12","parent":2,"sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":90,"s":[0]},{"t":93,"s":[100]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[82.899,-10.945,0],"ix":2},"a":{"a":0,"k":[57.428,11.945,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"a","pt":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.172,"y":0},"t":90,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[48,0.184],[48,23.575],[47.857,23.693],[47.857,0.302]],"c":true}]},{"t":107,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[48,0.184],[48,23.575],[78.107,23.575],[78.107,0.184]],"c":true}]}],"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[57.179,-8.742],[-57.179,11.696],[-57.179,8.741],[57.179,-11.696]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.428,11.946],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":90,"op":150,"st":90,"bm":0},{"ddd":0,"ind":5,"ty":4,"nm":"path 11","parent":2,"sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":90,"s":[0]},{"t":93,"s":[100]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[130.649,-9.432,0],"ix":2},"a":{"a":0,"k":[57.428,14.871,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"a","pt":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.172,"y":0},"t":90,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,29.492],[0.107,29.385],[0.107,0.143]],"c":true}]},{"t":107,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,29.492],[78.357,29.373],[78.357,0.131]],"c":true}]}],"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[57.179,-5.816],[-57.179,14.621],[-57.179,5.815],[57.179,-14.621]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.428,14.871],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":90,"op":150,"st":90,"bm":0},{"ddd":0,"ind":6,"ty":4,"nm":"path 10","parent":2,"sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":90,"s":[0]},{"t":93,"s":[100]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[88.434,151.269,0],"ix":2},"a":{"a":0,"k":[57.428,11.946,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"a","pt":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.172,"y":0},"t":90,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,23.642],[-0.268,23.635],[-0.268,0.243]],"c":true}]},{"t":97,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,23.642],[48.607,23.645],[48.607,0.253]],"c":true}]}],"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[57.179,-8.741],[-57.179,11.696],[-57.179,8.741],[57.179,-11.696]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.428,11.946],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":90,"op":150,"st":90,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"1","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":60,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":63,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":89,"s":[100]},{"t":92,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.221,"y":0},"t":62,"s":[253.453,124.531,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0,"y":1},"o":{"x":0.709,"y":0},"t":82,"s":[148.474,146.18,0],"to":[0,0,0],"ti":[0,0,0]},{"t":102,"s":[57.752,165.252,0]}],"ix":2},"a":{"a":0,"k":[21.618,66.274,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[-4.083,5.622],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[13.185,-6.729],[0,0],[0,0],[0,0]],"v":[[-0.661,66.024],[-0.661,-37.291],[-21.368,-28.11],[-21.368,-44.489],[4.536,-63.021],[21.368,-66.024],[21.368,62.087]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.922000002394,0.243000000598,0.149000010771,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[21.618,66.274],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":60,"op":103,"st":0,"bm":0},{"ddd":0,"ind":8,"ty":4,"nm":"1 light","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":60,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":63,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":89,"s":[100]},{"t":92,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.221,"y":0},"t":61,"s":[253.453,124.531,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0,"y":1},"o":{"x":0.709,"y":0},"t":81,"s":[148.474,146.18,0],"to":[0,0,0],"ti":[0,0,0]},{"t":101,"s":[57.752,165.252,0]}],"ix":2},"a":{"a":0,"k":[21.618,66.274,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[-4.083,5.622],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[13.185,-6.729],[0,0],[0,0],[0,0]],"v":[[-0.661,66.024],[-0.661,-37.291],[-21.368,-28.11],[-21.368,-44.489],[4.536,-63.021],[21.368,-66.024],[21.368,62.087]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[15.618,71.274],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":60,"op":103,"st":0,"bm":0},{"ddd":0,"ind":9,"ty":4,"nm":"1 dark","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":60,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":63,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":89,"s":[100]},{"t":92,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.221,"y":0},"t":60,"s":[253.453,124.531,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0,"y":1},"o":{"x":0.709,"y":0},"t":80,"s":[148.474,146.18,0],"to":[0,0,0],"ti":[0,0,0]},{"t":100,"s":[57.752,165.252,0]}],"ix":2},"a":{"a":0,"k":[21.618,66.274,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[-4.083,5.622],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[13.185,-6.729],[0,0],[0,0],[0,0]],"v":[[-0.661,66.024],[-0.661,-37.291],[-21.368,-28.11],[-21.368,-44.489],[4.536,-63.021],[21.368,-66.024],[21.368,62.087]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.949019607843,0.643137254902,0.149019607843,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[9.618,76.274],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":60,"op":103,"st":0,"bm":0},{"ddd":0,"ind":10,"ty":4,"nm":"path 9","parent":7,"sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":60,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":63,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":89,"s":[100]},{"t":92,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[111.448,33.497,0],"ix":2},"a":{"a":0,"k":[57.428,11.945,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"a","pt":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.172,"y":0},"t":60,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[48,0.184],[48,23.575],[47.857,23.693],[47.857,0.302]],"c":true}]},{"t":80,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[48,0.184],[48,23.575],[78.107,23.575],[78.107,0.184]],"c":true}]}],"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[57.179,-8.742],[-57.179,11.696],[-57.179,8.741],[57.179,-11.696]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.428,11.946],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":60,"op":103,"st":60,"bm":0},{"ddd":0,"ind":11,"ty":4,"nm":"path 8","parent":7,"sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":60,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":63,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":89,"s":[100]},{"t":92,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[111.448,43.76,0],"ix":2},"a":{"a":0,"k":[57.428,14.871,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"a","pt":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.172,"y":0},"t":60,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,29.492],[0.107,29.385],[0.107,0.143]],"c":true}]},{"t":80,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,29.492],[78.357,29.373],[78.357,0.131]],"c":true}]}],"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[57.179,-5.816],[-57.179,14.621],[-57.179,5.815],[57.179,-14.621]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.428,14.871],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":60,"op":103,"st":60,"bm":0},{"ddd":0,"ind":12,"ty":4,"nm":"path 7","parent":7,"sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":60,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":63,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":89,"s":[100]},{"t":92,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[111.448,73.066,0],"ix":2},"a":{"a":0,"k":[57.428,11.946,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"a","pt":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.172,"y":0},"t":60,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,23.642],[-0.268,23.635],[-0.268,0.243]],"c":true}]},{"t":80,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,23.642],[48.607,23.645],[48.607,0.253]],"c":true}]}],"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[57.179,-8.741],[-57.179,11.696],[-57.179,8.741],[57.179,-11.696]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.428,11.946],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":60,"op":103,"st":60,"bm":0},{"ddd":0,"ind":13,"ty":4,"nm":"2","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":30,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":33,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":59,"s":[100]},{"t":62,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.221,"y":0},"t":32,"s":[253.453,124.531,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0,"y":1},"o":{"x":0.719,"y":0},"t":52,"s":[155,145.711,0],"to":[0,0,0],"ti":[0,0,0]},{"t":72,"s":[66.34,165.814,0]}],"ix":2},"a":{"a":0,"k":[32.785,66.886,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-2.003,3.328],[-0.649,1.288],[-1.177,2.626],[-0.424,2.195],[0,2.392],[1.727,2.234],[3.598,-0.844],[0,-12.911],[0,0],[0,0],[0,0],[-1.199,4.673],[-2.501,3.839],[-4.224,2.55],[-5.705,1.018],[-5.381,-4.698],[0,-10.367],[0.654,-3.256],[1.45,-3.249],[1.252,-2.267],[2.199,-3.632],[0.125,-0.224],[0.201,-0.31],[0.148,-0.273],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0.451,-0.827],[2.001,-3.322],[0.649,-1.285],[1.176,-2.63],[0.426,-2.194],[0,-4.884],[-1.727,-2.234],[-7.609,1.707],[0,0],[0,0],[0,0],[0,-5.684],[1.207,-4.679],[2.501,-3.836],[4.228,-2.551],[10.508,-1.875],[5.378,4.696],[0,3.539],[-0.648,3.259],[-1.452,3.249],[-1.249,2.268],[-0.25,0.395],[-0.125,0.221],[-0.201,0.309],[0,0],[0,0],[0,0],[0,0]],"v":[[-32.535,66.636],[-32.535,51.682],[-2.141,-1.155],[1.538,-7.383],[5.516,-14.297],[8.256,-20.169],[10.657,-27.406],[11.297,-34.286],[8.706,-44.963],[0.715,-47.052],[-10.697,-25.125],[-10.697,-19.965],[-31.71,-16.215],[-31.71,-21.524],[-29.911,-37.061],[-24.355,-49.833],[-14.262,-59.409],[0.637,-64.761],[24.467,-60.524],[32.535,-37.924],[31.559,-27.732],[28.409,-17.974],[24.353,-9.697],[19.174,-0.845],[18.611,0.077],[18.124,0.875],[17.6,1.751],[-7.993,45.131],[29.305,38.474],[29.305,55.596]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.922000002394,0.243000000598,0.149000010771,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[32.785,66.886],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":30,"op":73,"st":30,"bm":0},{"ddd":0,"ind":14,"ty":4,"nm":"2 light","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":30,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":33,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":59,"s":[100]},{"t":62,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.221,"y":0},"t":31,"s":[252.453,124.531,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0,"y":1},"o":{"x":0.719,"y":0},"t":51,"s":[154,145.711,0],"to":[0,0,0],"ti":[0,0,0]},{"t":71,"s":[65.34,165.814,0]}],"ix":2},"a":{"a":0,"k":[32.785,66.886,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-2.003,3.328],[-0.649,1.288],[-1.177,2.626],[-0.424,2.195],[0,2.392],[1.727,2.234],[3.598,-0.844],[0,-12.911],[0,0],[0,0],[0,0],[-1.199,4.673],[-2.501,3.839],[-4.224,2.55],[-5.705,1.018],[-5.381,-4.698],[0,-10.367],[0.654,-3.256],[1.45,-3.249],[1.252,-2.267],[2.199,-3.632],[0.125,-0.224],[0.201,-0.31],[0.148,-0.273],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0.451,-0.827],[2.001,-3.322],[0.649,-1.285],[1.176,-2.63],[0.426,-2.194],[0,-4.884],[-1.727,-2.234],[-7.609,1.707],[0,0],[0,0],[0,0],[0,-5.684],[1.207,-4.679],[2.501,-3.836],[4.228,-2.551],[10.508,-1.875],[5.378,4.696],[0,3.539],[-0.648,3.259],[-1.452,3.249],[-1.249,2.268],[-0.25,0.395],[-0.125,0.221],[-0.201,0.309],[0,0],[0,0],[0,0],[0,0]],"v":[[-32.535,66.636],[-32.535,51.682],[-2.141,-1.155],[1.538,-7.383],[5.516,-14.297],[8.256,-20.169],[10.657,-27.406],[11.297,-34.286],[8.706,-44.963],[0.715,-47.052],[-10.697,-25.125],[-10.697,-19.965],[-31.71,-16.215],[-31.71,-21.524],[-29.911,-37.061],[-24.355,-49.833],[-14.262,-59.409],[0.637,-64.761],[24.467,-60.524],[32.535,-37.924],[31.559,-27.732],[28.409,-17.974],[24.353,-9.697],[19.174,-0.845],[18.611,0.077],[18.124,0.875],[17.6,1.751],[-7.993,45.131],[29.305,38.474],[29.305,55.596]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[27.785,71.886],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":30,"op":73,"st":30,"bm":0},{"ddd":0,"ind":15,"ty":4,"nm":"2 dark","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":30,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":33,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":59,"s":[100]},{"t":62,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.221,"y":0},"t":30,"s":[252.453,124.531,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0,"y":1},"o":{"x":0.719,"y":0},"t":50,"s":[154,145.711,0],"to":[0,0,0],"ti":[0,0,0]},{"t":70,"s":[65.34,165.814,0]}],"ix":2},"a":{"a":0,"k":[32.785,66.886,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-2.003,3.328],[-0.649,1.288],[-1.177,2.626],[-0.424,2.195],[0,2.392],[1.727,2.234],[3.598,-0.844],[0,-12.911],[0,0],[0,0],[0,0],[-1.199,4.673],[-2.501,3.839],[-4.224,2.55],[-5.705,1.018],[-5.381,-4.698],[0,-10.367],[0.654,-3.256],[1.45,-3.249],[1.252,-2.267],[2.199,-3.632],[0.125,-0.224],[0.201,-0.31],[0.148,-0.273],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0.451,-0.827],[2.001,-3.322],[0.649,-1.285],[1.176,-2.63],[0.426,-2.194],[0,-4.884],[-1.727,-2.234],[-7.609,1.707],[0,0],[0,0],[0,0],[0,-5.684],[1.207,-4.679],[2.501,-3.836],[4.228,-2.551],[10.508,-1.875],[5.378,4.696],[0,3.539],[-0.648,3.259],[-1.452,3.249],[-1.249,2.268],[-0.25,0.395],[-0.125,0.221],[-0.201,0.309],[0,0],[0,0],[0,0],[0,0]],"v":[[-32.535,66.636],[-32.535,51.682],[-2.141,-1.155],[1.538,-7.383],[5.516,-14.297],[8.256,-20.169],[10.657,-27.406],[11.297,-34.286],[8.706,-44.963],[0.715,-47.052],[-10.697,-25.125],[-10.697,-19.965],[-31.71,-16.215],[-31.71,-21.524],[-29.911,-37.061],[-24.355,-49.833],[-14.262,-59.409],[0.637,-64.761],[24.467,-60.524],[32.535,-37.924],[31.559,-27.732],[28.409,-17.974],[24.353,-9.697],[19.174,-0.845],[18.611,0.077],[18.124,0.875],[17.6,1.751],[-7.993,45.131],[29.305,38.474],[29.305,55.596]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.949019607843,0.643137254902,0.149019607843,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[22.785,76.886],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":30,"op":73,"st":30,"bm":0},{"ddd":0,"ind":16,"ty":4,"nm":"path 6","parent":13,"sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":30,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":33,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":59,"s":[100]},{"t":62,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[127.68,29.25,0],"ix":2},"a":{"a":0,"k":[57.428,11.945,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"a","pt":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.172,"y":0},"t":30,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[48,0.184],[48,23.575],[47.857,23.693],[47.857,0.302]],"c":true}]},{"t":50,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[48,0.184],[48,23.575],[78.107,23.575],[78.107,0.184]],"c":true}]}],"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[57.179,-8.742],[-57.179,11.696],[-57.179,8.741],[57.179,-11.696]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.428,11.946],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":30,"op":73,"st":30,"bm":0},{"ddd":0,"ind":17,"ty":4,"nm":"path 5","parent":13,"sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":30,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":33,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":59,"s":[100]},{"t":62,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[127.68,39.513,0],"ix":2},"a":{"a":0,"k":[57.428,14.871,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"a","pt":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.172,"y":0},"t":30,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,29.492],[0.107,29.385],[0.107,0.143]],"c":true}]},{"t":50,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,29.492],[78.357,29.373],[78.357,0.131]],"c":true}]}],"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[57.179,-5.816],[-57.179,14.621],[-57.179,5.815],[57.179,-14.621]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.428,14.871],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":30,"op":73,"st":30,"bm":0},{"ddd":0,"ind":18,"ty":4,"nm":"path 4","parent":13,"sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":30,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":33,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":59,"s":[100]},{"t":62,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[127.68,68.819,0],"ix":2},"a":{"a":0,"k":[57.428,11.946,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"a","pt":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.172,"y":0},"t":30,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,23.642],[-0.268,23.635],[-0.268,0.243]],"c":true}]},{"t":50,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,23.642],[48.607,23.645],[48.607,0.253]],"c":true}]}],"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[57.179,-8.741],[-57.179,11.696],[-57.179,8.741],[57.179,-11.696]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.428,11.946],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":30,"op":73,"st":30,"bm":0},{"ddd":0,"ind":19,"ty":4,"nm":"3","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":3,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":29,"s":[100]},{"t":32,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.221,"y":0},"t":2,"s":[253.453,124.531,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0,"y":1},"o":{"x":0.729,"y":0},"t":22,"s":[154.484,144.18,0],"to":[0,0,0],"ti":[0,0,0]},{"t":42,"s":[58.092,163.252,0]}],"ix":2},"a":{"a":0,"k":[33.579,67.432,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[11.498,-2.051],[5.438,5.32],[0,11.453],[0,0],[0,0],[0,0],[-1.615,-2.774],[-4.465,0.795],[-1.413,0.916],[-0.821,1.197],[-0.436,1.892],[-0.151,1.866],[0,2.656],[2.207,3.129],[5.489,-0.676],[0.922,-0.142],[0.159,-0.027],[0,0],[-0.311,0.108],[-2.254,3.194],[0,6.387],[1.72,2.501],[4.363,-0.777],[1.355,-0.855],[0.817,-1.169],[0.487,-1.696],[0.179,-1.717],[0.05,-2.258],[0,0],[0,0],[0,0],[-5.772,6.989],[-10.622,1.896],[-5.771,-4.799],[0,-10.787],[3.129,-5.36],[5.185,-2.407],[-2.978,-4.609],[0,-8.334],[5.337,-7.753]],"o":[[-11.389,2.031],[-5.438,-5.316],[0,0],[0,0],[0,0],[0.101,6.427],[1.619,2.783],[1.949,-0.348],[1.409,-0.916],[0.825,-1.189],[0.436,-1.893],[0.156,-1.872],[0,-6.746],[-2.21,-3.136],[-0.206,0.034],[-0.923,0.139],[0,0],[1.645,-0.291],[5.64,-1.162],[2.261,-3.187],[0,-5.623],[-1.717,-2.508],[-1.845,0.332],[-1.362,0.855],[-0.822,1.17],[-0.49,1.697],[-0.179,1.72],[0,0],[0,0],[0,0],[0,-10.838],[5.773,-6.985],[10.723,-1.914],[5.773,4.799],[0,7.208],[-3.133,5.366],[5.493,0.912],[2.973,4.604],[0,12.115],[-5.336,7.753]],"v":[[0.075,65.15],[-25.171,60.224],[-33.329,35.07],[-33.329,30.545],[-11.47,26.641],[-11.47,30.17],[-8.892,43.971],[0.23,46.949],[5.273,45.053],[8.618,41.883],[10.508,37.254],[11.389,31.616],[11.618,24.824],[8.314,10.001],[-3.235,6.31],[-4.927,6.574],[-6.546,6.824],[-6.546,-11.432],[-3.616,-12.027],[8.232,-18.553],[11.618,-32.919],[9.04,-45.113],[-0.078,-47.708],[-4.887,-45.928],[-8.158,-42.889],[-10.122,-38.59],[-11.122,-33.466],[-11.47,-27.499],[-11.47,-23.206],[-33.329,-19.303],[-33.329,-25.208],[-24.671,-51.947],[-0.078,-65.268],[24.667,-60.943],[33.329,-37.562],[28.632,-18.704],[16.161,-7.046],[28.866,1.234],[33.329,20.643],[25.32,50.447]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.922000002394,0.243000000598,0.149000010771,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[33.578,67.432],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":42,"st":0,"bm":0},{"ddd":0,"ind":20,"ty":4,"nm":"3 light","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":3,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":29,"s":[100]},{"t":32,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.221,"y":0},"t":1,"s":[247.453,129.531,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0,"y":1},"o":{"x":0.729,"y":0},"t":21,"s":[148.484,149.18,0],"to":[0,0,0],"ti":[0,0,0]},{"t":41,"s":[52.092,168.252,0]}],"ix":2},"a":{"a":0,"k":[33.579,67.432,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[11.498,-2.051],[5.438,5.32],[0,11.453],[0,0],[0,0],[0,0],[-1.615,-2.774],[-4.465,0.795],[-1.413,0.916],[-0.821,1.197],[-0.436,1.892],[-0.151,1.866],[0,2.656],[2.207,3.129],[5.489,-0.676],[0.922,-0.142],[0.159,-0.027],[0,0],[-0.311,0.108],[-2.254,3.194],[0,6.387],[1.72,2.501],[4.363,-0.777],[1.355,-0.855],[0.817,-1.169],[0.487,-1.696],[0.179,-1.717],[0.05,-2.258],[0,0],[0,0],[0,0],[-5.772,6.989],[-10.622,1.896],[-5.771,-4.799],[0,-10.787],[3.129,-5.36],[5.185,-2.407],[-2.978,-4.609],[0,-8.334],[5.337,-7.753]],"o":[[-11.389,2.031],[-5.438,-5.316],[0,0],[0,0],[0,0],[0.101,6.427],[1.619,2.783],[1.949,-0.348],[1.409,-0.916],[0.825,-1.189],[0.436,-1.893],[0.156,-1.872],[0,-6.746],[-2.21,-3.136],[-0.206,0.034],[-0.923,0.139],[0,0],[1.645,-0.291],[5.64,-1.162],[2.261,-3.187],[0,-5.623],[-1.717,-2.508],[-1.845,0.332],[-1.362,0.855],[-0.822,1.17],[-0.49,1.697],[-0.179,1.72],[0,0],[0,0],[0,0],[0,-10.838],[5.773,-6.985],[10.723,-1.914],[5.773,4.799],[0,7.208],[-3.133,5.366],[5.493,0.912],[2.973,4.604],[0,12.115],[-5.336,7.753]],"v":[[0.075,65.15],[-25.171,60.224],[-33.329,35.07],[-33.329,30.545],[-11.47,26.641],[-11.47,30.17],[-8.892,43.971],[0.23,46.949],[5.273,45.053],[8.618,41.883],[10.508,37.254],[11.389,31.616],[11.618,24.824],[8.314,10.001],[-3.235,6.31],[-4.927,6.574],[-6.546,6.824],[-6.546,-11.432],[-3.616,-12.027],[8.232,-18.553],[11.618,-32.919],[9.04,-45.113],[-0.078,-47.708],[-4.887,-45.928],[-8.158,-42.889],[-10.122,-38.59],[-11.122,-33.466],[-11.47,-27.499],[-11.47,-23.206],[-33.329,-19.303],[-33.329,-25.208],[-24.671,-51.947],[-0.078,-65.268],[24.667,-60.943],[33.329,-37.562],[28.632,-18.704],[16.161,-7.046],[28.866,1.234],[33.329,20.643],[25.32,50.447]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[33.578,67.432],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":42,"st":0,"bm":0},{"ddd":0,"ind":21,"ty":4,"nm":"3 dark","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":3,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":29,"s":[100]},{"t":32,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.221,"y":0},"t":0,"s":[242.453,134.531,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0,"y":1},"o":{"x":0.729,"y":0},"t":20,"s":[143.484,154.18,0],"to":[0,0,0],"ti":[0,0,0]},{"t":40,"s":[47.092,173.252,0]}],"ix":2},"a":{"a":0,"k":[33.579,67.432,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[11.498,-2.051],[5.438,5.32],[0,11.453],[0,0],[0,0],[0,0],[-1.615,-2.774],[-4.465,0.795],[-1.413,0.916],[-0.821,1.197],[-0.436,1.892],[-0.151,1.866],[0,2.656],[2.207,3.129],[5.489,-0.676],[0.922,-0.142],[0.159,-0.027],[0,0],[-0.311,0.108],[-2.254,3.194],[0,6.387],[1.72,2.501],[4.363,-0.777],[1.355,-0.855],[0.817,-1.169],[0.487,-1.696],[0.179,-1.717],[0.05,-2.258],[0,0],[0,0],[0,0],[-5.772,6.989],[-10.622,1.896],[-5.771,-4.799],[0,-10.787],[3.129,-5.36],[5.185,-2.407],[-2.978,-4.609],[0,-8.334],[5.337,-7.753]],"o":[[-11.389,2.031],[-5.438,-5.316],[0,0],[0,0],[0,0],[0.101,6.427],[1.619,2.783],[1.949,-0.348],[1.409,-0.916],[0.825,-1.189],[0.436,-1.893],[0.156,-1.872],[0,-6.746],[-2.21,-3.136],[-0.206,0.034],[-0.923,0.139],[0,0],[1.645,-0.291],[5.64,-1.162],[2.261,-3.187],[0,-5.623],[-1.717,-2.508],[-1.845,0.332],[-1.362,0.855],[-0.822,1.17],[-0.49,1.697],[-0.179,1.72],[0,0],[0,0],[0,0],[0,-10.838],[5.773,-6.985],[10.723,-1.914],[5.773,4.799],[0,7.208],[-3.133,5.366],[5.493,0.912],[2.973,4.604],[0,12.115],[-5.336,7.753]],"v":[[0.075,65.15],[-25.171,60.224],[-33.329,35.07],[-33.329,30.545],[-11.47,26.641],[-11.47,30.17],[-8.892,43.971],[0.23,46.949],[5.273,45.053],[8.618,41.883],[10.508,37.254],[11.389,31.616],[11.618,24.824],[8.314,10.001],[-3.235,6.31],[-4.927,6.574],[-6.546,6.824],[-6.546,-11.432],[-3.616,-12.027],[8.232,-18.553],[11.618,-32.919],[9.04,-45.113],[-0.078,-47.708],[-4.887,-45.928],[-8.158,-42.889],[-10.122,-38.59],[-11.122,-33.466],[-11.47,-27.499],[-11.47,-23.206],[-33.329,-19.303],[-33.329,-25.208],[-24.671,-51.947],[-0.078,-65.268],[24.667,-60.943],[33.329,-37.562],[28.632,-18.704],[16.161,-7.046],[28.866,1.234],[33.329,20.643],[25.32,50.447]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.949019607843,0.643137254902,0.149019607843,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[33.578,67.432],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":42,"st":0,"bm":0},{"ddd":0,"ind":22,"ty":4,"nm":"path 1","parent":19,"sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":3,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":29,"s":[100]},{"t":32,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[129.073,31.309,0],"ix":2},"a":{"a":0,"k":[57.428,11.945,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"a","pt":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.172,"y":0},"t":0,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[48,0.184],[48,23.575],[47.857,23.693],[47.857,0.302]],"c":true}]},{"t":20,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[48,0.184],[48,23.575],[78.107,23.575],[78.107,0.184]],"c":true}]}],"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[57.179,-8.742],[-57.179,11.696],[-57.179,8.741],[57.179,-11.696]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.428,11.946],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":42,"st":0,"bm":0},{"ddd":0,"ind":23,"ty":4,"nm":"path 2","parent":19,"sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":3,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":29,"s":[100]},{"t":32,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[129.073,41.572,0],"ix":2},"a":{"a":0,"k":[57.428,14.871,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"a","pt":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.172,"y":0},"t":0,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,29.492],[0.107,29.385],[0.107,0.143]],"c":true}]},{"t":20,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,29.492],[78.357,29.373],[78.357,0.131]],"c":true}]}],"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[57.179,-5.816],[-57.179,14.621],[-57.179,5.815],[57.179,-14.621]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.428,14.871],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":42,"st":0,"bm":0},{"ddd":0,"ind":24,"ty":4,"nm":"path 3","parent":19,"sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":3,"s":[100]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":29,"s":[100]},{"t":32,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[129.073,70.877,0],"ix":2},"a":{"a":0,"k":[57.428,11.946,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"a","pt":{"a":1,"k":[{"i":{"x":0,"y":1},"o":{"x":0.172,"y":0},"t":0,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,23.642],[-0.268,23.635],[-0.268,0.243]],"c":true}]},{"t":20,"s":[{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.25,0.25],[0.25,23.642],[48.607,23.645],[48.607,0.253]],"c":true}]}],"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[57.179,-8.741],[-57.179,11.696],[-57.179,8.741],[57.179,-11.696]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.428,11.946],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":42,"st":0,"bm":0}],"markers":[]}');

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/***/ (function(module) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/***/ (function(module) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/***/ (function(module) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ (function(module) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ (function(module) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayLikeToArray; }
/* harmony export */ });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithoutHoles; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return (0,_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__.default)(arr);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _defineProperty; }
/* harmony export */ });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArray; }
/* harmony export */ });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableSpread; }
/* harmony export */ });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _toConsumableArray; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _babel_runtime_helpers_esm_iterableToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/iterableToArray */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_nonIterableSpread__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/nonIterableSpread */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return (0,_babel_runtime_helpers_esm_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_babel_runtime_helpers_esm_iterableToArray__WEBPACK_IMPORTED_MODULE_1__.default)(arr) || (0,_babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__.default)(arr) || (0,_babel_runtime_helpers_esm_nonIterableSpread__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _unsupportedIterableToArray; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return (0,_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0,_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ (function(module) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/***/ (function(module) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/***/ (function(module) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/***/ (function(module) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ (function(module) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./components/Header.js":
/*!******************************!*\
  !*** ./components/Header.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Header; }
/* harmony export */ });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var query_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! query-string */ "./node_modules/query-string/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* module decorator */ module = __webpack_require__.hmd(module);

var _jsxFileName = "C:\\Users\\rahul\\Desktop\\quizApp\\components\\Header.js";


function Header(props) {
  var str = "";
  console.log(props);
  Object.keys(props).forEach(function (text) {
    str += props[text];
  });
  console.log(str);
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
    className: "header",
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
      children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("h4", {
        children: "QuizIt"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 15,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
      className: "li-div",
      children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("ul", {
        children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("li", {
          children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("a", {
            children: str
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 20,
            columnNumber: 13
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 19,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 18,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 17,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 13,
    columnNumber: 5
  }, this);
}
_c = Header;

var _c;

$RefreshReg$(_c, "Header");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./components/QuestionCard.js":
/*!************************************!*\
  !*** ./components/QuestionCard.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ QuestionCard; }
/* harmony export */ });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_rahul_Desktop_quizApp_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* module decorator */ module = __webpack_require__.hmd(module);


var _jsxFileName = "C:\\Users\\rahul\\Desktop\\quizApp\\components\\QuestionCard.js";


function QuestionCard(_ref) {
  var handleAnswer = _ref.handleAnswer,
      _ref$data = _ref.data,
      question = _ref$data.question,
      correct_answer = _ref$data.correct_answer,
      incorrect_answers = _ref$data.incorrect_answers;
  var shuffledAnswers = [correct_answer].concat((0,C_Users_rahul_Desktop_quizApp_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(incorrect_answers)).sort(function () {
    return Math.random() - 0.5;
  });
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
    className: "ques-card",
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
      className: "question",
      children: question
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
      className: "answers-box",
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
        className: "answers answers-white",
        onClick: function onClick() {
          return handleAnswer(shuffledAnswers[0]);
        },
        children: [" ", shuffledAnswers[0]]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 16,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
        className: "answers answers-white",
        onClick: function onClick() {
          return handleAnswer(shuffledAnswers[1]);
        },
        children: [" ", shuffledAnswers[1]]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 23,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
        className: "answers answers-white",
        onClick: function onClick() {
          return handleAnswer(shuffledAnswers[2]);
        },
        children: [" ", shuffledAnswers[2]]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 30,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
        className: "answers answers-white",
        onClick: function onClick() {
          return handleAnswer(shuffledAnswers[3]);
        },
        children: [" ", shuffledAnswers[3]]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 37,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 5
  }, this);
}
_c = QuestionCard;

var _c;

$RefreshReg$(_c, "QuestionCard");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./components/lottie.js":
/*!******************************!*\
  !*** ./components/lottie.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LottieAnimation; }
/* harmony export */ });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_lottie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-lottie */ "./node_modules/react-lottie/dist/index.js");
/* module decorator */ module = __webpack_require__.hmd(module);

var _jsxFileName = "C:\\Users\\rahul\\Desktop\\quizApp\\components\\lottie.js";


function LottieAnimation(_ref) {
  var lottie = _ref.lottie,
      height = _ref.height,
      width = _ref.width;
  var defaultOptions = {
    loop: true,
    autoplay: true,
    animationData: lottie
  };
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_lottie__WEBPACK_IMPORTED_MODULE_2__.default, {
      options: defaultOptions,
      height: height,
      width: width
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 12,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 11,
    columnNumber: 5
  }, this);
}
_c = LottieAnimation;

var _c;

$RefreshReg$(_c, "LottieAnimation");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


var normalizePathTrailingSlash =  false ? 0 : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


exports.__esModule = true;
exports.cancelIdleCallback = exports.requestIdleCallback = void 0;

var requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback || function (cb) {
  var start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};

exports.requestIdleCallback = requestIdleCallback;

var cancelIdleCallback = typeof self !== 'undefined' && self.cancelIdleCallback || function (id) {
  return clearTimeout(id);
};

exports.cancelIdleCallback = cancelIdleCallback;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.markAssetError = markAssetError;
exports.isAssetError = isAssetError;
exports.getClientBuildManifest = getClientBuildManifest;
exports.default = void 0;

var _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/router/utils/get-asset-path-from-route */ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js"));

var _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js"); // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive
// considers as "Good" time-to-interactive. We must assume something went
// wrong beyond this point, and then fall-back to a full page transition to
// show the user something of value.


var MS_MAX_IDLE_DELAY = 3800;

function withFuture(key, map, generator) {
  var entry = map.get(key);

  if (entry) {
    if ('future' in entry) {
      return entry.future;
    }

    return Promise.resolve(entry);
  }

  var resolver;
  var prom = new Promise(function (resolve) {
    resolver = resolve;
  });
  map.set(key, entry = {
    resolve: resolver,
    future: prom
  });
  return generator ? // eslint-disable-next-line no-sequences
  generator().then(function (value) {
    return resolver(value), value;
  }) : prom;
}

function hasPrefetch(link) {
  try {
    link = document.createElement('link');
    return (// detect IE11 since it supports prefetch but isn't detected
      // with relList.support
      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')
    );
  } catch (_unused) {
    return false;
  }
}

var canPrefetch = hasPrefetch();

function prefetchViaDom(href, as, link) {
  return new Promise(function (res, rej) {
    if (document.querySelector("link[rel=\"prefetch\"][href^=\"".concat(href, "\"]"))) {
      return res();
    }

    link = document.createElement('link'); // The order of property assignment here is intentional:

    if (as) link.as = as;
    link.rel = "prefetch";
    link.crossOrigin = undefined;
    link.onload = res;
    link.onerror = rej; // `href` should always be last:

    link.href = href;
    document.head.appendChild(link);
  });
}

var ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR'); // TODO: unexport

function markAssetError(err) {
  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
}

function isAssetError(err) {
  return err && ASSET_LOAD_ERROR in err;
}

function appendScript(src, script) {
  return new Promise(function (resolve, reject) {
    script = document.createElement('script'); // The order of property assignment here is intentional.
    // 1. Setup success/failure hooks in case the browser synchronously
    //    executes when `src` is set.

    script.onload = resolve;

    script.onerror = function () {
      return reject(markAssetError(new Error("Failed to load script: ".concat(src))));
    }; // 2. Configure the cross-origin attribute before setting `src` in case the
    //    browser begins to fetch.


    script.crossOrigin = undefined; // 3. Finally, set the source and inject into the DOM in case the child
    //    must be appended for fetching to start.

    script.src = src;
    document.body.appendChild(script);
  });
} // Resolve a promise that times out after given amount of milliseconds.


function resolvePromiseWithTimeout(p, ms, err) {
  return new Promise(function (resolve, reject) {
    var cancelled = false;
    p.then(function (r) {
      // Resolved, cancel the timeout
      cancelled = true;
      resolve(r);
    })["catch"](reject);
    (0, _requestIdleCallback.requestIdleCallback)(function () {
      return setTimeout(function () {
        if (!cancelled) {
          reject(err);
        }
      }, ms);
    });
  });
} // TODO: stop exporting or cache the failure
// It'd be best to stop exporting this. It's an implementation detail. We're
// only exporting it for backwards compatibilty with the `page-loader`.
// Only cache this response as a last resort if we cannot eliminate all other
// code branches that use the Build Manifest Callback and push them through
// the Route Loader interface.


function getClientBuildManifest() {
  if (self.__BUILD_MANIFEST) {
    return Promise.resolve(self.__BUILD_MANIFEST);
  }

  var onBuildManifest = new Promise(function (resolve) {
    // Mandatory because this is not concurrent safe:
    var cb = self.__BUILD_MANIFEST_CB;

    self.__BUILD_MANIFEST_CB = function () {
      resolve(self.__BUILD_MANIFEST);
      cb && cb();
    };
  });
  return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));
}

function getFilesForRoute(assetPrefix, route) {
  if (true) {
    return Promise.resolve({
      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute["default"])(route, '.js'))],
      // Styles are handled by `style-loader` in development:
      css: []
    });
  }

  return getClientBuildManifest().then(function (manifest) {
    if (!(route in manifest)) {
      throw markAssetError(new Error("Failed to lookup route: ".concat(route)));
    }

    var allFiles = manifest[route].map(function (entry) {
      return assetPrefix + '/_next/' + encodeURI(entry);
    });
    return {
      scripts: allFiles.filter(function (v) {
        return v.endsWith('.js');
      }),
      css: allFiles.filter(function (v) {
        return v.endsWith('.css');
      })
    };
  });
}

function createRouteLoader(assetPrefix) {
  var entrypoints = new Map();
  var loadedScripts = new Map();
  var styleSheets = new Map();
  var routes = new Map();

  function maybeExecuteScript(src) {
    var prom = loadedScripts.get(src);

    if (prom) {
      return prom;
    } // Skip executing script if it's already in the DOM:


    if (document.querySelector("script[src^=\"".concat(src, "\"]"))) {
      return Promise.resolve();
    }

    loadedScripts.set(src, prom = appendScript(src));
    return prom;
  }

  function fetchStyleSheet(href) {
    var prom = styleSheets.get(href);

    if (prom) {
      return prom;
    }

    styleSheets.set(href, prom = fetch(href).then(function (res) {
      if (!res.ok) {
        throw new Error("Failed to load stylesheet: ".concat(href));
      }

      return res.text().then(function (text) {
        return {
          href: href,
          content: text
        };
      });
    })["catch"](function (err) {
      throw markAssetError(err);
    }));
    return prom;
  }

  return {
    whenEntrypoint: function whenEntrypoint(route) {
      return withFuture(route, entrypoints);
    },
    onEntrypoint: function onEntrypoint(route, execute) {
      Promise.resolve(execute).then(function (fn) {
        return fn();
      }).then(function (exports) {
        return {
          component: exports && exports["default"] || exports,
          exports: exports
        };
      }, function (err) {
        return {
          error: err
        };
      }).then(function (input) {
        var old = entrypoints.get(route);
        entrypoints.set(route, input);
        if (old && 'resolve' in old) old.resolve(input);
      });
    },
    loadRoute: function loadRoute(route, prefetch) {
      var _this = this;

      return withFuture(route, routes, function () {
        return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(function (_ref) {
          var scripts = _ref.scripts,
              css = _ref.css;
          return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);
        }).then(function (res) {
          return _this.whenEntrypoint(route).then(function (entrypoint) {
            return {
              entrypoint: entrypoint,
              styles: res[1]
            };
          });
        }), MS_MAX_IDLE_DELAY, markAssetError(new Error("Route did not complete loading: ".concat(route)))).then(function (_ref2) {
          var entrypoint = _ref2.entrypoint,
              styles = _ref2.styles;
          var res = Object.assign({
            styles: styles
          }, entrypoint);
          return 'error' in entrypoint ? entrypoint : res;
        })["catch"](function (err) {
          if (prefetch) {
            // we don't want to cache errors during prefetch
            throw err;
          }

          return {
            error: err
          };
        });
      });
    },
    prefetch: function prefetch(route) {
      var _this2 = this;

      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      var cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }

      return getFilesForRoute(assetPrefix, route).then(function (output) {
        return Promise.all(canPrefetch ? output.scripts.map(function (script) {
          return prefetchViaDom(script, 'script');
        }) : []);
      }).then(function () {
        (0, _requestIdleCallback.requestIdleCallback)(function () {
          return _this2.loadRoute(route, true)["catch"](function () {});
        });
      })["catch"]( // swallow prefetch errors
      function () {});
    }
  };
}

var _default = createRouteLoader;
exports.default = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _construct = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/construct */ "./node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale', 'isReady', 'isPreview', 'isLocaleDomain'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          console.error("Error when running the Router event: ".concat(eventField));
          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports.default = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.default = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js ***!
  \******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


exports.__esModule = true;
exports.normalizeLocalePath = normalizeLocalePath;

function normalizeLocalePath(pathname, locales) {
  var detectedLocale; // first item will be empty string from splitting at first char

  var pathnameParts = pathname.split('/');
  (locales || []).some(function (locale) {
    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
      detectedLocale = locale;
      pathnameParts.splice(1, 1);
      pathname = pathnameParts.join('/') || '/';
      return true;
    }

    return false;
  });
  return {
    pathname: pathname,
    detectedLocale: detectedLocale
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


exports.__esModule = true;
exports.default = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var RouterContext = /*#__PURE__*/_react["default"].createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _regeneratorRuntime = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.getDomainLocale = getDomainLocale;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports.default = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ "./node_modules/next/dist/client/route-loader.js");

var _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ "./node_modules/next/dist/next-server/server/denormalize-page-path.js");

var _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "?ca47"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // tslint:disable:no-console


var detectDomainLocale;

if (false) {}

var basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : "".concat(prefix).concat(pathNoQueryHash(path) === '/' ? path.substring(1) : path) : path;
}

function getDomainLocale(path, locale, locales, domainLocales) {
  if (false) { var detectedDomain; }

  return false;
}

function addLocale(path, locale, defaultLocale) {
  if (false) { var localeLower, pathLower, pathname; }

  return path;
}

function delLocale(path, locale) {
  if (false) { var localeLower, pathLower, pathname; }

  return path;
}

function pathNoQueryHash(path) {
  var queryIndex = path.indexOf('?');
  var hashIndex = path.indexOf('#');

  if (queryIndex > -1 || hashIndex > -1) {
    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);
  }

  return path;
}

function hasBasePath(path) {
  path = pathNoQueryHash(path);
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  path = path.slice(basePath.length);
  if (!path.startsWith('/')) path = "/".concat(path);
  return path;
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  // prevent a hydration mismatch on href for url with anchor refs
  if (url.startsWith('/') || url.startsWith('#')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    var locationOrigin = (0, _utils.getLocationOrigin)();
    var resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  var interpolatedRoute = '';
  var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
  var dynamicGroups = dynamicRegex.groups;
  var dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  var params = Object.keys(dynamicGroups);

  if (!params.every(function (param) {
    var value = dynamicMatches[param] || '';
    var _dynamicGroups$param = dynamicGroups[param],
        repeat = _dynamicGroups$param.repeat,
        optional = _dynamicGroups$param.optional; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    var replaced = "[".concat(repeat ? '...' : '').concat(param, "]");

    if (optional) {
      replaced = "".concat(!value ? '/' : '', "[").concat(replaced, "]");
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present
    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just
    // path delimiter escaped since they are being inserted
    // into the URL and we expect URL encoded segments
    // when parsing dynamic route params
    function (segment) {
      return encodeURIComponent(segment);
    }).join('/') : encodeURIComponent(value)) || '/');
  })) {
    interpolatedRoute = ''; // did not satisfy all requirements
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params: params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  var filteredQuery = {};
  Object.keys(query).forEach(function (key) {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href, resolveAs) {
  // we use a dummy base url for relative urls
  var base;

  try {
    base = new URL(currentPath, 'http://n');
  } catch (_) {
    // fallback to / for invalid asPath values e.g. //
    base = new URL('/', 'http://n');
  }

  var urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href); // Return because it cannot be routed by the Next.js router

  if (!isLocalURL(urlAsString)) {
    return resolveAs ? [urlAsString] : urlAsString;
  }

  try {
    var finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);
    var interpolatedAs = '';

    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      var query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);

      var _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),
          result = _interpolateAs.result,
          params = _interpolateAs.params;

      if (result) {
        interpolatedAs = (0, _utils.formatWithValidation)({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

function stripOrigin(url) {
  var origin = (0, _utils.getLocationOrigin)();
  return url.startsWith(origin) ? url.substring(origin.length) : url;
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  var _resolveHref = resolveHref(router.asPath, url, true),
      _resolveHref2 = _slicedToArray(_resolveHref, 2),
      resolvedHref = _resolveHref2[0],
      resolvedAs = _resolveHref2[1];

  var origin = (0, _utils.getLocationOrigin)();
  var hrefHadOrigin = resolvedHref.startsWith(origin);
  var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);
  resolvedHref = stripOrigin(resolvedHref);
  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
  var preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);
  var preparedAs = as ? stripOrigin(resolveHref(router.asPath, as)) : resolvedAs || resolvedHref;
  return {
    url: preparedUrl,
    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)
  };
}

function resolveDynamicRoute(pathname, pages) {
  var cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(pathname));

  if (cleanPathname === '/404' || cleanPathname === '/_error') {
    return pathname;
  } // handle resolving href for dynamic routes


  if (!pages.includes(cleanPathname)) {
    // eslint-disable-next-line array-callback-return
    pages.some(function (page) {
      if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {
        pathname = page;
        return true;
      }
    });
  }

  return (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
}

var manualScrollRestoration =  false && 0;
var SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` won’t send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(function (res) {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      if (res.status === 404) {
        return res.json().then(function (data) {
          if (data.notFound) {
            return {
              notFound: SSG_DATA_NOT_FOUND
            };
          }

          throw new Error("Failed to load static props");
        });
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1)["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      (0, _routeLoader.markAssetError)(err);
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  // In-flight Server Data Requests, for deduping
  function Router(_pathname, _query, _as, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback,
        locale = _ref.locale,
        locales = _ref.locales,
        defaultLocale = _ref.defaultLocale,
        domainLocales = _ref.domainLocales,
        isPreview = _ref.isPreview;

    _classCallCheck(this, Router);

    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sdr = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;
    this._shallow = void 0;
    this.locale = void 0;
    this.locales = void 0;
    this.defaultLocale = void 0;
    this.domainLocales = void 0;
    this.isReady = void 0;
    this.isPreview = void 0;
    this.isLocaleDomain = void 0;
    this._idx = 0;

    this.onPopState = function (e) {
      var state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var _pathname2 = _this.pathname,
            query = _this.query;

        _this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname2),
          query: query
        }), (0, _utils.getURL)());

        return;
      }

      if (!state.__N) {
        return;
      }

      var forcedScroll;
      var url = state.url,
          as = state.as,
          options = state.options,
          idx = state.idx;

      if (false) { var v; }

      _this._idx = idx;

      var _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(url),
          pathname = _ref2.pathname; // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (_this.isSsr && as === _this.asPath && pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(state)) {
        return;
      }

      _this.change('replaceState', url, as, Object.assign({}, options, {
        shallow: options.shallow && _this._shallow,
        locale: options.locale || _this.defaultLocale
      }), forcedScroll);
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        initial: true,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    var autoExportDynamic = (0, _isDynamic.isDynamicRoute)(_pathname) && self.__NEXT_DATA__.autoExport;

    this.asPath = autoExportDynamic ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;
    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || !autoExportDynamic && !self.location.search && !false);
    this.isPreview = !!isPreview;
    this.isLocaleDomain = false;

    if (false) {}

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, _utils.getURL)(), {
          locale: locale
        });
      }

      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) {}
    }
  }

  _createClass(Router, [{
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
    * Go back in history
    */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
    * Performs a `pushState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "push",
    value: function push(url, as) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (false) {}

      ;

      var _prepareUrlAs = prepareUrlAs(this, url, as);

      url = _prepareUrlAs.url;
      as = _prepareUrlAs.as;
      return this.change('pushState', url, as, options);
    }
    /**
    * Performs a `replaceState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "replace",
    value: function replace(url, as) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs2 = prepareUrlAs(this, url, as);

      url = _prepareUrlAs2.url;
      as = _prepareUrlAs2.as;
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function () {
      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(method, url, as, options, forcedScroll) {
        var _options$scroll, shouldResolveHref, localeChange, parsedAs, localePathResult, didNavigate, _this$locales, detectedDomain, asNoBasePath, _options$shallow, shallow, routeProps, cleanedAs, parsed, pathname, query, pages, rewrites, _yield, resolvedAs, rewritesResult, route, _parsedAs, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, _self$__NEXT_DATA__$p, _self$__NEXT_DATA__$p2, routeInfo, _routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, appComp, isValidShallowRoute;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isLocalURL(url)) {
                  _context.next = 3;
                  break;
                }

                window.location.href = url;
                return _context.abrupt("return", false);

              case 3:
                shouldResolveHref = url === as || options._h; // for static pages with query params in the URL we delay
                // marking the router ready until after the query is updated

                if (options._h) {
                  this.isReady = true;
                } // Default to scroll reset behavior unless explicitly specified to be
                // `false`! This makes the behavior between using `Router#push` and a
                // `<Link />` consistent.


                options.scroll = !!((_options$scroll = options.scroll) != null ? _options$scroll : true);
                localeChange = options.locale !== this.locale;

                if (true) {
                  _context.next = 19;
                  break;
                }

                this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;

                if (typeof options.locale === 'undefined') {
                  options.locale = this.locale;
                }

                parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(hasBasePath(as) ? delBasePath(as) : as);
                localePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(parsedAs.pathname, this.locales);

                if (localePathResult.detectedLocale) {
                  this.locale = localePathResult.detectedLocale;
                  parsedAs.pathname = addBasePath(parsedAs.pathname);
                  as = (0, _utils.formatWithValidation)(parsedAs);
                  url = addBasePath((0, _normalizeLocalePath.normalizeLocalePath)(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);
                }

                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime
                // moves this on its own due to the return

                if (false) {}

                detectedDomain = detectDomainLocale(this.domainLocales, undefined, this.locale); // we need to wrap this in the env check again since regenerator runtime
                // moves this on its own due to the return

                if (false) {}

                if (!didNavigate) {
                  _context.next = 19;
                  break;
                }

                return _context.abrupt("return", new Promise(function () {}));

              case 19:
                if (!options._h) {
                  this.isSsr = false;
                } // marking route changes as a navigation start entry


                if (_utils.ST) {
                  performance.mark('routeChange');
                }

                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow;
                routeProps = {
                  shallow: shallow
                };

                if (this._inFlightRoute) {
                  this.abortComponentLoad(this._inFlightRoute, routeProps);
                }

                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));
                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
                this._inFlightRoute = as; // If the url change is only related to a hash change
                // We should not proceed. We should only change the state.
                // WARNING: `_h` is an internal option for handing Next.js client-side
                // hydration. Your app should _never_ use this property. It may change at
                // any time without notice.

                if (!(!options._h && this.onlyAHashChange(cleanedAs))) {
                  _context.next = 35;
                  break;
                }

                this.asPath = cleanedAs;
                Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?

                this.changeState(method, url, as, options);
                this.scrollToHash(cleanedAs);
                this.notify(this.components[this.route], null);
                Router.events.emit('hashChangeComplete', as, routeProps);
                return _context.abrupt("return", true);

              case 35:
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                pathname = parsed.pathname, query = parsed.query; // The build manifest needs to be loaded before auto-static dynamic pages
                // get their query parameters to allow ensuring they can be parsed properly
                // when rewritten to

                _context.prev = 37;
                _context.next = 40;
                return this.pageLoader.getPageList();

              case 40:
                pages = _context.sent;
                _context.next = 43;
                return (0, _routeLoader.getClientBuildManifest)();

              case 43:
                _yield = _context.sent;
                rewrites = _yield.__rewrites;
                _context.next = 51;
                break;

              case 47:
                _context.prev = 47;
                _context.t0 = _context["catch"](37);
                // If we fail to resolve the page list or client-build manifest, we must
                // do a server-side transition:
                window.location.href = as;
                return _context.abrupt("return", false);

              case 51:
                // If asked to change the current URL we should reload the current page
                // (not location.reload() but reload getInitialProps and other Next.js stuffs)
                // We also need to set the method = replaceState always
                // as this should not go into the history (That's how browsers work)
                // We should compare the new asPath to the current asPath, not the url
                if (!this.urlIsNew(cleanedAs) && !localeChange) {
                  method = 'replaceState';
                } // we need to resolve the as value using rewrites for dynamic SSG
                // pages to allow building the data URL correctly


                resolvedAs = as; // url and as should always be prefixed with basePath by this
                // point by either next/link or router.push/replace so strip the
                // basePath from the pathname to match the pages dir 1-to-1

                pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname;

                if (shouldResolveHref && pathname !== '/_error') {
                  if (false) {} else {
                    parsed.pathname = resolveDynamicRoute(pathname, pages);

                    if (parsed.pathname !== pathname) {
                      pathname = parsed.pathname;
                      url = (0, _utils.formatWithValidation)(parsed);
                    }
                  }
                }

                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);

                if (isLocalURL(as)) {
                  _context.next = 61;
                  break;
                }

                if (false) {}

                throw new Error("Invalid href: \"".concat(url, "\" and as: \"").concat(as, "\", received relative href and external as") + "\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as");

              case 59:
                window.location.href = as;
                return _context.abrupt("return", false);

              case 61:
                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

                if (!(0, _isDynamic.isDynamicRoute)(route)) {
                  _context.next = 77;
                  break;
                }

                _parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);
                asPathname = _parsedAs.pathname;
                routeRegex = (0, _routeRegex.getRouteRegex)(route);
                routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);
                shouldInterpolate = route === asPathname;
                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};

                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {
                  _context.next = 76;
                  break;
                }

                missingParams = Object.keys(routeRegex.groups).filter(function (param) {
                  return !query[param];
                });

                if (!(missingParams.length > 0)) {
                  _context.next = 74;
                  break;
                }

                if (true) {
                  console.warn("".concat(shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`", " failed to manually provide ") + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
                }

                throw new Error((shouldInterpolate ? "The provided `href` (".concat(url, ") value is missing query values (").concat(missingParams.join(', '), ") to be interpolated properly. ") : "The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ")) + "Read more: https://nextjs.org/docs/messages/".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));

              case 74:
                _context.next = 77;
                break;

              case 76:
                if (shouldInterpolate) {
                  as = (0, _utils.formatWithValidation)(Object.assign({}, _parsedAs, {
                    pathname: interpolatedAs.result,
                    query: omitParmsFromQuery(query, interpolatedAs.params)
                  }));
                } else {
                  // Merge params into `query`, overwriting any specified in search
                  Object.assign(query, routeMatch);
                }

              case 77:
                Router.events.emit('routeChangeStart', as, routeProps);
                _context.prev = 78;
                _context.next = 81;
                return this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps);

              case 81:
                routeInfo = _context.sent;
                _routeInfo = routeInfo, error = _routeInfo.error, props = _routeInfo.props, __N_SSG = _routeInfo.__N_SSG, __N_SSP = _routeInfo.__N_SSP; // handle redirect on client-transition

                if (!((__N_SSG || __N_SSP) && props)) {
                  _context.next = 108;
                  break;
                }

                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {
                  _context.next = 94;
                  break;
                }

                destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
                // client-navigation if it is falling back to hard navigation if
                // it's not

                if (!destination.startsWith('/')) {
                  _context.next = 92;
                  break;
                }

                parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);
                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);

                if (!pages.includes(parsedHref.pathname)) {
                  _context.next = 92;
                  break;
                }

                _prepareUrlAs3 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;
                return _context.abrupt("return", this.change(method, newUrl, newAs, options));

              case 92:
                window.location.href = destination;
                return _context.abrupt("return", new Promise(function () {}));

              case 94:
                this.isPreview = !!props.__N_PREVIEW; // handle SSG data 404

                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {
                  _context.next = 108;
                  break;
                }

                _context.prev = 96;
                _context.next = 99;
                return this.fetchComponent('/404');

              case 99:
                notFoundRoute = '/404';
                _context.next = 105;
                break;

              case 102:
                _context.prev = 102;
                _context.t1 = _context["catch"](96);
                notFoundRoute = '/_error';

              case 105:
                _context.next = 107;
                return this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {
                  shallow: false
                });

              case 107:
                routeInfo = _context.sent;

              case 108:
                Router.events.emit('beforeHistoryChange', as, routeProps);
                this.changeState(method, url, as, options);

                if (true) {
                  appComp = this.components['/_app'].Component;
                  window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
                } // shallow routing is only allowed for same page URL changes.


                isValidShallowRoute = options.shallow && this.route === route;

                if (options._h && pathname === '/_error' && ((_self$__NEXT_DATA__$p = self.__NEXT_DATA__.props) == null ? void 0 : (_self$__NEXT_DATA__$p2 = _self$__NEXT_DATA__$p.pageProps) == null ? void 0 : _self$__NEXT_DATA__$p2.statusCode) === 500 && props != null && props.pageProps) {
                  // ensure statusCode is still correct for static 500 page
                  // when updating query information
                  props.pageProps.statusCode = 500;
                }

                _context.next = 115;
                return this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll || (isValidShallowRoute || !options.scroll ? null : {
                  x: 0,
                  y: 0
                }))["catch"](function (e) {
                  if (e.cancelled) error = error || e;else throw e;
                });

              case 115:
                if (!error) {
                  _context.next = 118;
                  break;
                }

                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);
                throw error;

              case 118:
                if (false) {}

                Router.events.emit('routeChangeComplete', as, routeProps);
                return _context.abrupt("return", true);

              case 123:
                _context.prev = 123;
                _context.t2 = _context["catch"](78);

                if (!_context.t2.cancelled) {
                  _context.next = 127;
                  break;
                }

                return _context.abrupt("return", false);

              case 127:
                throw _context.t2;

              case 128:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[37, 47], [78, 123], [96, 102]]);
      }));

      function change(_x, _x2, _x3, _x4, _x5) {
        return _change.apply(this, arguments);
      }

      return change;
    }()
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        this._shallow = options.shallow;
        window.history[method]({
          url: url,
          as: as,
          options: options,
          __N: true,
          idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "handleRouteInfoError",
    value: function () {
      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(err, pathname, query, as, routeProps, loadErrorFail) {
        var Component, styleSheets, props, _yield$this$fetchComp, routeInfo;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!err.cancelled) {
                  _context2.next = 2;
                  break;
                }

                throw err;

              case 2:
                if (!((0, _routeLoader.isAssetError)(err) || loadErrorFail)) {
                  _context2.next = 6;
                  break;
                }

                Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons
                //  1. Page doesn't exists
                //  2. Page does exist in a different zone
                //  3. Internal error while loading the page
                // So, doing a hard reload is the proper way to deal with this.

                window.location.href = as; // Changing the URL doesn't block executing the current code path.
                // So let's throw a cancellation error stop the routing logic.

                throw buildCancellationError();

              case 6:
                _context2.prev = 6;

                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {
                  _context2.next = 14;
                  break;
                }

                ;
                _context2.next = 11;
                return this.fetchComponent('/_error');

              case 11:
                _yield$this$fetchComp = _context2.sent;
                Component = _yield$this$fetchComp.page;
                styleSheets = _yield$this$fetchComp.styleSheets;

              case 14:
                routeInfo = {
                  props: props,
                  Component: Component,
                  styleSheets: styleSheets,
                  err: err,
                  error: err
                };

                if (routeInfo.props) {
                  _context2.next = 26;
                  break;
                }

                _context2.prev = 16;
                _context2.next = 19;
                return this.getInitialProps(Component, {
                  err: err,
                  pathname: pathname,
                  query: query
                });

              case 19:
                routeInfo.props = _context2.sent;
                _context2.next = 26;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2["catch"](16);
                console.error('Error in error page `getInitialProps`: ', _context2.t0);
                routeInfo.props = {};

              case 26:
                return _context2.abrupt("return", routeInfo);

              case 29:
                _context2.prev = 29;
                _context2.t1 = _context2["catch"](6);
                return _context2.abrupt("return", this.handleRouteInfoError(_context2.t1, pathname, query, as, routeProps, true));

              case 32:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 29], [16, 22]]);
      }));

      function handleRouteInfoError(_x6, _x7, _x8, _x9, _x10, _x11) {
        return _handleRouteInfoError.apply(this, arguments);
      }

      return handleRouteInfoError;
    }()
  }, {
    key: "getRouteInfo",
    value: function () {
      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(route, pathname, query, as, resolvedAs, routeProps) {
        var _this2 = this;

        var existingRouteInfo, cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, _require, isValidElementType, dataHref, props;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                existingRouteInfo = this.components[route];

                if (!(routeProps.shallow && existingRouteInfo && this.route === route)) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", existingRouteInfo);

              case 4:
                cachedRouteInfo = existingRouteInfo && 'initial' in existingRouteInfo ? undefined : existingRouteInfo;

                if (!cachedRouteInfo) {
                  _context3.next = 9;
                  break;
                }

                _context3.t0 = cachedRouteInfo;
                _context3.next = 12;
                break;

              case 9:
                _context3.next = 11;
                return this.fetchComponent(route).then(function (res) {
                  return {
                    Component: res.page,
                    styleSheets: res.styleSheets,
                    __N_SSG: res.mod.__N_SSG,
                    __N_SSP: res.mod.__N_SSP
                  };
                });

              case 11:
                _context3.t0 = _context3.sent;

              case 12:
                routeInfo = _context3.t0;
                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;

                if (false) {}

                _require = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require.isValidElementType;

                if (isValidElementType(Component)) {
                  _context3.next = 18;
                  break;
                }

                throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));

              case 18:
                if (__N_SSG || __N_SSP) {
                  dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({
                    pathname: pathname,
                    query: query
                  }), resolvedAs, __N_SSG, this.locale);
                }

                _context3.next = 21;
                return this._getData(function () {
                  return __N_SSG ? _this2._getStaticData(dataHref) : __N_SSP ? _this2._getServerData(dataHref) : _this2.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
                  {
                    pathname: pathname,
                    query: query,
                    asPath: as,
                    locale: _this2.locale,
                    locales: _this2.locales,
                    defaultLocale: _this2.defaultLocale
                  });
                });

              case 21:
                props = _context3.sent;
                routeInfo.props = props;
                this.components[route] = routeInfo;
                return _context3.abrupt("return", routeInfo);

              case 27:
                _context3.prev = 27;
                _context3.t1 = _context3["catch"](0);
                return _context3.abrupt("return", this.handleRouteInfoError(_context3.t1, pathname, query, as, routeProps));

              case 30:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 27]]);
      }));

      function getRouteInfo(_x12, _x13, _x14, _x15, _x16, _x17) {
        return _getRouteInfo.apply(this, arguments);
      }

      return getRouteInfo;
    }()
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data, resetScroll) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      return this.notify(data, resetScroll);
    }
    /**
    * Callback to execute before replacing router state
    * @param cb callback to be executed
    */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value or `#top`
      // To mirror browsers


      if (hash === '' || hash === 'top') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
    /**
    * Prefetch page code, you may wait for the data during page rendering.
    * This feature only works in production!
    * @param url the href of prefetched page
    * @param asPath the as path of the prefetched page
    */

  }, {
    key: "prefetch",
    value: function () {
      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url) {
        var _this3 = this;

        var asPath,
            options,
            parsed,
            pathname,
            parsedAs,
            localePathResult,
            pages,
            resolvedAs,
            rewrites,
            _yield2,
            rewritesResult,
            route,
            _args4 = arguments;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                asPath = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : url;
                options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                pathname = parsed.pathname;

                if (false) {}

                _context4.next = 7;
                return this.pageLoader.getPageList();

              case 7:
                pages = _context4.sent;
                resolvedAs = asPath;

                if (true) {
                  _context4.next = 19;
                  break;
                }

                _context4.next = 12;
                return (0, _routeLoader.getClientBuildManifest)();

              case 12:
                _yield2 = _context4.sent;
                rewrites = _yield2.__rewrites;
                rewritesResult = (0, _resolveRewrites["default"])(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, function (p) {
                  return resolveDynamicRoute(p, pages);
                }, this.locales);
                resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);

                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {
                  // if this directly matches a page we need to update the href to
                  // allow the correct page chunk to be loaded
                  pathname = rewritesResult.resolvedHref;
                  parsed.pathname = pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                }

                _context4.next = 21;
                break;

              case 19:
                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                }

              case 21:
                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname); // Prefetch is not supported in development mode because it would trigger on-demand-entries

                if (false) {}

                return _context4.abrupt("return");

              case 24:
                _context4.next = 26;
                return Promise.all([this.pageLoader._isSsg(route).then(function (isSsg) {
                  return isSsg ? _this3._getStaticData(_this3.pageLoader.getDataHref(url, resolvedAs, true, typeof options.locale !== 'undefined' ? options.locale : _this3.locale)) : false;
                }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);

              case 26:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function prefetch(_x18) {
        return _prefetch.apply(this, arguments);
      }

      return prefetch;
    }()
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                _context5.next = 4;
                return this.pageLoader.loadPage(route);

              case 4:
                componentResult = _context5.sent;

                if (!cancelled) {
                  _context5.next = 9;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 9:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context5.abrupt("return", componentResult);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function fetchComponent(_x19) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this4 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this4.clc) {
          _this4.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "_getStaticData",
    value: function _getStaticData(dataHref) {
      var _this5 = this;

      var _URL = new URL(dataHref, window.location.href),
          cacheKey = _URL.href;

      if (false) {}

      return fetchNextData(dataHref, this.isSsr).then(function (data) {
        _this5.sdc[cacheKey] = data;
        return data;
      });
    }
  }, {
    key: "_getServerData",
    value: function _getServerData(dataHref) {
      var _this6 = this;

      var _URL2 = new URL(dataHref, window.location.href),
          resourceKey = _URL2.href;

      if (this.sdr[resourceKey]) {
        return this.sdr[resourceKey];
      }

      return this.sdr[resourceKey] = fetchNextData(dataHref, this.isSsr).then(function (data) {
        delete _this6.sdr[resourceKey];
        return data;
      })["catch"](function (err) {
        delete _this6.sdr[resourceKey];
        throw err;
      });
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return (0, _utils.loadGetInitialProps)(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as, routeProps) {
      if (this.clc) {
        Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data, resetScroll) {
      return this.sub(data, this.components['/_app'].Component, resetScroll);
    }
  }]);

  return Router;
}();

exports.default = Router;
Router.events = (0, _mitt["default"])();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  var auth = urlObj.auth,
      hostname = urlObj.hostname;
  var protocol = urlObj.protocol || '';
  var pathname = urlObj.pathname || '';
  var hash = urlObj.hash || '';
  var query = urlObj.query || '';
  var host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  var search = urlObj.search || query && "?".concat(query) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js ***!
  \******************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


exports.__esModule = true;
exports.default = getAssetPathFromRoute; // Translates a logical route into its pages asset path (relative from a common prefix)
// "asset path" being its javascript file, data file, prerendered html,...

function getAssetPathFromRoute(route) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var path = route === '/' ? '/index' : /^\/index(\/|$)/.test(route) ? "/index".concat(route) : "".concat(route);
  return path + ext;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/


function parseRelativeUrl(url, base) {
  var globalBase = new URL( false ? 0 : (0, _utils.getLocationOrigin)());
  var resolvedBase = base ? new URL(base, globalBase) : globalBase;

  var _URL = new URL(url, resolvedBase),
      pathname = _URL.pathname,
      searchParams = _URL.searchParams,
      search = _URL.search,
      hash = _URL.hash,
      href = _URL.href,
      origin = _URL.origin;

  if (origin !== globalBase.origin) {
    throw new Error("invariant: invalid relative URL, router received ".concat(url));
  }

  return {
    pathname: pathname,
    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
    search: search,
    hash: hash,
    href: href.slice(globalBase.origin.length)
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  var query = {};
  searchParams.forEach(function (value, key) {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function stringifyUrlQueryParam(param) {
  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
    return String(param);
  } else {
    return '';
  }
}

function urlQueryToSearchParams(urlQuery) {
  var result = new URLSearchParams();
  Object.entries(urlQuery).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (Array.isArray(value)) {
      value.forEach(function (item) {
        return result.append(key, stringifyUrlQueryParam(item));
      });
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}

function assign(target) {
  for (var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    searchParamsList[_key - 1] = arguments[_key];
  }

  searchParamsList.forEach(function (searchParams) {
    Array.from(searchParams.keys()).forEach(function (key) {
      return target["delete"](key);
    });
    searchParams.forEach(function (value, key) {
      return target.append(key, value);
    });
  });
  return target;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  var optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  var repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat: repeat,
    optional: optional
  };
}

function getRouteRegex(normalizedRoute) {
  var segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = segments.map(function (segment) {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      var _parseParameter = parseParameter(segment.slice(1, -1)),
          key = _parseParameter.key,
          optional = _parseParameter.optional,
          repeat = _parseParameter.repeat;

      groups[key] = {
        pos: groupIndex++,
        repeat: repeat,
        optional: optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return "/".concat(escapeRegex(segment));
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) { var namedParameterizedRoute, routeKeys, getSafeRouteKey, routeKeyCharLength, routeKeyCharCode; }

  return {
    re: new RegExp("^".concat(parameterizedRoute, "(?:/)?$")),
    groups: groups
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _regeneratorRuntime = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_App$prototype = App.prototype) != null && _App$prototype.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

var urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

var SP = typeof performance !== 'undefined';
exports.SP = SP;
var ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./pages/testing.js":
/*!**************************!*\
  !*** ./pages/testing.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ testing; }
/* harmony export */ });
/* harmony import */ var C_Users_rahul_Desktop_quizApp_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/router */ "./node_modules/next/router.js");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _components_Header__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Header */ "./components/Header.js");
/* harmony import */ var _Animations_65509_3_2_1_go_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Animations/65509-3-2-1-go.json */ "./Animations/65509-3-2-1-go.json");
/* harmony import */ var _Animations_43444_trophy_animation_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Animations/43444-trophy-animation.json */ "./Animations/43444-trophy-animation.json");
/* harmony import */ var _components_lottie__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/lottie */ "./components/lottie.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _components_QuestionCard__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../components/QuestionCard */ "./components/QuestionCard.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\rahul\\Desktop\\quizApp\\pages\\testing.js",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_rahul_Desktop_quizApp_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }









function testing() {
  _s();

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)("answers-white"),
      bgColor = _useState[0],
      setBgcolor = _useState[1];

  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]),
      questions = _useState2[0],
      setQuestions = _useState2[1];

  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0),
      currentQuestion = _useState3[0],
      setcurrentQuestion = _useState3[1];

  var _useState4 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0),
      score = _useState4[0],
      setScore = _useState4[1];

  var router = (0,next_router__WEBPACK_IMPORTED_MODULE_3__.useRouter)();
  var yourname = router.query.name;
  var category = router.query.category;
  var difficulty = router.query.questionDifficulty;
  var numberOfQuestions = router.query.numberOfQuestions;
  var t = "multiple";
  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function () {
    axios__WEBPACK_IMPORTED_MODULE_8___default().get("https://opentdb.com/api.php?amount=".concat(numberOfQuestions, "&category=").concat(category, "&difficulty=").concat(difficulty, "&type=").concat(t)).then(function (resp) {
      setQuestions(resp.data.results);
    })["catch"](function (err) {
      console.error(err);
    });
  }, []);

  var handleAnswer = function handleAnswer(answer) {
    if (answer === questions[currentQuestion].correct_answer) {
      setScore(score + 1);
      setcurrentQuestion(currentQuestion + 1);
    } else {
      console.log("false");
      setcurrentQuestion(currentQuestion + 1);
    }
  };

  return currentQuestion >= numberOfQuestions ? /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("div", {
    className: "score",
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("div", {
      children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_components_lottie__WEBPACK_IMPORTED_MODULE_7__.default, {
        lottie: _Animations_43444_trophy_animation_json__WEBPACK_IMPORTED_MODULE_6__,
        height: 200,
        width: 200
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 49,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 48,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("div", {
      children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("h4", {
        children: ["Your score is ", score, " out of ", numberOfQuestions]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 52,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 51,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 47,
    columnNumber: 5
  }, this) : questions.length > 0 ? /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("div", {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_components_Header__WEBPACK_IMPORTED_MODULE_4__.default, _objectSpread({}, yourname), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 59,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("div", {
      className: "score-div",
      children: ["Score: ", score]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 60,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_components_QuestionCard__WEBPACK_IMPORTED_MODULE_9__.default, {
      handleAnswer: handleAnswer,
      data: questions[currentQuestion]
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 62,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 58,
    columnNumber: 5
  }, this) : /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("div", {
    className: "lotties",
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_components_lottie__WEBPACK_IMPORTED_MODULE_7__.default, {
      lottie: _Animations_65509_3_2_1_go_json__WEBPACK_IMPORTED_MODULE_5__,
      height: 650,
      width: 700
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 69,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 68,
    columnNumber: 5
  }, this);
}

_s(testing, "ETgPPiNpxUQJD1x+OjwQkcyo/kI=", false, function () {
  return [next_router__WEBPACK_IMPORTED_MODULE_3__.useRouter];
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ (function(module) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ (function(module) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ (function(module) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process */ "./node_modules/process/browser.js");


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ (function(module) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ (function(module) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ (function(module) {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ (function(module) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/assign.js":
/*!*************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/assign.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/create.js":
/*!*************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/create.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/create */ "./node_modules/core-js/library/fn/object/create.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/define-property.js":
/*!**********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/define-property.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-property */ "./node_modules/core-js/library/fn/object/define-property.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js":
/*!***********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/get-prototype-of.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/get-prototype-of */ "./node_modules/core-js/library/fn/object/get-prototype-of.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/set-prototype-of.js":
/*!***********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/set-prototype-of.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/set-prototype-of */ "./node_modules/core-js/library/fn/object/set-prototype-of.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol.js":
/*!******************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/symbol.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol */ "./node_modules/core-js/library/fn/symbol/index.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol/iterator.js":
/*!***************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/symbol/iterator.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol/iterator */ "./node_modules/core-js/library/fn/symbol/iterator.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/classCallCheck.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/classCallCheck.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/createClass.js":
/*!***********************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/createClass.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(/*! ../core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/extends.js":
/*!*******************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/extends.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(/*! ../core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/inherits.js":
/*!********************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/inherits.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(/*! ../core-js/object/set-prototype-of */ "./node_modules/babel-runtime/core-js/object/set-prototype-of.js");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(/*! ../core-js/object/create */ "./node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js":
/*!*************************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/possibleConstructorReturn.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/typeof.js":
/*!******************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/typeof.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(/*! ../core-js/symbol/iterator */ "./node_modules/babel-runtime/core-js/symbol/iterator.js");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(/*! ../core-js/symbol */ "./node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/assign.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/assign.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.assign */ "./node_modules/core-js/library/modules/es6.object.assign.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.assign;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/create.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/create.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.create */ "./node_modules/core-js/library/modules/es6.object.create.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/define-property.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/define-property.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.define-property */ "./node_modules/core-js/library/modules/es6.object.define-property.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/get-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/get-prototype-of.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.get-prototype-of */ "./node_modules/core-js/library/modules/es6.object.get-prototype-of.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.getPrototypeOf;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/set-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/set-prototype-of.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.set-prototype-of */ "./node_modules/core-js/library/modules/es6.object.set-prototype-of.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.setPrototypeOf;


/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/fn/symbol/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.symbol */ "./node_modules/core-js/library/modules/es6.symbol.js");
__webpack_require__(/*! ../../modules/es6.object.to-string */ "./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__(/*! ../../modules/es7.symbol.async-iterator */ "./node_modules/core-js/library/modules/es7.symbol.async-iterator.js");
__webpack_require__(/*! ../../modules/es7.symbol.observable */ "./node_modules/core-js/library/modules/es7.symbol.observable.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Symbol;


/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/fn/symbol/iterator.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
module.exports = __webpack_require__(/*! ../../modules/_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js").f('iterator');


/***/ }),

/***/ "./node_modules/core-js/library/modules/_a-function.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_a-function.js ***!
  \*************************************************************/
/***/ (function(module) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_add-to-unscopables.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_add-to-unscopables.js ***!
  \*********************************************************************/
/***/ (function(module) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_an-object.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-includes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-includes.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/library/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_cof.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_cof.js ***!
  \******************************************************/
/***/ (function(module) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_core.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_core.js ***!
  \*******************************************************/
/***/ (function(module) {

var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ctx.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ctx.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_defined.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_defined.js ***!
  \**********************************************************/
/***/ (function(module) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_descriptors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_descriptors.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_dom-create.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_dom-create.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-bug-keys.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_enum-bug-keys.js ***!
  \****************************************************************/
/***/ (function(module) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-keys.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_enum-keys.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_export.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_export.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_fails.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_fails.js ***!
  \********************************************************/
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_global.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_global.js ***!
  \*********************************************************/
/***/ (function(module) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_has.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_has.js ***!
  \******************************************************/
/***/ (function(module) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_hide.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_hide.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_html.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_html.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iobject.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iobject.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-array.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-object.js ***!
  \************************************************************/
/***/ (function(module) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-create.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-create.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-define.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-define.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/library/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/library/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/library/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-step.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-step.js ***!
  \************************************************************/
/***/ (function(module) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iterators.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iterators.js ***!
  \************************************************************/
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_library.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_library.js ***!
  \**********************************************************/
/***/ (function(module) {

module.exports = true;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_meta.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_meta.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js")('meta');
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-assign.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-assign.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-create.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/library/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/core-js/library/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dp.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dp.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dps.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dps.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopd.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopd.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopn-ext.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopn-ext.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/library/modules/_object-gopn.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopn.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopn.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/library/modules/_object-keys-internal.js");
var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gops.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gops.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gpo.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gpo.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys-internal.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys-internal.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/library/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/library/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-pie.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-pie.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-sap.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-sap.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_property-desc.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_property-desc.js ***!
  \****************************************************************/
/***/ (function(module) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_redefine.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-proto.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-proto.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-to-string-tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-to-string-tag.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared-key.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared-key.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js") ? 'pure' : 'global',
  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_string-at.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_string-at.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-absolute-index.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-absolute-index.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-integer.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-integer.js ***!
  \*************************************************************/
/***/ (function(module) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-iobject.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-iobject.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-length.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-length.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-object.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-primitive.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_uid.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_uid.js ***!
  \******************************************************/
/***/ (function(module) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks-define.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks-define.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js");
var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks-ext.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js");


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.iterator.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.iterator.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/library/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/library/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.assign.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.assign.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/library/modules/_object-assign.js") });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.create.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.create.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js") });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.define-property.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.define-property.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.get-prototype-of.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.get-prototype-of.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/library/modules/_object-gpo.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.set-prototype-of.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.set-prototype-of.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/library/modules/_set-proto.js").set });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.to-string.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.to-string.js ***!
  \**********************************************************************/
/***/ (function() {



/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.string.iterator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.string.iterator.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/library/modules/_string-at.js")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.symbol.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.symbol.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/library/modules/_redefine.js");
var META = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/library/modules/_meta.js").KEY;
var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");
var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js");
var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js");
var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/core-js/library/modules/_enum-keys.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/library/modules/_is-array.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/library/modules/_object-gopn-ext.js");
var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js");
var $GOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/library/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.symbol.async-iterator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.symbol.async-iterator.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js")('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.symbol.observable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.symbol.observable.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js")('observable');


/***/ }),

/***/ "./node_modules/core-js/library/modules/web.dom.iterable.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/web.dom.iterable.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/library/modules/es6.array.iterator.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var TO_STRING_TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "./node_modules/decode-uri-component/index.js":
/*!****************************************************!*\
  !*** ./node_modules/decode-uri-component/index.js ***!
  \****************************************************/
/***/ (function(module) {

"use strict";

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return decodeURIComponent(components.join(''));
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher);

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher);
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

module.exports = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};


/***/ }),

/***/ "./node_modules/filter-obj/index.js":
/*!******************************************!*\
  !*** ./node_modules/filter-obj/index.js ***!
  \******************************************/
/***/ (function(module) {

"use strict";

module.exports = function (obj, predicate) {
	var ret = {};
	var keys = Object.keys(obj);
	var isArr = Array.isArray(predicate);

	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		var val = obj[key];

		if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
			ret[key] = val;
		}
	}

	return ret;
};


/***/ }),

/***/ "./node_modules/lottie-web/build/player/lottie.js":
/*!********************************************************!*\
  !*** ./node_modules/lottie-web/build/player/lottie.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;(typeof navigator !== "undefined") && (function(root, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
            return factory(root);
        }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}((window || {}), function(window) {
	/* global locationHref:writable, animationManager, subframeEnabled:writable, defaultCurveSegments:writable, roundValues,
expressionsPlugin:writable, PropertyFactory, ShapePropertyFactory, Matrix, idPrefix:writable */
/* exported locationHref, subframeEnabled, expressionsPlugin, idPrefix */

'use strict';

/* exported svgNS, locationHref, initialDefaultFrame */

var svgNS = 'http://www.w3.org/2000/svg';

var locationHref = '';

var initialDefaultFrame = -999999;

/* global createSizedArray */
/* exported subframeEnabled, expressionsPlugin, isSafari, cachedColors, bmPow, bmSqrt, bmFloor, bmMax, bmMin, ProjectInterface,
defaultCurveSegments, degToRads, roundCorner, bmRnd, styleDiv, BMEnterFrameEvent, BMCompleteEvent, BMCompleteLoopEvent,
BMSegmentStartEvent, BMDestroyEvent, BMRenderFrameErrorEvent, BMConfigErrorEvent, BMAnimationConfigErrorEvent, createElementID,
addSaturationToRGB, addBrightnessToRGB, addHueToRGB, rgbToHex */

var subframeEnabled = true;
var idPrefix = '';
var expressionsPlugin;
var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
var cachedColors = {};
var bmRnd;
var bmPow = Math.pow;
var bmSqrt = Math.sqrt;
var bmFloor = Math.floor;
var bmMax = Math.max;
var bmMin = Math.min;

var BMMath = {};
(function () {
  var propertyNames = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'cbrt', 'expm1', 'clz32', 'cos', 'cosh', 'exp', 'floor', 'fround', 'hypot', 'imul', 'log', 'log1p', 'log2', 'log10', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'];
  var i;
  var len = propertyNames.length;
  for (i = 0; i < len; i += 1) {
    BMMath[propertyNames[i]] = Math[propertyNames[i]];
  }
}());

function ProjectInterface() { return {}; }

BMMath.random = Math.random;
BMMath.abs = function (val) {
  var tOfVal = typeof val;
  if (tOfVal === 'object' && val.length) {
    var absArr = createSizedArray(val.length);
    var i;
    var len = val.length;
    for (i = 0; i < len; i += 1) {
      absArr[i] = Math.abs(val[i]);
    }
    return absArr;
  }
  return Math.abs(val);
};
var defaultCurveSegments = 150;
var degToRads = Math.PI / 180;
var roundCorner = 0.5519;

function roundValues(flag) {
  if (flag) {
    bmRnd = Math.round;
  } else {
    bmRnd = function (val) {
      return val;
    };
  }
}
roundValues(false);

function styleDiv(element) {
  element.style.position = 'absolute';
  element.style.top = 0;
  element.style.left = 0;
  element.style.display = 'block';
  element.style.transformOrigin = '0 0';
  element.style.webkitTransformOrigin = '0 0';
  element.style.backfaceVisibility = 'visible';
  element.style.webkitBackfaceVisibility = 'visible';
  element.style.transformStyle = 'preserve-3d';
  element.style.webkitTransformStyle = 'preserve-3d';
  element.style.mozTransformStyle = 'preserve-3d';
}

function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
  this.type = type;
  this.currentTime = currentTime;
  this.totalTime = totalTime;
  this.direction = frameMultiplier < 0 ? -1 : 1;
}

function BMCompleteEvent(type, frameMultiplier) {
  this.type = type;
  this.direction = frameMultiplier < 0 ? -1 : 1;
}

function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
  this.type = type;
  this.currentLoop = currentLoop;
  this.totalLoops = totalLoops;
  this.direction = frameMultiplier < 0 ? -1 : 1;
}

function BMSegmentStartEvent(type, firstFrame, totalFrames) {
  this.type = type;
  this.firstFrame = firstFrame;
  this.totalFrames = totalFrames;
}

function BMDestroyEvent(type, target) {
  this.type = type;
  this.target = target;
}

function BMRenderFrameErrorEvent(nativeError, currentTime) {
  this.type = 'renderFrameError';
  this.nativeError = nativeError;
  this.currentTime = currentTime;
}

function BMConfigErrorEvent(nativeError) {
  this.type = 'configError';
  this.nativeError = nativeError;
}

function BMAnimationConfigErrorEvent(type, nativeError) {
  this.type = type;
  this.nativeError = nativeError;
}

var createElementID = (function () {
  var _count = 0;
  return function createID() {
    _count += 1;
    return idPrefix + '__lottie_element_' + _count;
  };
}());

function HSVtoRGB(h, s, v) {
  var r;
  var g;
  var b;
  var i;
  var f;
  var p;
  var q;
  var t;
  i = Math.floor(h * 6);
  f = h * 6 - i;
  p = v * (1 - s);
  q = v * (1 - f * s);
  t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0: r = v; g = t; b = p; break;
    case 1: r = q; g = v; b = p; break;
    case 2: r = p; g = v; b = t; break;
    case 3: r = p; g = q; b = v; break;
    case 4: r = t; g = p; b = v; break;
    case 5: r = v; g = p; b = q; break;
    default: break;
  }
  return [r,
    g,
    b];
}

function RGBtoHSV(r, g, b) {
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var d = max - min;
  var h;
  var s = (max === 0 ? 0 : d / max);
  var v = max / 255;

  switch (max) {
    case min: h = 0; break;
    case r: h = (g - b) + d * (g < b ? 6 : 0); h /= 6 * d; break;
    case g: h = (b - r) + d * 2; h /= 6 * d; break;
    case b: h = (r - g) + d * 4; h /= 6 * d; break;
    default: break;
  }

  return [
    h,
    s,
    v,
  ];
}

function addSaturationToRGB(color, offset) {
  var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
  hsv[1] += offset;
  if (hsv[1] > 1) {
    hsv[1] = 1;
  } else if (hsv[1] <= 0) {
    hsv[1] = 0;
  }
  return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
}

function addBrightnessToRGB(color, offset) {
  var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
  hsv[2] += offset;
  if (hsv[2] > 1) {
    hsv[2] = 1;
  } else if (hsv[2] < 0) {
    hsv[2] = 0;
  }
  return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
}

function addHueToRGB(color, offset) {
  var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
  hsv[0] += offset / 360;
  if (hsv[0] > 1) {
    hsv[0] -= 1;
  } else if (hsv[0] < 0) {
    hsv[0] += 1;
  }
  return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
}

var rgbToHex = (function () {
  var colorMap = [];
  var i;
  var hex;
  for (i = 0; i < 256; i += 1) {
    hex = i.toString(16);
    colorMap[i] = hex.length === 1 ? '0' + hex : hex;
  }

  return function (r, g, b) {
    if (r < 0) {
      r = 0;
    }
    if (g < 0) {
      g = 0;
    }
    if (b < 0) {
      b = 0;
    }
    return '#' + colorMap[r] + colorMap[g] + colorMap[b];
  };
}());

function BaseEvent() {}
BaseEvent.prototype = {
  triggerEvent: function (eventName, args) {
    if (this._cbs[eventName]) {
      var len = this._cbs[eventName].length;
      for (var i = 0; i < len; i += 1) {
        this._cbs[eventName][i](args);
      }
    }
  },
  addEventListener: function (eventName, callback) {
    if (!this._cbs[eventName]) {
      this._cbs[eventName] = [];
    }
    this._cbs[eventName].push(callback);

    return function () {
      this.removeEventListener(eventName, callback);
    }.bind(this);
  },
  removeEventListener: function (eventName, callback) {
    if (!callback) {
      this._cbs[eventName] = null;
    } else if (this._cbs[eventName]) {
      var i = 0;
      var len = this._cbs[eventName].length;
      while (i < len) {
        if (this._cbs[eventName][i] === callback) {
          this._cbs[eventName].splice(i, 1);
          i -= 1;
          len -= 1;
        }
        i += 1;
      }
      if (!this._cbs[eventName].length) {
        this._cbs[eventName] = null;
      }
    }
  },
};

/* exported createTypedArray, createSizedArray */

var createTypedArray = (function () {
  function createRegularArray(type, len) {
    var i = 0;
    var arr = [];
    var value;
    switch (type) {
      case 'int16':
      case 'uint8c':
        value = 1;
        break;
      default:
        value = 1.1;
        break;
    }
    for (i = 0; i < len; i += 1) {
      arr.push(value);
    }
    return arr;
  }
  function createTypedArrayFactory(type, len) {
    if (type === 'float32') {
      return new Float32Array(len);
    } if (type === 'int16') {
      return new Int16Array(len);
    } if (type === 'uint8c') {
      return new Uint8ClampedArray(len);
    }
    return createRegularArray(type, len);
  }
  if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {
    return createTypedArrayFactory;
  }
  return createRegularArray;
}());

function createSizedArray(len) {
  return Array.apply(null, { length: len });
}

/* global svgNS */
/* exported createNS */

function createNS(type) {
  // return {appendChild:function(){},setAttribute:function(){},style:{}}
  return document.createElementNS(svgNS, type);
}

/* exported createTag */

function createTag(type) {
  // return {appendChild:function(){},setAttribute:function(){},style:{}}
  return document.createElement(type);
}

function DynamicPropertyContainer() {}
DynamicPropertyContainer.prototype = {
  addDynamicProperty: function (prop) {
    if (this.dynamicProperties.indexOf(prop) === -1) {
      this.dynamicProperties.push(prop);
      this.container.addDynamicProperty(this);
      this._isAnimated = true;
    }
  },
  iterateDynamicProperties: function () {
    this._mdf = false;
    var i;
    var len = this.dynamicProperties.length;
    for (i = 0; i < len; i += 1) {
      this.dynamicProperties[i].getValue();
      if (this.dynamicProperties[i]._mdf) {
        this._mdf = true;
      }
    }
  },
  initDynamicPropertyContainer: function (container) {
    this.container = container;
    this.dynamicProperties = [];
    this._mdf = false;
    this._isAnimated = false;
  },
};

/* exported getBlendMode */

var getBlendMode = (function () {
  var blendModeEnums = {
    0: 'source-over',
    1: 'multiply',
    2: 'screen',
    3: 'overlay',
    4: 'darken',
    5: 'lighten',
    6: 'color-dodge',
    7: 'color-burn',
    8: 'hard-light',
    9: 'soft-light',
    10: 'difference',
    11: 'exclusion',
    12: 'hue',
    13: 'saturation',
    14: 'color',
    15: 'luminosity',
  };

  return function (mode) {
    return blendModeEnums[mode] || '';
  };
}());

/* global createTypedArray */

/*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */

/**
 * 2D transformation matrix object initialized with identity matrix.
 *
 * The matrix can synchronize a canvas context by supplying the context
 * as an argument, or later apply current absolute transform to an
 * existing context.
 *
 * All values are handled as floating point values.
 *
 * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
 * @prop {number} a - scale x
 * @prop {number} b - shear y
 * @prop {number} c - shear x
 * @prop {number} d - scale y
 * @prop {number} e - translate x
 * @prop {number} f - translate y
 * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
 * @constructor
 */

var Matrix = (function () {
  var _cos = Math.cos;
  var _sin = Math.sin;
  var _tan = Math.tan;
  var _rnd = Math.round;

  function reset() {
    this.props[0] = 1;
    this.props[1] = 0;
    this.props[2] = 0;
    this.props[3] = 0;
    this.props[4] = 0;
    this.props[5] = 1;
    this.props[6] = 0;
    this.props[7] = 0;
    this.props[8] = 0;
    this.props[9] = 0;
    this.props[10] = 1;
    this.props[11] = 0;
    this.props[12] = 0;
    this.props[13] = 0;
    this.props[14] = 0;
    this.props[15] = 1;
    return this;
  }

  function rotate(angle) {
    if (angle === 0) {
      return this;
    }
    var mCos = _cos(angle);
    var mSin = _sin(angle);
    return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  }

  function rotateX(angle) {
    if (angle === 0) {
      return this;
    }
    var mCos = _cos(angle);
    var mSin = _sin(angle);
    return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
  }

  function rotateY(angle) {
    if (angle === 0) {
      return this;
    }
    var mCos = _cos(angle);
    var mSin = _sin(angle);
    return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
  }

  function rotateZ(angle) {
    if (angle === 0) {
      return this;
    }
    var mCos = _cos(angle);
    var mSin = _sin(angle);
    return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  }

  function shear(sx, sy) {
    return this._t(1, sy, sx, 1, 0, 0);
  }

  function skew(ax, ay) {
    return this.shear(_tan(ax), _tan(ay));
  }

  function skewFromAxis(ax, angle) {
    var mCos = _cos(angle);
    var mSin = _sin(angle);
    return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
      ._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
      ._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
  }

  function scale(sx, sy, sz) {
    if (!sz && sz !== 0) {
      sz = 1;
    }
    if (sx === 1 && sy === 1 && sz === 1) {
      return this;
    }
    return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
  }

  function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
    this.props[0] = a;
    this.props[1] = b;
    this.props[2] = c;
    this.props[3] = d;
    this.props[4] = e;
    this.props[5] = f;
    this.props[6] = g;
    this.props[7] = h;
    this.props[8] = i;
    this.props[9] = j;
    this.props[10] = k;
    this.props[11] = l;
    this.props[12] = m;
    this.props[13] = n;
    this.props[14] = o;
    this.props[15] = p;
    return this;
  }

  function translate(tx, ty, tz) {
    tz = tz || 0;
    if (tx !== 0 || ty !== 0 || tz !== 0) {
      return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
    }
    return this;
  }

  function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
    var _p = this.props;

    if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
      // NOTE: commenting this condition because TurboFan deoptimizes code when present
      // if(m2 !== 0 || n2 !== 0 || o2 !== 0){
      _p[12] = _p[12] * a2 + _p[15] * m2;
      _p[13] = _p[13] * f2 + _p[15] * n2;
      _p[14] = _p[14] * k2 + _p[15] * o2;
      _p[15] *= p2;
      // }
      this._identityCalculated = false;
      return this;
    }

    var a1 = _p[0];
    var b1 = _p[1];
    var c1 = _p[2];
    var d1 = _p[3];
    var e1 = _p[4];
    var f1 = _p[5];
    var g1 = _p[6];
    var h1 = _p[7];
    var i1 = _p[8];
    var j1 = _p[9];
    var k1 = _p[10];
    var l1 = _p[11];
    var m1 = _p[12];
    var n1 = _p[13];
    var o1 = _p[14];
    var p1 = _p[15];

    /* matrix order (canvas compatible):
         * ace
         * bdf
         * 001
         */
    _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
    _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
    _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
    _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;

    _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
    _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
    _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
    _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;

    _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
    _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
    _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
    _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;

    _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
    _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
    _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
    _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;

    this._identityCalculated = false;
    return this;
  }

  function isIdentity() {
    if (!this._identityCalculated) {
      this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
      this._identityCalculated = true;
    }
    return this._identity;
  }

  function equals(matr) {
    var i = 0;
    while (i < 16) {
      if (matr.props[i] !== this.props[i]) {
        return false;
      }
      i += 1;
    }
    return true;
  }

  function clone(matr) {
    var i;
    for (i = 0; i < 16; i += 1) {
      matr.props[i] = this.props[i];
    }
    return matr;
  }

  function cloneFromProps(props) {
    var i;
    for (i = 0; i < 16; i += 1) {
      this.props[i] = props[i];
    }
  }

  function applyToPoint(x, y, z) {
    return {
      x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
      y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
      z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14],
    };
    /* return {
         x: x * me.a + y * me.c + me.e,
         y: x * me.b + y * me.d + me.f
         }; */
  }
  function applyToX(x, y, z) {
    return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
  }
  function applyToY(x, y, z) {
    return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
  }
  function applyToZ(x, y, z) {
    return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
  }

  function getInverseMatrix() {
    var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
    var a = this.props[5] / determinant;
    var b = -this.props[1] / determinant;
    var c = -this.props[4] / determinant;
    var d = this.props[0] / determinant;
    var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
    var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
    var inverseMatrix = new Matrix();
    inverseMatrix.props[0] = a;
    inverseMatrix.props[1] = b;
    inverseMatrix.props[4] = c;
    inverseMatrix.props[5] = d;
    inverseMatrix.props[12] = e;
    inverseMatrix.props[13] = f;
    return inverseMatrix;
  }

  function inversePoint(pt) {
    var inverseMatrix = this.getInverseMatrix();
    return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
  }

  function inversePoints(pts) {
    var i;
    var len = pts.length;
    var retPts = [];
    for (i = 0; i < len; i += 1) {
      retPts[i] = inversePoint(pts[i]);
    }
    return retPts;
  }

  function applyToTriplePoints(pt1, pt2, pt3) {
    var arr = createTypedArray('float32', 6);
    if (this.isIdentity()) {
      arr[0] = pt1[0];
      arr[1] = pt1[1];
      arr[2] = pt2[0];
      arr[3] = pt2[1];
      arr[4] = pt3[0];
      arr[5] = pt3[1];
    } else {
      var p0 = this.props[0];
      var p1 = this.props[1];
      var p4 = this.props[4];
      var p5 = this.props[5];
      var p12 = this.props[12];
      var p13 = this.props[13];
      arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
      arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
      arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
      arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
      arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
      arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
    }
    return arr;
  }

  function applyToPointArray(x, y, z) {
    var arr;
    if (this.isIdentity()) {
      arr = [x, y, z];
    } else {
      arr = [
        x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
        x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
        x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14],
      ];
    }
    return arr;
  }

  function applyToPointStringified(x, y) {
    if (this.isIdentity()) {
      return x + ',' + y;
    }
    var _p = this.props;
    return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
  }

  function toCSS() {
    // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
    /* if(this.isIdentity()) {
            return '';
        } */
    var i = 0;
    var props = this.props;
    var cssValue = 'matrix3d(';
    var v = 10000;
    while (i < 16) {
      cssValue += _rnd(props[i] * v) / v;
      cssValue += i === 15 ? ')' : ',';
      i += 1;
    }
    return cssValue;
  }

  function roundMatrixProperty(val) {
    var v = 10000;
    if ((val < 0.000001 && val > 0) || (val > -0.000001 && val < 0)) {
      return _rnd(val * v) / v;
    }
    return val;
  }

  function to2dCSS() {
    // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
    /* if(this.isIdentity()) {
            return '';
        } */
    var props = this.props;
    var _a = roundMatrixProperty(props[0]);
    var _b = roundMatrixProperty(props[1]);
    var _c = roundMatrixProperty(props[4]);
    var _d = roundMatrixProperty(props[5]);
    var _e = roundMatrixProperty(props[12]);
    var _f = roundMatrixProperty(props[13]);
    return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')';
  }

  return function () {
    this.reset = reset;
    this.rotate = rotate;
    this.rotateX = rotateX;
    this.rotateY = rotateY;
    this.rotateZ = rotateZ;
    this.skew = skew;
    this.skewFromAxis = skewFromAxis;
    this.shear = shear;
    this.scale = scale;
    this.setTransform = setTransform;
    this.translate = translate;
    this.transform = transform;
    this.applyToPoint = applyToPoint;
    this.applyToX = applyToX;
    this.applyToY = applyToY;
    this.applyToZ = applyToZ;
    this.applyToPointArray = applyToPointArray;
    this.applyToTriplePoints = applyToTriplePoints;
    this.applyToPointStringified = applyToPointStringified;
    this.toCSS = toCSS;
    this.to2dCSS = to2dCSS;
    this.clone = clone;
    this.cloneFromProps = cloneFromProps;
    this.equals = equals;
    this.inversePoints = inversePoints;
    this.inversePoint = inversePoint;
    this.getInverseMatrix = getInverseMatrix;
    this._t = this.transform;
    this.isIdentity = isIdentity;
    this._identity = true;
    this._identityCalculated = false;

    this.props = createTypedArray('float32', 16);
    this.reset();
  };
}());

/* eslint-disable */
/*
 Copyright 2014 David Bau.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
    var global = this,
        width = 256,        // each RC4 output is 0 <= x < 256
        chunks = 6,         // at least six RC4 outputs for each double
        digits = 52,        // there are 52 significant digits in a double
        rngname = 'random', // rngname: name for Math.random and Math.seedrandom
        startdenom = math.pow(width, chunks),
        significance = math.pow(2, digits),
        overflow = significance * 2,
        mask = width - 1,
        nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
    function seedrandom(seed, options, callback) {
        var key = [];
        options = (options === true) ? { entropy: true } : (options || {});

        // Flatten the seed string or build one from local entropy if needed.
        var shortseed = mixkey(flatten(
            options.entropy ? [seed, tostring(pool)] :
                (seed === null) ? autoseed() : seed, 3), key);

        // Use the seed to initialize an ARC4 generator.
        var arc4 = new ARC4(key);

        // This function returns a random double in [0, 1) that contains
        // randomness in every bit of the mantissa of the IEEE 754 value.
        var prng = function() {
            var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
                d = startdenom,                 //   and denominator d = 2 ^ 48.
                x = 0;                          //   and no 'extra last byte'.
            while (n < significance) {          // Fill up all significant digits by
                n = (n + x) * width;              //   shifting numerator and
                d *= width;                       //   denominator and generating a
                x = arc4.g(1);                    //   new least-significant-byte.
            }
            while (n >= overflow) {             // To avoid rounding up, before adding
                n /= 2;                           //   last byte, shift everything
                d /= 2;                           //   right using integer math until
                x >>>= 1;                         //   we have exactly the desired bits.
            }
            return (n + x) / d;                 // Form the number within [0, 1).
        };

        prng.int32 = function() { return arc4.g(4) | 0; };
        prng.quick = function() { return arc4.g(4) / 0x100000000; };
        prng.double = prng;

        // Mix the randomness into accumulated entropy.
        mixkey(tostring(arc4.S), pool);

        // Calling convention: what to return as a function of prng, seed, is_math.
        return (options.pass || callback ||
        function(prng, seed, is_math_call, state) {
            if (state) {
                // Load the arc4 state from the given state if it has an S array.
                if (state.S) { copy(state, arc4); }
                // Only provide the .state method if requested via options.state.
                prng.state = function() { return copy(arc4, {}); };
            }

            // If called as a method of Math (Math.seedrandom()), mutate
            // Math.random because that is how seedrandom.js has worked since v1.0.
            if (is_math_call) { math[rngname] = prng; return seed; }

            // Otherwise, it is a newer calling convention, so return the
            // prng directly.
            else return prng;
        })(
            prng,
            shortseed,
            'global' in options ? options.global : (this == math),
            options.state);
    }
    math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
    function ARC4(key) {
        var t, keylen = key.length,
            me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

        // The empty key [] is treated as [0].
        if (!keylen) { key = [keylen++]; }

        // Set up S using the standard key scheduling algorithm.
        while (i < width) {
            s[i] = i++;
        }
        for (i = 0; i < width; i++) {
            s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
            s[j] = t;
        }

        // The "g" method returns the next (count) outputs as one number.
        me.g = function(count) {
            // Using instance members instead of closure state nearly doubles speed.
            var t, r = 0,
                i = me.i, j = me.j, s = me.S;
            while (count--) {
                t = s[i = mask & (i + 1)];
                r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
            }
            me.i = i; me.j = j;
            return r;
            // For robust unpredictability, the function call below automatically
            // discards an initial batch of values.  This is called RC4-drop[256].
            // See http://google.com/search?q=rsa+fluhrer+response&btnI
        };
    }

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
    function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
    }

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
    function flatten(obj, depth) {
        var result = [], typ = (typeof obj), prop;
        if (depth && typ == 'object') {
            for (prop in obj) {
                try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
            }
        }
        return (result.length ? result : typ == 'string' ? obj : obj + '\0');
    }

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
    function mixkey(seed, key) {
        var stringseed = seed + '', smear, j = 0;
        while (j < stringseed.length) {
            key[mask & j] =
                mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
        }
        return tostring(key);
    }

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
    function autoseed() {
        try {
            if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }
            var out = new Uint8Array(width);
            (global.crypto || global.msCrypto).getRandomValues(out);
            return tostring(out);
        } catch (e) {
            var browser = global.navigator,
                plugins = browser && browser.plugins;
            return [+new Date(), global, plugins, global.screen, tostring(pool)];
        }
    }

//
// tostring()
// Converts an array of charcodes to a string
//
    function tostring(a) {
        return String.fromCharCode.apply(0, a);
    }

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
    mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//

// End anonymous scope, and pass initial values.
})(
    [],     // pool: entropy pool starts empty
    BMMath    // math: package containing random, pow, and seedrandom
);
/* eslint-disable */
var BezierFactory = (function () {
  /**
     * BezierEasing - use bezier curve for transition easing function
     * by Gaëtan Renaudeau 2014 - 2015 – MIT License
     *
     * Credits: is based on Firefox's nsSMILKeySpline.cpp
     * Usage:
     * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
     * spline.get(x) => returns the easing value | x must be in [0, 1] range
     *
     */

  var ob = {};
  ob.getBezierEasing = getBezierEasing;
  var beziers = {};

  function getBezierEasing(a, b, c, d, nm) {
    var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\./g, 'p');
    if (beziers[str]) {
      return beziers[str];
    }
    var bezEasing = new BezierEasing([a, b, c, d]);
    beziers[str] = bezEasing;
    return bezEasing;
  }

  // These values are established by empiricism with tests (tradeoff: performance VS precision)
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;

  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  var float32ArraySupported = typeof Float32Array === 'function';

  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
  function C(aA1) { return 3.0 * aA1; }

  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
      currentT,
      i = 0;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) return aGuessT;
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }

  /**
     * points is an array of [ mX1, mY1, mX2, mY2 ]
     */
  function BezierEasing(points) {
    this._p = points;
    this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    this._precomputed = false;

    this.get = this.get.bind(this);
  }

  BezierEasing.prototype = {

    get: function (x) {
      var mX1 = this._p[0],
        mY1 = this._p[1],
        mX2 = this._p[2],
        mY2 = this._p[3];
      if (!this._precomputed) this._precompute();
      if (mX1 === mY1 && mX2 === mY2) return x; // linear
      // Because JavaScript number are imprecise, we should guarantee the extremes are right.
      if (x === 0) return 0;
      if (x === 1) return 1;
      return calcBezier(this._getTForX(x), mY1, mY2);
    },

    // Private part

    _precompute: function () {
      var mX1 = this._p[0],
        mY1 = this._p[1],
        mX2 = this._p[2],
        mY2 = this._p[3];
      this._precomputed = true;
      if (mX1 !== mY1 || mX2 !== mY2) { this._calcSampleValues(); }
    },

    _calcSampleValues: function () {
      var mX1 = this._p[0],
        mX2 = this._p[2];
      for (var i = 0; i < kSplineTableSize; ++i) {
        this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    },

    /**
         * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
         */
    _getTForX: function (aX) {
      var mX1 = this._p[0],
        mX2 = this._p[2],
        mSampleValues = this._mSampleValues;

      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }
      --currentSample;

      // Interpolate to provide an initial guess for t
      var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;

      var initialSlope = getSlope(guessForT, mX1, mX2);
      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } if (initialSlope === 0.0) {
        return guessForT;
      }
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    },
  };

  return ob;
}());

(function () {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) { // eslint-disable-line no-plusplus
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function (callback) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = setTimeout(function () {
        callback(currTime + timeToCall);
      },
      timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };
  }
}());

/* exported extendPrototype, getDescriptor, createProxyFunction */

function extendPrototype(sources, destination) {
  var i;
  var len = sources.length;
  var sourcePrototype;
  for (i = 0; i < len; i += 1) {
    sourcePrototype = sources[i].prototype;
    for (var attr in sourcePrototype) {
      if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
    }
  }
}

function getDescriptor(object, prop) {
  return Object.getOwnPropertyDescriptor(object, prop);
}

function createProxyFunction(prototype) {
  function ProxyFunction() {}
  ProxyFunction.prototype = prototype;
  return ProxyFunction;
}

/* global segmentsLengthPool, defaultCurveSegments, createSizedArray, bmPow, bmSqrt, bmFloor, createTypedArray, bezierLengthPool */
/* exported bez */

function bezFunction() {
  var math = Math;

  function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
    var det1 = (x1 * y2) + (y1 * x3) + (x2 * y3) - (x3 * y2) - (y3 * x1) - (x2 * y1);
    return det1 > -0.001 && det1 < 0.001;
  }

  function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
    if (z1 === 0 && z2 === 0 && z3 === 0) {
      return pointOnLine2D(x1, y1, x2, y2, x3, y3);
    }
    var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
    var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
    var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
    var diffDist;
    if (dist1 > dist2) {
      if (dist1 > dist3) {
        diffDist = dist1 - dist2 - dist3;
      } else {
        diffDist = dist3 - dist2 - dist1;
      }
    } else if (dist3 > dist2) {
      diffDist = dist3 - dist2 - dist1;
    } else {
      diffDist = dist2 - dist1 - dist3;
    }
    return diffDist > -0.0001 && diffDist < 0.0001;
  }

  var getBezierLength = (function () {
    return function (pt1, pt2, pt3, pt4) {
      var curveSegments = defaultCurveSegments;
      var k;
      var i;
      var len;
      var ptCoord;
      var perc;
      var addedLength = 0;
      var ptDistance;
      var point = [];
      var lastPoint = [];
      var lengthData = bezierLengthPool.newElement();
      len = pt3.length;
      for (k = 0; k < curveSegments; k += 1) {
        perc = k / (curveSegments - 1);
        ptDistance = 0;
        for (i = 0; i < len; i += 1) {
          ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
          point[i] = ptCoord;
          if (lastPoint[i] !== null) {
            ptDistance += bmPow(point[i] - lastPoint[i], 2);
          }
          lastPoint[i] = point[i];
        }
        if (ptDistance) {
          ptDistance = bmSqrt(ptDistance);
          addedLength += ptDistance;
        }
        lengthData.percents[k] = perc;
        lengthData.lengths[k] = addedLength;
      }
      lengthData.addedLength = addedLength;
      return lengthData;
    };
  }());

  function getSegmentsLength(shapeData) {
    var segmentsLength = segmentsLengthPool.newElement();
    var closed = shapeData.c;
    var pathV = shapeData.v;
    var pathO = shapeData.o;
    var pathI = shapeData.i;
    var i;
    var len = shapeData._length;
    var lengths = segmentsLength.lengths;
    var totalLength = 0;
    for (i = 0; i < len - 1; i += 1) {
      lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
      totalLength += lengths[i].addedLength;
    }
    if (closed && len) {
      lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
      totalLength += lengths[i].addedLength;
    }
    segmentsLength.totalLength = totalLength;
    return segmentsLength;
  }

  function BezierData(length) {
    this.segmentLength = 0;
    this.points = new Array(length);
  }

  function PointData(partial, point) {
    this.partialLength = partial;
    this.point = point;
  }

  var buildBezierData = (function () {
    var storedData = {};

    return function (pt1, pt2, pt3, pt4) {
      var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\./g, 'p');
      if (!storedData[bezierName]) {
        var curveSegments = defaultCurveSegments;
        var k;
        var i;
        var len;
        var ptCoord;
        var perc;
        var addedLength = 0;
        var ptDistance;
        var point;
        var lastPoint = null;
        if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
          curveSegments = 2;
        }
        var bezierData = new BezierData(curveSegments);
        len = pt3.length;
        for (k = 0; k < curveSegments; k += 1) {
          point = createSizedArray(len);
          perc = k / (curveSegments - 1);
          ptDistance = 0;
          for (i = 0; i < len; i += 1) {
            ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
            point[i] = ptCoord;
            if (lastPoint !== null) {
              ptDistance += bmPow(point[i] - lastPoint[i], 2);
            }
          }
          ptDistance = bmSqrt(ptDistance);
          addedLength += ptDistance;
          bezierData.points[k] = new PointData(ptDistance, point);
          lastPoint = point;
        }
        bezierData.segmentLength = addedLength;
        storedData[bezierName] = bezierData;
      }
      return storedData[bezierName];
    };
  }());

  function getDistancePerc(perc, bezierData) {
    var percents = bezierData.percents;
    var lengths = bezierData.lengths;
    var len = percents.length;
    var initPos = bmFloor((len - 1) * perc);
    var lengthPos = perc * bezierData.addedLength;
    var lPerc = 0;
    if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
      return percents[initPos];
    }
    var dir = lengths[initPos] > lengthPos ? -1 : 1;
    var flag = true;
    while (flag) {
      if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
        lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
        flag = false;
      } else {
        initPos += dir;
      }
      if (initPos < 0 || initPos >= len - 1) {
        // FIX for TypedArrays that don't store floating point values with enough accuracy
        if (initPos === len - 1) {
          return percents[initPos];
        }
        flag = false;
      }
    }
    return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
  }

  function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
    var t1 = getDistancePerc(percent, bezierData);
    var u1 = 1 - t1;
    var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;
    var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;
    return [ptX, ptY];
  }

  var bezierSegmentPoints = createTypedArray('float32', 8);

  function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
    if (startPerc < 0) {
      startPerc = 0;
    } else if (startPerc > 1) {
      startPerc = 1;
    }
    var t0 = getDistancePerc(startPerc, bezierData);
    endPerc = endPerc > 1 ? 1 : endPerc;
    var t1 = getDistancePerc(endPerc, bezierData);
    var i;
    var len = pt1.length;
    var u0 = 1 - t0;
    var u1 = 1 - t1;
    var u0u0u0 = u0 * u0 * u0;
    var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase
    var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase
    var t0t0t0 = t0 * t0 * t0;
    //
    var u0u0u1 = u0 * u0 * u1;
    var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase
    var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase
    var t0t0t1 = t0 * t0 * t1;
    //
    var u0u1u1 = u0 * u1 * u1;
    var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase
    var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase
    var t0t1t1 = t0 * t1 * t1;
    //
    var u1u1u1 = u1 * u1 * u1;
    var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase
    var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase
    var t1t1t1 = t1 * t1 * t1;
    for (i = 0; i < len; i += 1) {
      bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
      bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
      bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
      bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
    }

    return bezierSegmentPoints;
  }

  return {
    getSegmentsLength: getSegmentsLength,
    getNewSegment: getNewSegment,
    getPointInSegment: getPointInSegment,
    buildBezierData: buildBezierData,
    pointOnLine2D: pointOnLine2D,
    pointOnLine3D: pointOnLine3D,
  };
}

var bez = bezFunction();

/* exported dataManager */

function dataFunctionManager() {
  // var tCanvasHelper = createTag('canvas').getContext('2d');

  function completeLayers(layers, comps, fontManager) {
    var layerData;
    var i;
    var len = layers.length;
    var j;
    var jLen;
    var k;
    var kLen;
    for (i = 0; i < len; i += 1) {
      layerData = layers[i];
      if (('ks' in layerData) && !layerData.completed) {
        layerData.completed = true;
        if (layerData.tt) {
          layers[i - 1].td = layerData.tt;
        }
        if (layerData.hasMask) {
          var maskProps = layerData.masksProperties;
          jLen = maskProps.length;
          for (j = 0; j < jLen; j += 1) {
            if (maskProps[j].pt.k.i) {
              convertPathsToAbsoluteValues(maskProps[j].pt.k);
            } else {
              kLen = maskProps[j].pt.k.length;
              for (k = 0; k < kLen; k += 1) {
                if (maskProps[j].pt.k[k].s) {
                  convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                }
                if (maskProps[j].pt.k[k].e) {
                  convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                }
              }
            }
          }
        }
        if (layerData.ty === 0) {
          layerData.layers = findCompLayers(layerData.refId, comps);
          completeLayers(layerData.layers, comps, fontManager);
        } else if (layerData.ty === 4) {
          completeShapes(layerData.shapes);
        } else if (layerData.ty === 5) {
          completeText(layerData, fontManager);
        }
      }
    }
  }

  function findCompLayers(id, comps) {
    var i = 0;
    var len = comps.length;
    while (i < len) {
      if (comps[i].id === id) {
        if (!comps[i].layers.__used) {
          comps[i].layers.__used = true;
          return comps[i].layers;
        }
        return JSON.parse(JSON.stringify(comps[i].layers));
      }
      i += 1;
    }
    return null;
  }

  function completeShapes(arr) {
    var i;
    var len = arr.length;
    var j;
    var jLen;
    for (i = len - 1; i >= 0; i -= 1) {
      if (arr[i].ty === 'sh') {
        if (arr[i].ks.k.i) {
          convertPathsToAbsoluteValues(arr[i].ks.k);
        } else {
          jLen = arr[i].ks.k.length;
          for (j = 0; j < jLen; j += 1) {
            if (arr[i].ks.k[j].s) {
              convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
            }
            if (arr[i].ks.k[j].e) {
              convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
            }
          }
        }
      } else if (arr[i].ty === 'gr') {
        completeShapes(arr[i].it);
      }
    }
  }

  function convertPathsToAbsoluteValues(path) {
    var i;
    var len = path.i.length;
    for (i = 0; i < len; i += 1) {
      path.i[i][0] += path.v[i][0];
      path.i[i][1] += path.v[i][1];
      path.o[i][0] += path.v[i][0];
      path.o[i][1] += path.v[i][1];
    }
  }

  function checkVersion(minimum, animVersionString) {
    var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];
    if (minimum[0] > animVersion[0]) {
      return true;
    } if (animVersion[0] > minimum[0]) {
      return false;
    }
    if (minimum[1] > animVersion[1]) {
      return true;
    } if (animVersion[1] > minimum[1]) {
      return false;
    }
    if (minimum[2] > animVersion[2]) {
      return true;
    } if (animVersion[2] > minimum[2]) {
      return false;
    }
    return null;
  }

  var checkText = (function () {
    var minimumVersion = [4, 4, 14];

    function updateTextLayer(textLayer) {
      var documentData = textLayer.t.d;
      textLayer.t.d = {
        k: [
          {
            s: documentData,
            t: 0,
          },
        ],
      };
    }

    function iterateLayers(layers) {
      var i;
      var len = layers.length;
      for (i = 0; i < len; i += 1) {
        if (layers[i].ty === 5) {
          updateTextLayer(layers[i]);
        }
      }
    }

    return function (animationData) {
      if (checkVersion(minimumVersion, animationData.v)) {
        iterateLayers(animationData.layers);
        if (animationData.assets) {
          var i;
          var len = animationData.assets.length;
          for (i = 0; i < len; i += 1) {
            if (animationData.assets[i].layers) {
              iterateLayers(animationData.assets[i].layers);
            }
          }
        }
      }
    };
  }());

  var checkChars = (function () {
    var minimumVersion = [4, 7, 99];
    return function (animationData) {
      if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
        var i;
        var len = animationData.chars.length;
        var j;
        var jLen;
        var pathData;
        var paths;
        for (i = 0; i < len; i += 1) {
          if (animationData.chars[i].data && animationData.chars[i].data.shapes) {
            paths = animationData.chars[i].data.shapes[0].it;
            jLen = paths.length;

            for (j = 0; j < jLen; j += 1) {
              pathData = paths[j].ks.k;
              if (!pathData.__converted) {
                convertPathsToAbsoluteValues(paths[j].ks.k);
                pathData.__converted = true;
              }
            }
          }
        }
      }
    };
  }());

  var checkColors = (function () {
    var minimumVersion = [4, 1, 9];

    function iterateShapes(shapes) {
      var i;
      var len = shapes.length;
      var j;
      var jLen;
      for (i = 0; i < len; i += 1) {
        if (shapes[i].ty === 'gr') {
          iterateShapes(shapes[i].it);
        } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {
          if (shapes[i].c.k && shapes[i].c.k[0].i) {
            jLen = shapes[i].c.k.length;
            for (j = 0; j < jLen; j += 1) {
              if (shapes[i].c.k[j].s) {
                shapes[i].c.k[j].s[0] /= 255;
                shapes[i].c.k[j].s[1] /= 255;
                shapes[i].c.k[j].s[2] /= 255;
                shapes[i].c.k[j].s[3] /= 255;
              }
              if (shapes[i].c.k[j].e) {
                shapes[i].c.k[j].e[0] /= 255;
                shapes[i].c.k[j].e[1] /= 255;
                shapes[i].c.k[j].e[2] /= 255;
                shapes[i].c.k[j].e[3] /= 255;
              }
            }
          } else {
            shapes[i].c.k[0] /= 255;
            shapes[i].c.k[1] /= 255;
            shapes[i].c.k[2] /= 255;
            shapes[i].c.k[3] /= 255;
          }
        }
      }
    }

    function iterateLayers(layers) {
      var i;
      var len = layers.length;
      for (i = 0; i < len; i += 1) {
        if (layers[i].ty === 4) {
          iterateShapes(layers[i].shapes);
        }
      }
    }

    return function (animationData) {
      if (checkVersion(minimumVersion, animationData.v)) {
        iterateLayers(animationData.layers);
        if (animationData.assets) {
          var i;
          var len = animationData.assets.length;
          for (i = 0; i < len; i += 1) {
            if (animationData.assets[i].layers) {
              iterateLayers(animationData.assets[i].layers);
            }
          }
        }
      }
    };
  }());

  var checkShapes = (function () {
    var minimumVersion = [4, 4, 18];

    function completeClosingShapes(arr) {
      var i;
      var len = arr.length;
      var j;
      var jLen;
      for (i = len - 1; i >= 0; i -= 1) {
        if (arr[i].ty === 'sh') {
          if (arr[i].ks.k.i) {
            arr[i].ks.k.c = arr[i].closed;
          } else {
            jLen = arr[i].ks.k.length;
            for (j = 0; j < jLen; j += 1) {
              if (arr[i].ks.k[j].s) {
                arr[i].ks.k[j].s[0].c = arr[i].closed;
              }
              if (arr[i].ks.k[j].e) {
                arr[i].ks.k[j].e[0].c = arr[i].closed;
              }
            }
          }
        } else if (arr[i].ty === 'gr') {
          completeClosingShapes(arr[i].it);
        }
      }
    }

    function iterateLayers(layers) {
      var layerData;
      var i;
      var len = layers.length;
      var j;
      var jLen;
      var k;
      var kLen;
      for (i = 0; i < len; i += 1) {
        layerData = layers[i];
        if (layerData.hasMask) {
          var maskProps = layerData.masksProperties;
          jLen = maskProps.length;
          for (j = 0; j < jLen; j += 1) {
            if (maskProps[j].pt.k.i) {
              maskProps[j].pt.k.c = maskProps[j].cl;
            } else {
              kLen = maskProps[j].pt.k.length;
              for (k = 0; k < kLen; k += 1) {
                if (maskProps[j].pt.k[k].s) {
                  maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                }
                if (maskProps[j].pt.k[k].e) {
                  maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                }
              }
            }
          }
        }
        if (layerData.ty === 4) {
          completeClosingShapes(layerData.shapes);
        }
      }
    }

    return function (animationData) {
      if (checkVersion(minimumVersion, animationData.v)) {
        iterateLayers(animationData.layers);
        if (animationData.assets) {
          var i;
          var len = animationData.assets.length;
          for (i = 0; i < len; i += 1) {
            if (animationData.assets[i].layers) {
              iterateLayers(animationData.assets[i].layers);
            }
          }
        }
      }
    };
  }());

  function completeData(animationData, fontManager) {
    if (animationData.__complete) {
      return;
    }
    checkColors(animationData);
    checkText(animationData);
    checkChars(animationData);
    checkShapes(animationData);
    completeLayers(animationData.layers, animationData.assets, fontManager);
    animationData.__complete = true;
  }

  function completeText(data) {
    if (data.t.a.length === 0 && !('m' in data.t.p)) {
      data.singleShape = true;
    }
  }

  var moduleOb = {};
  moduleOb.completeData = completeData;
  moduleOb.checkColors = checkColors;
  moduleOb.checkChars = checkChars;
  moduleOb.checkShapes = checkShapes;
  moduleOb.completeLayers = completeLayers;

  return moduleOb;
}

var dataManager = dataFunctionManager();

/* exported getFontProperties */

function getFontProperties(fontData) {
  var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];

  var fWeight = 'normal'; var
    fStyle = 'normal';
  var len = styles.length;
  var styleName;
  for (var i = 0; i < len; i += 1) {
    styleName = styles[i].toLowerCase();
    switch (styleName) {
      case 'italic':
        fStyle = 'italic';
        break;
      case 'bold':
        fWeight = '700';
        break;
      case 'black':
        fWeight = '900';
        break;
      case 'medium':
        fWeight = '500';
        break;
      case 'regular':
      case 'normal':
        fWeight = '400';
        break;
      case 'light':
      case 'thin':
        fWeight = '200';
        break;
      default:
        break;
    }
  }

  return {
    style: fStyle,
    weight: fontData.fWeight || fWeight,
  };
}

/* global createNS, createTag, getFontProperties */
/* exported FontManager */

var FontManager = (function () {
  var maxWaitingTime = 5000;
  var emptyChar = {
    w: 0,
    size: 0,
    shapes: [],
  };
  var combinedCharacters = [];
  // Hindi characters
  combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366,
    2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379,
    2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);

  function trimFontOptions(font) {
    var familyArray = font.split(',');
    var i;
    var len = familyArray.length;
    var enabledFamilies = [];
    for (i = 0; i < len; i += 1) {
      if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {
        enabledFamilies.push(familyArray[i]);
      }
    }
    return enabledFamilies.join(',');
  }

  function setUpNode(font, family) {
    var parentNode = createTag('span');
    // Node is invisible to screen readers.
    parentNode.setAttribute('aria-hidden', true);
    parentNode.style.fontFamily = family;
    var node = createTag('span');
    // Characters that vary significantly among different fonts
    node.innerText = 'giItT1WQy@!-/#';
    // Visible - so we can measure it - but not on the screen
    parentNode.style.position = 'absolute';
    parentNode.style.left = '-10000px';
    parentNode.style.top = '-10000px';
    // Large font size makes even subtle changes obvious
    parentNode.style.fontSize = '300px';
    // Reset any font properties
    parentNode.style.fontVariant = 'normal';
    parentNode.style.fontStyle = 'normal';
    parentNode.style.fontWeight = 'normal';
    parentNode.style.letterSpacing = '0';
    parentNode.appendChild(node);
    document.body.appendChild(parentNode);

    // Remember width with no applied web font
    var width = node.offsetWidth;
    node.style.fontFamily = trimFontOptions(font) + ', ' + family;
    return { node: node, w: width, parent: parentNode };
  }

  function checkLoadedFonts() {
    var i;
    var len = this.fonts.length;
    var node;
    var w;
    var loadedCount = len;
    for (i = 0; i < len; i += 1) {
      if (this.fonts[i].loaded) {
        loadedCount -= 1;
      } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {
        this.fonts[i].loaded = true;
      } else {
        node = this.fonts[i].monoCase.node;
        w = this.fonts[i].monoCase.w;
        if (node.offsetWidth !== w) {
          loadedCount -= 1;
          this.fonts[i].loaded = true;
        } else {
          node = this.fonts[i].sansCase.node;
          w = this.fonts[i].sansCase.w;
          if (node.offsetWidth !== w) {
            loadedCount -= 1;
            this.fonts[i].loaded = true;
          }
        }
        if (this.fonts[i].loaded) {
          this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
          this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
        }
      }
    }

    if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
      setTimeout(this.checkLoadedFontsBinded, 20);
    } else {
      setTimeout(this.setIsLoadedBinded, 10);
    }
  }

  function createHelper(def, fontData) {
    var tHelper = createNS('text');
    tHelper.style.fontSize = '100px';
    // tHelper.style.fontFamily = fontData.fFamily;

    var fontProps = getFontProperties(fontData);
    tHelper.setAttribute('font-family', fontData.fFamily);
    tHelper.setAttribute('font-style', fontProps.style);
    tHelper.setAttribute('font-weight', fontProps.weight);
    tHelper.textContent = '1';
    if (fontData.fClass) {
      tHelper.style.fontFamily = 'inherit';
      tHelper.setAttribute('class', fontData.fClass);
    } else {
      tHelper.style.fontFamily = fontData.fFamily;
    }
    def.appendChild(tHelper);
    var tCanvasHelper = createTag('canvas').getContext('2d');
    tCanvasHelper.font = fontData.fWeight + ' ' + fontData.fStyle + ' 100px ' + fontData.fFamily;
    // tCanvasHelper.font = ' 100px '+ fontData.fFamily;
    return tHelper;
  }

  function addFonts(fontData, defs) {
    if (!fontData) {
      this.isLoaded = true;
      return;
    }
    if (this.chars) {
      this.isLoaded = true;
      this.fonts = fontData.list;
      return;
    }

    var fontArr = fontData.list;
    var i;
    var len = fontArr.length;
    var _pendingFonts = len;
    for (i = 0; i < len; i += 1) {
      var shouldLoadFont = true;
      var loadedSelector;
      var j;
      fontArr[i].loaded = false;
      fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');
      fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');
      if (!fontArr[i].fPath) {
        fontArr[i].loaded = true;
        _pendingFonts -= 1;
      } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {
        loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');

        if (loadedSelector.length > 0) {
          shouldLoadFont = false;
        }

        if (shouldLoadFont) {
          var s = createTag('style');
          s.setAttribute('f-forigin', fontArr[i].fOrigin);
          s.setAttribute('f-origin', fontArr[i].origin);
          s.setAttribute('f-family', fontArr[i].fFamily);
          s.type = 'text/css';
          s.innerText = '@font-face {font-family: ' + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
          defs.appendChild(s);
        }
      } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {
        loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');

        for (j = 0; j < loadedSelector.length; j += 1) {
          if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
            // Font is already loaded
            shouldLoadFont = false;
          }
        }

        if (shouldLoadFont) {
          var l = createTag('link');
          l.setAttribute('f-forigin', fontArr[i].fOrigin);
          l.setAttribute('f-origin', fontArr[i].origin);
          l.type = 'text/css';
          l.rel = 'stylesheet';
          l.href = fontArr[i].fPath;
          document.body.appendChild(l);
        }
      } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {
        loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');

        for (j = 0; j < loadedSelector.length; j += 1) {
          if (fontArr[i].fPath === loadedSelector[j].src) {
            // Font is already loaded
            shouldLoadFont = false;
          }
        }

        if (shouldLoadFont) {
          var sc = createTag('link');
          sc.setAttribute('f-forigin', fontArr[i].fOrigin);
          sc.setAttribute('f-origin', fontArr[i].origin);
          sc.setAttribute('rel', 'stylesheet');
          sc.setAttribute('href', fontArr[i].fPath);
          defs.appendChild(sc);
        }
      }
      fontArr[i].helper = createHelper(defs, fontArr[i]);
      fontArr[i].cache = {};
      this.fonts.push(fontArr[i]);
    }
    if (_pendingFonts === 0) {
      this.isLoaded = true;
    } else {
      // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
      // Adding this timeout seems to fix it
      setTimeout(this.checkLoadedFonts.bind(this), 100);
    }
  }

  function addChars(chars) {
    if (!chars) {
      return;
    }
    if (!this.chars) {
      this.chars = [];
    }
    var i;
    var len = chars.length;
    var j;
    var jLen = this.chars.length;
    var found;
    for (i = 0; i < len; i += 1) {
      j = 0;
      found = false;
      while (j < jLen) {
        if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {
          found = true;
        }
        j += 1;
      }
      if (!found) {
        this.chars.push(chars[i]);
        jLen += 1;
      }
    }
  }

  function getCharData(char, style, font) {
    var i = 0;
    var len = this.chars.length;
    while (i < len) {
      if (this.chars[i].ch === char && this.chars[i].style === style && this.chars[i].fFamily === font) {
        return this.chars[i];
      }
      i += 1;
    }
    if (((typeof char === 'string' && char.charCodeAt(0) !== 13) || !char)
            && console
            && console.warn // eslint-disable-line no-console
            && !this._warned
    ) {
      this._warned = true;
      console.warn('Missing character from exported characters list: ', char, style, font); // eslint-disable-line no-console
    }
    return emptyChar;
  }

  function measureText(char, fontName, size) {
    var fontData = this.getFontByName(fontName);
    var index = char.charCodeAt(0);
    if (!fontData.cache[index + 1]) {
      var tHelper = fontData.helper;
      // Canvas version
      // fontData.cache[index] = tHelper.measureText(char).width / 100;
      // SVG version
      // console.log(tHelper.getBBox().width)
      if (char === ' ') {
        tHelper.textContent = '|' + char + '|';
        var doubleSize = tHelper.getComputedTextLength();
        tHelper.textContent = '||';
        var singleSize = tHelper.getComputedTextLength();
        fontData.cache[index + 1] = (doubleSize - singleSize) / 100;
      } else {
        tHelper.textContent = char;
        fontData.cache[index + 1] = (tHelper.getComputedTextLength()) / 100;
      }
    }
    return fontData.cache[index + 1] * size;
  }

  function getFontByName(name) {
    var i = 0;
    var len = this.fonts.length;
    while (i < len) {
      if (this.fonts[i].fName === name) {
        return this.fonts[i];
      }
      i += 1;
    }
    return this.fonts[0];
  }

  function getCombinedCharacterCodes() {
    return combinedCharacters;
  }

  function setIsLoaded() {
    this.isLoaded = true;
  }

  var Font = function () {
    this.fonts = [];
    this.chars = null;
    this.typekitLoaded = 0;
    this.isLoaded = false;
    this._warned = false;
    this.initTime = Date.now();
    this.setIsLoadedBinded = this.setIsLoaded.bind(this);
    this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
  };
    // TODO: for now I'm adding these methods to the Class and not the prototype. Think of a better way to implement it.
  Font.getCombinedCharacterCodes = getCombinedCharacterCodes;

  var fontPrototype = {
    addChars: addChars,
    addFonts: addFonts,
    getCharData: getCharData,
    getFontByName: getFontByName,
    measureText: measureText,
    checkLoadedFonts: checkLoadedFonts,
    setIsLoaded: setIsLoaded,
  };

  Font.prototype = fontPrototype;

  return Font;
}());

/* global initialDefaultFrame, BezierFactory, degToRads, bez, createTypedArray */
/* exported PropertyFactory */

var PropertyFactory = (function () {
  var initFrame = initialDefaultFrame;
  var mathAbs = Math.abs;

  function interpolateValue(frameNum, caching) {
    var offsetTime = this.offsetTime;
    var newValue;
    if (this.propType === 'multidimensional') {
      newValue = createTypedArray('float32', this.pv.length);
    }
    var iterationIndex = caching.lastIndex;
    var i = iterationIndex;
    var len = this.keyframes.length - 1;
    var flag = true;
    var keyData;
    var nextKeyData;

    while (flag) {
      keyData = this.keyframes[i];
      nextKeyData = this.keyframes[i + 1];
      if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
        if (keyData.h) {
          keyData = nextKeyData;
        }
        iterationIndex = 0;
        break;
      }
      if ((nextKeyData.t - offsetTime) > frameNum) {
        iterationIndex = i;
        break;
      }
      if (i < len - 1) {
        i += 1;
      } else {
        iterationIndex = 0;
        flag = false;
      }
    }

    var k;
    var kLen;
    var perc;
    var jLen;
    var j;
    var fnc;
    var nextKeyTime = nextKeyData.t - offsetTime;
    var keyTime = keyData.t - offsetTime;
    var endValue;
    if (keyData.to) {
      if (!keyData.bezierData) {
        keyData.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
      }
      var bezierData = keyData.bezierData;
      if (frameNum >= nextKeyTime || frameNum < keyTime) {
        var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
        kLen = bezierData.points[ind].point.length;
        for (k = 0; k < kLen; k += 1) {
          newValue[k] = bezierData.points[ind].point[k];
        }
        // caching._lastKeyframeIndex = -1;
      } else {
        if (keyData.__fnct) {
          fnc = keyData.__fnct;
        } else {
          fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
          keyData.__fnct = fnc;
        }
        perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
        var distanceInLine = bezierData.segmentLength * perc;

        var segmentPerc;
        var addedLength = (caching.lastFrame < frameNum && caching._lastKeyframeIndex === i) ? caching._lastAddedLength : 0;
        j = (caching.lastFrame < frameNum && caching._lastKeyframeIndex === i) ? caching._lastPoint : 0;
        flag = true;
        jLen = bezierData.points.length;
        while (flag) {
          addedLength += bezierData.points[j].partialLength;
          if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
            kLen = bezierData.points[j].point.length;
            for (k = 0; k < kLen; k += 1) {
              newValue[k] = bezierData.points[j].point[k];
            }
            break;
          } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
            segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
            kLen = bezierData.points[j].point.length;
            for (k = 0; k < kLen; k += 1) {
              newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
            }
            break;
          }
          if (j < jLen - 1) {
            j += 1;
          } else {
            flag = false;
          }
        }
        caching._lastPoint = j;
        caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
        caching._lastKeyframeIndex = i;
      }
    } else {
      var outX;
      var outY;
      var inX;
      var inY;
      var keyValue;
      len = keyData.s.length;
      endValue = nextKeyData.s || keyData.e;
      if (this.sh && keyData.h !== 1) {
        if (frameNum >= nextKeyTime) {
          newValue[0] = endValue[0];
          newValue[1] = endValue[1];
          newValue[2] = endValue[2];
        } else if (frameNum <= keyTime) {
          newValue[0] = keyData.s[0];
          newValue[1] = keyData.s[1];
          newValue[2] = keyData.s[2];
        } else {
          var quatStart = createQuaternion(keyData.s);
          var quatEnd = createQuaternion(endValue);
          var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
          quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
        }
      } else {
        for (i = 0; i < len; i += 1) {
          if (keyData.h !== 1) {
            if (frameNum >= nextKeyTime) {
              perc = 1;
            } else if (frameNum < keyTime) {
              perc = 0;
            } else {
              if (keyData.o.x.constructor === Array) {
                if (!keyData.__fnct) {
                  keyData.__fnct = [];
                }
                if (!keyData.__fnct[i]) {
                  outX = (typeof keyData.o.x[i] === 'undefined') ? keyData.o.x[0] : keyData.o.x[i];
                  outY = (typeof keyData.o.y[i] === 'undefined') ? keyData.o.y[0] : keyData.o.y[i];
                  inX = (typeof keyData.i.x[i] === 'undefined') ? keyData.i.x[0] : keyData.i.x[i];
                  inY = (typeof keyData.i.y[i] === 'undefined') ? keyData.i.y[0] : keyData.i.y[i];
                  fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                  keyData.__fnct[i] = fnc;
                } else {
                  fnc = keyData.__fnct[i];
                }
              } else if (!keyData.__fnct) {
                outX = keyData.o.x;
                outY = keyData.o.y;
                inX = keyData.i.x;
                inY = keyData.i.y;
                fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                keyData.__fnct = fnc;
              } else {
                fnc = keyData.__fnct;
              }
              perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
            }
          }

          endValue = nextKeyData.s || keyData.e;
          keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;

          if (this.propType === 'multidimensional') {
            newValue[i] = keyValue;
          } else {
            newValue = keyValue;
          }
        }
      }
    }
    caching.lastIndex = iterationIndex;
    return newValue;
  }

  // based on @Toji's https://github.com/toji/gl-matrix/
  function slerp(a, b, t) {
    var out = [];
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    var bx = b[0];
    var by = b[1];
    var bz = b[2];
    var bw = b[3];

    var omega;
    var cosom;
    var sinom;
    var scale0;
    var scale1;

    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if ((1.0 - cosom) > 0.000001) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1.0 - t;
      scale1 = t;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;

    return out;
  }

  function quaternionToEuler(out, quat) {
    var qx = quat[0];
    var qy = quat[1];
    var qz = quat[2];
    var qw = quat[3];
    var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
    var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
    var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
    out[0] = heading / degToRads;
    out[1] = attitude / degToRads;
    out[2] = bank / degToRads;
  }

  function createQuaternion(values) {
    var heading = values[0] * degToRads;
    var attitude = values[1] * degToRads;
    var bank = values[2] * degToRads;
    var c1 = Math.cos(heading / 2);
    var c2 = Math.cos(attitude / 2);
    var c3 = Math.cos(bank / 2);
    var s1 = Math.sin(heading / 2);
    var s2 = Math.sin(attitude / 2);
    var s3 = Math.sin(bank / 2);
    var w = c1 * c2 * c3 - s1 * s2 * s3;
    var x = s1 * s2 * c3 + c1 * c2 * s3;
    var y = s1 * c2 * c3 + c1 * s2 * s3;
    var z = c1 * s2 * c3 - s1 * c2 * s3;

    return [x, y, z, w];
  }

  function getValueAtCurrentTime() {
    var frameNum = this.comp.renderedFrame - this.offsetTime;
    var initTime = this.keyframes[0].t - this.offsetTime;
    var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
    if (!(frameNum === this._caching.lastFrame || (this._caching.lastFrame !== initFrame && ((this._caching.lastFrame >= endTime && frameNum >= endTime) || (this._caching.lastFrame < initTime && frameNum < initTime))))) {
      if (this._caching.lastFrame >= frameNum) {
        this._caching._lastKeyframeIndex = -1;
        this._caching.lastIndex = 0;
      }

      var renderResult = this.interpolateValue(frameNum, this._caching);
      this.pv = renderResult;
    }
    this._caching.lastFrame = frameNum;
    return this.pv;
  }

  function setVValue(val) {
    var multipliedValue;
    if (this.propType === 'unidimensional') {
      multipliedValue = val * this.mult;
      if (mathAbs(this.v - multipliedValue) > 0.00001) {
        this.v = multipliedValue;
        this._mdf = true;
      }
    } else {
      var i = 0;
      var len = this.v.length;
      while (i < len) {
        multipliedValue = val[i] * this.mult;
        if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {
          this.v[i] = multipliedValue;
          this._mdf = true;
        }
        i += 1;
      }
    }
  }

  function processEffectsSequence() {
    if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
      return;
    }
    if (this.lock) {
      this.setVValue(this.pv);
      return;
    }
    this.lock = true;
    this._mdf = this._isFirstFrame;
    var i;
    var len = this.effectsSequence.length;
    var finalValue = this.kf ? this.pv : this.data.k;
    for (i = 0; i < len; i += 1) {
      finalValue = this.effectsSequence[i](finalValue);
    }
    this.setVValue(finalValue);
    this._isFirstFrame = false;
    this.lock = false;
    this.frameId = this.elem.globalData.frameId;
  }

  function addEffect(effectFunction) {
    this.effectsSequence.push(effectFunction);
    this.container.addDynamicProperty(this);
  }

  function ValueProperty(elem, data, mult, container) {
    this.propType = 'unidimensional';
    this.mult = mult || 1;
    this.data = data;
    this.v = mult ? data.k * mult : data.k;
    this.pv = data.k;
    this._mdf = false;
    this.elem = elem;
    this.container = container;
    this.comp = elem.comp;
    this.k = false;
    this.kf = false;
    this.vel = 0;
    this.effectsSequence = [];
    this._isFirstFrame = true;
    this.getValue = processEffectsSequence;
    this.setVValue = setVValue;
    this.addEffect = addEffect;
  }

  function MultiDimensionalProperty(elem, data, mult, container) {
    this.propType = 'multidimensional';
    this.mult = mult || 1;
    this.data = data;
    this._mdf = false;
    this.elem = elem;
    this.container = container;
    this.comp = elem.comp;
    this.k = false;
    this.kf = false;
    this.frameId = -1;
    var i;
    var len = data.k.length;
    this.v = createTypedArray('float32', len);
    this.pv = createTypedArray('float32', len);
    this.vel = createTypedArray('float32', len);
    for (i = 0; i < len; i += 1) {
      this.v[i] = data.k[i] * this.mult;
      this.pv[i] = data.k[i];
    }
    this._isFirstFrame = true;
    this.effectsSequence = [];
    this.getValue = processEffectsSequence;
    this.setVValue = setVValue;
    this.addEffect = addEffect;
  }

  function KeyframedValueProperty(elem, data, mult, container) {
    this.propType = 'unidimensional';
    this.keyframes = data.k;
    this.offsetTime = elem.data.st;
    this.frameId = -1;
    this._caching = {
      lastFrame: initFrame, lastIndex: 0, value: 0, _lastKeyframeIndex: -1,
    };
    this.k = true;
    this.kf = true;
    this.data = data;
    this.mult = mult || 1;
    this.elem = elem;
    this.container = container;
    this.comp = elem.comp;
    this.v = initFrame;
    this.pv = initFrame;
    this._isFirstFrame = true;
    this.getValue = processEffectsSequence;
    this.setVValue = setVValue;
    this.interpolateValue = interpolateValue;
    this.effectsSequence = [getValueAtCurrentTime.bind(this)];
    this.addEffect = addEffect;
  }

  function KeyframedMultidimensionalProperty(elem, data, mult, container) {
    this.propType = 'multidimensional';
    var i;
    var len = data.k.length;
    var s;
    var e;
    var to;
    var ti;
    for (i = 0; i < len - 1; i += 1) {
      if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {
        s = data.k[i].s;
        e = data.k[i + 1].s;
        to = data.k[i].to;
        ti = data.k[i].ti;
        if ((s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1])) || (s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2]))) {
          data.k[i].to = null;
          data.k[i].ti = null;
        }
        if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
          if (s.length === 2 || (s[2] === e[2] && to[2] === 0 && ti[2] === 0)) {
            data.k[i].to = null;
            data.k[i].ti = null;
          }
        }
      }
    }
    this.effectsSequence = [getValueAtCurrentTime.bind(this)];
    this.data = data;
    this.keyframes = data.k;
    this.offsetTime = elem.data.st;
    this.k = true;
    this.kf = true;
    this._isFirstFrame = true;
    this.mult = mult || 1;
    this.elem = elem;
    this.container = container;
    this.comp = elem.comp;
    this.getValue = processEffectsSequence;
    this.setVValue = setVValue;
    this.interpolateValue = interpolateValue;
    this.frameId = -1;
    var arrLen = data.k[0].s.length;
    this.v = createTypedArray('float32', arrLen);
    this.pv = createTypedArray('float32', arrLen);
    for (i = 0; i < arrLen; i += 1) {
      this.v[i] = initFrame;
      this.pv[i] = initFrame;
    }
    this._caching = { lastFrame: initFrame, lastIndex: 0, value: createTypedArray('float32', arrLen) };
    this.addEffect = addEffect;
  }

  function getProp(elem, data, type, mult, container) {
    var p;
    if (!data.k.length) {
      p = new ValueProperty(elem, data, mult, container);
    } else if (typeof (data.k[0]) === 'number') {
      p = new MultiDimensionalProperty(elem, data, mult, container);
    } else {
      switch (type) {
        case 0:
          p = new KeyframedValueProperty(elem, data, mult, container);
          break;
        case 1:
          p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
          break;
        default:
          break;
      }
    }
    if (p.effectsSequence.length) {
      container.addDynamicProperty(p);
    }
    return p;
  }

  var ob = {
    getProp: getProp,
  };
  return ob;
}());

/* global Matrix, degToRads, PropertyFactory, extendPrototype, DynamicPropertyContainer */
/* exported TransformPropertyFactory */

var TransformPropertyFactory = (function () {
  var defaultVector = [0, 0];

  function applyToMatrix(mat) {
    var _mdf = this._mdf;
    this.iterateDynamicProperties();
    this._mdf = this._mdf || _mdf;
    if (this.a) {
      mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
    }
    if (this.s) {
      mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
    }
    if (this.sk) {
      mat.skewFromAxis(-this.sk.v, this.sa.v);
    }
    if (this.r) {
      mat.rotate(-this.r.v);
    } else {
      mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
        .rotateY(this.or.v[1])
        .rotateX(this.or.v[0]);
    }
    if (this.data.p.s) {
      if (this.data.p.z) {
        mat.translate(this.px.v, this.py.v, -this.pz.v);
      } else {
        mat.translate(this.px.v, this.py.v, 0);
      }
    } else {
      mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
    }
  }
  function processKeys(forceRender) {
    if (this.elem.globalData.frameId === this.frameId) {
      return;
    }
    if (this._isDirty) {
      this.precalculateMatrix();
      this._isDirty = false;
    }

    this.iterateDynamicProperties();

    if (this._mdf || forceRender) {
      var frameRate;
      this.v.cloneFromProps(this.pre.props);
      if (this.appliedTransformations < 1) {
        this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
      }
      if (this.appliedTransformations < 2) {
        this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
      }
      if (this.sk && this.appliedTransformations < 3) {
        this.v.skewFromAxis(-this.sk.v, this.sa.v);
      }
      if (this.r && this.appliedTransformations < 4) {
        this.v.rotate(-this.r.v);
      } else if (!this.r && this.appliedTransformations < 4) {
        this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
          .rotateY(this.or.v[1])
          .rotateX(this.or.v[0]);
      }
      if (this.autoOriented) {
        var v1;
        var v2;
        frameRate = this.elem.globalData.frameRate;
        if (this.p && this.p.keyframes && this.p.getValueAtTime) {
          if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
            v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
            v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
          } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
            v1 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t / frameRate), 0);
            v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
          } else {
            v1 = this.p.pv;
            v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
          }
        } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
          v1 = [];
          v2 = [];
          var px = this.px;
          var py = this.py;
          if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
            v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
            v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
            v2[0] = px.getValueAtTime((px.keyframes[0].t) / frameRate, 0);
            v2[1] = py.getValueAtTime((py.keyframes[0].t) / frameRate, 0);
          } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
            v1[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t / frameRate), 0);
            v1[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t / frameRate), 0);
            v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
            v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
          } else {
            v1 = [px.pv, py.pv];
            v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
            v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
          }
        } else {
          v2 = defaultVector;
          v1 = v2;
        }
        this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
      }
      if (this.data.p && this.data.p.s) {
        if (this.data.p.z) {
          this.v.translate(this.px.v, this.py.v, -this.pz.v);
        } else {
          this.v.translate(this.px.v, this.py.v, 0);
        }
      } else {
        this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
      }
    }
    this.frameId = this.elem.globalData.frameId;
  }

  function precalculateMatrix() {
    if (!this.a.k) {
      this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
      this.appliedTransformations = 1;
    } else {
      return;
    }
    if (!this.s.effectsSequence.length) {
      this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
      this.appliedTransformations = 2;
    } else {
      return;
    }
    if (this.sk) {
      if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
        this.pre.skewFromAxis(-this.sk.v, this.sa.v);
        this.appliedTransformations = 3;
      } else {
        return;
      }
    }
    if (this.r) {
      if (!this.r.effectsSequence.length) {
        this.pre.rotate(-this.r.v);
        this.appliedTransformations = 4;
      }
    } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
      this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
        .rotateY(this.or.v[1])
        .rotateX(this.or.v[0]);
      this.appliedTransformations = 4;
    }
  }

  function autoOrient() {
    //
    // var prevP = this.getValueAtTime();
  }

  function addDynamicProperty(prop) {
    this._addDynamicProperty(prop);
    this.elem.addDynamicProperty(prop);
    this._isDirty = true;
  }

  function TransformProperty(elem, data, container) {
    this.elem = elem;
    this.frameId = -1;
    this.propType = 'transform';
    this.data = data;
    this.v = new Matrix();
    // Precalculated matrix with non animated properties
    this.pre = new Matrix();
    this.appliedTransformations = 0;
    this.initDynamicPropertyContainer(container || elem);
    if (data.p && data.p.s) {
      this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
      this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);
      if (data.p.z) {
        this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
      }
    } else {
      this.p = PropertyFactory.getProp(elem, data.p || { k: [0, 0, 0] }, 1, 0, this);
    }
    if (data.rx) {
      this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
      this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
      this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
      if (data.or.k[0].ti) {
        var i;
        var len = data.or.k.length;
        for (i = 0; i < len; i += 1) {
          data.or.k[i].to = null;
          data.or.k[i].ti = null;
        }
      }
      this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);
      // sh Indicates it needs to be capped between -180 and 180
      this.or.sh = true;
    } else {
      this.r = PropertyFactory.getProp(elem, data.r || { k: 0 }, 0, degToRads, this);
    }
    if (data.sk) {
      this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
      this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
    }
    this.a = PropertyFactory.getProp(elem, data.a || { k: [0, 0, 0] }, 1, 0, this);
    this.s = PropertyFactory.getProp(elem, data.s || { k: [100, 100, 100] }, 1, 0.01, this);
    // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.
    if (data.o) {
      this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
    } else {
      this.o = { _mdf: false, v: 1 };
    }
    this._isDirty = true;
    if (!this.dynamicProperties.length) {
      this.getValue(true);
    }
  }

  TransformProperty.prototype = {
    applyToMatrix: applyToMatrix,
    getValue: processKeys,
    precalculateMatrix: precalculateMatrix,
    autoOrient: autoOrient,
  };

  extendPrototype([DynamicPropertyContainer], TransformProperty);
  TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
  TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;

  function getTransformProperty(elem, data, container) {
    return new TransformProperty(elem, data, container);
  }

  return {
    getTransformProperty: getTransformProperty,
  };
}());

/* global createSizedArray, createSizedArray, pointPool */

function ShapePath() {
  this.c = false;
  this._length = 0;
  this._maxLength = 8;
  this.v = createSizedArray(this._maxLength);
  this.o = createSizedArray(this._maxLength);
  this.i = createSizedArray(this._maxLength);
}

ShapePath.prototype.setPathData = function (closed, len) {
  this.c = closed;
  this.setLength(len);
  var i = 0;
  while (i < len) {
    this.v[i] = pointPool.newElement();
    this.o[i] = pointPool.newElement();
    this.i[i] = pointPool.newElement();
    i += 1;
  }
};

ShapePath.prototype.setLength = function (len) {
  while (this._maxLength < len) {
    this.doubleArrayLength();
  }
  this._length = len;
};

ShapePath.prototype.doubleArrayLength = function () {
  this.v = this.v.concat(createSizedArray(this._maxLength));
  this.i = this.i.concat(createSizedArray(this._maxLength));
  this.o = this.o.concat(createSizedArray(this._maxLength));
  this._maxLength *= 2;
};

ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {
  var arr;
  this._length = Math.max(this._length, pos + 1);
  if (this._length >= this._maxLength) {
    this.doubleArrayLength();
  }
  switch (type) {
    case 'v':
      arr = this.v;
      break;
    case 'i':
      arr = this.i;
      break;
    case 'o':
      arr = this.o;
      break;
    default:
      arr = [];
      break;
  }
  if (!arr[pos] || (arr[pos] && !replace)) {
    arr[pos] = pointPool.newElement();
  }
  arr[pos][0] = x;
  arr[pos][1] = y;
};

ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {
  this.setXYAt(vX, vY, 'v', pos, replace);
  this.setXYAt(oX, oY, 'o', pos, replace);
  this.setXYAt(iX, iY, 'i', pos, replace);
};

ShapePath.prototype.reverse = function () {
  var newPath = new ShapePath();
  newPath.setPathData(this.c, this._length);
  var vertices = this.v;
  var outPoints = this.o;
  var inPoints = this.i;
  var init = 0;
  if (this.c) {
    newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
    init = 1;
  }
  var cnt = this._length - 1;
  var len = this._length;

  var i;
  for (i = init; i < len; i += 1) {
    newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
    cnt -= 1;
  }
  return newPath;
};

/* global extendPrototype, roundCorner, BezierFactory, shapePool, degToRads,
  shapeCollectionPool, PropertyFactory, bmMin, DynamicPropertyContainer */
/* exported ShapePropertyFactory */

var ShapePropertyFactory = (function () {
  var initFrame = -999999;

  function interpolateShape(frameNum, previousValue, caching) {
    var iterationIndex = caching.lastIndex;
    var keyPropS;
    var keyPropE;
    var isHold;
    var j;
    var k;
    var jLen;
    var kLen;
    var perc;
    var vertexValue;
    var kf = this.keyframes;
    if (frameNum < kf[0].t - this.offsetTime) {
      keyPropS = kf[0].s[0];
      isHold = true;
      iterationIndex = 0;
    } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
      keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
      /* if(kf[kf.length - 1].s){
                keyPropS = kf[kf.length - 1].s[0];
            }else{
                keyPropS = kf[kf.length - 2].e[0];
            } */
      isHold = true;
    } else {
      var i = iterationIndex;
      var len = kf.length - 1;
      var flag = true;
      var keyData;
      var nextKeyData;
      while (flag) {
        keyData = kf[i];
        nextKeyData = kf[i + 1];
        if ((nextKeyData.t - this.offsetTime) > frameNum) {
          break;
        }
        if (i < len - 1) {
          i += 1;
        } else {
          flag = false;
        }
      }
      isHold = keyData.h === 1;
      iterationIndex = i;
      if (!isHold) {
        if (frameNum >= nextKeyData.t - this.offsetTime) {
          perc = 1;
        } else if (frameNum < keyData.t - this.offsetTime) {
          perc = 0;
        } else {
          var fnc;
          if (keyData.__fnct) {
            fnc = keyData.__fnct;
          } else {
            fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
            keyData.__fnct = fnc;
          }
          perc = fnc((frameNum - (keyData.t - this.offsetTime)) / ((nextKeyData.t - this.offsetTime) - (keyData.t - this.offsetTime)));
        }
        keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
      }
      keyPropS = keyData.s[0];
    }
    jLen = previousValue._length;
    kLen = keyPropS.i[0].length;
    caching.lastIndex = iterationIndex;

    for (j = 0; j < jLen; j += 1) {
      for (k = 0; k < kLen; k += 1) {
        vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
        previousValue.i[j][k] = vertexValue;
        vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
        previousValue.o[j][k] = vertexValue;
        vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
        previousValue.v[j][k] = vertexValue;
      }
    }
  }

  function interpolateShapeCurrentTime() {
    var frameNum = this.comp.renderedFrame - this.offsetTime;
    var initTime = this.keyframes[0].t - this.offsetTime;
    var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
    var lastFrame = this._caching.lastFrame;
    if (!(lastFrame !== initFrame && ((lastFrame < initTime && frameNum < initTime) || (lastFrame > endTime && frameNum > endTime)))) {
      /// /
      this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
      this.interpolateShape(frameNum, this.pv, this._caching);
      /// /
    }
    this._caching.lastFrame = frameNum;
    return this.pv;
  }

  function resetShape() {
    this.paths = this.localShapeCollection;
  }

  function shapesEqual(shape1, shape2) {
    if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
      return false;
    }
    var i;
    var len = shape1._length;
    for (i = 0; i < len; i += 1) {
      if (shape1.v[i][0] !== shape2.v[i][0]
            || shape1.v[i][1] !== shape2.v[i][1]
            || shape1.o[i][0] !== shape2.o[i][0]
            || shape1.o[i][1] !== shape2.o[i][1]
            || shape1.i[i][0] !== shape2.i[i][0]
            || shape1.i[i][1] !== shape2.i[i][1]) {
        return false;
      }
    }
    return true;
  }

  function setVValue(newPath) {
    if (!shapesEqual(this.v, newPath)) {
      this.v = shapePool.clone(newPath);
      this.localShapeCollection.releaseShapes();
      this.localShapeCollection.addShape(this.v);
      this._mdf = true;
      this.paths = this.localShapeCollection;
    }
  }

  function processEffectsSequence() {
    if (this.elem.globalData.frameId === this.frameId) {
      return;
    } if (!this.effectsSequence.length) {
      this._mdf = false;
      return;
    }
    if (this.lock) {
      this.setVValue(this.pv);
      return;
    }
    this.lock = true;
    this._mdf = false;
    var finalValue;
    if (this.kf) {
      finalValue = this.pv;
    } else if (this.data.ks) {
      finalValue = this.data.ks.k;
    } else {
      finalValue = this.data.pt.k;
    }
    var i;
    var len = this.effectsSequence.length;
    for (i = 0; i < len; i += 1) {
      finalValue = this.effectsSequence[i](finalValue);
    }
    this.setVValue(finalValue);
    this.lock = false;
    this.frameId = this.elem.globalData.frameId;
  }

  function ShapeProperty(elem, data, type) {
    this.propType = 'shape';
    this.comp = elem.comp;
    this.container = elem;
    this.elem = elem;
    this.data = data;
    this.k = false;
    this.kf = false;
    this._mdf = false;
    var pathData = type === 3 ? data.pt.k : data.ks.k;
    this.v = shapePool.clone(pathData);
    this.pv = shapePool.clone(this.v);
    this.localShapeCollection = shapeCollectionPool.newShapeCollection();
    this.paths = this.localShapeCollection;
    this.paths.addShape(this.v);
    this.reset = resetShape;
    this.effectsSequence = [];
  }

  function addEffect(effectFunction) {
    this.effectsSequence.push(effectFunction);
    this.container.addDynamicProperty(this);
  }

  ShapeProperty.prototype.interpolateShape = interpolateShape;
  ShapeProperty.prototype.getValue = processEffectsSequence;
  ShapeProperty.prototype.setVValue = setVValue;
  ShapeProperty.prototype.addEffect = addEffect;

  function KeyframedShapeProperty(elem, data, type) {
    this.propType = 'shape';
    this.comp = elem.comp;
    this.elem = elem;
    this.container = elem;
    this.offsetTime = elem.data.st;
    this.keyframes = type === 3 ? data.pt.k : data.ks.k;
    this.k = true;
    this.kf = true;
    var len = this.keyframes[0].s[0].i.length;
    this.v = shapePool.newElement();
    this.v.setPathData(this.keyframes[0].s[0].c, len);
    this.pv = shapePool.clone(this.v);
    this.localShapeCollection = shapeCollectionPool.newShapeCollection();
    this.paths = this.localShapeCollection;
    this.paths.addShape(this.v);
    this.lastFrame = initFrame;
    this.reset = resetShape;
    this._caching = { lastFrame: initFrame, lastIndex: 0 };
    this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
  }
  KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
  KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
  KeyframedShapeProperty.prototype.setVValue = setVValue;
  KeyframedShapeProperty.prototype.addEffect = addEffect;

  var EllShapeProperty = (function () {
    var cPoint = roundCorner;

    function EllShapePropertyFactory(elem, data) {
      /* this.v = {
                v: createSizedArray(4),
                i: createSizedArray(4),
                o: createSizedArray(4),
                c: true
            }; */
      this.v = shapePool.newElement();
      this.v.setPathData(true, 4);
      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
      this.paths = this.localShapeCollection;
      this.localShapeCollection.addShape(this.v);
      this.d = data.d;
      this.elem = elem;
      this.comp = elem.comp;
      this.frameId = -1;
      this.initDynamicPropertyContainer(elem);
      this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
      this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
      if (this.dynamicProperties.length) {
        this.k = true;
      } else {
        this.k = false;
        this.convertEllToPath();
      }
    }

    EllShapePropertyFactory.prototype = {
      reset: resetShape,
      getValue: function () {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();

        if (this._mdf) {
          this.convertEllToPath();
        }
      },
      convertEllToPath: function () {
        var p0 = this.p.v[0];
        var p1 = this.p.v[1];
        var s0 = this.s.v[0] / 2;
        var s1 = this.s.v[1] / 2;
        var _cw = this.d !== 3;
        var _v = this.v;
        _v.v[0][0] = p0;
        _v.v[0][1] = p1 - s1;
        _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
        _v.v[1][1] = p1;
        _v.v[2][0] = p0;
        _v.v[2][1] = p1 + s1;
        _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
        _v.v[3][1] = p1;
        _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
        _v.i[0][1] = p1 - s1;
        _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
        _v.i[1][1] = p1 - s1 * cPoint;
        _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
        _v.i[2][1] = p1 + s1;
        _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
        _v.i[3][1] = p1 + s1 * cPoint;
        _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
        _v.o[0][1] = p1 - s1;
        _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
        _v.o[1][1] = p1 + s1 * cPoint;
        _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
        _v.o[2][1] = p1 + s1;
        _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
        _v.o[3][1] = p1 - s1 * cPoint;
      },
    };

    extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);

    return EllShapePropertyFactory;
  }());

  var StarShapeProperty = (function () {
    function StarShapePropertyFactory(elem, data) {
      this.v = shapePool.newElement();
      this.v.setPathData(true, 0);
      this.elem = elem;
      this.comp = elem.comp;
      this.data = data;
      this.frameId = -1;
      this.d = data.d;
      this.initDynamicPropertyContainer(elem);
      if (data.sy === 1) {
        this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
        this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
        this.convertToPath = this.convertStarToPath;
      } else {
        this.convertToPath = this.convertPolygonToPath;
      }
      this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
      this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
      this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
      this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
      this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
      this.localShapeCollection.addShape(this.v);
      this.paths = this.localShapeCollection;
      if (this.dynamicProperties.length) {
        this.k = true;
      } else {
        this.k = false;
        this.convertToPath();
      }
    }

    StarShapePropertyFactory.prototype = {
      reset: resetShape,
      getValue: function () {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
        if (this._mdf) {
          this.convertToPath();
        }
      },
      convertStarToPath: function () {
        var numPts = Math.floor(this.pt.v) * 2;
        var angle = (Math.PI * 2) / numPts;
        /* this.v.v.length = numPts;
                this.v.i.length = numPts;
                this.v.o.length = numPts; */
        var longFlag = true;
        var longRad = this.or.v;
        var shortRad = this.ir.v;
        var longRound = this.os.v;
        var shortRound = this.is.v;
        var longPerimSegment = (2 * Math.PI * longRad) / (numPts * 2);
        var shortPerimSegment = (2 * Math.PI * shortRad) / (numPts * 2);
        var i;
        var rad;
        var roundness;
        var perimSegment;
        var currentAng = -Math.PI / 2;
        currentAng += this.r.v;
        var dir = this.data.d === 3 ? -1 : 1;
        this.v._length = 0;
        for (i = 0; i < numPts; i += 1) {
          rad = longFlag ? longRad : shortRad;
          roundness = longFlag ? longRound : shortRound;
          perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
          var x = rad * Math.cos(currentAng);
          var y = rad * Math.sin(currentAng);
          var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
          var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
          x += +this.p.v[0];
          y += +this.p.v[1];
          this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);

          /* this.v.v[i] = [x,y];
                    this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
                    this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
                    this.v._length = numPts; */
          longFlag = !longFlag;
          currentAng += angle * dir;
        }
      },
      convertPolygonToPath: function () {
        var numPts = Math.floor(this.pt.v);
        var angle = (Math.PI * 2) / numPts;
        var rad = this.or.v;
        var roundness = this.os.v;
        var perimSegment = (2 * Math.PI * rad) / (numPts * 4);
        var i;
        var currentAng = -Math.PI * 0.5;
        var dir = this.data.d === 3 ? -1 : 1;
        currentAng += this.r.v;
        this.v._length = 0;
        for (i = 0; i < numPts; i += 1) {
          var x = rad * Math.cos(currentAng);
          var y = rad * Math.sin(currentAng);
          var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
          var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
          x += +this.p.v[0];
          y += +this.p.v[1];
          this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
          currentAng += angle * dir;
        }
        this.paths.length = 0;
        this.paths[0] = this.v;
      },

    };
    extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);

    return StarShapePropertyFactory;
  }());

  var RectShapeProperty = (function () {
    function RectShapePropertyFactory(elem, data) {
      this.v = shapePool.newElement();
      this.v.c = true;
      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
      this.localShapeCollection.addShape(this.v);
      this.paths = this.localShapeCollection;
      this.elem = elem;
      this.comp = elem.comp;
      this.frameId = -1;
      this.d = data.d;
      this.initDynamicPropertyContainer(elem);
      this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
      this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
      this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);
      if (this.dynamicProperties.length) {
        this.k = true;
      } else {
        this.k = false;
        this.convertRectToPath();
      }
    }

    RectShapePropertyFactory.prototype = {
      convertRectToPath: function () {
        var p0 = this.p.v[0];
        var p1 = this.p.v[1];
        var v0 = this.s.v[0] / 2;
        var v1 = this.s.v[1] / 2;
        var round = bmMin(v0, v1, this.r.v);
        var cPoint = round * (1 - roundCorner);
        this.v._length = 0;

        if (this.d === 2 || this.d === 1) {
          this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
          this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
          if (round !== 0) {
            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
          } else {
            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
          }
        } else {
          this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
          if (round !== 0) {
            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
          } else {
            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
            this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
          }
        }
      },
      getValue: function () {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
        if (this._mdf) {
          this.convertRectToPath();
        }
      },
      reset: resetShape,
    };
    extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);

    return RectShapePropertyFactory;
  }());

  function getShapeProp(elem, data, type) {
    var prop;
    if (type === 3 || type === 4) {
      var dataProp = type === 3 ? data.pt : data.ks;
      var keys = dataProp.k;
      if (keys.length) {
        prop = new KeyframedShapeProperty(elem, data, type);
      } else {
        prop = new ShapeProperty(elem, data, type);
      }
    } else if (type === 5) {
      prop = new RectShapeProperty(elem, data);
    } else if (type === 6) {
      prop = new EllShapeProperty(elem, data);
    } else if (type === 7) {
      prop = new StarShapeProperty(elem, data);
    }
    if (prop.k) {
      elem.addDynamicProperty(prop);
    }
    return prop;
  }

  function getConstructorFunction() {
    return ShapeProperty;
  }

  function getKeyframedConstructorFunction() {
    return KeyframedShapeProperty;
  }

  var ob = {};
  ob.getShapeProp = getShapeProp;
  ob.getConstructorFunction = getConstructorFunction;
  ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
  return ob;
}());

/* global shapeCollectionPool, initialDefaultFrame, extendPrototype, DynamicPropertyContainer */
/* exported ShapeModifiers */

var ShapeModifiers = (function () {
  var ob = {};
  var modifiers = {};
  ob.registerModifier = registerModifier;
  ob.getModifier = getModifier;

  function registerModifier(nm, factory) {
    if (!modifiers[nm]) {
      modifiers[nm] = factory;
    }
  }

  function getModifier(nm, elem, data) {
    return new modifiers[nm](elem, data);
  }

  return ob;
}());

function ShapeModifier() {}
ShapeModifier.prototype.initModifierProperties = function () {};
ShapeModifier.prototype.addShapeToModifier = function () {};
ShapeModifier.prototype.addShape = function (data) {
  if (!this.closed) {
    // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
    data.sh.container.addDynamicProperty(data.sh);
    var shapeData = { shape: data.sh, data: data, localShapeCollection: shapeCollectionPool.newShapeCollection() };
    this.shapes.push(shapeData);
    this.addShapeToModifier(shapeData);
    if (this._isAnimated) {
      data.setAsAnimated();
    }
  }
};
ShapeModifier.prototype.init = function (elem, data) {
  this.shapes = [];
  this.elem = elem;
  this.initDynamicPropertyContainer(elem);
  this.initModifierProperties(elem, data);
  this.frameId = initialDefaultFrame;
  this.closed = false;
  this.k = false;
  if (this.dynamicProperties.length) {
    this.k = true;
  } else {
    this.getValue(true);
  }
};
ShapeModifier.prototype.processKeys = function () {
  if (this.elem.globalData.frameId === this.frameId) {
    return;
  }
  this.frameId = this.elem.globalData.frameId;
  this.iterateDynamicProperties();
};

extendPrototype([DynamicPropertyContainer], ShapeModifier);

/* global extendPrototype, ShapeModifier, PropertyFactory, segmentsLengthPool, bez, shapePool, ShapeModifiers */

function TrimModifier() {
}
extendPrototype([ShapeModifier], TrimModifier);
TrimModifier.prototype.initModifierProperties = function (elem, data) {
  this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
  this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
  this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
  this.sValue = 0;
  this.eValue = 0;
  this.getValue = this.processKeys;
  this.m = data.m;
  this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
};

TrimModifier.prototype.addShapeToModifier = function (shapeData) {
  shapeData.pathsData = [];
};

TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {
  var segments = [];
  if (e <= 1) {
    segments.push({
      s: s,
      e: e,
    });
  } else if (s >= 1) {
    segments.push({
      s: s - 1,
      e: e - 1,
    });
  } else {
    segments.push({
      s: s,
      e: 1,
    });
    segments.push({
      s: 0,
      e: e - 1,
    });
  }
  var shapeSegments = [];
  var i;
  var len = segments.length;
  var segmentOb;
  for (i = 0; i < len; i += 1) {
    segmentOb = segments[i];
    if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
      var shapeS;
      var shapeE;
      if (segmentOb.s * totalModifierLength <= addedLength) {
        shapeS = 0;
      } else {
        shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
      }
      if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
        shapeE = 1;
      } else {
        shapeE = ((segmentOb.e * totalModifierLength - addedLength) / shapeLength);
      }
      shapeSegments.push([shapeS, shapeE]);
    }
  }
  if (!shapeSegments.length) {
    shapeSegments.push([0, 0]);
  }
  return shapeSegments;
};

TrimModifier.prototype.releasePathsData = function (pathsData) {
  var i;
  var len = pathsData.length;
  for (i = 0; i < len; i += 1) {
    segmentsLengthPool.release(pathsData[i]);
  }
  pathsData.length = 0;
  return pathsData;
};

TrimModifier.prototype.processShapes = function (_isFirstFrame) {
  var s;
  var e;
  if (this._mdf || _isFirstFrame) {
    var o = (this.o.v % 360) / 360;
    if (o < 0) {
      o += 1;
    }
    if (this.s.v > 1) {
      s = 1 + o;
    } else if (this.s.v < 0) {
      s = 0 + o;
    } else {
      s = this.s.v + o;
    }
    if (this.e.v > 1) {
      e = 1 + o;
    } else if (this.e.v < 0) {
      e = 0 + o;
    } else {
      e = this.e.v + o;
    }

    if (s > e) {
      var _s = s;
      s = e;
      e = _s;
    }
    s = Math.round(s * 10000) * 0.0001;
    e = Math.round(e * 10000) * 0.0001;
    this.sValue = s;
    this.eValue = e;
  } else {
    s = this.sValue;
    e = this.eValue;
  }
  var shapePaths;
  var i;
  var len = this.shapes.length;
  var j;
  var jLen;
  var pathsData;
  var pathData;
  var totalShapeLength;
  var totalModifierLength = 0;

  if (e === s) {
    for (i = 0; i < len; i += 1) {
      this.shapes[i].localShapeCollection.releaseShapes();
      this.shapes[i].shape._mdf = true;
      this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
      if (this._mdf) {
        this.shapes[i].pathsData.length = 0;
      }
    }
  } else if (!((e === 1 && s === 0) || (e === 0 && s === 1))) {
    var segments = [];
    var shapeData;
    var localShapeCollection;
    for (i = 0; i < len; i += 1) {
      shapeData = this.shapes[i];
      // if shape hasn't changed and trim properties haven't changed, cached previous path can be used
      if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
        shapeData.shape.paths = shapeData.localShapeCollection;
      } else {
        shapePaths = shapeData.shape.paths;
        jLen = shapePaths._length;
        totalShapeLength = 0;
        if (!shapeData.shape._mdf && shapeData.pathsData.length) {
          totalShapeLength = shapeData.totalShapeLength;
        } else {
          pathsData = this.releasePathsData(shapeData.pathsData);
          for (j = 0; j < jLen; j += 1) {
            pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
            pathsData.push(pathData);
            totalShapeLength += pathData.totalLength;
          }
          shapeData.totalShapeLength = totalShapeLength;
          shapeData.pathsData = pathsData;
        }

        totalModifierLength += totalShapeLength;
        shapeData.shape._mdf = true;
      }
    }
    var shapeS = s;
    var shapeE = e;
    var addedLength = 0;
    var edges;
    for (i = len - 1; i >= 0; i -= 1) {
      shapeData = this.shapes[i];
      if (shapeData.shape._mdf) {
        localShapeCollection = shapeData.localShapeCollection;
        localShapeCollection.releaseShapes();
        // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group
        if (this.m === 2 && len > 1) {
          edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
          addedLength += shapeData.totalShapeLength;
        } else {
          edges = [[shapeS, shapeE]];
        }
        jLen = edges.length;
        for (j = 0; j < jLen; j += 1) {
          shapeS = edges[j][0];
          shapeE = edges[j][1];
          segments.length = 0;
          if (shapeE <= 1) {
            segments.push({
              s: shapeData.totalShapeLength * shapeS,
              e: shapeData.totalShapeLength * shapeE,
            });
          } else if (shapeS >= 1) {
            segments.push({
              s: shapeData.totalShapeLength * (shapeS - 1),
              e: shapeData.totalShapeLength * (shapeE - 1),
            });
          } else {
            segments.push({
              s: shapeData.totalShapeLength * shapeS,
              e: shapeData.totalShapeLength,
            });
            segments.push({
              s: 0,
              e: shapeData.totalShapeLength * (shapeE - 1),
            });
          }
          var newShapesData = this.addShapes(shapeData, segments[0]);
          if (segments[0].s !== segments[0].e) {
            if (segments.length > 1) {
              var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
              if (lastShapeInCollection.c) {
                var lastShape = newShapesData.pop();
                this.addPaths(newShapesData, localShapeCollection);
                newShapesData = this.addShapes(shapeData, segments[1], lastShape);
              } else {
                this.addPaths(newShapesData, localShapeCollection);
                newShapesData = this.addShapes(shapeData, segments[1]);
              }
            }
            this.addPaths(newShapesData, localShapeCollection);
          }
        }
        shapeData.shape.paths = localShapeCollection;
      }
    }
  } else if (this._mdf) {
    for (i = 0; i < len; i += 1) {
      // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
      // Don't remove this even if it's losing cached info.
      this.shapes[i].pathsData.length = 0;
      this.shapes[i].shape._mdf = true;
    }
  }
};

TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {
  var i;
  var len = newPaths.length;
  for (i = 0; i < len; i += 1) {
    localShapeCollection.addShape(newPaths[i]);
  }
};

TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
  shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);
  shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);
  if (newShape) {
    shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);
  }
  shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);
};

TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {
  shapePath.setXYAt(points[1], points[5], 'o', pos);
  shapePath.setXYAt(points[2], points[6], 'i', pos + 1);
  if (newShape) {
    shapePath.setXYAt(points[0], points[4], 'v', pos);
  }
  shapePath.setXYAt(points[3], points[7], 'v', pos + 1);
};

TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {
  var pathsData = shapeData.pathsData;
  var shapePaths = shapeData.shape.paths.shapes;
  var i;
  var len = shapeData.shape.paths._length;
  var j;
  var jLen;
  var addedLength = 0;
  var currentLengthData;
  var segmentCount;
  var lengths;
  var segment;
  var shapes = [];
  var initPos;
  var newShape = true;
  if (!shapePath) {
    shapePath = shapePool.newElement();
    segmentCount = 0;
    initPos = 0;
  } else {
    segmentCount = shapePath._length;
    initPos = shapePath._length;
  }
  shapes.push(shapePath);
  for (i = 0; i < len; i += 1) {
    lengths = pathsData[i].lengths;
    shapePath.c = shapePaths[i].c;
    jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
    for (j = 1; j < jLen; j += 1) {
      currentLengthData = lengths[j - 1];
      if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
        addedLength += currentLengthData.addedLength;
        shapePath.c = false;
      } else if (addedLength > shapeSegment.e) {
        shapePath.c = false;
        break;
      } else {
        if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
          this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
          newShape = false;
        } else {
          segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
          this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
          // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
          newShape = false;
          shapePath.c = false;
        }
        addedLength += currentLengthData.addedLength;
        segmentCount += 1;
      }
    }
    if (shapePaths[i].c && lengths.length) {
      currentLengthData = lengths[j - 1];
      if (addedLength <= shapeSegment.e) {
        var segmentLength = lengths[j - 1].addedLength;
        if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
          this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
          newShape = false;
        } else {
          segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
          this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
          // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
          newShape = false;
          shapePath.c = false;
        }
      } else {
        shapePath.c = false;
      }
      addedLength += currentLengthData.addedLength;
      segmentCount += 1;
    }
    if (shapePath._length) {
      shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);
      shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);
    }
    if (addedLength > shapeSegment.e) {
      break;
    }
    if (i < len - 1) {
      shapePath = shapePool.newElement();
      newShape = true;
      shapes.push(shapePath);
      segmentCount = 0;
    }
  }
  return shapes;
};

ShapeModifiers.registerModifier('tm', TrimModifier);

/* global extendPrototype, ShapeModifier, PropertyFactory, shapePool, roundCorner, ShapeModifiers */

function RoundCornersModifier() {}
extendPrototype([ShapeModifier], RoundCornersModifier);
RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {
  this.getValue = this.processKeys;
  this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
  this._isAnimated = !!this.rd.effectsSequence.length;
};

RoundCornersModifier.prototype.processPath = function (path, round) {
  var clonedPath = shapePool.newElement();
  clonedPath.c = path.c;
  var i;
  var len = path._length;
  var currentV;
  var currentI;
  var currentO;
  var closerV;
  var distance;
  var newPosPerc;
  var index = 0;
  var vX;
  var vY;
  var oX;
  var oY;
  var iX;
  var iY;
  for (i = 0; i < len; i += 1) {
    currentV = path.v[i];
    currentO = path.o[i];
    currentI = path.i[i];
    if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
      if ((i === 0 || i === len - 1) && !path.c) {
        clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);
        /* clonedPath.v[index] = currentV;
                clonedPath.o[index] = currentO;
                clonedPath.i[index] = currentI; */
        index += 1;
      } else {
        if (i === 0) {
          closerV = path.v[len - 1];
        } else {
          closerV = path.v[i - 1];
        }
        distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
        newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
        iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
        vX = iX;
        iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
        vY = iY;
        oX = vX - (vX - currentV[0]) * roundCorner;
        oY = vY - (vY - currentV[1]) * roundCorner;
        clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
        index += 1;

        if (i === len - 1) {
          closerV = path.v[0];
        } else {
          closerV = path.v[i + 1];
        }
        distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
        newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
        oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
        vX = oX;
        oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
        vY = oY;
        iX = vX - (vX - currentV[0]) * roundCorner;
        iY = vY - (vY - currentV[1]) * roundCorner;
        clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
        index += 1;
      }
    } else {
      clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);
      index += 1;
    }
  }
  return clonedPath;
};

RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {
  var shapePaths;
  var i;
  var len = this.shapes.length;
  var j;
  var jLen;
  var rd = this.rd.v;

  if (rd !== 0) {
    var shapeData;
    var localShapeCollection;
    for (i = 0; i < len; i += 1) {
      shapeData = this.shapes[i];
      localShapeCollection = shapeData.localShapeCollection;
      if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
        localShapeCollection.releaseShapes();
        shapeData.shape._mdf = true;
        shapePaths = shapeData.shape.paths.shapes;
        jLen = shapeData.shape.paths._length;
        for (j = 0; j < jLen; j += 1) {
          localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
        }
      }
      shapeData.shape.paths = shapeData.localShapeCollection;
    }
  }
  if (!this.dynamicProperties.length) {
    this._mdf = false;
  }
};

ShapeModifiers.registerModifier('rd', RoundCornersModifier);

/* global extendPrototype, ShapeModifier, PropertyFactory, shapePool, ShapeModifiers */

function PuckerAndBloatModifier() {}
extendPrototype([ShapeModifier], PuckerAndBloatModifier);
PuckerAndBloatModifier.prototype.initModifierProperties = function (elem, data) {
  this.getValue = this.processKeys;
  this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
  this._isAnimated = !!this.amount.effectsSequence.length;
};

PuckerAndBloatModifier.prototype.processPath = function (path, amount) {
  var percent = amount / 100;
  var centerPoint = [0, 0];
  var pathLength = path._length;
  var i = 0;
  for (i = 0; i < pathLength; i += 1) {
    centerPoint[0] += path.v[i][0];
    centerPoint[1] += path.v[i][1];
  }
  centerPoint[0] /= pathLength;
  centerPoint[1] /= pathLength;
  var clonedPath = shapePool.newElement();
  clonedPath.c = path.c;
  var vX;
  var vY;
  var oX;
  var oY;
  var iX;
  var iY;
  for (i = 0; i < pathLength; i += 1) {
    vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
    vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
    oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
    oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
    iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
    iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
  }
  return clonedPath;
};

PuckerAndBloatModifier.prototype.processShapes = function (_isFirstFrame) {
  var shapePaths;
  var i;
  var len = this.shapes.length;
  var j;
  var jLen;
  var amount = this.amount.v;

  if (amount !== 0) {
    var shapeData;
    var localShapeCollection;
    for (i = 0; i < len; i += 1) {
      shapeData = this.shapes[i];
      localShapeCollection = shapeData.localShapeCollection;
      if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
        localShapeCollection.releaseShapes();
        shapeData.shape._mdf = true;
        shapePaths = shapeData.shape.paths.shapes;
        jLen = shapeData.shape.paths._length;
        for (j = 0; j < jLen; j += 1) {
          localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
        }
      }
      shapeData.shape.paths = shapeData.localShapeCollection;
    }
  }
  if (!this.dynamicProperties.length) {
    this._mdf = false;
  }
};
ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);

/* global extendPrototype, ShapeModifier, TransformPropertyFactory, PropertyFactory, Matrix, ShapeModifiers */

function RepeaterModifier() {}
extendPrototype([ShapeModifier], RepeaterModifier);

RepeaterModifier.prototype.initModifierProperties = function (elem, data) {
  this.getValue = this.processKeys;
  this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
  this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
  this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
  this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
  this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
  this.data = data;
  if (!this.dynamicProperties.length) {
    this.getValue(true);
  }
  this._isAnimated = !!this.dynamicProperties.length;
  this.pMatrix = new Matrix();
  this.rMatrix = new Matrix();
  this.sMatrix = new Matrix();
  this.tMatrix = new Matrix();
  this.matrix = new Matrix();
};

RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {
  var dir = inv ? -1 : 1;
  var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
  var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
  pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
  rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
  rMatrix.rotate(-transform.r.v * dir * perc);
  rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
  sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
  sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
  sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
};

RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {
  this.elem = elem;
  this.arr = arr;
  this.pos = pos;
  this.elemsData = elemsData;
  this._currentCopies = 0;
  this._elements = [];
  this._groups = [];
  this.frameId = -1;
  this.initDynamicPropertyContainer(elem);
  this.initModifierProperties(elem, arr[pos]);
  while (pos > 0) {
    pos -= 1;
    // this._elements.unshift(arr.splice(pos,1)[0]);
    this._elements.unshift(arr[pos]);
  }
  if (this.dynamicProperties.length) {
    this.k = true;
  } else {
    this.getValue(true);
  }
};

RepeaterModifier.prototype.resetElements = function (elements) {
  var i;
  var len = elements.length;
  for (i = 0; i < len; i += 1) {
    elements[i]._processed = false;
    if (elements[i].ty === 'gr') {
      this.resetElements(elements[i].it);
    }
  }
};

RepeaterModifier.prototype.cloneElements = function (elements) {
  var newElements = JSON.parse(JSON.stringify(elements));
  this.resetElements(newElements);
  return newElements;
};

RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {
  var i;
  var len = elements.length;
  for (i = 0; i < len; i += 1) {
    elements[i]._render = renderFlag;
    if (elements[i].ty === 'gr') {
      this.changeGroupRender(elements[i].it, renderFlag);
    }
  }
};

RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {
  var items;
  var itemsTransform;
  var i;
  var dir;
  var cont;
  var hasReloaded = false;
  if (this._mdf || _isFirstFrame) {
    var copies = Math.ceil(this.c.v);
    if (this._groups.length < copies) {
      while (this._groups.length < copies) {
        var group = {
          it: this.cloneElements(this._elements),
          ty: 'gr',
        };
        group.it.push({
          a: { a: 0, ix: 1, k: [0, 0] }, nm: 'Transform', o: { a: 0, ix: 7, k: 100 }, p: { a: 0, ix: 2, k: [0, 0] }, r: { a: 1, ix: 6, k: [{ s: 0, e: 0, t: 0 }, { s: 0, e: 0, t: 1 }] }, s: { a: 0, ix: 3, k: [100, 100] }, sa: { a: 0, ix: 5, k: 0 }, sk: { a: 0, ix: 4, k: 0 }, ty: 'tr',
        });

        this.arr.splice(0, 0, group);
        this._groups.splice(0, 0, group);
        this._currentCopies += 1;
      }
      this.elem.reloadShapes();
      hasReloaded = true;
    }
    cont = 0;
    var renderFlag;
    for (i = 0; i <= this._groups.length - 1; i += 1) {
      renderFlag = cont < copies;
      this._groups[i]._render = renderFlag;
      this.changeGroupRender(this._groups[i].it, renderFlag);
      if (!renderFlag) {
        var elems = this.elemsData[i].it;
        var transformData = elems[elems.length - 1];
        if (transformData.transform.op.v !== 0) {
          transformData.transform.op._mdf = true;
          transformData.transform.op.v = 0;
        } else {
          transformData.transform.op._mdf = false;
        }
      }
      cont += 1;
    }

    this._currentCopies = copies;
    /// /

    var offset = this.o.v;
    var offsetModulo = offset % 1;
    var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
    var pProps = this.pMatrix.props;
    var rProps = this.rMatrix.props;
    var sProps = this.sMatrix.props;
    this.pMatrix.reset();
    this.rMatrix.reset();
    this.sMatrix.reset();
    this.tMatrix.reset();
    this.matrix.reset();
    var iteration = 0;

    if (offset > 0) {
      while (iteration < roundOffset) {
        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
        iteration += 1;
      }
      if (offsetModulo) {
        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
        iteration += offsetModulo;
      }
    } else if (offset < 0) {
      while (iteration > roundOffset) {
        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
        iteration -= 1;
      }
      if (offsetModulo) {
        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
        iteration -= offsetModulo;
      }
    }
    i = this.data.m === 1 ? 0 : this._currentCopies - 1;
    dir = this.data.m === 1 ? 1 : -1;
    cont = this._currentCopies;
    var j;
    var jLen;
    while (cont) {
      items = this.elemsData[i].it;
      itemsTransform = items[items.length - 1].transform.mProps.v.props;
      jLen = itemsTransform.length;
      items[items.length - 1].transform.mProps._mdf = true;
      items[items.length - 1].transform.op._mdf = true;
      items[items.length - 1].transform.op.v = this._currentCopies === 1
        ? this.so.v
        : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));

      if (iteration !== 0) {
        if ((i !== 0 && dir === 1) || (i !== this._currentCopies - 1 && dir === -1)) {
          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
        }
        this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
        this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
        this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);

        for (j = 0; j < jLen; j += 1) {
          itemsTransform[j] = this.matrix.props[j];
        }
        this.matrix.reset();
      } else {
        this.matrix.reset();
        for (j = 0; j < jLen; j += 1) {
          itemsTransform[j] = this.matrix.props[j];
        }
      }
      iteration += 1;
      cont -= 1;
      i += dir;
    }
  } else {
    cont = this._currentCopies;
    i = 0;
    dir = 1;
    while (cont) {
      items = this.elemsData[i].it;
      itemsTransform = items[items.length - 1].transform.mProps.v.props;
      items[items.length - 1].transform.mProps._mdf = false;
      items[items.length - 1].transform.op._mdf = false;
      cont -= 1;
      i += dir;
    }
  }
  return hasReloaded;
};

RepeaterModifier.prototype.addShape = function () {};

ShapeModifiers.registerModifier('rp', RepeaterModifier);

/* global createSizedArray, shapePool */

function ShapeCollection() {
  this._length = 0;
  this._maxLength = 4;
  this.shapes = createSizedArray(this._maxLength);
}

ShapeCollection.prototype.addShape = function (shapeData) {
  if (this._length === this._maxLength) {
    this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
    this._maxLength *= 2;
  }
  this.shapes[this._length] = shapeData;
  this._length += 1;
};

ShapeCollection.prototype.releaseShapes = function () {
  var i;
  for (i = 0; i < this._length; i += 1) {
    shapePool.release(this.shapes[i]);
  }
  this._length = 0;
};

/* global createSizedArray, createTypedArray, PropertyFactory, extendPrototype, DynamicPropertyContainer */

function DashProperty(elem, data, renderer, container) {
  this.elem = elem;
  this.frameId = -1;
  this.dataProps = createSizedArray(data.length);
  this.renderer = renderer;
  this.k = false;
  this.dashStr = '';
  this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);
  this.dashoffset = createTypedArray('float32', 1);
  this.initDynamicPropertyContainer(container);
  var i;
  var len = data.length || 0;
  var prop;
  for (i = 0; i < len; i += 1) {
    prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
    this.k = prop.k || this.k;
    this.dataProps[i] = { n: data[i].n, p: prop };
  }
  if (!this.k) {
    this.getValue(true);
  }
  this._isAnimated = this.k;
}

DashProperty.prototype.getValue = function (forceRender) {
  if (this.elem.globalData.frameId === this.frameId && !forceRender) {
    return;
  }
  this.frameId = this.elem.globalData.frameId;
  this.iterateDynamicProperties();
  this._mdf = this._mdf || forceRender;
  if (this._mdf) {
    var i = 0;
    var len = this.dataProps.length;
    if (this.renderer === 'svg') {
      this.dashStr = '';
    }
    for (i = 0; i < len; i += 1) {
      if (this.dataProps[i].n !== 'o') {
        if (this.renderer === 'svg') {
          this.dashStr += ' ' + this.dataProps[i].p.v;
        } else {
          this.dashArray[i] = this.dataProps[i].p.v;
        }
      } else {
        this.dashoffset[0] = this.dataProps[i].p.v;
      }
    }
  }
};
extendPrototype([DynamicPropertyContainer], DashProperty);

/* global createTypedArray, PropertyFactory, extendPrototype, DynamicPropertyContainer */
function GradientProperty(elem, data, container) {
  this.data = data;
  this.c = createTypedArray('uint8c', data.p * 4);
  var cLength = data.k.k[0].s ? (data.k.k[0].s.length - data.p * 4) : data.k.k.length - data.p * 4;
  this.o = createTypedArray('float32', cLength);
  this._cmdf = false;
  this._omdf = false;
  this._collapsable = this.checkCollapsable();
  this._hasOpacity = cLength;
  this.initDynamicPropertyContainer(container);
  this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
  this.k = this.prop.k;
  this.getValue(true);
}

GradientProperty.prototype.comparePoints = function (values, points) {
  var i = 0;
  var len = this.o.length / 2;
  var diff;
  while (i < len) {
    diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);
    if (diff > 0.01) {
      return false;
    }
    i += 1;
  }
  return true;
};

GradientProperty.prototype.checkCollapsable = function () {
  if (this.o.length / 2 !== this.c.length / 4) {
    return false;
  }
  if (this.data.k.k[0].s) {
    var i = 0;
    var len = this.data.k.k.length;
    while (i < len) {
      if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
        return false;
      }
      i += 1;
    }
  } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
    return false;
  }
  return true;
};

GradientProperty.prototype.getValue = function (forceRender) {
  this.prop.getValue();
  this._mdf = false;
  this._cmdf = false;
  this._omdf = false;
  if (this.prop._mdf || forceRender) {
    var i;
    var len = this.data.p * 4;
    var mult;
    var val;
    for (i = 0; i < len; i += 1) {
      mult = i % 4 === 0 ? 100 : 255;
      val = Math.round(this.prop.v[i] * mult);
      if (this.c[i] !== val) {
        this.c[i] = val;
        this._cmdf = !forceRender;
      }
    }
    if (this.o.length) {
      len = this.prop.v.length;
      for (i = this.data.p * 4; i < len; i += 1) {
        mult = i % 2 === 0 ? 100 : 1;
        val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];
        if (this.o[i - this.data.p * 4] !== val) {
          this.o[i - this.data.p * 4] = val;
          this._omdf = !forceRender;
        }
      }
    }
    this._mdf = !forceRender;
  }
};

extendPrototype([DynamicPropertyContainer], GradientProperty);

/* exported buildShapeString */

var buildShapeString = function (pathNodes, length, closed, mat) {
  if (length === 0) {
    return '';
  }
  var _o = pathNodes.o;
  var _i = pathNodes.i;
  var _v = pathNodes.v;
  var i;
  var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
  for (i = 1; i < length; i += 1) {
    shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[i][0], _i[i][1]) + ' ' + mat.applyToPointStringified(_v[i][0], _v[i][1]);
  }
  if (closed && length) {
    shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[0][0], _i[0][1]) + ' ' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
    shapeString += 'z';
  }
  return shapeString;
};

/* global Howl */
/* exported audioControllerFactory */

var audioControllerFactory = (function () {
  function AudioController(audioFactory) {
    this.audios = [];
    this.audioFactory = audioFactory;
    this._volume = 1;
    this._isMuted = false;
  }

  AudioController.prototype = {
    addAudio: function (audio) {
      this.audios.push(audio);
    },
    pause: function () {
      var i;
      var len = this.audios.length;
      for (i = 0; i < len; i += 1) {
        this.audios[i].pause();
      }
    },
    resume: function () {
      var i;
      var len = this.audios.length;
      for (i = 0; i < len; i += 1) {
        this.audios[i].resume();
      }
    },
    setRate: function (rateValue) {
      var i;
      var len = this.audios.length;
      for (i = 0; i < len; i += 1) {
        this.audios[i].setRate(rateValue);
      }
    },
    createAudio: function (assetPath) {
      if (this.audioFactory) {
        return this.audioFactory(assetPath);
      } if (Howl) {
        return new Howl({
          src: [assetPath],
        });
      }
      return {
        isPlaying: false,
        play: function () { this.isPlaying = true; },
        seek: function () { this.isPlaying = false; },
        playing: function () {},
        rate: function () {},
        setVolume: function () {},
      };
    },
    setAudioFactory: function (audioFactory) {
      this.audioFactory = audioFactory;
    },
    setVolume: function (value) {
      this._volume = value;
      this._updateVolume();
    },
    mute: function () {
      this._isMuted = true;
      this._updateVolume();
    },
    unmute: function () {
      this._isMuted = false;
      this._updateVolume();
    },
    getVolume: function () {
      return this._volume;
    },
    _updateVolume: function () {
      var i;
      var len = this.audios.length;
      for (i = 0; i < len; i += 1) {
        this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
      }
    },
  };

  return function () {
    return new AudioController();
  };
}());

/* global createTag, createNS, isSafari, assetLoader */
/* exported ImagePreloader */

var ImagePreloader = (function () {
  var proxyImage = (function () {
    var canvas = createTag('canvas');
    canvas.width = 1;
    canvas.height = 1;
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0, 0, 1, 1);
    return canvas;
  }());

  function imageLoaded() {
    this.loadedAssets += 1;
    if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
      if (this.imagesLoadedCb) {
        this.imagesLoadedCb(null);
      }
    }
  }
  function footageLoaded() {
    this.loadedFootagesCount += 1;
    if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
      if (this.imagesLoadedCb) {
        this.imagesLoadedCb(null);
      }
    }
  }

  function getAssetsPath(assetData, assetsPath, originalPath) {
    var path = '';
    if (assetData.e) {
      path = assetData.p;
    } else if (assetsPath) {
      var imagePath = assetData.p;
      if (imagePath.indexOf('images/') !== -1) {
        imagePath = imagePath.split('/')[1];
      }
      path = assetsPath + imagePath;
    } else {
      path = originalPath;
      path += assetData.u ? assetData.u : '';
      path += assetData.p;
    }
    return path;
  }

  function testImageLoaded(img) {
    var _count = 0;
    var intervalId = setInterval(function () {
      var box = img.getBBox();
      if (box.width || _count > 500) {
        this._imageLoaded();
        clearInterval(intervalId);
      }
      _count += 1;
    }.bind(this), 50);
  }

  function createImageData(assetData) {
    var path = getAssetsPath(assetData, this.assetsPath, this.path);
    var img = createNS('image');
    if (isSafari) {
      this.testImageLoaded(img);
    } else {
      img.addEventListener('load', this._imageLoaded, false);
    }
    img.addEventListener('error', function () {
      ob.img = proxyImage;
      this._imageLoaded();
    }.bind(this), false);
    img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);
    if (this._elementHelper.append) {
      this._elementHelper.append(img);
    } else {
      this._elementHelper.appendChild(img);
    }
    var ob = {
      img: img,
      assetData: assetData,
    };
    return ob;
  }

  function createImgData(assetData) {
    var path = getAssetsPath(assetData, this.assetsPath, this.path);
    var img = createTag('img');
    img.crossOrigin = 'anonymous';
    img.addEventListener('load', this._imageLoaded, false);
    img.addEventListener('error', function () {
      ob.img = proxyImage;
      this._imageLoaded();
    }.bind(this), false);
    img.src = path;
    var ob = {
      img: img,
      assetData: assetData,
    };
    return ob;
  }

  function createFootageData(data) {
    var ob = {
      assetData: data,
    };
    var path = getAssetsPath(data, this.assetsPath, this.path);
    assetLoader.load(path, function (footageData) {
      ob.img = footageData;
      this._footageLoaded();
    }.bind(this), function () {
      ob.img = {};
      this._footageLoaded();
    }.bind(this));
    return ob;
  }

  function loadAssets(assets, cb) {
    this.imagesLoadedCb = cb;
    var i;
    var len = assets.length;
    for (i = 0; i < len; i += 1) {
      if (!assets[i].layers) {
        if (!assets[i].t || assets[i].t === 'seq') {
          this.totalImages += 1;
          this.images.push(this._createImageData(assets[i]));
        } else if (assets[i].t === 3) {
          this.totalFootages += 1;
          this.images.push(this.createFootageData(assets[i]));
        }
      }
    }
  }

  function setPath(path) {
    this.path = path || '';
  }

  function setAssetsPath(path) {
    this.assetsPath = path || '';
  }

  function getAsset(assetData) {
    var i = 0;
    var len = this.images.length;
    while (i < len) {
      if (this.images[i].assetData === assetData) {
        return this.images[i].img;
      }
      i += 1;
    }
    return null;
  }

  function destroy() {
    this.imagesLoadedCb = null;
    this.images.length = 0;
  }

  function loadedImages() {
    return this.totalImages === this.loadedAssets;
  }

  function loadedFootages() {
    return this.totalFootages === this.loadedFootagesCount;
  }

  function setCacheType(type, elementHelper) {
    if (type === 'svg') {
      this._elementHelper = elementHelper;
      this._createImageData = this.createImageData.bind(this);
    } else {
      this._createImageData = this.createImgData.bind(this);
    }
  }

  function ImagePreloaderFactory() {
    this._imageLoaded = imageLoaded.bind(this);
    this._footageLoaded = footageLoaded.bind(this);
    this.testImageLoaded = testImageLoaded.bind(this);
    this.createFootageData = createFootageData.bind(this);
    this.assetsPath = '';
    this.path = '';
    this.totalImages = 0;
    this.totalFootages = 0;
    this.loadedAssets = 0;
    this.loadedFootagesCount = 0;
    this.imagesLoadedCb = null;
    this.images = [];
  }

  ImagePreloaderFactory.prototype = {
    loadAssets: loadAssets,
    setAssetsPath: setAssetsPath,
    setPath: setPath,
    loadedImages: loadedImages,
    loadedFootages: loadedFootages,
    destroy: destroy,
    getAsset: getAsset,
    createImgData: createImgData,
    createImageData: createImageData,
    imageLoaded: imageLoaded,
    footageLoaded: footageLoaded,
    setCacheType: setCacheType,
  };

  return ImagePreloaderFactory;
}());

/* exported featureSupport */

var featureSupport = (function () {
  var ob = {
    maskType: true,
  };
  if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
    ob.maskType = false;
  }
  return ob;
}());

/* global createNS */
/* exported filtersFactory */

var filtersFactory = (function () {
  var ob = {};
  ob.createFilter = createFilter;
  ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;

  function createFilter(filId, skipCoordinates) {
    var fil = createNS('filter');
    fil.setAttribute('id', filId);
    if (skipCoordinates !== true) {
      fil.setAttribute('filterUnits', 'objectBoundingBox');
      fil.setAttribute('x', '0%');
      fil.setAttribute('y', '0%');
      fil.setAttribute('width', '100%');
      fil.setAttribute('height', '100%');
    }
    return fil;
  }

  function createAlphaToLuminanceFilter() {
    var feColorMatrix = createNS('feColorMatrix');
    feColorMatrix.setAttribute('type', 'matrix');
    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
    feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
    return feColorMatrix;
  }

  return ob;
}());

/* exported assetLoader */

var assetLoader = (function () {
  function formatResponse(xhr) {
    if (xhr.response && typeof xhr.response === 'object') {
      return xhr.response;
    } if (xhr.response && typeof xhr.response === 'string') {
      return JSON.parse(xhr.response);
    } if (xhr.responseText) {
      return JSON.parse(xhr.responseText);
    }
    return null;
  }

  function loadAsset(path, callback, errorCallback) {
    var response;
    var xhr = new XMLHttpRequest();
    // set responseType after calling open or IE will break.
    try {
      // This crashes on Android WebView prior to KitKat
      xhr.responseType = 'json';
    } catch (err) {} // eslint-disable-line no-empty
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          response = formatResponse(xhr);
          callback(response);
        } else {
          try {
            response = formatResponse(xhr);
            callback(response);
          } catch (err) {
            if (errorCallback) {
              errorCallback(err);
            }
          }
        }
      }
    };
    xhr.open('GET', path, true);
    xhr.send();
  }
  return {
    load: loadAsset,
  };
}());

/* global createSizedArray, PropertyFactory, TextAnimatorDataProperty, bez, addHueToRGB,
  addSaturationToRGB, addBrightnessToRGB, LetterProps, Matrix, extendPrototype, DynamicPropertyContainer */

function TextAnimatorProperty(textData, renderType, elem) {
  this._isFirstFrame = true;
  this._hasMaskedPath = false;
  this._frameId = -1;
  this._textData = textData;
  this._renderType = renderType;
  this._elem = elem;
  this._animatorsData = createSizedArray(this._textData.a.length);
  this._pathData = {};
  this._moreOptions = {
    alignment: {},
  };
  this.renderedLetters = [];
  this.lettersChangedFlag = false;
  this.initDynamicPropertyContainer(elem);
}

TextAnimatorProperty.prototype.searchProperties = function () {
  var i;
  var len = this._textData.a.length;
  var animatorProps;
  var getProp = PropertyFactory.getProp;
  for (i = 0; i < len; i += 1) {
    animatorProps = this._textData.a[i];
    this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
  }
  if (this._textData.p && 'm' in this._textData.p) {
    this._pathData = {
      f: getProp(this._elem, this._textData.p.f, 0, 0, this),
      l: getProp(this._elem, this._textData.p.l, 0, 0, this),
      r: this._textData.p.r,
      m: this._elem.maskManager.getMaskProperty(this._textData.p.m),
    };
    this._hasMaskedPath = true;
  } else {
    this._hasMaskedPath = false;
  }
  this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
};

TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {
  this.lettersChangedFlag = lettersChangedFlag;
  if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
    return;
  }
  this._isFirstFrame = false;
  var alignment = this._moreOptions.alignment.v;
  var animators = this._animatorsData;
  var textData = this._textData;
  var matrixHelper = this.mHelper;
  var renderType = this._renderType;
  var renderedLettersCount = this.renderedLetters.length;
  var xPos;
  var yPos;
  var i;
  var len;
  var letters = documentData.l;
  var pathInfo;
  var currentLength;
  var currentPoint;
  var segmentLength;
  var flag;
  var pointInd;
  var segmentInd;
  var prevPoint;
  var points;
  var segments;
  var partialLength;
  var totalLength;
  var perc;
  var tanAngle;
  var mask;
  if (this._hasMaskedPath) {
    mask = this._pathData.m;
    if (!this._pathData.n || this._pathData._mdf) {
      var paths = mask.v;
      if (this._pathData.r) {
        paths = paths.reverse();
      }
      // TODO: release bezier data cached from previous pathInfo: this._pathData.pi
      pathInfo = {
        tLength: 0,
        segments: [],
      };
      len = paths._length - 1;
      var bezierData;
      totalLength = 0;
      for (i = 0; i < len; i += 1) {
        bezierData = bez.buildBezierData(paths.v[i],
          paths.v[i + 1],
          [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],
          [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
        pathInfo.tLength += bezierData.segmentLength;
        pathInfo.segments.push(bezierData);
        totalLength += bezierData.segmentLength;
      }
      i = len;
      if (mask.v.c) {
        bezierData = bez.buildBezierData(paths.v[i],
          paths.v[0],
          [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],
          [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
        pathInfo.tLength += bezierData.segmentLength;
        pathInfo.segments.push(bezierData);
        totalLength += bezierData.segmentLength;
      }
      this._pathData.pi = pathInfo;
    }
    pathInfo = this._pathData.pi;

    currentLength = this._pathData.f.v;
    segmentInd = 0;
    pointInd = 1;
    segmentLength = 0;
    flag = true;
    segments = pathInfo.segments;
    if (currentLength < 0 && mask.v.c) {
      if (pathInfo.tLength < Math.abs(currentLength)) {
        currentLength = -Math.abs(currentLength) % pathInfo.tLength;
      }
      segmentInd = segments.length - 1;
      points = segments[segmentInd].points;
      pointInd = points.length - 1;
      while (currentLength < 0) {
        currentLength += points[pointInd].partialLength;
        pointInd -= 1;
        if (pointInd < 0) {
          segmentInd -= 1;
          points = segments[segmentInd].points;
          pointInd = points.length - 1;
        }
      }
    }
    points = segments[segmentInd].points;
    prevPoint = points[pointInd - 1];
    currentPoint = points[pointInd];
    partialLength = currentPoint.partialLength;
  }

  len = letters.length;
  xPos = 0;
  yPos = 0;
  var yOff = documentData.finalSize * 1.2 * 0.714;
  var firstLine = true;
  var animatorProps;
  var animatorSelector;
  var j;
  var jLen;
  var letterValue;

  jLen = animators.length;

  var mult;
  var ind = -1;
  var offf;
  var xPathPos;
  var yPathPos;
  var initPathPos = currentLength;
  var initSegmentInd = segmentInd;
  var initPointInd = pointInd;
  var currentLine = -1;
  var elemOpacity;
  var sc;
  var sw;
  var fc;
  var k;
  var letterSw;
  var letterSc;
  var letterFc;
  var letterM = '';
  var letterP = this.defaultPropsArray;
  var letterO;

  //
  if (documentData.j === 2 || documentData.j === 1) {
    var animatorJustifyOffset = 0;
    var animatorFirstCharOffset = 0;
    var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
    var lastIndex = 0;
    var isNewLine = true;

    for (i = 0; i < len; i += 1) {
      if (letters[i].n) {
        if (animatorJustifyOffset) {
          animatorJustifyOffset += animatorFirstCharOffset;
        }
        while (lastIndex < i) {
          letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
          lastIndex += 1;
        }
        animatorJustifyOffset = 0;
        isNewLine = true;
      } else {
        for (j = 0; j < jLen; j += 1) {
          animatorProps = animators[j].a;
          if (animatorProps.t.propType) {
            if (isNewLine && documentData.j === 2) {
              animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
            }
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
            if (mult.length) {
              animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
            } else {
              animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
            }
          }
        }
        isNewLine = false;
      }
    }
    if (animatorJustifyOffset) {
      animatorJustifyOffset += animatorFirstCharOffset;
    }
    while (lastIndex < i) {
      letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
      lastIndex += 1;
    }
  }
  //

  for (i = 0; i < len; i += 1) {
    matrixHelper.reset();
    elemOpacity = 1;
    if (letters[i].n) {
      xPos = 0;
      yPos += documentData.yOffset;
      yPos += firstLine ? 1 : 0;
      currentLength = initPathPos;
      firstLine = false;
      if (this._hasMaskedPath) {
        segmentInd = initSegmentInd;
        pointInd = initPointInd;
        points = segments[segmentInd].points;
        prevPoint = points[pointInd - 1];
        currentPoint = points[pointInd];
        partialLength = currentPoint.partialLength;
        segmentLength = 0;
      }
      letterM = '';
      letterFc = '';
      letterSw = '';
      letterO = '';
      letterP = this.defaultPropsArray;
    } else {
      if (this._hasMaskedPath) {
        if (currentLine !== letters[i].line) {
          switch (documentData.j) {
            case 1:
              currentLength += totalLength - documentData.lineWidths[letters[i].line];
              break;
            case 2:
              currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
              break;
            default:
              break;
          }
          currentLine = letters[i].line;
        }
        if (ind !== letters[i].ind) {
          if (letters[ind]) {
            currentLength += letters[ind].extra;
          }
          currentLength += letters[i].an / 2;
          ind = letters[i].ind;
        }
        currentLength += (alignment[0] * letters[i].an) * 0.005;
        var animatorOffset = 0;
        for (j = 0; j < jLen; j += 1) {
          animatorProps = animators[j].a;
          if (animatorProps.p.propType) {
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
            if (mult.length) {
              animatorOffset += animatorProps.p.v[0] * mult[0];
            } else {
              animatorOffset += animatorProps.p.v[0] * mult;
            }
          }
          if (animatorProps.a.propType) {
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
            if (mult.length) {
              animatorOffset += animatorProps.a.v[0] * mult[0];
            } else {
              animatorOffset += animatorProps.a.v[0] * mult;
            }
          }
        }
        flag = true;
        while (flag) {
          if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
            perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
            xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
            yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
            matrixHelper.translate((-alignment[0] * letters[i].an) * 0.005, -(alignment[1] * yOff) * 0.01);
            flag = false;
          } else if (points) {
            segmentLength += currentPoint.partialLength;
            pointInd += 1;
            if (pointInd >= points.length) {
              pointInd = 0;
              segmentInd += 1;
              if (!segments[segmentInd]) {
                if (mask.v.c) {
                  pointInd = 0;
                  segmentInd = 0;
                  points = segments[segmentInd].points;
                } else {
                  segmentLength -= currentPoint.partialLength;
                  points = null;
                }
              } else {
                points = segments[segmentInd].points;
              }
            }
            if (points) {
              prevPoint = currentPoint;
              currentPoint = points[pointInd];
              partialLength = currentPoint.partialLength;
            }
          }
        }
        offf = letters[i].an / 2 - letters[i].add;
        matrixHelper.translate(-offf, 0, 0);
      } else {
        offf = letters[i].an / 2 - letters[i].add;
        matrixHelper.translate(-offf, 0, 0);

        // Grouping alignment
        matrixHelper.translate((-alignment[0] * letters[i].an) * 0.005, (-alignment[1] * yOff) * 0.01, 0);
      }

      for (j = 0; j < jLen; j += 1) {
        animatorProps = animators[j].a;
        if (animatorProps.t.propType) {
          animatorSelector = animators[j].s;
          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
          // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"
          if (xPos !== 0 || documentData.j !== 0) {
            if (this._hasMaskedPath) {
              if (mult.length) {
                currentLength += animatorProps.t.v * mult[0];
              } else {
                currentLength += animatorProps.t.v * mult;
              }
            } else if (mult.length) {
              xPos += animatorProps.t.v * mult[0];
            } else {
              xPos += animatorProps.t.v * mult;
            }
          }
        }
      }
      if (documentData.strokeWidthAnim) {
        sw = documentData.sw || 0;
      }
      if (documentData.strokeColorAnim) {
        if (documentData.sc) {
          sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
        } else {
          sc = [0, 0, 0];
        }
      }
      if (documentData.fillColorAnim && documentData.fc) {
        fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
      }
      for (j = 0; j < jLen; j += 1) {
        animatorProps = animators[j].a;
        if (animatorProps.a.propType) {
          animatorSelector = animators[j].s;
          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

          if (mult.length) {
            matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
          } else {
            matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
          }
        }
      }
      for (j = 0; j < jLen; j += 1) {
        animatorProps = animators[j].a;
        if (animatorProps.s.propType) {
          animatorSelector = animators[j].s;
          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
          if (mult.length) {
            matrixHelper.scale(1 + ((animatorProps.s.v[0] - 1) * mult[0]), 1 + ((animatorProps.s.v[1] - 1) * mult[1]), 1);
          } else {
            matrixHelper.scale(1 + ((animatorProps.s.v[0] - 1) * mult), 1 + ((animatorProps.s.v[1] - 1) * mult), 1);
          }
        }
      }
      for (j = 0; j < jLen; j += 1) {
        animatorProps = animators[j].a;
        animatorSelector = animators[j].s;
        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
        if (animatorProps.sk.propType) {
          if (mult.length) {
            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
          } else {
            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
          }
        }
        if (animatorProps.r.propType) {
          if (mult.length) {
            matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
          } else {
            matrixHelper.rotateZ(-animatorProps.r.v * mult);
          }
        }
        if (animatorProps.ry.propType) {
          if (mult.length) {
            matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
          } else {
            matrixHelper.rotateY(animatorProps.ry.v * mult);
          }
        }
        if (animatorProps.rx.propType) {
          if (mult.length) {
            matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
          } else {
            matrixHelper.rotateX(animatorProps.rx.v * mult);
          }
        }
        if (animatorProps.o.propType) {
          if (mult.length) {
            elemOpacity += ((animatorProps.o.v) * mult[0] - elemOpacity) * mult[0];
          } else {
            elemOpacity += ((animatorProps.o.v) * mult - elemOpacity) * mult;
          }
        }
        if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
          if (mult.length) {
            sw += animatorProps.sw.v * mult[0];
          } else {
            sw += animatorProps.sw.v * mult;
          }
        }
        if (documentData.strokeColorAnim && animatorProps.sc.propType) {
          for (k = 0; k < 3; k += 1) {
            if (mult.length) {
              sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
            } else {
              sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
            }
          }
        }
        if (documentData.fillColorAnim && documentData.fc) {
          if (animatorProps.fc.propType) {
            for (k = 0; k < 3; k += 1) {
              if (mult.length) {
                fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
              } else {
                fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
              }
            }
          }
          if (animatorProps.fh.propType) {
            if (mult.length) {
              fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
            } else {
              fc = addHueToRGB(fc, animatorProps.fh.v * mult);
            }
          }
          if (animatorProps.fs.propType) {
            if (mult.length) {
              fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
            } else {
              fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
            }
          }
          if (animatorProps.fb.propType) {
            if (mult.length) {
              fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
            } else {
              fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
            }
          }
        }
      }

      for (j = 0; j < jLen; j += 1) {
        animatorProps = animators[j].a;

        if (animatorProps.p.propType) {
          animatorSelector = animators[j].s;
          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
          if (this._hasMaskedPath) {
            if (mult.length) {
              matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
            } else {
              matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
            }
          } else if (mult.length) {
            matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
          } else {
            matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
          }
        }
      }
      if (documentData.strokeWidthAnim) {
        letterSw = sw < 0 ? 0 : sw;
      }
      if (documentData.strokeColorAnim) {
        letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';
      }
      if (documentData.fillColorAnim && documentData.fc) {
        letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';
      }

      if (this._hasMaskedPath) {
        matrixHelper.translate(0, -documentData.ls);

        matrixHelper.translate(0, (alignment[1] * yOff) * 0.01 + yPos, 0);
        if (textData.p.p) {
          tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
          var rot = (Math.atan(tanAngle) * 180) / Math.PI;
          if (currentPoint.point[0] < prevPoint.point[0]) {
            rot += 180;
          }
          matrixHelper.rotate((-rot * Math.PI) / 180);
        }
        matrixHelper.translate(xPathPos, yPathPos, 0);
        currentLength -= (alignment[0] * letters[i].an) * 0.005;
        if (letters[i + 1] && ind !== letters[i + 1].ind) {
          currentLength += letters[i].an / 2;
          currentLength += (documentData.tr * 0.001) * documentData.finalSize;
        }
      } else {
        matrixHelper.translate(xPos, yPos, 0);

        if (documentData.ps) {
          // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
          matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
        }
        switch (documentData.j) {
          case 1:
            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
            break;
          case 2:
            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
            break;
          default:
            break;
        }
        matrixHelper.translate(0, -documentData.ls);
        matrixHelper.translate(offf, 0, 0);
        matrixHelper.translate((alignment[0] * letters[i].an) * 0.005, (alignment[1] * yOff) * 0.01, 0);
        xPos += letters[i].l + (documentData.tr * 0.001) * documentData.finalSize;
      }
      if (renderType === 'html') {
        letterM = matrixHelper.toCSS();
      } else if (renderType === 'svg') {
        letterM = matrixHelper.to2dCSS();
      } else {
        letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
      }
      letterO = elemOpacity;
    }

    if (renderedLettersCount <= i) {
      letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
      this.renderedLetters.push(letterValue);
      renderedLettersCount += 1;
      this.lettersChangedFlag = true;
    } else {
      letterValue = this.renderedLetters[i];
      this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
    }
  }
};

TextAnimatorProperty.prototype.getValue = function () {
  if (this._elem.globalData.frameId === this._frameId) {
    return;
  }
  this._frameId = this._elem.globalData.frameId;
  this.iterateDynamicProperties();
};

TextAnimatorProperty.prototype.mHelper = new Matrix();
TextAnimatorProperty.prototype.defaultPropsArray = [];
extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);

/* global PropertyFactory, degToRads, TextSelectorProp */
/* exported TextAnimatorDataProperty */

function TextAnimatorDataProperty(elem, animatorProps, container) {
  var defaultData = { propType: false };
  var getProp = PropertyFactory.getProp;
  var textAnimatorAnimatables = animatorProps.a;
  this.a = {
    r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
    rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
    ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
    sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
    sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
    s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
    a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
    o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
    p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
    sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
    sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
    fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
    fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
    fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
    fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
    t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData,
  };

  this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
  this.s.t = animatorProps.s.t;
}

function LetterProps(o, sw, sc, fc, m, p) {
  this.o = o;
  this.sw = sw;
  this.sc = sc;
  this.fc = fc;
  this.m = m;
  this.p = p;
  this._mdf = {
    o: true,
    sw: !!sw,
    sc: !!sc,
    fc: !!fc,
    m: true,
    p: true,
  };
}

LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {
  this._mdf.o = false;
  this._mdf.sw = false;
  this._mdf.sc = false;
  this._mdf.fc = false;
  this._mdf.m = false;
  this._mdf.p = false;
  var updated = false;

  if (this.o !== o) {
    this.o = o;
    this._mdf.o = true;
    updated = true;
  }
  if (this.sw !== sw) {
    this.sw = sw;
    this._mdf.sw = true;
    updated = true;
  }
  if (this.sc !== sc) {
    this.sc = sc;
    this._mdf.sc = true;
    updated = true;
  }
  if (this.fc !== fc) {
    this.fc = fc;
    this._mdf.fc = true;
    updated = true;
  }
  if (this.m !== m) {
    this.m = m;
    this._mdf.m = true;
    updated = true;
  }
  if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
    this.p = p;
    this._mdf.p = true;
    updated = true;
  }
  return updated;
};

/* global FontManager, initialDefaultFrame, getFontProperties */
/* exported TextProperty */

function TextProperty(elem, data) {
  this._frameId = initialDefaultFrame;
  this.pv = '';
  this.v = '';
  this.kf = false;
  this._isFirstFrame = true;
  this._mdf = false;
  this.data = data;
  this.elem = elem;
  this.comp = this.elem.comp;
  this.keysIndex = 0;
  this.canResize = false;
  this.minimumFontSize = 1;
  this.effectsSequence = [];
  this.currentData = {
    ascent: 0,
    boxWidth: this.defaultBoxWidth,
    f: '',
    fStyle: '',
    fWeight: '',
    fc: '',
    j: '',
    justifyOffset: '',
    l: [],
    lh: 0,
    lineWidths: [],
    ls: '',
    of: '',
    s: '',
    sc: '',
    sw: 0,
    t: 0,
    tr: 0,
    sz: 0,
    ps: null,
    fillColorAnim: false,
    strokeColorAnim: false,
    strokeWidthAnim: false,
    yOffset: 0,
    finalSize: 0,
    finalText: [],
    finalLineHeight: 0,
    __complete: false,

  };
  this.copyData(this.currentData, this.data.d.k[0].s);

  if (!this.searchProperty()) {
    this.completeTextData(this.currentData);
  }
}

TextProperty.prototype.defaultBoxWidth = [0, 0];

TextProperty.prototype.copyData = function (obj, data) {
  for (var s in data) {
    if (Object.prototype.hasOwnProperty.call(data, s)) {
      obj[s] = data[s];
    }
  }
  return obj;
};

TextProperty.prototype.setCurrentData = function (data) {
  if (!data.__complete) {
    this.completeTextData(data);
  }
  this.currentData = data;
  this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
  this._mdf = true;
};

TextProperty.prototype.searchProperty = function () {
  return this.searchKeyframes();
};

TextProperty.prototype.searchKeyframes = function () {
  this.kf = this.data.d.k.length > 1;
  if (this.kf) {
    this.addEffect(this.getKeyframeValue.bind(this));
  }
  return this.kf;
};

TextProperty.prototype.addEffect = function (effectFunction) {
  this.effectsSequence.push(effectFunction);
  this.elem.addDynamicProperty(this);
};

TextProperty.prototype.getValue = function (_finalValue) {
  if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
    return;
  }
  this.currentData.t = this.data.d.k[this.keysIndex].s.t;
  var currentValue = this.currentData;
  var currentIndex = this.keysIndex;
  if (this.lock) {
    this.setCurrentData(this.currentData);
    return;
  }
  this.lock = true;
  this._mdf = false;
  var i; var
    len = this.effectsSequence.length;
  var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
  for (i = 0; i < len; i += 1) {
    // Checking if index changed to prevent creating a new object every time the expression updates.
    if (currentIndex !== this.keysIndex) {
      finalValue = this.effectsSequence[i](finalValue, finalValue.t);
    } else {
      finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
    }
  }
  if (currentValue !== finalValue) {
    this.setCurrentData(finalValue);
  }
  this.v = this.currentData;
  this.pv = this.v;
  this.lock = false;
  this.frameId = this.elem.globalData.frameId;
};

TextProperty.prototype.getKeyframeValue = function () {
  var textKeys = this.data.d.k;
  var frameNum = this.elem.comp.renderedFrame;
  var i = 0; var
    len = textKeys.length;
  while (i <= len - 1) {
    if (i === len - 1 || textKeys[i + 1].t > frameNum) {
      break;
    }
    i += 1;
  }
  if (this.keysIndex !== i) {
    this.keysIndex = i;
  }
  return this.data.d.k[this.keysIndex].s;
};

TextProperty.prototype.buildFinalText = function (text) {
  var combinedCharacters = FontManager.getCombinedCharacterCodes();
  var charactersArray = [];
  var i = 0; var
    len = text.length;
  var charCode;
  while (i < len) {
    charCode = text.charCodeAt(i);
    if (combinedCharacters.indexOf(charCode) !== -1) {
      charactersArray[charactersArray.length - 1] += text.charAt(i);
    } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      charCode = text.charCodeAt(i + 1);
      if (charCode >= 0xDC00 && charCode <= 0xDFFF) {
        charactersArray.push(text.substr(i, 2));
        i += 1;
      } else {
        charactersArray.push(text.charAt(i));
      }
    } else {
      charactersArray.push(text.charAt(i));
    }
    i += 1;
  }
  return charactersArray;
};

TextProperty.prototype.completeTextData = function (documentData) {
  documentData.__complete = true;
  var fontManager = this.elem.globalData.fontManager;
  var data = this.data;
  var letters = [];
  var i; var
    len;
  var newLineFlag; var index = 0; var
    val;
  var anchorGrouping = data.m.g;
  var currentSize = 0; var currentPos = 0; var currentLine = 0; var
    lineWidths = [];
  var lineWidth = 0;
  var maxLineWidth = 0;
  var j; var
    jLen;
  var fontData = fontManager.getFontByName(documentData.f);
  var charData; var
    cLength = 0;

  var fontProps = getFontProperties(fontData);
  documentData.fWeight = fontProps.weight;
  documentData.fStyle = fontProps.style;
  documentData.finalSize = documentData.s;
  documentData.finalText = this.buildFinalText(documentData.t);
  len = documentData.finalText.length;
  documentData.finalLineHeight = documentData.lh;
  var trackingOffset = (documentData.tr / 1000) * documentData.finalSize;
  var charCode;
  if (documentData.sz) {
    var flag = true;
    var boxWidth = documentData.sz[0];
    var boxHeight = documentData.sz[1];
    var currentHeight; var
      finalText;
    while (flag) {
      finalText = this.buildFinalText(documentData.t);
      currentHeight = 0;
      lineWidth = 0;
      len = finalText.length;
      trackingOffset = (documentData.tr / 1000) * documentData.finalSize;
      var lastSpaceIndex = -1;
      for (i = 0; i < len; i += 1) {
        charCode = finalText[i].charCodeAt(0);
        newLineFlag = false;
        if (finalText[i] === ' ') {
          lastSpaceIndex = i;
        } else if (charCode === 13 || charCode === 3) {
          lineWidth = 0;
          newLineFlag = true;
          currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
        }
        if (fontManager.chars) {
          charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
          cLength = newLineFlag ? 0 : (charData.w * documentData.finalSize) / 100;
        } else {
          // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
          cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
        }
        if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {
          if (lastSpaceIndex === -1) {
            len += 1;
          } else {
            i = lastSpaceIndex;
          }
          currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
          finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\r');
          // finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);
          lastSpaceIndex = -1;
          lineWidth = 0;
        } else {
          lineWidth += cLength;
          lineWidth += trackingOffset;
        }
      }
      currentHeight += (fontData.ascent * documentData.finalSize) / 100;
      if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
        documentData.finalSize -= 1;
        documentData.finalLineHeight = (documentData.finalSize * documentData.lh) / documentData.s;
      } else {
        documentData.finalText = finalText;
        len = documentData.finalText.length;
        flag = false;
      }
    }
  }
  lineWidth = -trackingOffset;
  cLength = 0;
  var uncollapsedSpaces = 0;
  var currentChar;
  for (i = 0; i < len; i += 1) {
    newLineFlag = false;
    currentChar = documentData.finalText[i];
    charCode = currentChar.charCodeAt(0);
    if (charCode === 13 || charCode === 3) {
      uncollapsedSpaces = 0;
      lineWidths.push(lineWidth);
      maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
      lineWidth = -2 * trackingOffset;
      val = '';
      newLineFlag = true;
      currentLine += 1;
    } else {
      val = currentChar;
    }
    if (fontManager.chars) {
      charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
      cLength = newLineFlag ? 0 : (charData.w * documentData.finalSize) / 100;
    } else {
      // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
      // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
      cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
    }

    //
    if (currentChar === ' ') {
      uncollapsedSpaces += cLength + trackingOffset;
    } else {
      lineWidth += cLength + trackingOffset + uncollapsedSpaces;
      uncollapsedSpaces = 0;
    }
    letters.push({
      l: cLength, an: cLength, add: currentSize, n: newLineFlag, anIndexes: [], val: val, line: currentLine, animatorJustifyOffset: 0,
    });
    if (anchorGrouping == 2) { // eslint-disable-line eqeqeq
      currentSize += cLength;
      if (val === '' || val === ' ' || i === len - 1) {
        if (val === '' || val === ' ') {
          currentSize -= cLength;
        }
        while (currentPos <= i) {
          letters[currentPos].an = currentSize;
          letters[currentPos].ind = index;
          letters[currentPos].extra = cLength;
          currentPos += 1;
        }
        index += 1;
        currentSize = 0;
      }
    } else if (anchorGrouping == 3) { // eslint-disable-line eqeqeq
      currentSize += cLength;
      if (val === '' || i === len - 1) {
        if (val === '') {
          currentSize -= cLength;
        }
        while (currentPos <= i) {
          letters[currentPos].an = currentSize;
          letters[currentPos].ind = index;
          letters[currentPos].extra = cLength;
          currentPos += 1;
        }
        currentSize = 0;
        index += 1;
      }
    } else {
      letters[index].ind = index;
      letters[index].extra = 0;
      index += 1;
    }
  }
  documentData.l = letters;
  maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
  lineWidths.push(lineWidth);
  if (documentData.sz) {
    documentData.boxWidth = documentData.sz[0];
    documentData.justifyOffset = 0;
  } else {
    documentData.boxWidth = maxLineWidth;
    switch (documentData.j) {
      case 1:
        documentData.justifyOffset = -documentData.boxWidth;
        break;
      case 2:
        documentData.justifyOffset = -documentData.boxWidth / 2;
        break;
      default:
        documentData.justifyOffset = 0;
    }
  }
  documentData.lineWidths = lineWidths;

  var animators = data.a; var animatorData; var
    letterData;
  jLen = animators.length;
  var based; var ind; var
    indexes = [];
  for (j = 0; j < jLen; j += 1) {
    animatorData = animators[j];
    if (animatorData.a.sc) {
      documentData.strokeColorAnim = true;
    }
    if (animatorData.a.sw) {
      documentData.strokeWidthAnim = true;
    }
    if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
      documentData.fillColorAnim = true;
    }
    ind = 0;
    based = animatorData.s.b;
    for (i = 0; i < len; i += 1) {
      letterData = letters[i];
      letterData.anIndexes[j] = ind;
      if ((based == 1 && letterData.val !== '') || (based == 2 && letterData.val !== '' && letterData.val !== ' ') || (based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1)) || (based == 4 && (letterData.n || i == len - 1))) { // eslint-disable-line eqeqeq
        if (animatorData.s.rn === 1) {
          indexes.push(ind);
        }
        ind += 1;
      }
    }
    data.a[j].s.totalChars = ind;
    var currentInd = -1; var
      newInd;
    if (animatorData.s.rn === 1) {
      for (i = 0; i < len; i += 1) {
        letterData = letters[i];
        if (currentInd != letterData.anIndexes[j]) { // eslint-disable-line eqeqeq
          currentInd = letterData.anIndexes[j];
          newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
        }
        letterData.anIndexes[j] = newInd;
      }
    }
  }
  documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
  documentData.ls = documentData.ls || 0;
  documentData.ascent = (fontData.ascent * documentData.finalSize) / 100;
};

TextProperty.prototype.updateDocumentData = function (newData, index) {
  index = index === undefined ? this.keysIndex : index;
  var dData = this.copyData({}, this.data.d.k[index].s);
  dData = this.copyData(dData, newData);
  this.data.d.k[index].s = dData;
  this.recalculate(index);
  this.elem.addDynamicProperty(this);
};

TextProperty.prototype.recalculate = function (index) {
  var dData = this.data.d.k[index].s;
  dData.__complete = false;
  this.keysIndex = 0;
  this._isFirstFrame = true;
  this.getValue(dData);
};

TextProperty.prototype.canResizeFont = function (_canResize) {
  this.canResize = _canResize;
  this.recalculate(this.keysIndex);
  this.elem.addDynamicProperty(this);
};

TextProperty.prototype.setMinimumFontSize = function (_fontValue) {
  this.minimumFontSize = Math.floor(_fontValue) || 1;
  this.recalculate(this.keysIndex);
  this.elem.addDynamicProperty(this);
};

/* global extendPrototype, BezierFactory, PropertyFactory, DynamicPropertyContainer */
/* exported TextSelectorProp */

var TextSelectorProp = (function () {
  var max = Math.max;
  var min = Math.min;
  var floor = Math.floor;

  function TextSelectorPropFactory(elem, data) {
    this._currentTextLength = -1;
    this.k = false;
    this.data = data;
    this.elem = elem;
    this.comp = elem.comp;
    this.finalS = 0;
    this.finalE = 0;
    this.initDynamicPropertyContainer(elem);
    this.s = PropertyFactory.getProp(elem, data.s || { k: 0 }, 0, 0, this);
    if ('e' in data) {
      this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
    } else {
      this.e = { v: 100 };
    }
    this.o = PropertyFactory.getProp(elem, data.o || { k: 0 }, 0, 0, this);
    this.xe = PropertyFactory.getProp(elem, data.xe || { k: 0 }, 0, 0, this);
    this.ne = PropertyFactory.getProp(elem, data.ne || { k: 0 }, 0, 0, this);
    this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);
    if (!this.dynamicProperties.length) {
      this.getValue();
    }
  }

  TextSelectorPropFactory.prototype = {
    getMult: function (ind) {
      if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
        this.getValue();
      }
      // var easer = bez.getEasingCurve(this.ne.v/100,0,1-this.xe.v/100,1);
      var x1 = 0;
      var y1 = 0;
      var x2 = 1;
      var y2 = 1;
      if (this.ne.v > 0) {
        x1 = this.ne.v / 100.0;
      } else {
        y1 = -this.ne.v / 100.0;
      }
      if (this.xe.v > 0) {
        x2 = 1.0 - this.xe.v / 100.0;
      } else {
        y2 = 1.0 + this.xe.v / 100.0;
      }
      var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;

      var mult = 0;
      var s = this.finalS;
      var e = this.finalE;
      var type = this.data.sh;
      if (type === 2) {
        if (e === s) {
          mult = ind >= e ? 1 : 0;
        } else {
          mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
        }
        mult = easer(mult);
      } else if (type === 3) {
        if (e === s) {
          mult = ind >= e ? 0 : 1;
        } else {
          mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
        }

        mult = easer(mult);
      } else if (type === 4) {
        if (e === s) {
          mult = 0;
        } else {
          mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
          if (mult < 0.5) {
            mult *= 2;
          } else {
            mult = 1 - 2 * (mult - 0.5);
          }
        }
        mult = easer(mult);
      } else if (type === 5) {
        if (e === s) {
          mult = 0;
        } else {
          var tot = e - s;
          /* ind += 0.5;
                    mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */
          ind = min(max(0, ind + 0.5 - s), e - s);
          var x = -tot / 2 + ind;
          var a = tot / 2;
          mult = Math.sqrt(1 - (x * x) / (a * a));
        }
        mult = easer(mult);
      } else if (type === 6) {
        if (e === s) {
          mult = 0;
        } else {
          ind = min(max(0, ind + 0.5 - s), e - s);
          mult = (1 + (Math.cos((Math.PI + Math.PI * 2 * (ind) / (e - s))))) / 2; // eslint-disable-line
        }
        mult = easer(mult);
      } else {
        if (ind >= floor(s)) {
          if (ind - s < 0) {
            mult = max(0, min(min(e, 1) - (s - ind), 1));
          } else {
            mult = max(0, min(e - ind, 1));
          }
        }
        mult = easer(mult);
      }
      return mult * this.a.v;
    },
    getValue: function (newCharsFlag) {
      this.iterateDynamicProperties();
      this._mdf = newCharsFlag || this._mdf;
      this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
      if (newCharsFlag && this.data.r === 2) {
        this.e.v = this._currentTextLength;
      }
      var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
      var o = this.o.v / divisor;
      var s = this.s.v / divisor + o;
      var e = (this.e.v / divisor) + o;
      if (s > e) {
        var _s = s;
        s = e;
        e = _s;
      }
      this.finalS = s;
      this.finalE = e;
    },
  };
  extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);

  function getTextSelectorProp(elem, data, arr) {
    return new TextSelectorPropFactory(elem, data, arr);
  }

  return {
    getTextSelectorProp: getTextSelectorProp,
  };
}());

/* global createSizedArray, pooling */
/* exported poolFactory */

var poolFactory = (function () {
  return function (initialLength, _create, _release) {
    var _length = 0;
    var _maxLength = initialLength;
    var pool = createSizedArray(_maxLength);

    var ob = {
      newElement: newElement,
      release: release,
    };

    function newElement() {
      var element;
      if (_length) {
        _length -= 1;
        element = pool[_length];
      } else {
        element = _create();
      }
      return element;
    }

    function release(element) {
      if (_length === _maxLength) {
        pool = pooling.double(pool);
        _maxLength *= 2;
      }
      if (_release) {
        _release(element);
      }
      pool[_length] = element;
      _length += 1;
    }

    return ob;
  };
}());

/* global createSizedArray */
/* exported pooling */

var pooling = (function () {
  function double(arr) {
    return arr.concat(createSizedArray(arr.length));
  }

  return {
    double: double,
  };
}());

/* global createTypedArray, poolFactory */
/* exported pointPool */

var pointPool = (function () {
  function create() {
    return createTypedArray('float32', 2);
  }
  return poolFactory(8, create);
}());

/* global ShapePath, pointPool, poolFactory */
/* exported shapePool */

var shapePool = (function () {
  function create() {
    return new ShapePath();
  }

  function release(shapePath) {
    var len = shapePath._length;
    var i;
    for (i = 0; i < len; i += 1) {
      pointPool.release(shapePath.v[i]);
      pointPool.release(shapePath.i[i]);
      pointPool.release(shapePath.o[i]);
      shapePath.v[i] = null;
      shapePath.i[i] = null;
      shapePath.o[i] = null;
    }
    shapePath._length = 0;
    shapePath.c = false;
  }

  function clone(shape) {
    var cloned = factory.newElement();
    var i;
    var len = shape._length === undefined ? shape.v.length : shape._length;
    cloned.setLength(len);
    cloned.c = shape.c;

    for (i = 0; i < len; i += 1) {
      cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
    }
    return cloned;
  }

  var factory = poolFactory(4, create, release);
  factory.clone = clone;

  return factory;
}());

/* global createSizedArray, ShapeCollection, shapePool, pooling */
/* exported shapeCollectionPool */

var shapeCollectionPool = (function () {
  var ob = {
    newShapeCollection: newShapeCollection,
    release: release,
  };

  var _length = 0;
  var _maxLength = 4;
  var pool = createSizedArray(_maxLength);

  function newShapeCollection() {
    var shapeCollection;
    if (_length) {
      _length -= 1;
      shapeCollection = pool[_length];
    } else {
      shapeCollection = new ShapeCollection();
    }
    return shapeCollection;
  }

  function release(shapeCollection) {
    var i;
    var len = shapeCollection._length;
    for (i = 0; i < len; i += 1) {
      shapePool.release(shapeCollection.shapes[i]);
    }
    shapeCollection._length = 0;

    if (_length === _maxLength) {
      pool = pooling.double(pool);
      _maxLength *= 2;
    }
    pool[_length] = shapeCollection;
    _length += 1;
  }

  return ob;
}());

/* global poolFactory, bezierLengthPool */
/* exported segmentsLengthPool */

var segmentsLengthPool = (function () {
  function create() {
    return {
      lengths: [],
      totalLength: 0,
    };
  }

  function release(element) {
    var i;
    var len = element.lengths.length;
    for (i = 0; i < len; i += 1) {
      bezierLengthPool.release(element.lengths[i]);
    }
    element.lengths.length = 0;
  }

  return poolFactory(8, create, release);
}());

/* global createTypedArray, defaultCurveSegments, poolFactory */
/* exported bezierLengthPool */

var bezierLengthPool = (function () {
  function create() {
    return {
      addedLength: 0,
      percents: createTypedArray('float32', defaultCurveSegments),
      lengths: createTypedArray('float32', defaultCurveSegments),
    };
  }
  return poolFactory(8, create);
}());

/* exported markerParser */

var markerParser = (

  function () {
    function parsePayloadLines(payload) {
      var lines = payload.split('\r\n');
      var keys = {};
      var line;
      var keysCount = 0;
      for (var i = 0; i < lines.length; i += 1) {
        line = lines[i].split(':');
        if (line.length === 2) {
          keys[line[0]] = line[1].trim();
          keysCount += 1;
        }
      }
      if (keysCount === 0) {
        throw new Error();
      }
      return keys;
    }

    return function (_markers) {
      var markers = [];
      for (var i = 0; i < _markers.length; i += 1) {
        var _marker = _markers[i];
        var markerData = {
          time: _marker.tm,
          duration: _marker.dr,
        };
        try {
          markerData.payload = JSON.parse(_markers[i].cm);
        } catch (_) {
          try {
            markerData.payload = parsePayloadLines(_markers[i].cm);
          } catch (__) {
            markerData.payload = {
              name: _markers[i],
            };
          }
        }
        markers.push(markerData);
      }
      return markers;
    };
  }());

/* global AudioElement, FootageElement, FontManager */

function BaseRenderer() {}
BaseRenderer.prototype.checkLayers = function (num) {
  var i;
  var len = this.layers.length;
  var data;
  this.completeLayers = true;
  for (i = len - 1; i >= 0; i -= 1) {
    if (!this.elements[i]) {
      data = this.layers[i];
      if (data.ip - data.st <= (num - this.layers[i].st) && data.op - data.st > (num - this.layers[i].st)) {
        this.buildItem(i);
      }
    }
    this.completeLayers = this.elements[i] ? this.completeLayers : false;
  }
  this.checkPendingElements();
};

BaseRenderer.prototype.createItem = function (layer) {
  switch (layer.ty) {
    case 2:
      return this.createImage(layer);
    case 0:
      return this.createComp(layer);
    case 1:
      return this.createSolid(layer);
    case 3:
      return this.createNull(layer);
    case 4:
      return this.createShape(layer);
    case 5:
      return this.createText(layer);
    case 6:
      return this.createAudio(layer);
    case 13:
      return this.createCamera(layer);
    case 15:
      return this.createFootage(layer);
    default:
      return this.createNull(layer);
  }
};

BaseRenderer.prototype.createCamera = function () {
  throw new Error('You\'re using a 3d camera. Try the html renderer.');
};

BaseRenderer.prototype.createAudio = function (data) {
  return new AudioElement(data, this.globalData, this);
};

BaseRenderer.prototype.createFootage = function (data) {
  return new FootageElement(data, this.globalData, this);
};

BaseRenderer.prototype.buildAllItems = function () {
  var i;
  var len = this.layers.length;
  for (i = 0; i < len; i += 1) {
    this.buildItem(i);
  }
  this.checkPendingElements();
};

BaseRenderer.prototype.includeLayers = function (newLayers) {
  this.completeLayers = false;
  var i;
  var len = newLayers.length;
  var j;
  var jLen = this.layers.length;
  for (i = 0; i < len; i += 1) {
    j = 0;
    while (j < jLen) {
      if (this.layers[j].id === newLayers[i].id) {
        this.layers[j] = newLayers[i];
        break;
      }
      j += 1;
    }
  }
};

BaseRenderer.prototype.setProjectInterface = function (pInterface) {
  this.globalData.projectInterface = pInterface;
};

BaseRenderer.prototype.initItems = function () {
  if (!this.globalData.progressiveLoad) {
    this.buildAllItems();
  }
};
BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {
  var elements = this.elements;
  var layers = this.layers;
  var i = 0;
  var len = layers.length;
  while (i < len) {
    if (layers[i].ind == parentName) { // eslint-disable-line eqeqeq
      if (!elements[i] || elements[i] === true) {
        this.buildItem(i);
        this.addPendingElement(element);
      } else {
        hierarchy.push(elements[i]);
        elements[i].setAsParent();
        if (layers[i].parent !== undefined) {
          this.buildElementParenting(element, layers[i].parent, hierarchy);
        } else {
          element.setHierarchy(hierarchy);
        }
      }
    }
    i += 1;
  }
};

BaseRenderer.prototype.addPendingElement = function (element) {
  this.pendingElements.push(element);
};

BaseRenderer.prototype.searchExtraCompositions = function (assets) {
  var i;
  var len = assets.length;
  for (i = 0; i < len; i += 1) {
    if (assets[i].xt) {
      var comp = this.createComp(assets[i]);
      comp.initExpressions();
      this.globalData.projectInterface.registerComposition(comp);
    }
  }
};

BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {
  this.globalData.fontManager = new FontManager();
  this.globalData.fontManager.addChars(animData.chars);
  this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
  this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
  this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
  this.globalData.imageLoader = this.animationItem.imagePreloader;
  this.globalData.audioController = this.animationItem.audioController;
  this.globalData.frameId = 0;
  this.globalData.frameRate = animData.fr;
  this.globalData.nm = animData.nm;
  this.globalData.compSize = {
    w: animData.w,
    h: animData.h,
  };
};

/* global createElementID, extendPrototype, BaseRenderer, NullElement, SVGShapeElement, SVGTextLottieElement,
IImageElement, SVGCompElement, ISolidElement, createNS, locationHref, createSizedArray, expressionsPlugin */

function SVGRenderer(animationItem, config) {
  this.animationItem = animationItem;
  this.layers = null;
  this.renderedFrame = -1;
  this.svgElement = createNS('svg');
  var ariaLabel = '';
  if (config && config.title) {
    var titleElement = createNS('title');
    var titleId = createElementID();
    titleElement.setAttribute('id', titleId);
    titleElement.textContent = config.title;
    this.svgElement.appendChild(titleElement);
    ariaLabel += titleId;
  }
  if (config && config.description) {
    var descElement = createNS('desc');
    var descId = createElementID();
    descElement.setAttribute('id', descId);
    descElement.textContent = config.description;
    this.svgElement.appendChild(descElement);
    ariaLabel += ' ' + descId;
  }
  if (ariaLabel) {
    this.svgElement.setAttribute('aria-labelledby', ariaLabel);
  }
  var defs = createNS('defs');
  this.svgElement.appendChild(defs);
  var maskElement = createNS('g');
  this.svgElement.appendChild(maskElement);
  this.layerElement = maskElement;
  this.renderConfig = {
    preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
    imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
    progressiveLoad: (config && config.progressiveLoad) || false,
    hideOnTransparent: !((config && config.hideOnTransparent === false)),
    viewBoxOnly: (config && config.viewBoxOnly) || false,
    viewBoxSize: (config && config.viewBoxSize) || false,
    className: (config && config.className) || '',
    id: (config && config.id) || '',
    focusable: config && config.focusable,
    filterSize: {
      width: (config && config.filterSize && config.filterSize.width) || '100%',
      height: (config && config.filterSize && config.filterSize.height) || '100%',
      x: (config && config.filterSize && config.filterSize.x) || '0%',
      y: (config && config.filterSize && config.filterSize.y) || '0%',
    },
  };

  this.globalData = {
    _mdf: false,
    frameNum: -1,
    defs: defs,
    renderConfig: this.renderConfig,
  };
  this.elements = [];
  this.pendingElements = [];
  this.destroyed = false;
  this.rendererType = 'svg';
}

extendPrototype([BaseRenderer], SVGRenderer);

SVGRenderer.prototype.createNull = function (data) {
  return new NullElement(data, this.globalData, this);
};

SVGRenderer.prototype.createShape = function (data) {
  return new SVGShapeElement(data, this.globalData, this);
};

SVGRenderer.prototype.createText = function (data) {
  return new SVGTextLottieElement(data, this.globalData, this);
};

SVGRenderer.prototype.createImage = function (data) {
  return new IImageElement(data, this.globalData, this);
};

SVGRenderer.prototype.createComp = function (data) {
  return new SVGCompElement(data, this.globalData, this);
};

SVGRenderer.prototype.createSolid = function (data) {
  return new ISolidElement(data, this.globalData, this);
};

SVGRenderer.prototype.configAnimation = function (animData) {
  this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  if (this.renderConfig.viewBoxSize) {
    this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);
  } else {
    this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);
  }

  if (!this.renderConfig.viewBoxOnly) {
    this.svgElement.setAttribute('width', animData.w);
    this.svgElement.setAttribute('height', animData.h);
    this.svgElement.style.width = '100%';
    this.svgElement.style.height = '100%';
    this.svgElement.style.transform = 'translate3d(0,0,0)';
  }
  if (this.renderConfig.className) {
    this.svgElement.setAttribute('class', this.renderConfig.className);
  }
  if (this.renderConfig.id) {
    this.svgElement.setAttribute('id', this.renderConfig.id);
  }
  if (this.renderConfig.focusable !== undefined) {
    this.svgElement.setAttribute('focusable', this.renderConfig.focusable);
  }
  this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio);
  // this.layerElement.style.transform = 'translate3d(0,0,0)';
  // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";
  this.animationItem.wrapper.appendChild(this.svgElement);
  // Mask animation
  var defs = this.globalData.defs;

  this.setupGlobalData(animData, defs);
  this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
  this.data = animData;

  var maskElement = createNS('clipPath');
  var rect = createNS('rect');
  rect.setAttribute('width', animData.w);
  rect.setAttribute('height', animData.h);
  rect.setAttribute('x', 0);
  rect.setAttribute('y', 0);
  var maskId = createElementID();
  maskElement.setAttribute('id', maskId);
  maskElement.appendChild(rect);
  this.layerElement.setAttribute('clip-path', 'url(' + locationHref + '#' + maskId + ')');

  defs.appendChild(maskElement);
  this.layers = animData.layers;
  this.elements = createSizedArray(animData.layers.length);
};

SVGRenderer.prototype.destroy = function () {
  if (this.animationItem.wrapper) {
    this.animationItem.wrapper.innerText = '';
  }
  this.layerElement = null;
  this.globalData.defs = null;
  var i;
  var len = this.layers ? this.layers.length : 0;
  for (i = 0; i < len; i += 1) {
    if (this.elements[i]) {
      this.elements[i].destroy();
    }
  }
  this.elements.length = 0;
  this.destroyed = true;
  this.animationItem = null;
};

SVGRenderer.prototype.updateContainerSize = function () {
};

SVGRenderer.prototype.buildItem = function (pos) {
  var elements = this.elements;
  if (elements[pos] || this.layers[pos].ty === 99) {
    return;
  }
  elements[pos] = true;
  var element = this.createItem(this.layers[pos]);

  elements[pos] = element;
  if (expressionsPlugin) {
    if (this.layers[pos].ty === 0) {
      this.globalData.projectInterface.registerComposition(element);
    }
    element.initExpressions();
  }
  this.appendElementInPos(element, pos);
  if (this.layers[pos].tt) {
    if (!this.elements[pos - 1] || this.elements[pos - 1] === true) {
      this.buildItem(pos - 1);
      this.addPendingElement(element);
    } else {
      element.setMatte(elements[pos - 1].layerId);
    }
  }
};

SVGRenderer.prototype.checkPendingElements = function () {
  while (this.pendingElements.length) {
    var element = this.pendingElements.pop();
    element.checkParenting();
    if (element.data.tt) {
      var i = 0;
      var len = this.elements.length;
      while (i < len) {
        if (this.elements[i] === element) {
          element.setMatte(this.elements[i - 1].layerId);
          break;
        }
        i += 1;
      }
    }
  }
};

SVGRenderer.prototype.renderFrame = function (num) {
  if (this.renderedFrame === num || this.destroyed) {
    return;
  }
  if (num === null) {
    num = this.renderedFrame;
  } else {
    this.renderedFrame = num;
  }
  // console.log('-------');
  // console.log('FRAME ',num);
  this.globalData.frameNum = num;
  this.globalData.frameId += 1;
  this.globalData.projectInterface.currentFrame = num;
  this.globalData._mdf = false;
  var i;
  var len = this.layers.length;
  if (!this.completeLayers) {
    this.checkLayers(num);
  }
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.completeLayers || this.elements[i]) {
      this.elements[i].prepareFrame(num - this.layers[i].st);
    }
  }
  if (this.globalData._mdf) {
    for (i = 0; i < len; i += 1) {
      if (this.completeLayers || this.elements[i]) {
        this.elements[i].renderFrame();
      }
    }
  }
};

SVGRenderer.prototype.appendElementInPos = function (element, pos) {
  var newElement = element.getBaseElement();
  if (!newElement) {
    return;
  }
  var i = 0;
  var nextElement;
  while (i < pos) {
    if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {
      nextElement = this.elements[i].getBaseElement();
    }
    i += 1;
  }
  if (nextElement) {
    this.layerElement.insertBefore(newElement, nextElement);
  } else {
    this.layerElement.appendChild(newElement);
  }
};

SVGRenderer.prototype.hide = function () {
  this.layerElement.style.display = 'none';
};

SVGRenderer.prototype.show = function () {
  this.layerElement.style.display = 'block';
};

/* global CVContextData, Matrix, extendPrototype, BaseRenderer, CVShapeElement, CVTextElement,
CVImageElement, CVCompElement, CVSolidElement, SVGRenderer, createTag, createSizedArray */

function CanvasRenderer(animationItem, config) {
  this.animationItem = animationItem;
  this.renderConfig = {
    clearCanvas: (config && config.clearCanvas !== undefined) ? config.clearCanvas : true,
    context: (config && config.context) || null,
    progressiveLoad: (config && config.progressiveLoad) || false,
    preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
    imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
    className: (config && config.className) || '',
    id: (config && config.id) || '',
  };
  this.renderConfig.dpr = (config && config.dpr) || 1;
  if (this.animationItem.wrapper) {
    this.renderConfig.dpr = (config && config.dpr) || window.devicePixelRatio || 1;
  }
  this.renderedFrame = -1;
  this.globalData = {
    frameNum: -1,
    _mdf: false,
    renderConfig: this.renderConfig,
    currentGlobalAlpha: -1,
  };
  this.contextData = new CVContextData();
  this.elements = [];
  this.pendingElements = [];
  this.transformMat = new Matrix();
  this.completeLayers = false;
  this.rendererType = 'canvas';
}
extendPrototype([BaseRenderer], CanvasRenderer);

CanvasRenderer.prototype.createShape = function (data) {
  return new CVShapeElement(data, this.globalData, this);
};

CanvasRenderer.prototype.createText = function (data) {
  return new CVTextElement(data, this.globalData, this);
};

CanvasRenderer.prototype.createImage = function (data) {
  return new CVImageElement(data, this.globalData, this);
};

CanvasRenderer.prototype.createComp = function (data) {
  return new CVCompElement(data, this.globalData, this);
};

CanvasRenderer.prototype.createSolid = function (data) {
  return new CVSolidElement(data, this.globalData, this);
};

CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull;

CanvasRenderer.prototype.ctxTransform = function (props) {
  if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
    return;
  }
  if (!this.renderConfig.clearCanvas) {
    this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
    return;
  }
  this.transformMat.cloneFromProps(props);
  var cProps = this.contextData.cTr.props;
  this.transformMat.transform(cProps[0], cProps[1], cProps[2], cProps[3], cProps[4], cProps[5], cProps[6], cProps[7], cProps[8], cProps[9], cProps[10], cProps[11], cProps[12], cProps[13], cProps[14], cProps[15]);
  // this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
  this.contextData.cTr.cloneFromProps(this.transformMat.props);
  var trProps = this.contextData.cTr.props;
  this.canvasContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
};

CanvasRenderer.prototype.ctxOpacity = function (op) {
  /* if(op === 1){
        return;
    } */
  if (!this.renderConfig.clearCanvas) {
    this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
    this.globalData.currentGlobalAlpha = this.contextData.cO;
    return;
  }
  this.contextData.cO *= op < 0 ? 0 : op;
  if (this.globalData.currentGlobalAlpha !== this.contextData.cO) {
    this.canvasContext.globalAlpha = this.contextData.cO;
    this.globalData.currentGlobalAlpha = this.contextData.cO;
  }
};

CanvasRenderer.prototype.reset = function () {
  if (!this.renderConfig.clearCanvas) {
    this.canvasContext.restore();
    return;
  }
  this.contextData.reset();
};

CanvasRenderer.prototype.save = function (actionFlag) {
  if (!this.renderConfig.clearCanvas) {
    this.canvasContext.save();
    return;
  }
  if (actionFlag) {
    this.canvasContext.save();
  }
  var props = this.contextData.cTr.props;
  if (this.contextData._length <= this.contextData.cArrPos) {
    this.contextData.duplicate();
  }
  var i;
  var arr = this.contextData.saved[this.contextData.cArrPos];
  for (i = 0; i < 16; i += 1) {
    arr[i] = props[i];
  }
  this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO;
  this.contextData.cArrPos += 1;
};

CanvasRenderer.prototype.restore = function (actionFlag) {
  if (!this.renderConfig.clearCanvas) {
    this.canvasContext.restore();
    return;
  }
  if (actionFlag) {
    this.canvasContext.restore();
    this.globalData.blendMode = 'source-over';
  }
  this.contextData.cArrPos -= 1;
  var popped = this.contextData.saved[this.contextData.cArrPos];
  var i;
  var arr = this.contextData.cTr.props;
  for (i = 0; i < 16; i += 1) {
    arr[i] = popped[i];
  }
  this.canvasContext.setTransform(popped[0], popped[1], popped[4], popped[5], popped[12], popped[13]);
  popped = this.contextData.savedOp[this.contextData.cArrPos];
  this.contextData.cO = popped;
  if (this.globalData.currentGlobalAlpha !== popped) {
    this.canvasContext.globalAlpha = popped;
    this.globalData.currentGlobalAlpha = popped;
  }
};

CanvasRenderer.prototype.configAnimation = function (animData) {
  if (this.animationItem.wrapper) {
    this.animationItem.container = createTag('canvas');
    var containerStyle = this.animationItem.container.style;
    containerStyle.width = '100%';
    containerStyle.height = '100%';
    var origin = '0px 0px 0px';
    containerStyle.transformOrigin = origin;
    containerStyle.mozTransformOrigin = origin;
    containerStyle.webkitTransformOrigin = origin;
    containerStyle['-webkit-transform'] = origin;
    this.animationItem.wrapper.appendChild(this.animationItem.container);
    this.canvasContext = this.animationItem.container.getContext('2d');
    if (this.renderConfig.className) {
      this.animationItem.container.setAttribute('class', this.renderConfig.className);
    }
    if (this.renderConfig.id) {
      this.animationItem.container.setAttribute('id', this.renderConfig.id);
    }
  } else {
    this.canvasContext = this.renderConfig.context;
  }
  this.data = animData;
  this.layers = animData.layers;
  this.transformCanvas = {
    w: animData.w,
    h: animData.h,
    sx: 0,
    sy: 0,
    tx: 0,
    ty: 0,
  };
  this.setupGlobalData(animData, document.body);
  this.globalData.canvasContext = this.canvasContext;
  this.globalData.renderer = this;
  this.globalData.isDashed = false;
  this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
  this.globalData.transformCanvas = this.transformCanvas;
  this.elements = createSizedArray(animData.layers.length);

  this.updateContainerSize();
};

CanvasRenderer.prototype.updateContainerSize = function () {
  this.reset();
  var elementWidth;
  var elementHeight;
  if (this.animationItem.wrapper && this.animationItem.container) {
    elementWidth = this.animationItem.wrapper.offsetWidth;
    elementHeight = this.animationItem.wrapper.offsetHeight;
    this.animationItem.container.setAttribute('width', elementWidth * this.renderConfig.dpr);
    this.animationItem.container.setAttribute('height', elementHeight * this.renderConfig.dpr);
  } else {
    elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr;
    elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr;
  }
  var elementRel;
  var animationRel;
  if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {
    var par = this.renderConfig.preserveAspectRatio.split(' ');
    var fillType = par[1] || 'meet';
    var pos = par[0] || 'xMidYMid';
    var xPos = pos.substr(0, 4);
    var yPos = pos.substr(4);
    elementRel = elementWidth / elementHeight;
    animationRel = this.transformCanvas.w / this.transformCanvas.h;
    if ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice')) {
      this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
      this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
    } else {
      this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
      this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
    }

    if (xPos === 'xMid' && ((animationRel < elementRel && fillType === 'meet') || (animationRel > elementRel && fillType === 'slice'))) {
      this.transformCanvas.tx = ((elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2) * this.renderConfig.dpr;
    } else if (xPos === 'xMax' && ((animationRel < elementRel && fillType === 'meet') || (animationRel > elementRel && fillType === 'slice'))) {
      this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
    } else {
      this.transformCanvas.tx = 0;
    }
    if (yPos === 'YMid' && ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice'))) {
      this.transformCanvas.ty = ((elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2) * this.renderConfig.dpr;
    } else if (yPos === 'YMax' && ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice'))) {
      this.transformCanvas.ty = ((elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w))) * this.renderConfig.dpr;
    } else {
      this.transformCanvas.ty = 0;
    }
  } else if (this.renderConfig.preserveAspectRatio === 'none') {
    this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
    this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
    this.transformCanvas.tx = 0;
    this.transformCanvas.ty = 0;
  } else {
    this.transformCanvas.sx = this.renderConfig.dpr;
    this.transformCanvas.sy = this.renderConfig.dpr;
    this.transformCanvas.tx = 0;
    this.transformCanvas.ty = 0;
  }
  this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
  /* var i, len = this.elements.length;
    for(i=0;i<len;i+=1){
        if(this.elements[i] && this.elements[i].data.ty === 0){
            this.elements[i].resize(this.globalData.transformCanvas);
        }
    } */
  this.ctxTransform(this.transformCanvas.props);
  this.canvasContext.beginPath();
  this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
  this.canvasContext.closePath();
  this.canvasContext.clip();

  this.renderFrame(this.renderedFrame, true);
};

CanvasRenderer.prototype.destroy = function () {
  if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
    this.animationItem.wrapper.innerText = '';
  }
  var i;
  var len = this.layers ? this.layers.length : 0;
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.elements[i]) {
      this.elements[i].destroy();
    }
  }
  this.elements.length = 0;
  this.globalData.canvasContext = null;
  this.animationItem.container = null;
  this.destroyed = true;
};

CanvasRenderer.prototype.renderFrame = function (num, forceRender) {
  if ((this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender) || this.destroyed || num === -1) {
    return;
  }
  this.renderedFrame = num;
  this.globalData.frameNum = num - this.animationItem._isFirstFrame;
  this.globalData.frameId += 1;
  this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
  this.globalData.projectInterface.currentFrame = num;

  // console.log('--------');
  // console.log('NEW: ',num);
  var i;
  var len = this.layers.length;
  if (!this.completeLayers) {
    this.checkLayers(num);
  }

  for (i = 0; i < len; i += 1) {
    if (this.completeLayers || this.elements[i]) {
      this.elements[i].prepareFrame(num - this.layers[i].st);
    }
  }
  if (this.globalData._mdf) {
    if (this.renderConfig.clearCanvas === true) {
      this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
    } else {
      this.save();
    }
    for (i = len - 1; i >= 0; i -= 1) {
      if (this.completeLayers || this.elements[i]) {
        this.elements[i].renderFrame();
      }
    }
    if (this.renderConfig.clearCanvas !== true) {
      this.restore();
    }
  }
};

CanvasRenderer.prototype.buildItem = function (pos) {
  var elements = this.elements;
  if (elements[pos] || this.layers[pos].ty === 99) {
    return;
  }
  var element = this.createItem(this.layers[pos], this, this.globalData);
  elements[pos] = element;
  element.initExpressions();
  /* if(this.layers[pos].ty === 0){
        element.resize(this.globalData.transformCanvas);
    } */
};

CanvasRenderer.prototype.checkPendingElements = function () {
  while (this.pendingElements.length) {
    var element = this.pendingElements.pop();
    element.checkParenting();
  }
};

CanvasRenderer.prototype.hide = function () {
  this.animationItem.container.style.display = 'none';
};

CanvasRenderer.prototype.show = function () {
  this.animationItem.container.style.display = 'block';
};

/* global extendPrototype, BaseRenderer, SVGRenderer, SVGShapeElement, HShapeElement, SVGTextLottieElement,
HTextElement, HCameraElement, IImageElement, HImageElement, SVGCompElement, HCompElement, ISolidElement,
HSolidElement, styleDiv, createTag, createNS */

function HybridRenderer(animationItem, config) {
  this.animationItem = animationItem;
  this.layers = null;
  this.renderedFrame = -1;
  this.renderConfig = {
    className: (config && config.className) || '',
    imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
    hideOnTransparent: !(config && config.hideOnTransparent === false),
    filterSize: {
      width: (config && config.filterSize && config.filterSize.width) || '400%',
      height: (config && config.filterSize && config.filterSize.height) || '400%',
      x: (config && config.filterSize && config.filterSize.x) || '-100%',
      y: (config && config.filterSize && config.filterSize.y) || '-100%',
    },
  };
  this.globalData = {
    _mdf: false,
    frameNum: -1,
    renderConfig: this.renderConfig,
  };
  this.pendingElements = [];
  this.elements = [];
  this.threeDElements = [];
  this.destroyed = false;
  this.camera = null;
  this.supports3d = true;
  this.rendererType = 'html';
}

extendPrototype([BaseRenderer], HybridRenderer);

HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem;

HybridRenderer.prototype.checkPendingElements = function () {
  while (this.pendingElements.length) {
    var element = this.pendingElements.pop();
    element.checkParenting();
  }
};

HybridRenderer.prototype.appendElementInPos = function (element, pos) {
  var newDOMElement = element.getBaseElement();
  if (!newDOMElement) {
    return;
  }
  var layer = this.layers[pos];
  if (!layer.ddd || !this.supports3d) {
    if (this.threeDElements) {
      this.addTo3dContainer(newDOMElement, pos);
    } else {
      var i = 0;
      var nextDOMElement;
      var nextLayer;
      var tmpDOMElement;
      while (i < pos) {
        if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
          nextLayer = this.elements[i];
          tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
          nextDOMElement = tmpDOMElement || nextDOMElement;
        }
        i += 1;
      }
      if (nextDOMElement) {
        if (!layer.ddd || !this.supports3d) {
          this.layerElement.insertBefore(newDOMElement, nextDOMElement);
        }
      } else if (!layer.ddd || !this.supports3d) {
        this.layerElement.appendChild(newDOMElement);
      }
    }
  } else {
    this.addTo3dContainer(newDOMElement, pos);
  }
};

HybridRenderer.prototype.createShape = function (data) {
  if (!this.supports3d) {
    return new SVGShapeElement(data, this.globalData, this);
  }
  return new HShapeElement(data, this.globalData, this);
};

HybridRenderer.prototype.createText = function (data) {
  if (!this.supports3d) {
    return new SVGTextLottieElement(data, this.globalData, this);
  }
  return new HTextElement(data, this.globalData, this);
};

HybridRenderer.prototype.createCamera = function (data) {
  this.camera = new HCameraElement(data, this.globalData, this);
  return this.camera;
};

HybridRenderer.prototype.createImage = function (data) {
  if (!this.supports3d) {
    return new IImageElement(data, this.globalData, this);
  }
  return new HImageElement(data, this.globalData, this);
};

HybridRenderer.prototype.createComp = function (data) {
  if (!this.supports3d) {
    return new SVGCompElement(data, this.globalData, this);
  }
  return new HCompElement(data, this.globalData, this);
};

HybridRenderer.prototype.createSolid = function (data) {
  if (!this.supports3d) {
    return new ISolidElement(data, this.globalData, this);
  }
  return new HSolidElement(data, this.globalData, this);
};

HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull;

HybridRenderer.prototype.getThreeDContainerByPos = function (pos) {
  var i = 0;
  var len = this.threeDElements.length;
  while (i < len) {
    if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
      return this.threeDElements[i].perspectiveElem;
    }
    i += 1;
  }
  return null;
};

HybridRenderer.prototype.createThreeDContainer = function (pos, type) {
  var perspectiveElem = createTag('div');
  var style;
  var containerStyle;
  styleDiv(perspectiveElem);
  var container = createTag('div');
  styleDiv(container);
  if (type === '3d') {
    style = perspectiveElem.style;
    style.width = this.globalData.compSize.w + 'px';
    style.height = this.globalData.compSize.h + 'px';
    var center = '50% 50%';
    style.webkitTransformOrigin = center;
    style.mozTransformOrigin = center;
    style.transformOrigin = center;
    containerStyle = container.style;
    var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
    containerStyle.transform = matrix;
    containerStyle.webkitTransform = matrix;
  }

  perspectiveElem.appendChild(container);
  // this.resizerElem.appendChild(perspectiveElem);
  var threeDContainerData = {
    container: container,
    perspectiveElem: perspectiveElem,
    startPos: pos,
    endPos: pos,
    type: type,
  };
  this.threeDElements.push(threeDContainerData);
  return threeDContainerData;
};

HybridRenderer.prototype.build3dContainers = function () {
  var i;
  var len = this.layers.length;
  var lastThreeDContainerData;
  var currentContainer = '';
  for (i = 0; i < len; i += 1) {
    if (this.layers[i].ddd && this.layers[i].ty !== 3) {
      if (currentContainer !== '3d') {
        currentContainer = '3d';
        lastThreeDContainerData = this.createThreeDContainer(i, '3d');
      }
      lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
    } else {
      if (currentContainer !== '2d') {
        currentContainer = '2d';
        lastThreeDContainerData = this.createThreeDContainer(i, '2d');
      }
      lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
    }
  }
  len = this.threeDElements.length;
  for (i = len - 1; i >= 0; i -= 1) {
    this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
  }
};

HybridRenderer.prototype.addTo3dContainer = function (elem, pos) {
  var i = 0;
  var len = this.threeDElements.length;
  while (i < len) {
    if (pos <= this.threeDElements[i].endPos) {
      var j = this.threeDElements[i].startPos;
      var nextElement;
      while (j < pos) {
        if (this.elements[j] && this.elements[j].getBaseElement) {
          nextElement = this.elements[j].getBaseElement();
        }
        j += 1;
      }
      if (nextElement) {
        this.threeDElements[i].container.insertBefore(elem, nextElement);
      } else {
        this.threeDElements[i].container.appendChild(elem);
      }
      break;
    }
    i += 1;
  }
};

HybridRenderer.prototype.configAnimation = function (animData) {
  var resizerElem = createTag('div');
  var wrapper = this.animationItem.wrapper;
  var style = resizerElem.style;
  style.width = animData.w + 'px';
  style.height = animData.h + 'px';
  this.resizerElem = resizerElem;
  styleDiv(resizerElem);
  style.transformStyle = 'flat';
  style.mozTransformStyle = 'flat';
  style.webkitTransformStyle = 'flat';
  if (this.renderConfig.className) {
    resizerElem.setAttribute('class', this.renderConfig.className);
  }
  wrapper.appendChild(resizerElem);

  style.overflow = 'hidden';
  var svg = createNS('svg');
  svg.setAttribute('width', '1');
  svg.setAttribute('height', '1');
  styleDiv(svg);
  this.resizerElem.appendChild(svg);
  var defs = createNS('defs');
  svg.appendChild(defs);
  this.data = animData;
  // Mask animation
  this.setupGlobalData(animData, svg);
  this.globalData.defs = defs;
  this.layers = animData.layers;
  this.layerElement = this.resizerElem;
  this.build3dContainers();
  this.updateContainerSize();
};

HybridRenderer.prototype.destroy = function () {
  if (this.animationItem.wrapper) {
    this.animationItem.wrapper.innerText = '';
  }
  this.animationItem.container = null;
  this.globalData.defs = null;
  var i;
  var len = this.layers ? this.layers.length : 0;
  for (i = 0; i < len; i += 1) {
    this.elements[i].destroy();
  }
  this.elements.length = 0;
  this.destroyed = true;
  this.animationItem = null;
};

HybridRenderer.prototype.updateContainerSize = function () {
  var elementWidth = this.animationItem.wrapper.offsetWidth;
  var elementHeight = this.animationItem.wrapper.offsetHeight;
  var elementRel = elementWidth / elementHeight;
  var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
  var sx;
  var sy;
  var tx;
  var ty;
  if (animationRel > elementRel) {
    sx = elementWidth / (this.globalData.compSize.w);
    sy = elementWidth / (this.globalData.compSize.w);
    tx = 0;
    ty = ((elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2);
  } else {
    sx = elementHeight / (this.globalData.compSize.h);
    sy = elementHeight / (this.globalData.compSize.h);
    tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
    ty = 0;
  }
  var style = this.resizerElem.style;
  style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';
  style.transform = style.webkitTransform;
};

HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame;

HybridRenderer.prototype.hide = function () {
  this.resizerElem.style.display = 'none';
};

HybridRenderer.prototype.show = function () {
  this.resizerElem.style.display = 'block';
};

HybridRenderer.prototype.initItems = function () {
  this.buildAllItems();
  if (this.camera) {
    this.camera.setup();
  } else {
    var cWidth = this.globalData.compSize.w;
    var cHeight = this.globalData.compSize.h;
    var i;
    var len = this.threeDElements.length;
    for (i = 0; i < len; i += 1) {
      var style = this.threeDElements[i].perspectiveElem.style;
      style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';
      style.perspective = style.webkitPerspective;
    }
  }
};

HybridRenderer.prototype.searchExtraCompositions = function (assets) {
  var i;
  var len = assets.length;
  var floatingContainer = createTag('div');
  for (i = 0; i < len; i += 1) {
    if (assets[i].xt) {
      var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
      comp.initExpressions();
      this.globalData.projectInterface.registerComposition(comp);
    }
  }
};

/* global createSizedArray, createElementID, PropertyFactory, ShapePropertyFactory, createNS, locationHref */

function MaskElement(data, element, globalData) {
  this.data = data;
  this.element = element;
  this.globalData = globalData;
  this.storedData = [];
  this.masksProperties = this.data.masksProperties || [];
  this.maskElement = null;
  var defs = this.globalData.defs;
  var i;
  var len = this.masksProperties ? this.masksProperties.length : 0;
  this.viewData = createSizedArray(len);
  this.solidPath = '';

  var path;
  var properties = this.masksProperties;
  var count = 0;
  var currentMasks = [];
  var j;
  var jLen;
  var layerId = createElementID();
  var rect;
  var expansor;
  var feMorph;
  var x;
  var maskType = 'clipPath';
  var maskRef = 'clip-path';
  for (i = 0; i < len; i += 1) {
    if ((properties[i].mode !== 'a' && properties[i].mode !== 'n') || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
      maskType = 'mask';
      maskRef = 'mask';
    }

    if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {
      rect = createNS('rect');
      rect.setAttribute('fill', '#ffffff');
      rect.setAttribute('width', this.element.comp.data.w || 0);
      rect.setAttribute('height', this.element.comp.data.h || 0);
      currentMasks.push(rect);
    } else {
      rect = null;
    }

    path = createNS('path');
    if (properties[i].mode === 'n') {
      // TODO move this to a factory or to a constructor
      this.viewData[i] = {
        op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
        prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
        elem: path,
        lastPath: '',
      };
      defs.appendChild(path);
    } else {
      count += 1;

      path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');
      path.setAttribute('clip-rule', 'nonzero');
      var filterID;

      if (properties[i].x.k !== 0) {
        maskType = 'mask';
        maskRef = 'mask';
        x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
        filterID = createElementID();
        expansor = createNS('filter');
        expansor.setAttribute('id', filterID);
        feMorph = createNS('feMorphology');
        feMorph.setAttribute('operator', 'erode');
        feMorph.setAttribute('in', 'SourceGraphic');
        feMorph.setAttribute('radius', '0');
        expansor.appendChild(feMorph);
        defs.appendChild(expansor);
        path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');
      } else {
        feMorph = null;
        x = null;
      }

      // TODO move this to a factory or to a constructor
      this.storedData[i] = {
        elem: path,
        x: x,
        expan: feMorph,
        lastPath: '',
        lastOperator: '',
        filterId: filterID,
        lastRadius: 0,
      };
      if (properties[i].mode === 'i') {
        jLen = currentMasks.length;
        var g = createNS('g');
        for (j = 0; j < jLen; j += 1) {
          g.appendChild(currentMasks[j]);
        }
        var mask = createNS('mask');
        mask.setAttribute('mask-type', 'alpha');
        mask.setAttribute('id', layerId + '_' + count);
        mask.appendChild(path);
        defs.appendChild(mask);
        g.setAttribute('mask', 'url(' + locationHref + '#' + layerId + '_' + count + ')');

        currentMasks.length = 0;
        currentMasks.push(g);
      } else {
        currentMasks.push(path);
      }
      if (properties[i].inv && !this.solidPath) {
        this.solidPath = this.createLayerSolidPath();
      }
      // TODO move this to a factory or to a constructor
      this.viewData[i] = {
        elem: path,
        lastPath: '',
        op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
        prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
        invRect: rect,
      };
      if (!this.viewData[i].prop.k) {
        this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
      }
    }
  }

  this.maskElement = createNS(maskType);

  len = currentMasks.length;
  for (i = 0; i < len; i += 1) {
    this.maskElement.appendChild(currentMasks[i]);
  }

  if (count > 0) {
    this.maskElement.setAttribute('id', layerId);
    this.element.maskedElement.setAttribute(maskRef, 'url(' + locationHref + '#' + layerId + ')');
    defs.appendChild(this.maskElement);
  }
  if (this.viewData.length) {
    this.element.addRenderableComponent(this);
  }
}

MaskElement.prototype.getMaskProperty = function (pos) {
  return this.viewData[pos].prop;
};

MaskElement.prototype.renderFrame = function (isFirstFrame) {
  var finalMat = this.element.finalTransform.mat;
  var i;
  var len = this.masksProperties.length;
  for (i = 0; i < len; i += 1) {
    if (this.viewData[i].prop._mdf || isFirstFrame) {
      this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
    }
    if (this.viewData[i].op._mdf || isFirstFrame) {
      this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);
    }
    if (this.masksProperties[i].mode !== 'n') {
      if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
        this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());
      }
      if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
        var feMorph = this.storedData[i].expan;
        if (this.storedData[i].x.v < 0) {
          if (this.storedData[i].lastOperator !== 'erode') {
            this.storedData[i].lastOperator = 'erode';
            this.storedData[i].elem.setAttribute('filter', 'url(' + locationHref + '#' + this.storedData[i].filterId + ')');
          }
          feMorph.setAttribute('radius', -this.storedData[i].x.v);
        } else {
          if (this.storedData[i].lastOperator !== 'dilate') {
            this.storedData[i].lastOperator = 'dilate';
            this.storedData[i].elem.setAttribute('filter', null);
          }
          this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);
        }
      }
    }
  }
};

MaskElement.prototype.getMaskelement = function () {
  return this.maskElement;
};

MaskElement.prototype.createLayerSolidPath = function () {
  var path = 'M0,0 ';
  path += ' h' + this.globalData.compSize.w;
  path += ' v' + this.globalData.compSize.h;
  path += ' h-' + this.globalData.compSize.w;
  path += ' v-' + this.globalData.compSize.h + ' ';
  return path;
};

MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {
  var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
  var i;
  var len;
  len = pathNodes._length;
  for (i = 1; i < len; i += 1) {
    // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
    pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + ' ' + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];
  }
  // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
  if (pathNodes.c && len > 1) {
    pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + ' ' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
  }
  // pathNodes.__renderedString = pathString;

  if (viewData.lastPath !== pathString) {
    var pathShapeValue = '';
    if (viewData.elem) {
      if (pathNodes.c) {
        pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
      }
      viewData.elem.setAttribute('d', pathShapeValue);
    }
    viewData.lastPath = pathString;
  }
};

MaskElement.prototype.destroy = function () {
  this.element = null;
  this.globalData = null;
  this.maskElement = null;
  this.data = null;
  this.masksProperties = null;
};

/**
 * @file
 * Handles AE's layer parenting property.
 *
 */

function HierarchyElement() {}

HierarchyElement.prototype = {
  /**
     * @function
     * Initializes hierarchy properties
     *
     */
  initHierarchy: function () {
    // element's parent list
    this.hierarchy = [];
    // if element is parent of another layer _isParent will be true
    this._isParent = false;
    this.checkParenting();
  },
  /**
     * @function
     * Sets layer's hierarchy.
     * @param {array} hierarch
     * layer's parent list
     *
     */
  setHierarchy: function (hierarchy) {
    this.hierarchy = hierarchy;
  },
  /**
     * @function
     * Sets layer as parent.
     *
     */
  setAsParent: function () {
    this._isParent = true;
  },
  /**
     * @function
     * Searches layer's parenting chain
     *
     */
  checkParenting: function () {
    if (this.data.parent !== undefined) {
      this.comp.buildElementParenting(this, this.data.parent, []);
    }
  },
};

/**
 * @file
 * Handles element's layer frame update.
 * Checks layer in point and out point
 *
 */

function FrameElement() {}

FrameElement.prototype = {
  /**
     * @function
     * Initializes frame related properties.
     *
     */
  initFrame: function () {
    // set to true when inpoint is rendered
    this._isFirstFrame = false;
    // list of animated properties
    this.dynamicProperties = [];
    // If layer has been modified in current tick this will be true
    this._mdf = false;
  },
  /**
     * @function
     * Calculates all dynamic values
     *
     * @param {number} num
     * current frame number in Layer's time
     * @param {boolean} isVisible
     * if layers is currently in range
     *
     */
  prepareProperties: function (num, isVisible) {
    var i;
    var len = this.dynamicProperties.length;
    for (i = 0; i < len; i += 1) {
      if (isVisible || (this._isParent && this.dynamicProperties[i].propType === 'transform')) {
        this.dynamicProperties[i].getValue();
        if (this.dynamicProperties[i]._mdf) {
          this.globalData._mdf = true;
          this._mdf = true;
        }
      }
    }
  },
  addDynamicProperty: function (prop) {
    if (this.dynamicProperties.indexOf(prop) === -1) {
      this.dynamicProperties.push(prop);
    }
  },
};

/* global TransformPropertyFactory, Matrix */

function TransformElement() {}

TransformElement.prototype = {
  initTransform: function () {
    this.finalTransform = {
      mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : { o: 0 },
      _matMdf: false,
      _opMdf: false,
      mat: new Matrix(),
    };
    if (this.data.ao) {
      this.finalTransform.mProp.autoOriented = true;
    }

    // TODO: check TYPE 11: Guided elements
    if (this.data.ty !== 11) {
      // this.createElements();
    }
  },
  renderTransform: function () {
    this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
    this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;

    if (this.hierarchy) {
      var mat;
      var finalMat = this.finalTransform.mat;
      var i = 0;
      var len = this.hierarchy.length;
      // Checking if any of the transformation matrices in the hierarchy chain has changed.
      if (!this.finalTransform._matMdf) {
        while (i < len) {
          if (this.hierarchy[i].finalTransform.mProp._mdf) {
            this.finalTransform._matMdf = true;
            break;
          }
          i += 1;
        }
      }

      if (this.finalTransform._matMdf) {
        mat = this.finalTransform.mProp.v.props;
        finalMat.cloneFromProps(mat);
        for (i = 0; i < len; i += 1) {
          mat = this.hierarchy[i].finalTransform.mProp.v.props;
          finalMat.transform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
        }
      }
    }
  },
  globalToLocal: function (pt) {
    var transforms = [];
    transforms.push(this.finalTransform);
    var flag = true;
    var comp = this.comp;
    while (flag) {
      if (comp.finalTransform) {
        if (comp.data.hasMask) {
          transforms.splice(0, 0, comp.finalTransform);
        }
        comp = comp.comp;
      } else {
        flag = false;
      }
    }
    var i;
    var len = transforms.length;
    var ptNew;
    for (i = 0; i < len; i += 1) {
      ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);
      // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);
      pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
    }
    return pt;
  },
  mHelper: new Matrix(),
};

function RenderableElement() {

}

RenderableElement.prototype = {
  initRenderable: function () {
    // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
    this.isInRange = false;
    // layer's display state
    this.hidden = false;
    // If layer's transparency equals 0, it can be hidden
    this.isTransparent = false;
    // list of animated components
    this.renderableComponents = [];
  },
  addRenderableComponent: function (component) {
    if (this.renderableComponents.indexOf(component) === -1) {
      this.renderableComponents.push(component);
    }
  },
  removeRenderableComponent: function (component) {
    if (this.renderableComponents.indexOf(component) !== -1) {
      this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
    }
  },
  prepareRenderableFrame: function (num) {
    this.checkLayerLimits(num);
  },
  checkTransparency: function () {
    if (this.finalTransform.mProp.o.v <= 0) {
      if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
        this.isTransparent = true;
        this.hide();
      }
    } else if (this.isTransparent) {
      this.isTransparent = false;
      this.show();
    }
  },
  /**
     * @function
     * Initializes frame related properties.
     *
     * @param {number} num
     * current frame number in Layer's time
     *
     */
  checkLayerLimits: function (num) {
    if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
      if (this.isInRange !== true) {
        this.globalData._mdf = true;
        this._mdf = true;
        this.isInRange = true;
        this.show();
      }
    } else if (this.isInRange !== false) {
      this.globalData._mdf = true;
      this.isInRange = false;
      this.hide();
    }
  },
  renderRenderable: function () {
    var i;
    var len = this.renderableComponents.length;
    for (i = 0; i < len; i += 1) {
      this.renderableComponents[i].renderFrame(this._isFirstFrame);
    }
    /* this.maskManager.renderFrame(this.finalTransform.mat);
        this.renderableEffectsManager.renderFrame(this._isFirstFrame); */
  },
  sourceRectAtTime: function () {
    return {
      top: 0,
      left: 0,
      width: 100,
      height: 100,
    };
  },
  getLayerSize: function () {
    if (this.data.ty === 5) {
      return { w: this.data.textData.width, h: this.data.textData.height };
    }
    return { w: this.data.width, h: this.data.height };
  },
};

/* global extendPrototype, RenderableElement, createProxyFunction */

function RenderableDOMElement() {}

(function () {
  var _prototype = {
    initElement: function (data, globalData, comp) {
      this.initFrame();
      this.initBaseData(data, globalData, comp);
      this.initTransform(data, globalData, comp);
      this.initHierarchy();
      this.initRenderable();
      this.initRendererElement();
      this.createContainerElements();
      this.createRenderableComponents();
      this.createContent();
      this.hide();
    },
    hide: function () {
      if (!this.hidden && (!this.isInRange || this.isTransparent)) {
        var elem = this.baseElement || this.layerElement;
        elem.style.display = 'none';
        this.hidden = true;
      }
    },
    show: function () {
      if (this.isInRange && !this.isTransparent) {
        if (!this.data.hd) {
          var elem = this.baseElement || this.layerElement;
          elem.style.display = 'block';
        }
        this.hidden = false;
        this._isFirstFrame = true;
      }
    },
    renderFrame: function () {
      // If it is exported as hidden (data.hd === true) no need to render
      // If it is not visible no need to render
      if (this.data.hd || this.hidden) {
        return;
      }
      this.renderTransform();
      this.renderRenderable();
      this.renderElement();
      this.renderInnerContent();
      if (this._isFirstFrame) {
        this._isFirstFrame = false;
      }
    },
    renderInnerContent: function () {},
    prepareFrame: function (num) {
      this._mdf = false;
      this.prepareRenderableFrame(num);
      this.prepareProperties(num, this.isInRange);
      this.checkTransparency();
    },
    destroy: function () {
      this.innerElem = null;
      this.destroyBaseElement();
    },
  };
  extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
}());

/* exported ProcessedElement */

function ProcessedElement(element, position) {
  this.elem = element;
  this.pos = position;
}

/* global createNS */

function SVGStyleData(data, level) {
  this.data = data;
  this.type = data.ty;
  this.d = '';
  this.lvl = level;
  this._mdf = false;
  this.closed = data.hd === true;
  this.pElem = createNS('path');
  this.msElem = null;
}

SVGStyleData.prototype.reset = function () {
  this.d = '';
  this._mdf = false;
};

function SVGShapeData(transformers, level, shape) {
  this.caches = [];
  this.styles = [];
  this.transformers = transformers;
  this.lStr = '';
  this.sh = shape;
  this.lvl = level;
  // TODO find if there are some cases where _isAnimated can be false.
  // For now, since shapes add up with other shapes. They have to be calculated every time.
  // One way of finding out is checking if all styles associated to this shape depend only of this shape
  this._isAnimated = !!shape.k;
  // TODO: commenting this for now since all shapes are animated
  var i = 0;
  var len = transformers.length;
  while (i < len) {
    if (transformers[i].mProps.dynamicProperties.length) {
      this._isAnimated = true;
      break;
    }
    i += 1;
  }
}

SVGShapeData.prototype.setAsAnimated = function () {
  this._isAnimated = true;
};

/* exported SVGTransformData */

function SVGTransformData(mProps, op, container) {
  this.transform = {
    mProps: mProps,
    op: op,
    container: container,
  };
  this.elements = [];
  this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
}

/* global DashProperty, PropertyFactory, extendPrototype, DynamicPropertyContainer */

function SVGStrokeStyleData(elem, data, styleOb) {
  this.initDynamicPropertyContainer(elem);
  this.getValue = this.iterateDynamicProperties;
  this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
  this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
  this.d = new DashProperty(elem, data.d || {}, 'svg', this);
  this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
  this.style = styleOb;
  this._isAnimated = !!this._isAnimated;
}

extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);

/* global PropertyFactory, extendPrototype, DynamicPropertyContainer */

function SVGFillStyleData(elem, data, styleOb) {
  this.initDynamicPropertyContainer(elem);
  this.getValue = this.iterateDynamicProperties;
  this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
  this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
  this.style = styleOb;
}

extendPrototype([DynamicPropertyContainer], SVGFillStyleData);

/* global PropertyFactory, degToRads, GradientProperty, createElementID, createNS, locationHref,
extendPrototype, DynamicPropertyContainer */

function SVGGradientFillStyleData(elem, data, styleOb) {
  this.initDynamicPropertyContainer(elem);
  this.getValue = this.iterateDynamicProperties;
  this.initGradientData(elem, data, styleOb);
}

SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {
  this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
  this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
  this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
  this.h = PropertyFactory.getProp(elem, data.h || { k: 0 }, 0, 0.01, this);
  this.a = PropertyFactory.getProp(elem, data.a || { k: 0 }, 0, degToRads, this);
  this.g = new GradientProperty(elem, data.g, this);
  this.style = styleOb;
  this.stops = [];
  this.setGradientData(styleOb.pElem, data);
  this.setGradientOpacity(data, styleOb);
  this._isAnimated = !!this._isAnimated;
};

SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {
  var gradientId = createElementID();
  var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
  gfill.setAttribute('id', gradientId);
  gfill.setAttribute('spreadMethod', 'pad');
  gfill.setAttribute('gradientUnits', 'userSpaceOnUse');
  var stops = [];
  var stop;
  var j;
  var jLen;
  jLen = data.g.p * 4;
  for (j = 0; j < jLen; j += 4) {
    stop = createNS('stop');
    gfill.appendChild(stop);
    stops.push(stop);
  }
  pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + locationHref + '#' + gradientId + ')');

  this.gf = gfill;
  this.cst = stops;
};

SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {
  if (this.g._hasOpacity && !this.g._collapsable) {
    var stop;
    var j;
    var jLen;
    var mask = createNS('mask');
    var maskElement = createNS('path');
    mask.appendChild(maskElement);
    var opacityId = createElementID();
    var maskId = createElementID();
    mask.setAttribute('id', maskId);
    var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
    opFill.setAttribute('id', opacityId);
    opFill.setAttribute('spreadMethod', 'pad');
    opFill.setAttribute('gradientUnits', 'userSpaceOnUse');
    jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
    var stops = this.stops;
    for (j = data.g.p * 4; j < jLen; j += 2) {
      stop = createNS('stop');
      stop.setAttribute('stop-color', 'rgb(255,255,255)');
      opFill.appendChild(stop);
      stops.push(stop);
    }
    maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + locationHref + '#' + opacityId + ')');
    this.of = opFill;
    this.ms = mask;
    this.ost = stops;
    this.maskId = maskId;
    styleOb.msElem = maskElement;
  }
};

extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);

/* global PropertyFactory, DashProperty, extendPrototype, SVGGradientFillStyleData, DynamicPropertyContainer */

function SVGGradientStrokeStyleData(elem, data, styleOb) {
  this.initDynamicPropertyContainer(elem);
  this.getValue = this.iterateDynamicProperties;
  this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
  this.d = new DashProperty(elem, data.d || {}, 'svg', this);
  this.initGradientData(elem, data, styleOb);
  this._isAnimated = !!this._isAnimated;
}

extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);

/* global createNS */
/* exported ShapeGroupData */

function ShapeGroupData() {
  this.it = [];
  this.prevViewData = [];
  this.gr = createNS('g');
}

/* global Matrix, buildShapeString, bmFloor */
/* exported SVGElementsRenderer */

var SVGElementsRenderer = (function () {
  var _identityMatrix = new Matrix();
  var _matrixHelper = new Matrix();

  var ob = {
    createRenderFunction: createRenderFunction,
  };

  function createRenderFunction(data) {
    switch (data.ty) {
      case 'fl':
        return renderFill;
      case 'gf':
        return renderGradient;
      case 'gs':
        return renderGradientStroke;
      case 'st':
        return renderStroke;
      case 'sh':
      case 'el':
      case 'rc':
      case 'sr':
        return renderPath;
      case 'tr':
        return renderContentTransform;
      default:
        return null;
    }
  }

  function renderContentTransform(styleData, itemData, isFirstFrame) {
    if (isFirstFrame || itemData.transform.op._mdf) {
      itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);
    }
    if (isFirstFrame || itemData.transform.mProps._mdf) {
      itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());
    }
  }

  function renderPath(styleData, itemData, isFirstFrame) {
    var j;
    var jLen;
    var pathStringTransformed;
    var redraw;
    var pathNodes;
    var l;
    var lLen = itemData.styles.length;
    var lvl = itemData.lvl;
    var paths;
    var mat;
    var props;
    var iterations;
    var k;
    for (l = 0; l < lLen; l += 1) {
      redraw = itemData.sh._mdf || isFirstFrame;
      if (itemData.styles[l].lvl < lvl) {
        mat = _matrixHelper.reset();
        iterations = lvl - itemData.styles[l].lvl;
        k = itemData.transformers.length - 1;
        while (!redraw && iterations > 0) {
          redraw = itemData.transformers[k].mProps._mdf || redraw;
          iterations -= 1;
          k -= 1;
        }
        if (redraw) {
          iterations = lvl - itemData.styles[l].lvl;
          k = itemData.transformers.length - 1;
          while (iterations > 0) {
            props = itemData.transformers[k].mProps.v.props;
            mat.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
            iterations -= 1;
            k -= 1;
          }
        }
      } else {
        mat = _identityMatrix;
      }
      paths = itemData.sh.paths;
      jLen = paths._length;
      if (redraw) {
        pathStringTransformed = '';
        for (j = 0; j < jLen; j += 1) {
          pathNodes = paths.shapes[j];
          if (pathNodes && pathNodes._length) {
            pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
          }
        }
        itemData.caches[l] = pathStringTransformed;
      } else {
        pathStringTransformed = itemData.caches[l];
      }
      itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;
      itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
    }
  }

  function renderFill(styleData, itemData, isFirstFrame) {
    var styleElem = itemData.style;

    if (itemData.c._mdf || isFirstFrame) {
      styleElem.pElem.setAttribute('fill', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
    }
    if (itemData.o._mdf || isFirstFrame) {
      styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);
    }
  }

  function renderGradientStroke(styleData, itemData, isFirstFrame) {
    renderGradient(styleData, itemData, isFirstFrame);
    renderStroke(styleData, itemData, isFirstFrame);
  }

  function renderGradient(styleData, itemData, isFirstFrame) {
    var gfill = itemData.gf;
    var hasOpacity = itemData.g._hasOpacity;
    var pt1 = itemData.s.v;
    var pt2 = itemData.e.v;

    if (itemData.o._mdf || isFirstFrame) {
      var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';
      itemData.style.pElem.setAttribute(attr, itemData.o.v);
    }
    if (itemData.s._mdf || isFirstFrame) {
      var attr1 = styleData.t === 1 ? 'x1' : 'cx';
      var attr2 = attr1 === 'x1' ? 'y1' : 'cy';
      gfill.setAttribute(attr1, pt1[0]);
      gfill.setAttribute(attr2, pt1[1]);
      if (hasOpacity && !itemData.g._collapsable) {
        itemData.of.setAttribute(attr1, pt1[0]);
        itemData.of.setAttribute(attr2, pt1[1]);
      }
    }
    var stops;
    var i;
    var len;
    var stop;
    if (itemData.g._cmdf || isFirstFrame) {
      stops = itemData.cst;
      var cValues = itemData.g.c;
      len = stops.length;
      for (i = 0; i < len; i += 1) {
        stop = stops[i];
        stop.setAttribute('offset', cValues[i * 4] + '%');
        stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');
      }
    }
    if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
      var oValues = itemData.g.o;
      if (itemData.g._collapsable) {
        stops = itemData.cst;
      } else {
        stops = itemData.ost;
      }
      len = stops.length;
      for (i = 0; i < len; i += 1) {
        stop = stops[i];
        if (!itemData.g._collapsable) {
          stop.setAttribute('offset', oValues[i * 2] + '%');
        }
        stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);
      }
    }
    if (styleData.t === 1) {
      if (itemData.e._mdf || isFirstFrame) {
        gfill.setAttribute('x2', pt2[0]);
        gfill.setAttribute('y2', pt2[1]);
        if (hasOpacity && !itemData.g._collapsable) {
          itemData.of.setAttribute('x2', pt2[0]);
          itemData.of.setAttribute('y2', pt2[1]);
        }
      }
    } else {
      var rad;
      if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
        rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
        gfill.setAttribute('r', rad);
        if (hasOpacity && !itemData.g._collapsable) {
          itemData.of.setAttribute('r', rad);
        }
      }
      if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
        if (!rad) {
          rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
        }
        var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);

        var percent = itemData.h.v;
        if (percent >= 1) {
          percent = 0.99;
        } else if (percent <= -1) {
          percent = -0.99;
        }
        var dist = rad * percent;
        var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
        var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
        gfill.setAttribute('fx', x);
        gfill.setAttribute('fy', y);
        if (hasOpacity && !itemData.g._collapsable) {
          itemData.of.setAttribute('fx', x);
          itemData.of.setAttribute('fy', y);
        }
      }
      // gfill.setAttribute('fy','200');
    }
  }

  function renderStroke(styleData, itemData, isFirstFrame) {
    var styleElem = itemData.style;
    var d = itemData.d;
    if (d && (d._mdf || isFirstFrame) && d.dashStr) {
      styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);
      styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);
    }
    if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
      styleElem.pElem.setAttribute('stroke', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
    }
    if (itemData.o._mdf || isFirstFrame) {
      styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);
    }
    if (itemData.w._mdf || isFirstFrame) {
      styleElem.pElem.setAttribute('stroke-width', itemData.w.v);
      if (styleElem.msElem) {
        styleElem.msElem.setAttribute('stroke-width', itemData.w.v);
      }
    }
  }

  return ob;
}());

/* global Matrix */

function ShapeTransformManager() {
  this.sequences = {};
  this.sequenceList = [];
  this.transform_key_count = 0;
}

ShapeTransformManager.prototype = {
  addTransformSequence: function (transforms) {
    var i;
    var len = transforms.length;
    var key = '_';
    for (i = 0; i < len; i += 1) {
      key += transforms[i].transform.key + '_';
    }
    var sequence = this.sequences[key];
    if (!sequence) {
      sequence = {
        transforms: [].concat(transforms),
        finalTransform: new Matrix(),
        _mdf: false,
      };
      this.sequences[key] = sequence;
      this.sequenceList.push(sequence);
    }
    return sequence;
  },
  processSequence: function (sequence, isFirstFrame) {
    var i = 0;
    var len = sequence.transforms.length;
    var _mdf = isFirstFrame;
    while (i < len && !isFirstFrame) {
      if (sequence.transforms[i].transform.mProps._mdf) {
        _mdf = true;
        break;
      }
      i += 1;
    }
    if (_mdf) {
      var props;
      sequence.finalTransform.reset();
      for (i = len - 1; i >= 0; i -= 1) {
        props = sequence.transforms[i].transform.mProps.v.props;
        sequence.finalTransform.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
      }
    }
    sequence._mdf = _mdf;
  },
  processSequences: function (isFirstFrame) {
    var i;
    var len = this.sequenceList.length;
    for (i = 0; i < len; i += 1) {
      this.processSequence(this.sequenceList[i], isFirstFrame);
    }
  },
  getNewKey: function () {
    this.transform_key_count += 1;
    return '_' + this.transform_key_count;
  },
};

/* global ShapePropertyFactory, SVGShapeData */

function CVShapeData(element, data, styles, transformsManager) {
  this.styledShapes = [];
  this.tr = [0, 0, 0, 0, 0, 0];
  var ty = 4;
  if (data.ty === 'rc') {
    ty = 5;
  } else if (data.ty === 'el') {
    ty = 6;
  } else if (data.ty === 'sr') {
    ty = 7;
  }
  this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
  var i;
  var len = styles.length;
  var styledShape;
  for (i = 0; i < len; i += 1) {
    if (!styles[i].closed) {
      styledShape = {
        transforms: transformsManager.addTransformSequence(styles[i].transforms),
        trNodes: [],
      };
      this.styledShapes.push(styledShape);
      styles[i].elements.push(styledShape);
    }
  }
}

CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;

/* global LayerExpressionInterface, EffectsExpressionInterface, CompExpressionInterface, ShapeExpressionInterface,
TextExpressionInterface, getBlendMode,createElementID, EffectsManager */

function BaseElement() {
}

BaseElement.prototype = {
  checkMasks: function () {
    if (!this.data.hasMask) {
      return false;
    }
    var i = 0;
    var len = this.data.masksProperties.length;
    while (i < len) {
      if ((this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false)) {
        return true;
      }
      i += 1;
    }
    return false;
  },
  initExpressions: function () {
    this.layerInterface = LayerExpressionInterface(this);
    if (this.data.hasMask && this.maskManager) {
      this.layerInterface.registerMaskInterface(this.maskManager);
    }
    var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
    this.layerInterface.registerEffectsInterface(effectsInterface);

    if (this.data.ty === 0 || this.data.xt) {
      this.compInterface = CompExpressionInterface(this);
    } else if (this.data.ty === 4) {
      this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
      this.layerInterface.content = this.layerInterface.shapeInterface;
    } else if (this.data.ty === 5) {
      this.layerInterface.textInterface = TextExpressionInterface(this);
      this.layerInterface.text = this.layerInterface.textInterface;
    }
  },
  setBlendMode: function () {
    var blendModeValue = getBlendMode(this.data.bm);
    var elem = this.baseElement || this.layerElement;

    elem.style['mix-blend-mode'] = blendModeValue;
  },
  initBaseData: function (data, globalData, comp) {
    this.globalData = globalData;
    this.comp = comp;
    this.data = data;
    this.layerId = createElementID();

    // Stretch factor for old animations missing this property.
    if (!this.data.sr) {
      this.data.sr = 1;
    }
    // effects manager
    this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
  },
  getType: function () {
    return this.type;
  },
  sourceRectAtTime: function () {},
};

/* global extendPrototype, BaseElement, TransformElement, HierarchyElement, FrameElement */

function NullElement(data, globalData, comp) {
  this.initFrame();
  this.initBaseData(data, globalData, comp);
  this.initFrame();
  this.initTransform(data, globalData, comp);
  this.initHierarchy();
}

NullElement.prototype.prepareFrame = function (num) {
  this.prepareProperties(num, true);
};

NullElement.prototype.renderFrame = function () {
};

NullElement.prototype.getBaseElement = function () {
  return null;
};

NullElement.prototype.destroy = function () {
};

NullElement.prototype.sourceRectAtTime = function () {
};

NullElement.prototype.hide = function () {
};

extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);

/* global filtersFactory, featureSupport, filtersFactory, createElementID, createNS, MaskElement, SVGEffects, locationHref */

function SVGBaseElement() {
}

SVGBaseElement.prototype = {
  initRendererElement: function () {
    this.layerElement = createNS('g');
  },
  createContainerElements: function () {
    this.matteElement = createNS('g');
    this.transformedElement = this.layerElement;
    this.maskedElement = this.layerElement;
    this._sizeChanged = false;
    var layerElementParent = null;
    // If this layer acts as a mask for the following layer
    var filId;
    var fil;
    var gg;
    if (this.data.td) {
      if (this.data.td == 3 || this.data.td == 1) { // eslint-disable-line eqeqeq
        var masker = createNS('mask');
        masker.setAttribute('id', this.layerId);
        masker.setAttribute('mask-type', this.data.td == 3 ? 'luminance' : 'alpha'); // eslint-disable-line eqeqeq
        masker.appendChild(this.layerElement);
        layerElementParent = masker;
        this.globalData.defs.appendChild(masker);
        // This is only for IE and Edge when mask if of type alpha
        if (!featureSupport.maskType && this.data.td == 1) { // eslint-disable-line eqeqeq
          masker.setAttribute('mask-type', 'luminance');
          filId = createElementID();
          fil = filtersFactory.createFilter(filId);
          this.globalData.defs.appendChild(fil);
          fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
          gg = createNS('g');
          gg.appendChild(this.layerElement);
          layerElementParent = gg;
          masker.appendChild(gg);
          gg.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
        }
      } else if (this.data.td == 2) { // eslint-disable-line eqeqeq
        var maskGroup = createNS('mask');
        maskGroup.setAttribute('id', this.layerId);
        maskGroup.setAttribute('mask-type', 'alpha');
        var maskGrouper = createNS('g');
        maskGroup.appendChild(maskGrouper);
        filId = createElementID();
        fil = filtersFactory.createFilter(filId);
        /// /

        // This solution doesn't work on Android when meta tag with viewport attribute is set
        /* var feColorMatrix = createNS('feColorMatrix');
                feColorMatrix.setAttribute('type', 'matrix');
                feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
                feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');
                fil.appendChild(feColorMatrix); */
        /// /
        var feCTr = createNS('feComponentTransfer');
        feCTr.setAttribute('in', 'SourceGraphic');
        fil.appendChild(feCTr);
        var feFunc = createNS('feFuncA');
        feFunc.setAttribute('type', 'table');
        feFunc.setAttribute('tableValues', '1.0 0.0');
        feCTr.appendChild(feFunc);
        /// /
        this.globalData.defs.appendChild(fil);
        var alphaRect = createNS('rect');
        alphaRect.setAttribute('width', this.comp.data.w);
        alphaRect.setAttribute('height', this.comp.data.h);
        alphaRect.setAttribute('x', '0');
        alphaRect.setAttribute('y', '0');
        alphaRect.setAttribute('fill', '#ffffff');
        alphaRect.setAttribute('opacity', '0');
        maskGrouper.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
        maskGrouper.appendChild(alphaRect);
        maskGrouper.appendChild(this.layerElement);
        layerElementParent = maskGrouper;
        if (!featureSupport.maskType) {
          maskGroup.setAttribute('mask-type', 'luminance');
          fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
          gg = createNS('g');
          maskGrouper.appendChild(alphaRect);
          gg.appendChild(this.layerElement);
          layerElementParent = gg;
          maskGrouper.appendChild(gg);
        }
        this.globalData.defs.appendChild(maskGroup);
      }
    } else if (this.data.tt) {
      this.matteElement.appendChild(this.layerElement);
      layerElementParent = this.matteElement;
      this.baseElement = this.matteElement;
    } else {
      this.baseElement = this.layerElement;
    }
    if (this.data.ln) {
      this.layerElement.setAttribute('id', this.data.ln);
    }
    if (this.data.cl) {
      this.layerElement.setAttribute('class', this.data.cl);
    }
    // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped
    if (this.data.ty === 0 && !this.data.hd) {
      var cp = createNS('clipPath');
      var pt = createNS('path');
      pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');
      var clipId = createElementID();
      cp.setAttribute('id', clipId);
      cp.appendChild(pt);
      this.globalData.defs.appendChild(cp);

      if (this.checkMasks()) {
        var cpGroup = createNS('g');
        cpGroup.setAttribute('clip-path', 'url(' + locationHref + '#' + clipId + ')');
        cpGroup.appendChild(this.layerElement);
        this.transformedElement = cpGroup;
        if (layerElementParent) {
          layerElementParent.appendChild(this.transformedElement);
        } else {
          this.baseElement = this.transformedElement;
        }
      } else {
        this.layerElement.setAttribute('clip-path', 'url(' + locationHref + '#' + clipId + ')');
      }
    }
    if (this.data.bm !== 0) {
      this.setBlendMode();
    }
  },
  renderElement: function () {
    if (this.finalTransform._matMdf) {
      this.transformedElement.setAttribute('transform', this.finalTransform.mat.to2dCSS());
    }
    if (this.finalTransform._opMdf) {
      this.transformedElement.setAttribute('opacity', this.finalTransform.mProp.o.v);
    }
  },
  destroyBaseElement: function () {
    this.layerElement = null;
    this.matteElement = null;
    this.maskManager.destroy();
  },
  getBaseElement: function () {
    if (this.data.hd) {
      return null;
    }
    return this.baseElement;
  },
  createRenderableComponents: function () {
    this.maskManager = new MaskElement(this.data, this, this.globalData);
    this.renderableEffectsManager = new SVGEffects(this);
  },
  setMatte: function (id) {
    if (!this.matteElement) {
      return;
    }
    this.matteElement.setAttribute('mask', 'url(' + locationHref + '#' + id + ')');
  },
};

/* global ProcessedElement */

function IShapeElement() {
}

IShapeElement.prototype = {
  addShapeToModifiers: function (data) {
    var i;
    var len = this.shapeModifiers.length;
    for (i = 0; i < len; i += 1) {
      this.shapeModifiers[i].addShape(data);
    }
  },
  isShapeInAnimatedModifiers: function (data) {
    var i = 0;
    var len = this.shapeModifiers.length;
    while (i < len) {
      if (this.shapeModifiers[i].isAnimatedWithShape(data)) {
        return true;
      }
    }
    return false;
  },
  renderModifiers: function () {
    if (!this.shapeModifiers.length) {
      return;
    }
    var i;
    var len = this.shapes.length;
    for (i = 0; i < len; i += 1) {
      this.shapes[i].sh.reset();
    }

    len = this.shapeModifiers.length;
    var shouldBreakProcess;
    for (i = len - 1; i >= 0; i -= 1) {
      shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame);
      // workaround to fix cases where a repeater resets the shape so the following processes get called twice
      // TODO: find a better solution for this
      if (shouldBreakProcess) {
        break;
      }
    }
  },
  lcEnum: {
    1: 'butt',
    2: 'round',
    3: 'square',
  },
  ljEnum: {
    1: 'miter',
    2: 'round',
    3: 'bevel',
  },
  searchProcessedElement: function (elem) {
    var elements = this.processedElements;
    var i = 0;
    var len = elements.length;
    while (i < len) {
      if (elements[i].elem === elem) {
        return elements[i].pos;
      }
      i += 1;
    }
    return 0;
  },
  addProcessedElement: function (elem, pos) {
    var elements = this.processedElements;
    var i = elements.length;
    while (i) {
      i -= 1;
      if (elements[i].elem === elem) {
        elements[i].pos = pos;
        return;
      }
    }
    elements.push(new ProcessedElement(elem, pos));
  },
  prepareFrame: function (num) {
    this.prepareRenderableFrame(num);
    this.prepareProperties(num, this.isInRange);
  },
};

/* global TextProperty, TextAnimatorProperty, buildShapeString, LetterProps */

function ITextElement() {
}

ITextElement.prototype.initElement = function (data, globalData, comp) {
  this.lettersChangedFlag = true;
  this.initFrame();
  this.initBaseData(data, globalData, comp);
  this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
  this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
  this.initTransform(data, globalData, comp);
  this.initHierarchy();
  this.initRenderable();
  this.initRendererElement();
  this.createContainerElements();
  this.createRenderableComponents();
  this.createContent();
  this.hide();
  this.textAnimator.searchProperties(this.dynamicProperties);
};

ITextElement.prototype.prepareFrame = function (num) {
  this._mdf = false;
  this.prepareRenderableFrame(num);
  this.prepareProperties(num, this.isInRange);
  if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
    this.buildNewText();
    this.textProperty._isFirstFrame = false;
    this.textProperty._mdf = false;
  }
};

ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {
  var j;
  var jLen = shapes.length;
  var pathNodes;
  var shapeStr = '';
  for (j = 0; j < jLen; j += 1) {
    pathNodes = shapes[j].ks.k;
    shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
  }
  return shapeStr;
};

ITextElement.prototype.updateDocumentData = function (newData, index) {
  this.textProperty.updateDocumentData(newData, index);
};

ITextElement.prototype.canResizeFont = function (_canResize) {
  this.textProperty.canResizeFont(_canResize);
};

ITextElement.prototype.setMinimumFontSize = function (_fontSize) {
  this.textProperty.setMinimumFontSize(_fontSize);
};

ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {
  if (documentData.ps) {
    matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
  }
  matrixHelper.translate(0, -documentData.ls, 0);
  switch (documentData.j) {
    case 1:
      matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
      break;
    case 2:
      matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
      break;
    default:
      break;
  }
  matrixHelper.translate(xPos, yPos, 0);
};

ITextElement.prototype.buildColor = function (colorData) {
  return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';
};

ITextElement.prototype.emptyProp = new LetterProps();

ITextElement.prototype.destroy = function () {

};

/* global extendPrototype, BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement */

function ICompElement() {}

extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);

ICompElement.prototype.initElement = function (data, globalData, comp) {
  this.initFrame();
  this.initBaseData(data, globalData, comp);
  this.initTransform(data, globalData, comp);
  this.initRenderable();
  this.initHierarchy();
  this.initRendererElement();
  this.createContainerElements();
  this.createRenderableComponents();
  if (this.data.xt || !globalData.progressiveLoad) {
    this.buildAllItems();
  }
  this.hide();
};

/* ICompElement.prototype.hide = function(){
    if(!this.hidden){
        this.hideElement();
        var i,len = this.elements.length;
        for( i = 0; i < len; i+=1 ){
            if(this.elements[i]){
                this.elements[i].hide();
            }
        }
    }
}; */

ICompElement.prototype.prepareFrame = function (num) {
  this._mdf = false;
  this.prepareRenderableFrame(num);
  this.prepareProperties(num, this.isInRange);
  if (!this.isInRange && !this.data.xt) {
    return;
  }

  if (!this.tm._placeholder) {
    var timeRemapped = this.tm.v;
    if (timeRemapped === this.data.op) {
      timeRemapped = this.data.op - 1;
    }
    this.renderedFrame = timeRemapped;
  } else {
    this.renderedFrame = num / this.data.sr;
  }
  var i;
  var len = this.elements.length;
  if (!this.completeLayers) {
    this.checkLayers(this.renderedFrame);
  }
  // This iteration needs to be backwards because of how expressions connect between each other
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.completeLayers || this.elements[i]) {
      this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
      if (this.elements[i]._mdf) {
        this._mdf = true;
      }
    }
  }
};

ICompElement.prototype.renderInnerContent = function () {
  var i;
  var len = this.layers.length;
  for (i = 0; i < len; i += 1) {
    if (this.completeLayers || this.elements[i]) {
      this.elements[i].renderFrame();
    }
  }
};

ICompElement.prototype.setElements = function (elems) {
  this.elements = elems;
};

ICompElement.prototype.getElements = function () {
  return this.elements;
};

ICompElement.prototype.destroyElements = function () {
  var i;
  var len = this.layers.length;
  for (i = 0; i < len; i += 1) {
    if (this.elements[i]) {
      this.elements[i].destroy();
    }
  }
};

ICompElement.prototype.destroy = function () {
  this.destroyElements();
  this.destroyBaseElement();
};

/* global extendPrototype, BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, createNS */

function IImageElement(data, globalData, comp) {
  this.assetData = globalData.getAssetData(data.refId);
  this.initElement(data, globalData, comp);
  this.sourceRect = {
    top: 0, left: 0, width: this.assetData.w, height: this.assetData.h,
  };
}

extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);

IImageElement.prototype.createContent = function () {
  var assetPath = this.globalData.getAssetsPath(this.assetData);

  this.innerElem = createNS('image');
  this.innerElem.setAttribute('width', this.assetData.w + 'px');
  this.innerElem.setAttribute('height', this.assetData.h + 'px');
  this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
  this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);

  this.layerElement.appendChild(this.innerElem);
};

IImageElement.prototype.sourceRectAtTime = function () {
  return this.sourceRect;
};

/* global extendPrototype, IImageElement, createNS */

function ISolidElement(data, globalData, comp) {
  this.initElement(data, globalData, comp);
}
extendPrototype([IImageElement], ISolidElement);

ISolidElement.prototype.createContent = function () {
  var rect = createNS('rect');
  /// /rect.style.width = this.data.sw;
  /// /rect.style.height = this.data.sh;
  /// /rect.style.fill = this.data.sc;
  rect.setAttribute('width', this.data.sw);
  rect.setAttribute('height', this.data.sh);
  rect.setAttribute('fill', this.data.sc);
  this.layerElement.appendChild(rect);
};

/* global PropertyFactory, extendPrototype, RenderableElement, BaseElement, FrameElement */

function AudioElement(data, globalData, comp) {
  this.initFrame();
  this.initRenderable();
  this.assetData = globalData.getAssetData(data.refId);
  this.initBaseData(data, globalData, comp);
  this._isPlaying = false;
  this._canPlay = false;
  var assetPath = this.globalData.getAssetsPath(this.assetData);
  this.audio = this.globalData.audioController.createAudio(assetPath);
  this._currentTime = 0;
  this.globalData.audioController.addAudio(this);
  this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
}

AudioElement.prototype.prepareFrame = function (num) {
  this.prepareRenderableFrame(num, true);
  this.prepareProperties(num, true);
  if (!this.tm._placeholder) {
    var timeRemapped = this.tm.v;
    this._currentTime = timeRemapped;
  } else {
    this._currentTime = num / this.data.sr;
  }
};

extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);

AudioElement.prototype.renderFrame = function () {
  if (this.isInRange && this._canPlay) {
    if (!this._isPlaying) {
      this.audio.play();
      this.audio.seek(this._currentTime / this.globalData.frameRate);
      this._isPlaying = true;
    } else if (!this.audio.playing()
      || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1
    ) {
      this.audio.seek(this._currentTime / this.globalData.frameRate);
    }
  }
};

AudioElement.prototype.show = function () {
  // this.audio.play()
};

AudioElement.prototype.hide = function () {
  this.audio.pause();
  this._isPlaying = false;
};

AudioElement.prototype.pause = function () {
  this.audio.pause();
  this._isPlaying = false;
  this._canPlay = false;
};

AudioElement.prototype.resume = function () {
  this._canPlay = true;
};

AudioElement.prototype.setRate = function (rateValue) {
  this.audio.rate(rateValue);
};

AudioElement.prototype.volume = function (volumeValue) {
  this.audio.volume(volumeValue);
};

AudioElement.prototype.getBaseElement = function () {
  return null;
};

AudioElement.prototype.destroy = function () {
};

AudioElement.prototype.sourceRectAtTime = function () {
};

AudioElement.prototype.initExpressions = function () {
};

/* global extendPrototype, RenderableElement, BaseElement, FrameElement, FootageInterface */

function FootageElement(data, globalData, comp) {
  this.initFrame();
  this.initRenderable();
  this.assetData = globalData.getAssetData(data.refId);
  this.footageData = globalData.imageLoader.getAsset(this.assetData);
  this.initBaseData(data, globalData, comp);
}

FootageElement.prototype.prepareFrame = function () {
};

extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);

FootageElement.prototype.getBaseElement = function () {
  return null;
};

FootageElement.prototype.renderFrame = function () {
};

FootageElement.prototype.destroy = function () {
};

FootageElement.prototype.initExpressions = function () {
  this.layerInterface = FootageInterface(this);
};

FootageElement.prototype.getFootageData = function () {
  return this.footageData;
};

/* global createSizedArray, PropertyFactory, extendPrototype, SVGRenderer, ICompElement, SVGBaseElement */

function SVGCompElement(data, globalData, comp) {
  this.layers = data.layers;
  this.supports3d = true;
  this.completeLayers = false;
  this.pendingElements = [];
  this.elements = this.layers ? createSizedArray(this.layers.length) : [];
  // this.layerElement = createNS('g');
  this.initElement(data, globalData, comp);
  this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
}

extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement);

/* global extendPrototype, BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement,
RenderableDOMElement, ITextElement, createSizedArray, createNS */

function SVGTextLottieElement(data, globalData, comp) {
  this.textSpans = [];
  this.renderType = 'svg';
  this.initElement(data, globalData, comp);
}

extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);

SVGTextLottieElement.prototype.createContent = function () {
  if (this.data.singleShape && !this.globalData.fontManager.chars) {
    this.textContainer = createNS('text');
  }
};

SVGTextLottieElement.prototype.buildTextContents = function (textArray) {
  var i = 0;
  var len = textArray.length;
  var textContents = [];
  var currentTextContent = '';
  while (i < len) {
    if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
      textContents.push(currentTextContent);
      currentTextContent = '';
    } else {
      currentTextContent += textArray[i];
    }
    i += 1;
  }
  textContents.push(currentTextContent);
  return textContents;
};

SVGTextLottieElement.prototype.buildNewText = function () {
  var i;
  var len;

  var documentData = this.textProperty.currentData;
  this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
  if (documentData.fc) {
    this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
  } else {
    this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
  }
  if (documentData.sc) {
    this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
    this.layerElement.setAttribute('stroke-width', documentData.sw);
  }
  this.layerElement.setAttribute('font-size', documentData.finalSize);
  var fontData = this.globalData.fontManager.getFontByName(documentData.f);
  if (fontData.fClass) {
    this.layerElement.setAttribute('class', fontData.fClass);
  } else {
    this.layerElement.setAttribute('font-family', fontData.fFamily);
    var fWeight = documentData.fWeight;
    var fStyle = documentData.fStyle;
    this.layerElement.setAttribute('font-style', fStyle);
    this.layerElement.setAttribute('font-weight', fWeight);
  }
  this.layerElement.setAttribute('aria-label', documentData.t);

  var letters = documentData.l || [];
  var usesGlyphs = !!this.globalData.fontManager.chars;
  len = letters.length;

  var tSpan;
  var matrixHelper = this.mHelper;
  var shapes;
  var shapeStr = '';
  var singleShape = this.data.singleShape;
  var xPos = 0;
  var yPos = 0;
  var firstLine = true;
  var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
  if (singleShape && !usesGlyphs && !documentData.sz) {
    var tElement = this.textContainer;
    var justify = 'start';
    switch (documentData.j) {
      case 1:
        justify = 'end';
        break;
      case 2:
        justify = 'middle';
        break;
      default:
        justify = 'start';
        break;
    }
    tElement.setAttribute('text-anchor', justify);
    tElement.setAttribute('letter-spacing', trackingOffset);
    var textContent = this.buildTextContents(documentData.finalText);
    len = textContent.length;
    yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
    for (i = 0; i < len; i += 1) {
      tSpan = this.textSpans[i] || createNS('tspan');
      tSpan.textContent = textContent[i];
      tSpan.setAttribute('x', 0);
      tSpan.setAttribute('y', yPos);
      tSpan.style.display = 'inherit';
      tElement.appendChild(tSpan);
      this.textSpans[i] = tSpan;
      yPos += documentData.finalLineHeight;
    }

    this.layerElement.appendChild(tElement);
  } else {
    var cachedSpansLength = this.textSpans.length;
    var shapeData;
    var charData;
    for (i = 0; i < len; i += 1) {
      if (!usesGlyphs || !singleShape || i === 0) {
        tSpan = cachedSpansLength > i ? this.textSpans[i] : createNS(usesGlyphs ? 'path' : 'text');
        if (cachedSpansLength <= i) {
          tSpan.setAttribute('stroke-linecap', 'butt');
          tSpan.setAttribute('stroke-linejoin', 'round');
          tSpan.setAttribute('stroke-miterlimit', '4');
          this.textSpans[i] = tSpan;
          this.layerElement.appendChild(tSpan);
        }
        tSpan.style.display = 'inherit';
      }

      matrixHelper.reset();
      matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
      if (singleShape) {
        if (letters[i].n) {
          xPos = -trackingOffset;
          yPos += documentData.yOffset;
          yPos += firstLine ? 1 : 0;
          firstLine = false;
        }
        this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
        xPos += letters[i].l || 0;
        // xPos += letters[i].val === ' ' ? 0 : trackingOffset;
        xPos += trackingOffset;
      }
      if (usesGlyphs) {
        charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
        shapeData = (charData && charData.data) || {};
        shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
        if (!singleShape) {
          tSpan.setAttribute('d', this.createPathShape(matrixHelper, shapes));
        } else {
          shapeStr += this.createPathShape(matrixHelper, shapes);
        }
      } else {
        if (singleShape) {
          tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')');
        }
        tSpan.textContent = letters[i].val;
        tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
      }
      //
    }
    if (singleShape && tSpan) {
      tSpan.setAttribute('d', shapeStr);
    }
  }
  while (i < this.textSpans.length) {
    this.textSpans[i].style.display = 'none';
    i += 1;
  }

  this._sizeChanged = true;
};

SVGTextLottieElement.prototype.sourceRectAtTime = function () {
  this.prepareFrame(this.comp.renderedFrame - this.data.st);
  this.renderInnerContent();
  if (this._sizeChanged) {
    this._sizeChanged = false;
    var textBox = this.layerElement.getBBox();
    this.bbox = {
      top: textBox.y,
      left: textBox.x,
      width: textBox.width,
      height: textBox.height,
    };
  }
  return this.bbox;
};

SVGTextLottieElement.prototype.renderInnerContent = function () {
  if (!this.data.singleShape) {
    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
    if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
      this._sizeChanged = true;
      var i;
      var len;
      var renderedLetters = this.textAnimator.renderedLetters;

      var letters = this.textProperty.currentData.l;

      len = letters.length;
      var renderedLetter;
      var textSpan;
      for (i = 0; i < len; i += 1) {
        if (!letters[i].n) {
          renderedLetter = renderedLetters[i];
          textSpan = this.textSpans[i];
          if (renderedLetter._mdf.m) {
            textSpan.setAttribute('transform', renderedLetter.m);
          }
          if (renderedLetter._mdf.o) {
            textSpan.setAttribute('opacity', renderedLetter.o);
          }
          if (renderedLetter._mdf.sw) {
            textSpan.setAttribute('stroke-width', renderedLetter.sw);
          }
          if (renderedLetter._mdf.sc) {
            textSpan.setAttribute('stroke', renderedLetter.sc);
          }
          if (renderedLetter._mdf.fc) {
            textSpan.setAttribute('fill', renderedLetter.fc);
          }
        }
      }
    }
  }
};

/* global extendPrototype, BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement,
FrameElement, RenderableDOMElement, Matrix, SVGStyleData, SVGStrokeStyleData, SVGFillStyleData,
SVGGradientFillStyleData, SVGGradientStrokeStyleData, locationHref, getBlendMode, ShapeGroupData,
TransformPropertyFactory, SVGTransformData, ShapePropertyFactory, SVGShapeData, SVGElementsRenderer, ShapeModifiers */

function SVGShapeElement(data, globalData, comp) {
  // List of drawable elements
  this.shapes = [];
  // Full shape data
  this.shapesData = data.shapes;
  // List of styles that will be applied to shapes
  this.stylesList = [];
  // List of modifiers that will be applied to shapes
  this.shapeModifiers = [];
  // List of items in shape tree
  this.itemsData = [];
  // List of items in previous shape tree
  this.processedElements = [];
  // List of animated components
  this.animatedContents = [];
  this.initElement(data, globalData, comp);
  // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
  // List of elements that have been created
  this.prevViewData = [];
  // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
}

extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);

SVGShapeElement.prototype.initSecondaryElement = function () {
};

SVGShapeElement.prototype.identityMatrix = new Matrix();

SVGShapeElement.prototype.buildExpressionInterface = function () {};

SVGShapeElement.prototype.createContent = function () {
  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
  this.filterUniqueShapes();
};

/*
This method searches for multiple shapes that affect a single element and one of them is animated
*/
SVGShapeElement.prototype.filterUniqueShapes = function () {
  var i;
  var len = this.shapes.length;
  var shape;
  var j;
  var jLen = this.stylesList.length;
  var style;
  var tempShapes = [];
  var areAnimated = false;
  for (j = 0; j < jLen; j += 1) {
    style = this.stylesList[j];
    areAnimated = false;
    tempShapes.length = 0;
    for (i = 0; i < len; i += 1) {
      shape = this.shapes[i];
      if (shape.styles.indexOf(style) !== -1) {
        tempShapes.push(shape);
        areAnimated = shape._isAnimated || areAnimated;
      }
    }
    if (tempShapes.length > 1 && areAnimated) {
      this.setShapesAsAnimated(tempShapes);
    }
  }
};

SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {
  var i;
  var len = shapes.length;
  for (i = 0; i < len; i += 1) {
    shapes[i].setAsAnimated();
  }
};

SVGShapeElement.prototype.createStyleElement = function (data, level) {
  // TODO: prevent drawing of hidden styles
  var elementData;
  var styleOb = new SVGStyleData(data, level);

  var pathElement = styleOb.pElem;
  if (data.ty === 'st') {
    elementData = new SVGStrokeStyleData(this, data, styleOb);
  } else if (data.ty === 'fl') {
    elementData = new SVGFillStyleData(this, data, styleOb);
  } else if (data.ty === 'gf' || data.ty === 'gs') {
    var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
    elementData = new GradientConstructor(this, data, styleOb);
    this.globalData.defs.appendChild(elementData.gf);
    if (elementData.maskId) {
      this.globalData.defs.appendChild(elementData.ms);
      this.globalData.defs.appendChild(elementData.of);
      pathElement.setAttribute('mask', 'url(' + locationHref + '#' + elementData.maskId + ')');
    }
  }

  if (data.ty === 'st' || data.ty === 'gs') {
    pathElement.setAttribute('stroke-linecap', this.lcEnum[data.lc] || 'round');
    pathElement.setAttribute('stroke-linejoin', this.ljEnum[data.lj] || 'round');
    pathElement.setAttribute('fill-opacity', '0');
    if (data.lj === 1) {
      pathElement.setAttribute('stroke-miterlimit', data.ml);
    }
  }

  if (data.r === 2) {
    pathElement.setAttribute('fill-rule', 'evenodd');
  }

  if (data.ln) {
    pathElement.setAttribute('id', data.ln);
  }
  if (data.cl) {
    pathElement.setAttribute('class', data.cl);
  }
  if (data.bm) {
    pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);
  }
  this.stylesList.push(styleOb);
  this.addToAnimatedContents(data, elementData);
  return elementData;
};

SVGShapeElement.prototype.createGroupElement = function (data) {
  var elementData = new ShapeGroupData();
  if (data.ln) {
    elementData.gr.setAttribute('id', data.ln);
  }
  if (data.cl) {
    elementData.gr.setAttribute('class', data.cl);
  }
  if (data.bm) {
    elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);
  }
  return elementData;
};

SVGShapeElement.prototype.createTransformElement = function (data, container) {
  var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
  var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
  this.addToAnimatedContents(data, elementData);
  return elementData;
};

SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {
  var ty = 4;
  if (data.ty === 'rc') {
    ty = 5;
  } else if (data.ty === 'el') {
    ty = 6;
  } else if (data.ty === 'sr') {
    ty = 7;
  }
  var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
  var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
  this.shapes.push(elementData);
  this.addShapeToModifiers(elementData);
  this.addToAnimatedContents(data, elementData);
  return elementData;
};

SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {
  var i = 0;
  var len = this.animatedContents.length;
  while (i < len) {
    if (this.animatedContents[i].element === element) {
      return;
    }
    i += 1;
  }
  this.animatedContents.push({
    fn: SVGElementsRenderer.createRenderFunction(data),
    element: element,
    data: data,
  });
};

SVGShapeElement.prototype.setElementStyles = function (elementData) {
  var arr = elementData.styles;
  var j;
  var jLen = this.stylesList.length;
  for (j = 0; j < jLen; j += 1) {
    if (!this.stylesList[j].closed) {
      arr.push(this.stylesList[j]);
    }
  }
};

SVGShapeElement.prototype.reloadShapes = function () {
  this._isFirstFrame = true;
  var i;
  var len = this.itemsData.length;
  for (i = 0; i < len; i += 1) {
    this.prevViewData[i] = this.itemsData[i];
  }
  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
  this.filterUniqueShapes();
  len = this.dynamicProperties.length;
  for (i = 0; i < len; i += 1) {
    this.dynamicProperties[i].getValue();
  }
  this.renderModifiers();
};

SVGShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, container, level, transformers, render) {
  var ownTransformers = [].concat(transformers);
  var i;
  var len = arr.length - 1;
  var j;
  var jLen;
  var ownStyles = [];
  var ownModifiers = [];
  var currentTransform;
  var modifier;
  var processedPos;
  for (i = len; i >= 0; i -= 1) {
    processedPos = this.searchProcessedElement(arr[i]);
    if (!processedPos) {
      arr[i]._render = render;
    } else {
      itemsData[i] = prevViewData[processedPos - 1];
    }
    if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
      if (!processedPos) {
        itemsData[i] = this.createStyleElement(arr[i], level);
      } else {
        itemsData[i].style.closed = false;
      }
      if (arr[i]._render) {
        container.appendChild(itemsData[i].style.pElem);
      }
      ownStyles.push(itemsData[i].style);
    } else if (arr[i].ty === 'gr') {
      if (!processedPos) {
        itemsData[i] = this.createGroupElement(arr[i]);
      } else {
        jLen = itemsData[i].it.length;
        for (j = 0; j < jLen; j += 1) {
          itemsData[i].prevViewData[j] = itemsData[i].it[j];
        }
      }
      this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);
      if (arr[i]._render) {
        container.appendChild(itemsData[i].gr);
      }
    } else if (arr[i].ty === 'tr') {
      if (!processedPos) {
        itemsData[i] = this.createTransformElement(arr[i], container);
      }
      currentTransform = itemsData[i].transform;
      ownTransformers.push(currentTransform);
    } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
      if (!processedPos) {
        itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
      }
      this.setElementStyles(itemsData[i]);
    } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb') {
      if (!processedPos) {
        modifier = ShapeModifiers.getModifier(arr[i].ty);
        modifier.init(this, arr[i]);
        itemsData[i] = modifier;
        this.shapeModifiers.push(modifier);
      } else {
        modifier = itemsData[i];
        modifier.closed = false;
      }
      ownModifiers.push(modifier);
    } else if (arr[i].ty === 'rp') {
      if (!processedPos) {
        modifier = ShapeModifiers.getModifier(arr[i].ty);
        itemsData[i] = modifier;
        modifier.init(this, arr, i, itemsData);
        this.shapeModifiers.push(modifier);
        render = false;
      } else {
        modifier = itemsData[i];
        modifier.closed = true;
      }
      ownModifiers.push(modifier);
    }
    this.addProcessedElement(arr[i], i + 1);
  }
  len = ownStyles.length;
  for (i = 0; i < len; i += 1) {
    ownStyles[i].closed = true;
  }
  len = ownModifiers.length;
  for (i = 0; i < len; i += 1) {
    ownModifiers[i].closed = true;
  }
};

SVGShapeElement.prototype.renderInnerContent = function () {
  this.renderModifiers();
  var i;
  var len = this.stylesList.length;
  for (i = 0; i < len; i += 1) {
    this.stylesList[i].reset();
  }
  this.renderShape();

  for (i = 0; i < len; i += 1) {
    if (this.stylesList[i]._mdf || this._isFirstFrame) {
      if (this.stylesList[i].msElem) {
        this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d);
        // Adding M0 0 fixes same mask bug on all browsers
        this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;
      }
      this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');
    }
  }
};

SVGShapeElement.prototype.renderShape = function () {
  var i;
  var len = this.animatedContents.length;
  var animatedContent;
  for (i = 0; i < len; i += 1) {
    animatedContent = this.animatedContents[i];
    if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
      animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
    }
  }
};

SVGShapeElement.prototype.destroy = function () {
  this.destroyBaseElement();
  this.shapesData = null;
  this.itemsData = null;
};

/* global createNS */

function SVGTintFilter(filter, filterManager) {
  this.filterManager = filterManager;
  var feColorMatrix = createNS('feColorMatrix');
  feColorMatrix.setAttribute('type', 'matrix');
  feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
  feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
  feColorMatrix.setAttribute('result', 'f1');
  filter.appendChild(feColorMatrix);
  feColorMatrix = createNS('feColorMatrix');
  feColorMatrix.setAttribute('type', 'matrix');
  feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
  feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
  feColorMatrix.setAttribute('result', 'f2');
  filter.appendChild(feColorMatrix);
  this.matrixFilter = feColorMatrix;
  if (filterManager.effectElements[2].p.v !== 100 || filterManager.effectElements[2].p.k) {
    var feMerge = createNS('feMerge');
    filter.appendChild(feMerge);
    var feMergeNode;
    feMergeNode = createNS('feMergeNode');
    feMergeNode.setAttribute('in', 'SourceGraphic');
    feMerge.appendChild(feMergeNode);
    feMergeNode = createNS('feMergeNode');
    feMergeNode.setAttribute('in', 'f2');
    feMerge.appendChild(feMergeNode);
  }
}

SVGTintFilter.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    var colorBlack = this.filterManager.effectElements[0].p.v;
    var colorWhite = this.filterManager.effectElements[1].p.v;
    var opacity = this.filterManager.effectElements[2].p.v / 100;
    this.matrixFilter.setAttribute('values', (colorWhite[0] - colorBlack[0]) + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 ' + opacity + ' 0');
  }
};

/* global createNS */

function SVGFillFilter(filter, filterManager) {
  this.filterManager = filterManager;
  var feColorMatrix = createNS('feColorMatrix');
  feColorMatrix.setAttribute('type', 'matrix');
  feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
  feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
  filter.appendChild(feColorMatrix);
  this.matrixFilter = feColorMatrix;
}
SVGFillFilter.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    var color = this.filterManager.effectElements[2].p.v;
    var opacity = this.filterManager.effectElements[6].p.v;
    this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');
  }
};

/* global createNS */

function SVGGaussianBlurEffect(filter, filterManager) {
  // Outset the filter region by 100% on all sides to accommodate blur expansion.
  filter.setAttribute('x', '-100%');
  filter.setAttribute('y', '-100%');
  filter.setAttribute('width', '300%');
  filter.setAttribute('height', '300%');

  this.filterManager = filterManager;
  var feGaussianBlur = createNS('feGaussianBlur');
  filter.appendChild(feGaussianBlur);
  this.feGaussianBlur = feGaussianBlur;
}

SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    // Empirical value, matching AE's blur appearance.
    var kBlurrinessToSigma = 0.3;
    var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;

    // Dimensions mapping:
    //
    //   1 -> horizontal & vertical
    //   2 -> horizontal only
    //   3 -> vertical only
    //
    var dimensions = this.filterManager.effectElements[1].p.v;
    var sigmaX = (dimensions == 3) ? 0 : sigma; // eslint-disable-line eqeqeq
    var sigmaY = (dimensions == 2) ? 0 : sigma; // eslint-disable-line eqeqeq

    this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY);

    // Repeat edges mapping:
    //
    //   0 -> off -> duplicate
    //   1 -> on  -> wrap
    var edgeMode = (this.filterManager.effectElements[2].p.v == 1) ? 'wrap' : 'duplicate'; // eslint-disable-line eqeqeq
    this.feGaussianBlur.setAttribute('edgeMode', edgeMode);
  }
};

/* global createNS, createElementID, locationHref, bmFloor */

function SVGStrokeEffect(elem, filterManager) {
  this.initialized = false;
  this.filterManager = filterManager;
  this.elem = elem;
  this.paths = [];
}

SVGStrokeEffect.prototype.initialize = function () {
  var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
  var path;
  var groupPath;
  var i;
  var len;
  if (this.filterManager.effectElements[1].p.v === 1) {
    len = this.elem.maskManager.masksProperties.length;
    i = 0;
  } else {
    i = this.filterManager.effectElements[0].p.v - 1;
    len = i + 1;
  }
  groupPath = createNS('g');
  groupPath.setAttribute('fill', 'none');
  groupPath.setAttribute('stroke-linecap', 'round');
  groupPath.setAttribute('stroke-dashoffset', 1);
  for (i; i < len; i += 1) {
    path = createNS('path');
    groupPath.appendChild(path);
    this.paths.push({ p: path, m: i });
  }
  if (this.filterManager.effectElements[10].p.v === 3) {
    var mask = createNS('mask');
    var id = createElementID();
    mask.setAttribute('id', id);
    mask.setAttribute('mask-type', 'alpha');
    mask.appendChild(groupPath);
    this.elem.globalData.defs.appendChild(mask);
    var g = createNS('g');
    g.setAttribute('mask', 'url(' + locationHref + '#' + id + ')');
    while (elemChildren[0]) {
      g.appendChild(elemChildren[0]);
    }
    this.elem.layerElement.appendChild(g);
    this.masker = mask;
    groupPath.setAttribute('stroke', '#fff');
  } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
    if (this.filterManager.effectElements[10].p.v === 2) {
      elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
      while (elemChildren.length) {
        this.elem.layerElement.removeChild(elemChildren[0]);
      }
    }
    this.elem.layerElement.appendChild(groupPath);
    this.elem.layerElement.removeAttribute('mask');
    groupPath.setAttribute('stroke', '#fff');
  }
  this.initialized = true;
  this.pathMasker = groupPath;
};

SVGStrokeEffect.prototype.renderFrame = function (forceRender) {
  if (!this.initialized) {
    this.initialize();
  }
  var i;
  var len = this.paths.length;
  var mask;
  var path;
  for (i = 0; i < len; i += 1) {
    if (this.paths[i].m !== -1) {
      mask = this.elem.maskManager.viewData[this.paths[i].m];
      path = this.paths[i].p;
      if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
        path.setAttribute('d', mask.lastPath);
      }
      if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
        var dasharrayValue;
        if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
          var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
          var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
          var l = path.getTotalLength();
          dasharrayValue = '0 0 0 ' + l * s + ' ';
          var lineLength = l * (e - s);
          var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
          var units = Math.floor(lineLength / segment);
          var j;
          for (j = 0; j < units; j += 1) {
            dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';
          }
          dasharrayValue += '0 ' + l * 10 + ' 0 0';
        } else {
          dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
        }
        path.setAttribute('stroke-dasharray', dasharrayValue);
      }
    }
  }
  if (forceRender || this.filterManager.effectElements[4].p._mdf) {
    this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);
  }

  if (forceRender || this.filterManager.effectElements[6].p._mdf) {
    this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);
  }
  if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
    if (forceRender || this.filterManager.effectElements[3].p._mdf) {
      var color = this.filterManager.effectElements[3].p.v;
      this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');
    }
  }
};

/* global createNS */

function SVGTritoneFilter(filter, filterManager) {
  this.filterManager = filterManager;
  var feColorMatrix = createNS('feColorMatrix');
  feColorMatrix.setAttribute('type', 'matrix');
  feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
  feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
  feColorMatrix.setAttribute('result', 'f1');
  filter.appendChild(feColorMatrix);
  var feComponentTransfer = createNS('feComponentTransfer');
  feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
  filter.appendChild(feComponentTransfer);
  this.matrixFilter = feComponentTransfer;
  var feFuncR = createNS('feFuncR');
  feFuncR.setAttribute('type', 'table');
  feComponentTransfer.appendChild(feFuncR);
  this.feFuncR = feFuncR;
  var feFuncG = createNS('feFuncG');
  feFuncG.setAttribute('type', 'table');
  feComponentTransfer.appendChild(feFuncG);
  this.feFuncG = feFuncG;
  var feFuncB = createNS('feFuncB');
  feFuncB.setAttribute('type', 'table');
  feComponentTransfer.appendChild(feFuncB);
  this.feFuncB = feFuncB;
}

SVGTritoneFilter.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    var color1 = this.filterManager.effectElements[0].p.v;
    var color2 = this.filterManager.effectElements[1].p.v;
    var color3 = this.filterManager.effectElements[2].p.v;
    var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
    var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
    var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
    this.feFuncR.setAttribute('tableValues', tableR);
    this.feFuncG.setAttribute('tableValues', tableG);
    this.feFuncB.setAttribute('tableValues', tableB);
    // var opacity = this.filterManager.effectElements[2].p.v/100;
    // this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
  }
};

/* global createNS */

function SVGProLevelsFilter(filter, filterManager) {
  this.filterManager = filterManager;
  var effectElements = this.filterManager.effectElements;
  var feComponentTransfer = createNS('feComponentTransfer');

  if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
    this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
  }
  if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
    this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
  }
  if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
    this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
  }
  if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
    this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
  }

  if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
    filter.appendChild(feComponentTransfer);
    feComponentTransfer = createNS('feComponentTransfer');
  }

  if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
    filter.appendChild(feComponentTransfer);
    this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
    this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
    this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
  }
}

SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {
  var feFunc = createNS(type);
  feFunc.setAttribute('type', 'table');
  feComponentTransfer.appendChild(feFunc);
  return feFunc;
};

SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
  var cnt = 0;
  var segments = 256;
  var perc;
  var min = Math.min(inputBlack, inputWhite);
  var max = Math.max(inputBlack, inputWhite);
  var table = Array.call(null, { length: segments });
  var colorValue;
  var pos = 0;
  var outputDelta = outputWhite - outputBlack;
  var inputDelta = inputWhite - inputBlack;
  while (cnt <= 256) {
    perc = cnt / 256;
    if (perc <= min) {
      colorValue = inputDelta < 0 ? outputWhite : outputBlack;
    } else if (perc >= max) {
      colorValue = inputDelta < 0 ? outputBlack : outputWhite;
    } else {
      colorValue = (outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma));
    }
    table[pos] = colorValue;
    pos += 1;
    cnt += 256 / (segments - 1);
  }
  return table.join(' ');
};

SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    var val;
    var effectElements = this.filterManager.effectElements;
    if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
      val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
      this.feFuncRComposed.setAttribute('tableValues', val);
      this.feFuncGComposed.setAttribute('tableValues', val);
      this.feFuncBComposed.setAttribute('tableValues', val);
    }

    if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
      val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
      this.feFuncR.setAttribute('tableValues', val);
    }

    if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
      val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
      this.feFuncG.setAttribute('tableValues', val);
    }

    if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
      val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
      this.feFuncB.setAttribute('tableValues', val);
    }

    if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
      val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
      this.feFuncA.setAttribute('tableValues', val);
    }
  }
};

/* global createNS, rgbToHex, degToRads */

function SVGDropShadowEffect(filter, filterManager) {
  var filterSize = filterManager.container.globalData.renderConfig.filterSize;
  filter.setAttribute('x', filterSize.x);
  filter.setAttribute('y', filterSize.y);
  filter.setAttribute('width', filterSize.width);
  filter.setAttribute('height', filterSize.height);
  this.filterManager = filterManager;

  var feGaussianBlur = createNS('feGaussianBlur');
  feGaussianBlur.setAttribute('in', 'SourceAlpha');
  feGaussianBlur.setAttribute('result', 'drop_shadow_1');
  feGaussianBlur.setAttribute('stdDeviation', '0');
  this.feGaussianBlur = feGaussianBlur;
  filter.appendChild(feGaussianBlur);

  var feOffset = createNS('feOffset');
  feOffset.setAttribute('dx', '25');
  feOffset.setAttribute('dy', '0');
  feOffset.setAttribute('in', 'drop_shadow_1');
  feOffset.setAttribute('result', 'drop_shadow_2');
  this.feOffset = feOffset;
  filter.appendChild(feOffset);
  var feFlood = createNS('feFlood');
  feFlood.setAttribute('flood-color', '#00ff00');
  feFlood.setAttribute('flood-opacity', '1');
  feFlood.setAttribute('result', 'drop_shadow_3');
  this.feFlood = feFlood;
  filter.appendChild(feFlood);

  var feComposite = createNS('feComposite');
  feComposite.setAttribute('in', 'drop_shadow_3');
  feComposite.setAttribute('in2', 'drop_shadow_2');
  feComposite.setAttribute('operator', 'in');
  feComposite.setAttribute('result', 'drop_shadow_4');
  filter.appendChild(feComposite);

  var feMerge = createNS('feMerge');
  filter.appendChild(feMerge);
  var feMergeNode;
  feMergeNode = createNS('feMergeNode');
  feMerge.appendChild(feMergeNode);
  feMergeNode = createNS('feMergeNode');
  feMergeNode.setAttribute('in', 'SourceGraphic');
  this.feMergeNode = feMergeNode;
  this.feMerge = feMerge;
  this.originalNodeAdded = false;
  feMerge.appendChild(feMergeNode);
}

SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    if (forceRender || this.filterManager.effectElements[4].p._mdf) {
      this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
    }
    if (forceRender || this.filterManager.effectElements[0].p._mdf) {
      var col = this.filterManager.effectElements[0].p.v;
      this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
    }
    if (forceRender || this.filterManager.effectElements[1].p._mdf) {
      this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);
    }
    if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
      var distance = this.filterManager.effectElements[3].p.v;
      var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
      var x = distance * Math.cos(angle);
      var y = distance * Math.sin(angle);
      this.feOffset.setAttribute('dx', x);
      this.feOffset.setAttribute('dy', y);
    }
    /* if(forceRender || this.filterManager.effectElements[5].p._mdf){
            if(this.filterManager.effectElements[5].p.v === 1 && this.originalNodeAdded) {
                this.feMerge.removeChild(this.feMergeNode);
                this.originalNodeAdded = false;
            } else if(this.filterManager.effectElements[5].p.v === 0 && !this.originalNodeAdded) {
                this.feMerge.appendChild(this.feMergeNode);
                this.originalNodeAdded = true;
            }
        } */
  }
};

/* global createElementID, createNS */

var _svgMatteSymbols = [];

function SVGMatte3Effect(filterElem, filterManager, elem) {
  this.initialized = false;
  this.filterManager = filterManager;
  this.filterElem = filterElem;
  this.elem = elem;
  elem.matteElement = createNS('g');
  elem.matteElement.appendChild(elem.layerElement);
  elem.matteElement.appendChild(elem.transformedElement);
  elem.baseElement = elem.matteElement;
}

SVGMatte3Effect.prototype.findSymbol = function (mask) {
  var i = 0;
  var len = _svgMatteSymbols.length;
  while (i < len) {
    if (_svgMatteSymbols[i] === mask) {
      return _svgMatteSymbols[i];
    }
    i += 1;
  }
  return null;
};

SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {
  var parentNode = mask.layerElement.parentNode;
  if (!parentNode) {
    return;
  }
  var children = parentNode.children;
  var i = 0;
  var len = children.length;
  while (i < len) {
    if (children[i] === mask.layerElement) {
      break;
    }
    i += 1;
  }
  var nextChild;
  if (i <= len - 2) {
    nextChild = children[i + 1];
  }
  var useElem = createNS('use');
  useElem.setAttribute('href', '#' + symbolId);
  if (nextChild) {
    parentNode.insertBefore(useElem, nextChild);
  } else {
    parentNode.appendChild(useElem);
  }
};

SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {
  if (!this.findSymbol(mask)) {
    var symbolId = createElementID();
    var masker = createNS('mask');
    masker.setAttribute('id', mask.layerId);
    masker.setAttribute('mask-type', 'alpha');
    _svgMatteSymbols.push(mask);
    var defs = elem.globalData.defs;
    defs.appendChild(masker);
    var symbol = createNS('symbol');
    symbol.setAttribute('id', symbolId);
    this.replaceInParent(mask, symbolId);
    symbol.appendChild(mask.layerElement);
    defs.appendChild(symbol);
    var useElem = createNS('use');
    useElem.setAttribute('href', '#' + symbolId);
    masker.appendChild(useElem);
    mask.data.hd = false;
    mask.show();
  }
  elem.setMatte(mask.layerId);
};

SVGMatte3Effect.prototype.initialize = function () {
  var ind = this.filterManager.effectElements[0].p.v;
  var elements = this.elem.comp.elements;
  var i = 0;
  var len = elements.length;
  while (i < len) {
    if (elements[i] && elements[i].data.ind === ind) {
      this.setElementAsMask(this.elem, elements[i]);
    }
    i += 1;
  }
  this.initialized = true;
};

SVGMatte3Effect.prototype.renderFrame = function () {
  if (!this.initialized) {
    this.initialize();
  }
};

/* global createElementID, filtersFactory, SVGTintFilter, SVGFillFilter, SVGStrokeEffect, SVGTritoneFilter,
SVGProLevelsFilter, SVGDropShadowEffect, SVGMatte3Effect, SVGGaussianBlurEffect, locationHref */

function SVGEffects(elem) {
  var i;
  var len = elem.data.ef ? elem.data.ef.length : 0;
  var filId = createElementID();
  var fil = filtersFactory.createFilter(filId, true);
  var count = 0;
  this.filters = [];
  var filterManager;
  for (i = 0; i < len; i += 1) {
    filterManager = null;
    if (elem.data.ef[i].ty === 20) {
      count += 1;
      filterManager = new SVGTintFilter(fil, elem.effectsManager.effectElements[i]);
    } else if (elem.data.ef[i].ty === 21) {
      count += 1;
      filterManager = new SVGFillFilter(fil, elem.effectsManager.effectElements[i]);
    } else if (elem.data.ef[i].ty === 22) {
      filterManager = new SVGStrokeEffect(elem, elem.effectsManager.effectElements[i]);
    } else if (elem.data.ef[i].ty === 23) {
      count += 1;
      filterManager = new SVGTritoneFilter(fil, elem.effectsManager.effectElements[i]);
    } else if (elem.data.ef[i].ty === 24) {
      count += 1;
      filterManager = new SVGProLevelsFilter(fil, elem.effectsManager.effectElements[i]);
    } else if (elem.data.ef[i].ty === 25) {
      count += 1;
      filterManager = new SVGDropShadowEffect(fil, elem.effectsManager.effectElements[i]);
    } else if (elem.data.ef[i].ty === 28) {
      // count += 1;
      filterManager = new SVGMatte3Effect(fil, elem.effectsManager.effectElements[i], elem);
    } else if (elem.data.ef[i].ty === 29) {
      count += 1;
      filterManager = new SVGGaussianBlurEffect(fil, elem.effectsManager.effectElements[i]);
    }
    if (filterManager) {
      this.filters.push(filterManager);
    }
  }
  if (count) {
    elem.globalData.defs.appendChild(fil);
    elem.layerElement.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
  }
  if (this.filters.length) {
    elem.addRenderableComponent(this);
  }
}

SVGEffects.prototype.renderFrame = function (_isFirstFrame) {
  var i;
  var len = this.filters.length;
  for (i = 0; i < len; i += 1) {
    this.filters[i].renderFrame(_isFirstFrame);
  }
};

/* global Matrix, createTypedArray */

function CVContextData() {
  this.saved = [];
  this.cArrPos = 0;
  this.cTr = new Matrix();
  this.cO = 1;
  var i;
  var len = 15;
  this.savedOp = createTypedArray('float32', len);
  for (i = 0; i < len; i += 1) {
    this.saved[i] = createTypedArray('float32', 16);
  }
  this._length = len;
}

CVContextData.prototype.duplicate = function () {
  var newLength = this._length * 2;
  var currentSavedOp = this.savedOp;
  this.savedOp = createTypedArray('float32', newLength);
  this.savedOp.set(currentSavedOp);
  var i = 0;
  for (i = this._length; i < newLength; i += 1) {
    this.saved[i] = createTypedArray('float32', 16);
  }
  this._length = newLength;
};

CVContextData.prototype.reset = function () {
  this.cArrPos = 0;
  this.cTr.reset();
  this.cO = 1;
};

/* global CVEffects, getBlendMode, CVMaskElement, Matrix */

function CVBaseElement() {
}

CVBaseElement.prototype = {
  createElements: function () {},
  initRendererElement: function () {},
  createContainerElements: function () {
    this.canvasContext = this.globalData.canvasContext;
    this.renderableEffectsManager = new CVEffects(this);
  },
  createContent: function () {},
  setBlendMode: function () {
    var globalData = this.globalData;
    if (globalData.blendMode !== this.data.bm) {
      globalData.blendMode = this.data.bm;
      var blendModeValue = getBlendMode(this.data.bm);
      globalData.canvasContext.globalCompositeOperation = blendModeValue;
    }
  },
  createRenderableComponents: function () {
    this.maskManager = new CVMaskElement(this.data, this);
  },
  hideElement: function () {
    if (!this.hidden && (!this.isInRange || this.isTransparent)) {
      this.hidden = true;
    }
  },
  showElement: function () {
    if (this.isInRange && !this.isTransparent) {
      this.hidden = false;
      this._isFirstFrame = true;
      this.maskManager._isFirstFrame = true;
    }
  },
  renderFrame: function () {
    if (this.hidden || this.data.hd) {
      return;
    }
    this.renderTransform();
    this.renderRenderable();
    this.setBlendMode();
    var forceRealStack = this.data.ty === 0;
    this.globalData.renderer.save(forceRealStack);
    this.globalData.renderer.ctxTransform(this.finalTransform.mat.props);
    this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v);
    this.renderInnerContent();
    this.globalData.renderer.restore(forceRealStack);
    if (this.maskManager.hasMasks) {
      this.globalData.renderer.restore(true);
    }
    if (this._isFirstFrame) {
      this._isFirstFrame = false;
    }
  },
  destroy: function () {
    this.canvasContext = null;
    this.data = null;
    this.globalData = null;
    this.maskManager.destroy();
  },
  mHelper: new Matrix(),
};
CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;

/* global extendPrototype, BaseElement, TransformElement, CVBaseElement,HierarchyElement, FrameElement,
RenderableElement, SVGShapeElement, IImageElement, createTag */

function CVImageElement(data, globalData, comp) {
  this.assetData = globalData.getAssetData(data.refId);
  this.img = globalData.imageLoader.getAsset(this.assetData);
  this.initElement(data, globalData, comp);
}
extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);

CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

CVImageElement.prototype.createContent = function () {
  if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
    var canvas = createTag('canvas');
    canvas.width = this.assetData.w;
    canvas.height = this.assetData.h;
    var ctx = canvas.getContext('2d');

    var imgW = this.img.width;
    var imgH = this.img.height;
    var imgRel = imgW / imgH;
    var canvasRel = this.assetData.w / this.assetData.h;
    var widthCrop;
    var heightCrop;
    var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
    if ((imgRel > canvasRel && par === 'xMidYMid slice') || (imgRel < canvasRel && par !== 'xMidYMid slice')) {
      heightCrop = imgH;
      widthCrop = heightCrop * canvasRel;
    } else {
      widthCrop = imgW;
      heightCrop = widthCrop / canvasRel;
    }
    ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
    this.img = canvas;
  }
};

CVImageElement.prototype.renderInnerContent = function () {
  this.canvasContext.drawImage(this.img, 0, 0);
};

CVImageElement.prototype.destroy = function () {
  this.img = null;
};

/* global createSizedArray, PropertyFactory, extendPrototype, CanvasRenderer, ICompElement, CVBaseElement */

function CVCompElement(data, globalData, comp) {
  this.completeLayers = false;
  this.layers = data.layers;
  this.pendingElements = [];
  this.elements = createSizedArray(this.layers.length);
  this.initElement(data, globalData, comp);
  this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
}

extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement);

CVCompElement.prototype.renderInnerContent = function () {
  var ctx = this.canvasContext;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(this.data.w, 0);
  ctx.lineTo(this.data.w, this.data.h);
  ctx.lineTo(0, this.data.h);
  ctx.lineTo(0, 0);
  ctx.clip();
  var i;
  var len = this.layers.length;
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.completeLayers || this.elements[i]) {
      this.elements[i].renderFrame();
    }
  }
};

CVCompElement.prototype.destroy = function () {
  var i;
  var len = this.layers.length;
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.elements[i]) {
      this.elements[i].destroy();
    }
  }
  this.layers = null;
  this.elements = null;
};

/* global createSizedArray, ShapePropertyFactory, MaskElement */

function CVMaskElement(data, element) {
  this.data = data;
  this.element = element;
  this.masksProperties = this.data.masksProperties || [];
  this.viewData = createSizedArray(this.masksProperties.length);
  var i;
  var len = this.masksProperties.length;
  var hasMasks = false;
  for (i = 0; i < len; i += 1) {
    if (this.masksProperties[i].mode !== 'n') {
      hasMasks = true;
    }
    this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
  }
  this.hasMasks = hasMasks;
  if (hasMasks) {
    this.element.addRenderableComponent(this);
  }
}

CVMaskElement.prototype.renderFrame = function () {
  if (!this.hasMasks) {
    return;
  }
  var transform = this.element.finalTransform.mat;
  var ctx = this.element.canvasContext;
  var i;
  var len = this.masksProperties.length;
  var pt;
  var pts;
  var data;
  ctx.beginPath();
  for (i = 0; i < len; i += 1) {
    if (this.masksProperties[i].mode !== 'n') {
      if (this.masksProperties[i].inv) {
        ctx.moveTo(0, 0);
        ctx.lineTo(this.element.globalData.compSize.w, 0);
        ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
        ctx.lineTo(0, this.element.globalData.compSize.h);
        ctx.lineTo(0, 0);
      }
      data = this.viewData[i].v;
      pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
      ctx.moveTo(pt[0], pt[1]);
      var j;
      var jLen = data._length;
      for (j = 1; j < jLen; j += 1) {
        pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
        ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
      }
      pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
      ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
    }
  }
  this.element.globalData.renderer.save(true);
  ctx.clip();
};

CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;

CVMaskElement.prototype.destroy = function () {
  this.element = null;
};

/* global ShapeTransformManager, extendPrototype, BaseElement, TransformElement, CVBaseElement, IShapeElement,
HierarchyElement, FrameElement, RenderableElement, RenderableDOMElement, PropertyFactory, degToRads, GradientProperty,
DashProperty, TransformPropertyFactory, CVShapeData, ShapeModifiers, bmFloor */

function CVShapeElement(data, globalData, comp) {
  this.shapes = [];
  this.shapesData = data.shapes;
  this.stylesList = [];
  this.itemsData = [];
  this.prevViewData = [];
  this.shapeModifiers = [];
  this.processedElements = [];
  this.transformsManager = new ShapeTransformManager();
  this.initElement(data, globalData, comp);
}

extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);

CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;

CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: false };

CVShapeElement.prototype.dashResetter = [];

CVShapeElement.prototype.createContent = function () {
  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
};

CVShapeElement.prototype.createStyleElement = function (data, transforms) {
  var styleElem = {
    data: data,
    type: data.ty,
    preTransforms: this.transformsManager.addTransformSequence(transforms),
    transforms: [],
    elements: [],
    closed: data.hd === true,
  };
  var elementData = {};
  if (data.ty === 'fl' || data.ty === 'st') {
    elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);
    if (!elementData.c.k) {
      styleElem.co = 'rgb(' + bmFloor(elementData.c.v[0]) + ',' + bmFloor(elementData.c.v[1]) + ',' + bmFloor(elementData.c.v[2]) + ')';
    }
  } else if (data.ty === 'gf' || data.ty === 'gs') {
    elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);
    elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);
    elementData.h = PropertyFactory.getProp(this, data.h || { k: 0 }, 0, 0.01, this);
    elementData.a = PropertyFactory.getProp(this, data.a || { k: 0 }, 0, degToRads, this);
    elementData.g = new GradientProperty(this, data.g, this);
  }
  elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);
  if (data.ty === 'st' || data.ty === 'gs') {
    styleElem.lc = this.lcEnum[data.lc] || 'round';
    styleElem.lj = this.ljEnum[data.lj] || 'round';
    if (data.lj == 1) { // eslint-disable-line eqeqeq
      styleElem.ml = data.ml;
    }
    elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);
    if (!elementData.w.k) {
      styleElem.wi = elementData.w.v;
    }
    if (data.d) {
      var d = new DashProperty(this, data.d, 'canvas', this);
      elementData.d = d;
      if (!elementData.d.k) {
        styleElem.da = elementData.d.dashArray;
        styleElem.do = elementData.d.dashoffset[0];
      }
    }
  } else {
    styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
  }
  this.stylesList.push(styleElem);
  elementData.style = styleElem;
  return elementData;
};

CVShapeElement.prototype.createGroupElement = function () {
  var elementData = {
    it: [],
    prevViewData: [],
  };
  return elementData;
};

CVShapeElement.prototype.createTransformElement = function (data) {
  var elementData = {
    transform: {
      opacity: 1,
      _opMdf: false,
      key: this.transformsManager.getNewKey(),
      op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
      mProps: TransformPropertyFactory.getTransformProperty(this, data, this),
    },
  };
  return elementData;
};

CVShapeElement.prototype.createShapeElement = function (data) {
  var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);

  this.shapes.push(elementData);
  this.addShapeToModifiers(elementData);
  return elementData;
};

CVShapeElement.prototype.reloadShapes = function () {
  this._isFirstFrame = true;
  var i;
  var len = this.itemsData.length;
  for (i = 0; i < len; i += 1) {
    this.prevViewData[i] = this.itemsData[i];
  }
  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
  len = this.dynamicProperties.length;
  for (i = 0; i < len; i += 1) {
    this.dynamicProperties[i].getValue();
  }
  this.renderModifiers();
  this.transformsManager.processSequences(this._isFirstFrame);
};

CVShapeElement.prototype.addTransformToStyleList = function (transform) {
  var i;
  var len = this.stylesList.length;
  for (i = 0; i < len; i += 1) {
    if (!this.stylesList[i].closed) {
      this.stylesList[i].transforms.push(transform);
    }
  }
};

CVShapeElement.prototype.removeTransformFromStyleList = function () {
  var i;
  var len = this.stylesList.length;
  for (i = 0; i < len; i += 1) {
    if (!this.stylesList[i].closed) {
      this.stylesList[i].transforms.pop();
    }
  }
};

CVShapeElement.prototype.closeStyles = function (styles) {
  var i;
  var len = styles.length;
  for (i = 0; i < len; i += 1) {
    styles[i].closed = true;
  }
};

CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {
  var i;
  var len = arr.length - 1;
  var j;
  var jLen;
  var ownStyles = [];
  var ownModifiers = [];
  var processedPos;
  var modifier;
  var currentTransform;
  var ownTransforms = [].concat(transforms);
  for (i = len; i >= 0; i -= 1) {
    processedPos = this.searchProcessedElement(arr[i]);
    if (!processedPos) {
      arr[i]._shouldRender = shouldRender;
    } else {
      itemsData[i] = prevViewData[processedPos - 1];
    }
    if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
      if (!processedPos) {
        itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
      } else {
        itemsData[i].style.closed = false;
      }

      ownStyles.push(itemsData[i].style);
    } else if (arr[i].ty === 'gr') {
      if (!processedPos) {
        itemsData[i] = this.createGroupElement(arr[i]);
      } else {
        jLen = itemsData[i].it.length;
        for (j = 0; j < jLen; j += 1) {
          itemsData[i].prevViewData[j] = itemsData[i].it[j];
        }
      }
      this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
    } else if (arr[i].ty === 'tr') {
      if (!processedPos) {
        currentTransform = this.createTransformElement(arr[i]);
        itemsData[i] = currentTransform;
      }
      ownTransforms.push(itemsData[i]);
      this.addTransformToStyleList(itemsData[i]);
    } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
      if (!processedPos) {
        itemsData[i] = this.createShapeElement(arr[i]);
      }
    } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb') {
      if (!processedPos) {
        modifier = ShapeModifiers.getModifier(arr[i].ty);
        modifier.init(this, arr[i]);
        itemsData[i] = modifier;
        this.shapeModifiers.push(modifier);
      } else {
        modifier = itemsData[i];
        modifier.closed = false;
      }
      ownModifiers.push(modifier);
    } else if (arr[i].ty === 'rp') {
      if (!processedPos) {
        modifier = ShapeModifiers.getModifier(arr[i].ty);
        itemsData[i] = modifier;
        modifier.init(this, arr, i, itemsData);
        this.shapeModifiers.push(modifier);
        shouldRender = false;
      } else {
        modifier = itemsData[i];
        modifier.closed = true;
      }
      ownModifiers.push(modifier);
    }
    this.addProcessedElement(arr[i], i + 1);
  }
  this.removeTransformFromStyleList();
  this.closeStyles(ownStyles);
  len = ownModifiers.length;
  for (i = 0; i < len; i += 1) {
    ownModifiers[i].closed = true;
  }
};

CVShapeElement.prototype.renderInnerContent = function () {
  this.transformHelper.opacity = 1;
  this.transformHelper._opMdf = false;
  this.renderModifiers();
  this.transformsManager.processSequences(this._isFirstFrame);
  this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
};

CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {
  if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
    groupTransform.opacity = parentTransform.opacity;
    groupTransform.opacity *= groupTransform.op.v;
    groupTransform._opMdf = true;
  }
};

CVShapeElement.prototype.drawLayer = function () {
  var i;
  var len = this.stylesList.length;
  var j;
  var jLen;
  var k;
  var kLen;
  var elems;
  var nodes;
  var renderer = this.globalData.renderer;
  var ctx = this.globalData.canvasContext;
  var type;
  var currentStyle;
  for (i = 0; i < len; i += 1) {
    currentStyle = this.stylesList[i];
    type = currentStyle.type;

    // Skipping style when
    // Stroke width equals 0
    // style should not be rendered (extra unused repeaters)
    // current opacity equals 0
    // global opacity equals 0
    if (!(((type === 'st' || type === 'gs') && currentStyle.wi === 0) || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
      renderer.save();
      elems = currentStyle.elements;
      if (type === 'st' || type === 'gs') {
        ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;
        ctx.lineWidth = currentStyle.wi;
        ctx.lineCap = currentStyle.lc;
        ctx.lineJoin = currentStyle.lj;
        ctx.miterLimit = currentStyle.ml || 0;
      } else {
        ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
      }
      renderer.ctxOpacity(currentStyle.coOp);
      if (type !== 'st' && type !== 'gs') {
        ctx.beginPath();
      }
      renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
      jLen = elems.length;
      for (j = 0; j < jLen; j += 1) {
        if (type === 'st' || type === 'gs') {
          ctx.beginPath();
          if (currentStyle.da) {
            ctx.setLineDash(currentStyle.da);
            ctx.lineDashOffset = currentStyle.do;
          }
        }
        nodes = elems[j].trNodes;
        kLen = nodes.length;

        for (k = 0; k < kLen; k += 1) {
          if (nodes[k].t === 'm') {
            ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
          } else if (nodes[k].t === 'c') {
            ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
          } else {
            ctx.closePath();
          }
        }
        if (type === 'st' || type === 'gs') {
          ctx.stroke();
          if (currentStyle.da) {
            ctx.setLineDash(this.dashResetter);
          }
        }
      }
      if (type !== 'st' && type !== 'gs') {
        ctx.fill(currentStyle.r);
      }
      renderer.restore();
    }
  }
};

CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {
  var i;
  var len = items.length - 1;
  var groupTransform;
  groupTransform = parentTransform;
  for (i = len; i >= 0; i -= 1) {
    if (items[i].ty === 'tr') {
      groupTransform = data[i].transform;
      this.renderShapeTransform(parentTransform, groupTransform);
    } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {
      this.renderPath(items[i], data[i]);
    } else if (items[i].ty === 'fl') {
      this.renderFill(items[i], data[i], groupTransform);
    } else if (items[i].ty === 'st') {
      this.renderStroke(items[i], data[i], groupTransform);
    } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {
      this.renderGradientFill(items[i], data[i], groupTransform);
    } else if (items[i].ty === 'gr') {
      this.renderShape(groupTransform, items[i].it, data[i].it);
    } else if (items[i].ty === 'tm') {
      //
    }
  }
  if (isMain) {
    this.drawLayer();
  }
};

CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {
  if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
    var shapeNodes = styledShape.trNodes;
    var paths = shape.paths;
    var i;
    var len;
    var j;
    var jLen = paths._length;
    shapeNodes.length = 0;
    var groupTransformMat = styledShape.transforms.finalTransform;
    for (j = 0; j < jLen; j += 1) {
      var pathNodes = paths.shapes[j];
      if (pathNodes && pathNodes.v) {
        len = pathNodes._length;
        for (i = 1; i < len; i += 1) {
          if (i === 1) {
            shapeNodes.push({
              t: 'm',
              p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0),
            });
          }
          shapeNodes.push({
            t: 'c',
            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i]),
          });
        }
        if (len === 1) {
          shapeNodes.push({
            t: 'm',
            p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0),
          });
        }
        if (pathNodes.c && len) {
          shapeNodes.push({
            t: 'c',
            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0]),
          });
          shapeNodes.push({
            t: 'z',
          });
        }
      }
    }
    styledShape.trNodes = shapeNodes;
  }
};

CVShapeElement.prototype.renderPath = function (pathData, itemData) {
  if (pathData.hd !== true && pathData._shouldRender) {
    var i;
    var len = itemData.styledShapes.length;
    for (i = 0; i < len; i += 1) {
      this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
    }
  }
};

CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {
  var styleElem = itemData.style;

  if (itemData.c._mdf || this._isFirstFrame) {
    styleElem.co = 'rgb('
        + bmFloor(itemData.c.v[0]) + ','
        + bmFloor(itemData.c.v[1]) + ','
        + bmFloor(itemData.c.v[2]) + ')';
  }
  if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
    styleElem.coOp = itemData.o.v * groupTransform.opacity;
  }
};

CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {
  var styleElem = itemData.style;
  var grd;
  if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || (styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf))) {
    var ctx = this.globalData.canvasContext;
    var pt1 = itemData.s.v;
    var pt2 = itemData.e.v;
    if (styleData.t === 1) {
      grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
    } else {
      var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
      var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);

      var percent = itemData.h.v;
      if (percent >= 1) {
        percent = 0.99;
      } else if (percent <= -1) {
        percent = -0.99;
      }
      var dist = rad * percent;
      var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
      var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
      grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
    }

    var i;
    var len = styleData.g.p;
    var cValues = itemData.g.c;
    var opacity = 1;

    for (i = 0; i < len; i += 1) {
      if (itemData.g._hasOpacity && itemData.g._collapsable) {
        opacity = itemData.g.o[i * 2 + 1];
      }
      grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');
    }
    styleElem.grd = grd;
  }
  styleElem.coOp = itemData.o.v * groupTransform.opacity;
};

CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {
  var styleElem = itemData.style;
  var d = itemData.d;
  if (d && (d._mdf || this._isFirstFrame)) {
    styleElem.da = d.dashArray;
    styleElem.do = d.dashoffset[0];
  }
  if (itemData.c._mdf || this._isFirstFrame) {
    styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
  }
  if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
    styleElem.coOp = itemData.o.v * groupTransform.opacity;
  }
  if (itemData.w._mdf || this._isFirstFrame) {
    styleElem.wi = itemData.w.v;
  }
};

CVShapeElement.prototype.destroy = function () {
  this.shapesData = null;
  this.globalData = null;
  this.canvasContext = null;
  this.stylesList.length = 0;
  this.itemsData.length = 0;
};

/* global extendPrototype, BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement,
SVGShapeElement, IImageElement */

function CVSolidElement(data, globalData, comp) {
  this.initElement(data, globalData, comp);
}
extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);

CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

CVSolidElement.prototype.renderInnerContent = function () {
  var ctx = this.canvasContext;
  ctx.fillStyle = this.data.sc;
  ctx.fillRect(0, 0, this.data.sw, this.data.sh);
  //
};

/* global extendPrototype, BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement,
RenderableElement, ITextElement, createTag, createSizedArray */

function CVTextElement(data, globalData, comp) {
  this.textSpans = [];
  this.yOffset = 0;
  this.fillColorAnim = false;
  this.strokeColorAnim = false;
  this.strokeWidthAnim = false;
  this.stroke = false;
  this.fill = false;
  this.justifyOffset = 0;
  this.currentRender = null;
  this.renderType = 'canvas';
  this.values = {
    fill: 'rgba(0,0,0,0)',
    stroke: 'rgba(0,0,0,0)',
    sWidth: 0,
    fValue: '',
  };
  this.initElement(data, globalData, comp);
}
extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);

CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');

CVTextElement.prototype.buildNewText = function () {
  var documentData = this.textProperty.currentData;
  this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);

  var hasFill = false;
  if (documentData.fc) {
    hasFill = true;
    this.values.fill = this.buildColor(documentData.fc);
  } else {
    this.values.fill = 'rgba(0,0,0,0)';
  }
  this.fill = hasFill;
  var hasStroke = false;
  if (documentData.sc) {
    hasStroke = true;
    this.values.stroke = this.buildColor(documentData.sc);
    this.values.sWidth = documentData.sw;
  }
  var fontData = this.globalData.fontManager.getFontByName(documentData.f);
  var i;
  var len;
  var letters = documentData.l;
  var matrixHelper = this.mHelper;
  this.stroke = hasStroke;
  this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
  len = documentData.finalText.length;
  // this.tHelper.font = this.values.fValue;
  var charData;
  var shapeData;
  var k;
  var kLen;
  var shapes;
  var j;
  var jLen;
  var pathNodes;
  var commands;
  var pathArr;
  var singleShape = this.data.singleShape;
  var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
  var xPos = 0;
  var yPos = 0;
  var firstLine = true;
  var cnt = 0;
  for (i = 0; i < len; i += 1) {
    charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
    shapeData = (charData && charData.data) || {};
    matrixHelper.reset();
    if (singleShape && letters[i].n) {
      xPos = -trackingOffset;
      yPos += documentData.yOffset;
      yPos += firstLine ? 1 : 0;
      firstLine = false;
    }

    shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
    jLen = shapes.length;
    matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
    if (singleShape) {
      this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
    }
    commands = createSizedArray(jLen);
    for (j = 0; j < jLen; j += 1) {
      kLen = shapes[j].ks.k.i.length;
      pathNodes = shapes[j].ks.k;
      pathArr = [];
      for (k = 1; k < kLen; k += 1) {
        if (k === 1) {
          pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
        }
        pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
      }
      pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
      commands[j] = pathArr;
    }
    if (singleShape) {
      xPos += letters[i].l;
      xPos += trackingOffset;
    }
    if (this.textSpans[cnt]) {
      this.textSpans[cnt].elem = commands;
    } else {
      this.textSpans[cnt] = { elem: commands };
    }
    cnt += 1;
  }
};

CVTextElement.prototype.renderInnerContent = function () {
  var ctx = this.canvasContext;
  ctx.font = this.values.fValue;
  ctx.lineCap = 'butt';
  ctx.lineJoin = 'miter';
  ctx.miterLimit = 4;

  if (!this.data.singleShape) {
    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
  }

  var i;
  var len;
  var j;
  var jLen;
  var k;
  var kLen;
  var renderedLetters = this.textAnimator.renderedLetters;

  var letters = this.textProperty.currentData.l;

  len = letters.length;
  var renderedLetter;
  var lastFill = null;
  var lastStroke = null;
  var lastStrokeW = null;
  var commands;
  var pathArr;
  for (i = 0; i < len; i += 1) {
    if (!letters[i].n) {
      renderedLetter = renderedLetters[i];
      if (renderedLetter) {
        this.globalData.renderer.save();
        this.globalData.renderer.ctxTransform(renderedLetter.p);
        this.globalData.renderer.ctxOpacity(renderedLetter.o);
      }
      if (this.fill) {
        if (renderedLetter && renderedLetter.fc) {
          if (lastFill !== renderedLetter.fc) {
            lastFill = renderedLetter.fc;
            ctx.fillStyle = renderedLetter.fc;
          }
        } else if (lastFill !== this.values.fill) {
          lastFill = this.values.fill;
          ctx.fillStyle = this.values.fill;
        }
        commands = this.textSpans[i].elem;
        jLen = commands.length;
        this.globalData.canvasContext.beginPath();
        for (j = 0; j < jLen; j += 1) {
          pathArr = commands[j];
          kLen = pathArr.length;
          this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
          for (k = 2; k < kLen; k += 6) {
            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
          }
        }
        this.globalData.canvasContext.closePath();
        this.globalData.canvasContext.fill();
        /// ctx.fillText(this.textSpans[i].val,0,0);
      }
      if (this.stroke) {
        if (renderedLetter && renderedLetter.sw) {
          if (lastStrokeW !== renderedLetter.sw) {
            lastStrokeW = renderedLetter.sw;
            ctx.lineWidth = renderedLetter.sw;
          }
        } else if (lastStrokeW !== this.values.sWidth) {
          lastStrokeW = this.values.sWidth;
          ctx.lineWidth = this.values.sWidth;
        }
        if (renderedLetter && renderedLetter.sc) {
          if (lastStroke !== renderedLetter.sc) {
            lastStroke = renderedLetter.sc;
            ctx.strokeStyle = renderedLetter.sc;
          }
        } else if (lastStroke !== this.values.stroke) {
          lastStroke = this.values.stroke;
          ctx.strokeStyle = this.values.stroke;
        }
        commands = this.textSpans[i].elem;
        jLen = commands.length;
        this.globalData.canvasContext.beginPath();
        for (j = 0; j < jLen; j += 1) {
          pathArr = commands[j];
          kLen = pathArr.length;
          this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
          for (k = 2; k < kLen; k += 6) {
            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
          }
        }
        this.globalData.canvasContext.closePath();
        this.globalData.canvasContext.stroke();
        /// ctx.strokeText(letters[i].val,0,0);
      }
      if (renderedLetter) {
        this.globalData.renderer.restore();
      }
    }
  }
};

function CVEffects() {

}
CVEffects.prototype.renderFrame = function () {};

/* global createTag, createNS, styleDiv, CVEffects, MaskElement, SVGBaseElement, HybridRenderer */

function HBaseElement() {}
HBaseElement.prototype = {
  checkBlendMode: function () {},
  initRendererElement: function () {
    this.baseElement = createTag(this.data.tg || 'div');
    if (this.data.hasMask) {
      this.svgElement = createNS('svg');
      this.layerElement = createNS('g');
      this.maskedElement = this.layerElement;
      this.svgElement.appendChild(this.layerElement);
      this.baseElement.appendChild(this.svgElement);
    } else {
      this.layerElement = this.baseElement;
    }
    styleDiv(this.baseElement);
  },
  createContainerElements: function () {
    this.renderableEffectsManager = new CVEffects(this);
    this.transformedElement = this.baseElement;
    this.maskedElement = this.layerElement;
    if (this.data.ln) {
      this.layerElement.setAttribute('id', this.data.ln);
    }
    if (this.data.cl) {
      this.layerElement.setAttribute('class', this.data.cl);
    }
    if (this.data.bm !== 0) {
      this.setBlendMode();
    }
  },
  renderElement: function () {
    var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
    if (this.finalTransform._matMdf) {
      var matrixValue = this.finalTransform.mat.toCSS();
      transformedElementStyle.transform = matrixValue;
      transformedElementStyle.webkitTransform = matrixValue;
    }
    if (this.finalTransform._opMdf) {
      transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
    }
  },
  renderFrame: function () {
    // If it is exported as hidden (data.hd === true) no need to render
    // If it is not visible no need to render
    if (this.data.hd || this.hidden) {
      return;
    }
    this.renderTransform();
    this.renderRenderable();
    this.renderElement();
    this.renderInnerContent();
    if (this._isFirstFrame) {
      this._isFirstFrame = false;
    }
  },
  destroy: function () {
    this.layerElement = null;
    this.transformedElement = null;
    if (this.matteElement) {
      this.matteElement = null;
    }
    if (this.maskManager) {
      this.maskManager.destroy();
      this.maskManager = null;
    }
  },
  createRenderableComponents: function () {
    this.maskManager = new MaskElement(this.data, this, this.globalData);
  },
  addEffects: function () {
  },
  setMatte: function () {},
};
HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting;

/* global extendPrototype, BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement,
RenderableDOMElement, createNS, createTag */

function HSolidElement(data, globalData, comp) {
  this.initElement(data, globalData, comp);
}
extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);

HSolidElement.prototype.createContent = function () {
  var rect;
  if (this.data.hasMask) {
    rect = createNS('rect');
    rect.setAttribute('width', this.data.sw);
    rect.setAttribute('height', this.data.sh);
    rect.setAttribute('fill', this.data.sc);
    this.svgElement.setAttribute('width', this.data.sw);
    this.svgElement.setAttribute('height', this.data.sh);
  } else {
    rect = createTag('div');
    rect.style.width = this.data.sw + 'px';
    rect.style.height = this.data.sh + 'px';
    rect.style.backgroundColor = this.data.sc;
  }
  this.layerElement.appendChild(rect);
};

/* global createSizedArray, PropertyFactory, extendPrototype, HybridRenderer, ICompElement, HBaseElement */

function HCompElement(data, globalData, comp) {
  this.layers = data.layers;
  this.supports3d = !data.hasMask;
  this.completeLayers = false;
  this.pendingElements = [];
  this.elements = this.layers ? createSizedArray(this.layers.length) : [];
  this.initElement(data, globalData, comp);
  this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
}

extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement);
HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;

HCompElement.prototype.createContainerElements = function () {
  this._createBaseContainerElements();
  // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
  if (this.data.hasMask) {
    this.svgElement.setAttribute('width', this.data.w);
    this.svgElement.setAttribute('height', this.data.h);
    this.transformedElement = this.baseElement;
  } else {
    this.transformedElement = this.layerElement;
  }
};

HCompElement.prototype.addTo3dContainer = function (elem, pos) {
  var j = 0;
  var nextElement;
  while (j < pos) {
    if (this.elements[j] && this.elements[j].getBaseElement) {
      nextElement = this.elements[j].getBaseElement();
    }
    j += 1;
  }
  if (nextElement) {
    this.layerElement.insertBefore(elem, nextElement);
  } else {
    this.layerElement.appendChild(elem);
  }
};

/* global createNS, extendPrototype, BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement,
HierarchyElement, FrameElement, RenderableElement, createNS, bmMin, bmSqrt, bmMin, bmMax, bmPow */

function HShapeElement(data, globalData, comp) {
  // List of drawable elements
  this.shapes = [];
  // Full shape data
  this.shapesData = data.shapes;
  // List of styles that will be applied to shapes
  this.stylesList = [];
  // List of modifiers that will be applied to shapes
  this.shapeModifiers = [];
  // List of items in shape tree
  this.itemsData = [];
  // List of items in previous shape tree
  this.processedElements = [];
  // List of animated components
  this.animatedContents = [];
  this.shapesContainer = createNS('g');
  this.initElement(data, globalData, comp);
  // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
  // List of elements that have been created
  this.prevViewData = [];
  this.currentBBox = {
    x: 999999,
    y: -999999,
    h: 0,
    w: 0,
  };
}
extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;

HShapeElement.prototype.createContent = function () {
  var cont;
  this.baseElement.style.fontSize = 0;
  if (this.data.hasMask) {
    this.layerElement.appendChild(this.shapesContainer);
    cont = this.svgElement;
  } else {
    cont = createNS('svg');
    var size = this.comp.data ? this.comp.data : this.globalData.compSize;
    cont.setAttribute('width', size.w);
    cont.setAttribute('height', size.h);
    cont.appendChild(this.shapesContainer);
    this.layerElement.appendChild(cont);
  }

  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
  this.filterUniqueShapes();
  this.shapeCont = cont;
};

HShapeElement.prototype.getTransformedPoint = function (transformers, point) {
  var i;
  var len = transformers.length;
  for (i = 0; i < len; i += 1) {
    point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
  }
  return point;
};

HShapeElement.prototype.calculateShapeBoundingBox = function (item, boundingBox) {
  var shape = item.sh.v;
  var transformers = item.transformers;
  var i;
  var len = shape._length;
  var vPoint;
  var oPoint;
  var nextIPoint;
  var nextVPoint;
  if (len <= 1) {
    return;
  }
  for (i = 0; i < len - 1; i += 1) {
    vPoint = this.getTransformedPoint(transformers, shape.v[i]);
    oPoint = this.getTransformedPoint(transformers, shape.o[i]);
    nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
    nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
    this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
  }
  if (shape.c) {
    vPoint = this.getTransformedPoint(transformers, shape.v[i]);
    oPoint = this.getTransformedPoint(transformers, shape.o[i]);
    nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
    nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
    this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
  }
};

HShapeElement.prototype.checkBounds = function (vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
  this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
  var bounds = this.shapeBoundingBox;
  boundingBox.x = bmMin(bounds.left, boundingBox.x);
  boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
  boundingBox.y = bmMin(bounds.top, boundingBox.y);
  boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
};

HShapeElement.prototype.shapeBoundingBox = {
  left: 0,
  right: 0,
  top: 0,
  bottom: 0,
};

HShapeElement.prototype.tempBoundingBox = {
  x: 0,
  xMax: 0,
  y: 0,
  yMax: 0,
  width: 0,
  height: 0,
};

HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {
  var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];

  for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) { // eslint-disable-line no-plusplus
    b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
    a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
    c = 3 * p1[i] - 3 * p0[i];

    b |= 0; // eslint-disable-line no-bitwise
    a |= 0; // eslint-disable-line no-bitwise
    c |= 0; // eslint-disable-line no-bitwise

    if (a === 0 && b === 0) {
      //
    } else if (a === 0) {
      t = -c / b;

      if (t > 0 && t < 1) {
        bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
      }
    } else {
      b2ac = b * b - 4 * c * a;

      if (b2ac >= 0) {
        t1 = (-b + bmSqrt(b2ac)) / (2 * a);
        if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
        t2 = (-b - bmSqrt(b2ac)) / (2 * a);
        if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
      }
    }
  }

  this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
  this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
  this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
  this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
};

HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {
  return bmPow(1 - t, 3) * p0[i]
        + 3 * bmPow(1 - t, 2) * t * p1[i]
        + 3 * (1 - t) * bmPow(t, 2) * p2[i]
        + bmPow(t, 3) * p3[i];
};

HShapeElement.prototype.calculateBoundingBox = function (itemsData, boundingBox) {
  var i;
  var len = itemsData.length;
  for (i = 0; i < len; i += 1) {
    if (itemsData[i] && itemsData[i].sh) {
      this.calculateShapeBoundingBox(itemsData[i], boundingBox);
    } else if (itemsData[i] && itemsData[i].it) {
      this.calculateBoundingBox(itemsData[i].it, boundingBox);
    }
  }
};

HShapeElement.prototype.currentBoxContains = function (box) {
  return this.currentBBox.x <= box.x
    && this.currentBBox.y <= box.y
    && this.currentBBox.width + this.currentBBox.x >= box.x + box.width
    && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
};

HShapeElement.prototype.renderInnerContent = function () {
  this._renderShapeFrame();

  if (!this.hidden && (this._isFirstFrame || this._mdf)) {
    var tempBoundingBox = this.tempBoundingBox;
    var max = 999999;
    tempBoundingBox.x = max;
    tempBoundingBox.xMax = -max;
    tempBoundingBox.y = max;
    tempBoundingBox.yMax = -max;
    this.calculateBoundingBox(this.itemsData, tempBoundingBox);
    tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
    tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
    // var tempBoundingBox = this.shapeCont.getBBox();
    if (this.currentBoxContains(tempBoundingBox)) {
      return;
    }
    var changed = false;
    if (this.currentBBox.w !== tempBoundingBox.width) {
      this.currentBBox.w = tempBoundingBox.width;
      this.shapeCont.setAttribute('width', tempBoundingBox.width);
      changed = true;
    }
    if (this.currentBBox.h !== tempBoundingBox.height) {
      this.currentBBox.h = tempBoundingBox.height;
      this.shapeCont.setAttribute('height', tempBoundingBox.height);
      changed = true;
    }
    if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
      this.currentBBox.w = tempBoundingBox.width;
      this.currentBBox.h = tempBoundingBox.height;
      this.currentBBox.x = tempBoundingBox.x;
      this.currentBBox.y = tempBoundingBox.y;

      this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
      var shapeStyle = this.shapeCont.style;
      var shapeTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
      shapeStyle.transform = shapeTransform;
      shapeStyle.webkitTransform = shapeTransform;
    }
  }
};

/* global extendPrototype, BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement,
RenderableDOMElement, ITextElement, createSizedArray, createTag, styleDiv, createNS */

function HTextElement(data, globalData, comp) {
  this.textSpans = [];
  this.textPaths = [];
  this.currentBBox = {
    x: 999999,
    y: -999999,
    h: 0,
    w: 0,
  };
  this.renderType = 'svg';
  this.isMasked = false;
  this.initElement(data, globalData, comp);
}
extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);

HTextElement.prototype.createContent = function () {
  this.isMasked = this.checkMasks();
  if (this.isMasked) {
    this.renderType = 'svg';
    this.compW = this.comp.data.w;
    this.compH = this.comp.data.h;
    this.svgElement.setAttribute('width', this.compW);
    this.svgElement.setAttribute('height', this.compH);
    var g = createNS('g');
    this.maskedElement.appendChild(g);
    this.innerElem = g;
  } else {
    this.renderType = 'html';
    this.innerElem = this.layerElement;
  }

  this.checkParenting();
};

HTextElement.prototype.buildNewText = function () {
  var documentData = this.textProperty.currentData;
  this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
  var innerElemStyle = this.innerElem.style;
  var textColor = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';
  innerElemStyle.fill = textColor;
  innerElemStyle.color = textColor;
  if (documentData.sc) {
    innerElemStyle.stroke = this.buildColor(documentData.sc);
    innerElemStyle.strokeWidth = documentData.sw + 'px';
  }
  var fontData = this.globalData.fontManager.getFontByName(documentData.f);
  if (!this.globalData.fontManager.chars) {
    innerElemStyle.fontSize = documentData.finalSize + 'px';
    innerElemStyle.lineHeight = documentData.finalSize + 'px';
    if (fontData.fClass) {
      this.innerElem.className = fontData.fClass;
    } else {
      innerElemStyle.fontFamily = fontData.fFamily;
      var fWeight = documentData.fWeight;
      var fStyle = documentData.fStyle;
      innerElemStyle.fontStyle = fStyle;
      innerElemStyle.fontWeight = fWeight;
    }
  }
  var i;
  var len;

  var letters = documentData.l;
  len = letters.length;
  var tSpan;
  var tParent;
  var tCont;
  var matrixHelper = this.mHelper;
  var shapes;
  var shapeStr = '';
  var cnt = 0;
  for (i = 0; i < len; i += 1) {
    if (this.globalData.fontManager.chars) {
      if (!this.textPaths[cnt]) {
        tSpan = createNS('path');
        tSpan.setAttribute('stroke-linecap', 'butt');
        tSpan.setAttribute('stroke-linejoin', 'round');
        tSpan.setAttribute('stroke-miterlimit', '4');
      } else {
        tSpan = this.textPaths[cnt];
      }
      if (!this.isMasked) {
        if (this.textSpans[cnt]) {
          tParent = this.textSpans[cnt];
          tCont = tParent.children[0];
        } else {
          tParent = createTag('div');
          tParent.style.lineHeight = 0;
          tCont = createNS('svg');
          tCont.appendChild(tSpan);
          styleDiv(tParent);
        }
      }
    } else if (!this.isMasked) {
      if (this.textSpans[cnt]) {
        tParent = this.textSpans[cnt];
        tSpan = this.textPaths[cnt];
      } else {
        tParent = createTag('span');
        styleDiv(tParent);
        tSpan = createTag('span');
        styleDiv(tSpan);
        tParent.appendChild(tSpan);
      }
    } else {
      tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');
    }
    // tSpan.setAttribute('visibility', 'hidden');
    if (this.globalData.fontManager.chars) {
      var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
      var shapeData;
      if (charData) {
        shapeData = charData.data;
      } else {
        shapeData = null;
      }
      matrixHelper.reset();
      if (shapeData && shapeData.shapes) {
        shapes = shapeData.shapes[0].it;
        matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
        shapeStr = this.createPathShape(matrixHelper, shapes);
        tSpan.setAttribute('d', shapeStr);
      }
      if (!this.isMasked) {
        this.innerElem.appendChild(tParent);
        if (shapeData && shapeData.shapes) {
          // document.body.appendChild is needed to get exact measure of shape
          document.body.appendChild(tCont);
          var boundingBox = tCont.getBBox();
          tCont.setAttribute('width', boundingBox.width + 2);
          tCont.setAttribute('height', boundingBox.height + 2);
          tCont.setAttribute('viewBox', (boundingBox.x - 1) + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));
          var tContStyle = tCont.style;
          var tContTranslation = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';
          tContStyle.transform = tContTranslation;
          tContStyle.webkitTransform = tContTranslation;

          letters[i].yOffset = boundingBox.y - 1;
        } else {
          tCont.setAttribute('width', 1);
          tCont.setAttribute('height', 1);
        }
        tParent.appendChild(tCont);
      } else {
        this.innerElem.appendChild(tSpan);
      }
    } else {
      tSpan.textContent = letters[i].val;
      tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
      if (!this.isMasked) {
        this.innerElem.appendChild(tParent);
        //
        var tStyle = tSpan.style;
        var tSpanTranslation = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';
        tStyle.transform = tSpanTranslation;
        tStyle.webkitTransform = tSpanTranslation;
      } else {
        this.innerElem.appendChild(tSpan);
      }
    }
    //
    if (!this.isMasked) {
      this.textSpans[cnt] = tParent;
    } else {
      this.textSpans[cnt] = tSpan;
    }
    this.textSpans[cnt].style.display = 'block';
    this.textPaths[cnt] = tSpan;
    cnt += 1;
  }
  while (cnt < this.textSpans.length) {
    this.textSpans[cnt].style.display = 'none';
    cnt += 1;
  }
};

HTextElement.prototype.renderInnerContent = function () {
  var svgStyle;
  if (this.data.singleShape) {
    if (!this._isFirstFrame && !this.lettersChangedFlag) {
      return;
    } if (this.isMasked && this.finalTransform._matMdf) {
      // Todo Benchmark if using this is better than getBBox
      this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);
      svgStyle = this.svgElement.style;
      var translation = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
      svgStyle.transform = translation;
      svgStyle.webkitTransform = translation;
    }
  }

  this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
  if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
    return;
  }
  var i;
  var len;
  var count = 0;
  var renderedLetters = this.textAnimator.renderedLetters;

  var letters = this.textProperty.currentData.l;

  len = letters.length;
  var renderedLetter;
  var textSpan;
  var textPath;
  for (i = 0; i < len; i += 1) {
    if (letters[i].n) {
      count += 1;
    } else {
      textSpan = this.textSpans[i];
      textPath = this.textPaths[i];
      renderedLetter = renderedLetters[count];
      count += 1;
      if (renderedLetter._mdf.m) {
        if (!this.isMasked) {
          textSpan.style.webkitTransform = renderedLetter.m;
          textSpan.style.transform = renderedLetter.m;
        } else {
          textSpan.setAttribute('transform', renderedLetter.m);
        }
      }
      /// /textSpan.setAttribute('opacity',renderedLetter.o);
      textSpan.style.opacity = renderedLetter.o;
      if (renderedLetter.sw && renderedLetter._mdf.sw) {
        textPath.setAttribute('stroke-width', renderedLetter.sw);
      }
      if (renderedLetter.sc && renderedLetter._mdf.sc) {
        textPath.setAttribute('stroke', renderedLetter.sc);
      }
      if (renderedLetter.fc && renderedLetter._mdf.fc) {
        textPath.setAttribute('fill', renderedLetter.fc);
        textPath.style.color = renderedLetter.fc;
      }
    }
  }

  if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
    var boundingBox = this.innerElem.getBBox();

    if (this.currentBBox.w !== boundingBox.width) {
      this.currentBBox.w = boundingBox.width;
      this.svgElement.setAttribute('width', boundingBox.width);
    }
    if (this.currentBBox.h !== boundingBox.height) {
      this.currentBBox.h = boundingBox.height;
      this.svgElement.setAttribute('height', boundingBox.height);
    }

    var margin = 1;
    if (this.currentBBox.w !== (boundingBox.width + margin * 2) || this.currentBBox.h !== (boundingBox.height + margin * 2) || this.currentBBox.x !== (boundingBox.x - margin) || this.currentBBox.y !== (boundingBox.y - margin)) {
      this.currentBBox.w = boundingBox.width + margin * 2;
      this.currentBBox.h = boundingBox.height + margin * 2;
      this.currentBBox.x = boundingBox.x - margin;
      this.currentBBox.y = boundingBox.y - margin;

      this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
      svgStyle = this.svgElement.style;
      var svgTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
      svgStyle.transform = svgTransform;
      svgStyle.webkitTransform = svgTransform;
    }
  }
};

/* global extendPrototype, BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement,
FrameElement, RenderableElement, createNS */

function HImageElement(data, globalData, comp) {
  this.assetData = globalData.getAssetData(data.refId);
  this.initElement(data, globalData, comp);
}

extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);

HImageElement.prototype.createContent = function () {
  var assetPath = this.globalData.getAssetsPath(this.assetData);
  var img = new Image();

  if (this.data.hasMask) {
    this.imageElem = createNS('image');
    this.imageElem.setAttribute('width', this.assetData.w + 'px');
    this.imageElem.setAttribute('height', this.assetData.h + 'px');
    this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
    this.layerElement.appendChild(this.imageElem);
    this.baseElement.setAttribute('width', this.assetData.w);
    this.baseElement.setAttribute('height', this.assetData.h);
  } else {
    this.layerElement.appendChild(img);
  }
  img.crossOrigin = 'anonymous';
  img.src = assetPath;
  if (this.data.ln) {
    this.baseElement.setAttribute('id', this.data.ln);
  }
};

/* global PropertyFactory, degToRads, Matrix, extendPrototype, BaseElement, FrameElement, HierarchyElement */

function HCameraElement(data, globalData, comp) {
  this.initFrame();
  this.initBaseData(data, globalData, comp);
  this.initHierarchy();
  var getProp = PropertyFactory.getProp;
  this.pe = getProp(this, data.pe, 0, 0, this);
  if (data.ks.p.s) {
    this.px = getProp(this, data.ks.p.x, 1, 0, this);
    this.py = getProp(this, data.ks.p.y, 1, 0, this);
    this.pz = getProp(this, data.ks.p.z, 1, 0, this);
  } else {
    this.p = getProp(this, data.ks.p, 1, 0, this);
  }
  if (data.ks.a) {
    this.a = getProp(this, data.ks.a, 1, 0, this);
  }
  if (data.ks.or.k.length && data.ks.or.k[0].to) {
    var i;
    var len = data.ks.or.k.length;
    for (i = 0; i < len; i += 1) {
      data.ks.or.k[i].to = null;
      data.ks.or.k[i].ti = null;
    }
  }
  this.or = getProp(this, data.ks.or, 1, degToRads, this);
  this.or.sh = true;
  this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
  this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
  this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
  this.mat = new Matrix();
  this._prevMat = new Matrix();
  this._isFirstFrame = true;

  // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.
  this.finalTransform = {
    mProp: this,
  };
}
extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);

HCameraElement.prototype.setup = function () {
  var i;
  var len = this.comp.threeDElements.length;
  var comp;
  var perspectiveStyle;
  var containerStyle;
  for (i = 0; i < len; i += 1) {
    // [perspectiveElem,container]
    comp = this.comp.threeDElements[i];
    if (comp.type === '3d') {
      perspectiveStyle = comp.perspectiveElem.style;
      containerStyle = comp.container.style;
      var perspective = this.pe.v + 'px';
      var origin = '0px 0px 0px';
      var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
      perspectiveStyle.perspective = perspective;
      perspectiveStyle.webkitPerspective = perspective;
      containerStyle.transformOrigin = origin;
      containerStyle.mozTransformOrigin = origin;
      containerStyle.webkitTransformOrigin = origin;
      perspectiveStyle.transform = matrix;
      perspectiveStyle.webkitTransform = matrix;
    }
  }
};

HCameraElement.prototype.createElements = function () {
};

HCameraElement.prototype.hide = function () {
};

HCameraElement.prototype.renderFrame = function () {
  var _mdf = this._isFirstFrame;
  var i;
  var len;
  if (this.hierarchy) {
    len = this.hierarchy.length;
    for (i = 0; i < len; i += 1) {
      _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
    }
  }
  if (_mdf || this.pe._mdf || (this.p && this.p._mdf) || (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || (this.a && this.a._mdf)) {
    this.mat.reset();

    if (this.hierarchy) {
      len = this.hierarchy.length - 1;
      for (i = len; i >= 0; i -= 1) {
        var mTransf = this.hierarchy[i].finalTransform.mProp;
        this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
        this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
        this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
        this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
        this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
      }
    }
    if (this.p) {
      this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
    } else {
      this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
    }
    if (this.a) {
      var diffVector;
      if (this.p) {
        diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
      } else {
        diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
      }
      var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
      // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
      var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
      var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
      var mRotationX = (Math.atan2(lookDir[1], lookLengthOnXZ));
      var mRotationY = (Math.atan2(lookDir[0], -lookDir[2]));
      this.mat.rotateY(mRotationY).rotateX(-mRotationX);
    }
    this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
    this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
    this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
    this.mat.translate(0, 0, this.pe.v);

    var hasMatrixChanged = !this._prevMat.equals(this.mat);
    if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
      len = this.comp.threeDElements.length;
      var comp;
      var perspectiveStyle;
      var containerStyle;
      for (i = 0; i < len; i += 1) {
        comp = this.comp.threeDElements[i];
        if (comp.type === '3d') {
          if (hasMatrixChanged) {
            var matValue = this.mat.toCSS();
            containerStyle = comp.container.style;
            containerStyle.transform = matValue;
            containerStyle.webkitTransform = matValue;
          }
          if (this.pe._mdf) {
            perspectiveStyle = comp.perspectiveElem.style;
            perspectiveStyle.perspective = this.pe.v + 'px';
            perspectiveStyle.webkitPerspective = this.pe.v + 'px';
          }
        }
      }
      this.mat.clone(this._prevMat);
    }
  }
  this._isFirstFrame = false;
};

HCameraElement.prototype.prepareFrame = function (num) {
  this.prepareProperties(num, true);
};

HCameraElement.prototype.destroy = function () {
};
HCameraElement.prototype.getBaseElement = function () { return null; };

function HEffects() {
}
HEffects.prototype.renderFrame = function () {};

/* global createTag, AnimationItem */
/* exported animationManager */

var animationManager = (function () {
  var moduleOb = {};
  var registeredAnimations = [];
  var initTime = 0;
  var len = 0;
  var playingAnimationsNum = 0;
  var _stopped = true;
  var _isFrozen = false;

  function removeElement(ev) {
    var i = 0;
    var animItem = ev.target;
    while (i < len) {
      if (registeredAnimations[i].animation === animItem) {
        registeredAnimations.splice(i, 1);
        i -= 1;
        len -= 1;
        if (!animItem.isPaused) {
          subtractPlayingCount();
        }
      }
      i += 1;
    }
  }

  function registerAnimation(element, animationData) {
    if (!element) {
      return null;
    }
    var i = 0;
    while (i < len) {
      if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {
        return registeredAnimations[i].animation;
      }
      i += 1;
    }
    var animItem = new AnimationItem();
    setupAnimation(animItem, element);
    animItem.setData(element, animationData);
    return animItem;
  }

  function getRegisteredAnimations() {
    var i;
    var lenAnims = registeredAnimations.length;
    var animations = [];
    for (i = 0; i < lenAnims; i += 1) {
      animations.push(registeredAnimations[i].animation);
    }
    return animations;
  }

  function addPlayingCount() {
    playingAnimationsNum += 1;
    activate();
  }

  function subtractPlayingCount() {
    playingAnimationsNum -= 1;
  }

  function setupAnimation(animItem, element) {
    animItem.addEventListener('destroy', removeElement);
    animItem.addEventListener('_active', addPlayingCount);
    animItem.addEventListener('_idle', subtractPlayingCount);
    registeredAnimations.push({ elem: element, animation: animItem });
    len += 1;
  }

  function loadAnimation(params) {
    var animItem = new AnimationItem();
    setupAnimation(animItem, null);
    animItem.setParams(params);
    return animItem;
  }

  function setSpeed(val, animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.setSpeed(val, animation);
    }
  }

  function setDirection(val, animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.setDirection(val, animation);
    }
  }

  function play(animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.play(animation);
    }
  }
  function resume(nowTime) {
    var elapsedTime = nowTime - initTime;
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.advanceTime(elapsedTime);
    }
    initTime = nowTime;
    if (playingAnimationsNum && !_isFrozen) {
      window.requestAnimationFrame(resume);
    } else {
      _stopped = true;
    }
  }

  function first(nowTime) {
    initTime = nowTime;
    window.requestAnimationFrame(resume);
  }

  function pause(animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.pause(animation);
    }
  }

  function goToAndStop(value, isFrame, animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);
    }
  }

  function stop(animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.stop(animation);
    }
  }

  function togglePause(animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.togglePause(animation);
    }
  }

  function destroy(animation) {
    var i;
    for (i = (len - 1); i >= 0; i -= 1) {
      registeredAnimations[i].animation.destroy(animation);
    }
  }

  function searchAnimations(animationData, standalone, renderer) {
    var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')),
      [].slice.call(document.getElementsByClassName('bodymovin')));
    var i;
    var lenAnims = animElements.length;
    for (i = 0; i < lenAnims; i += 1) {
      if (renderer) {
        animElements[i].setAttribute('data-bm-type', renderer);
      }
      registerAnimation(animElements[i], animationData);
    }
    if (standalone && lenAnims === 0) {
      if (!renderer) {
        renderer = 'svg';
      }
      var body = document.getElementsByTagName('body')[0];
      body.innerText = '';
      var div = createTag('div');
      div.style.width = '100%';
      div.style.height = '100%';
      div.setAttribute('data-bm-type', renderer);
      body.appendChild(div);
      registerAnimation(div, animationData);
    }
  }

  function resize() {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.resize();
    }
  }

  function activate() {
    if (!_isFrozen && playingAnimationsNum) {
      if (_stopped) {
        window.requestAnimationFrame(first);
        _stopped = false;
      }
    }
  }

  function freeze() {
    _isFrozen = true;
  }

  function unfreeze() {
    _isFrozen = false;
    activate();
  }

  function setVolume(val, animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.setVolume(val, animation);
    }
  }

  function mute(animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.mute(animation);
    }
  }

  function unmute(animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.unmute(animation);
    }
  }

  moduleOb.registerAnimation = registerAnimation;
  moduleOb.loadAnimation = loadAnimation;
  moduleOb.setSpeed = setSpeed;
  moduleOb.setDirection = setDirection;
  moduleOb.play = play;
  moduleOb.pause = pause;
  moduleOb.stop = stop;
  moduleOb.togglePause = togglePause;
  moduleOb.searchAnimations = searchAnimations;
  moduleOb.resize = resize;
  // moduleOb.start = start;
  moduleOb.goToAndStop = goToAndStop;
  moduleOb.destroy = destroy;
  moduleOb.freeze = freeze;
  moduleOb.unfreeze = unfreeze;
  moduleOb.setVolume = setVolume;
  moduleOb.mute = mute;
  moduleOb.unmute = unmute;
  moduleOb.getRegisteredAnimations = getRegisteredAnimations;
  return moduleOb;
}());

/* global createElementID, subframeEnabled, ProjectInterface, ImagePreloader, audioControllerFactory, extendPrototype, BaseEvent,
CanvasRenderer, SVGRenderer, HybridRenderer, assetLoader, dataManager, expressionsPlugin, BMEnterFrameEvent, BMCompleteLoopEvent,
BMCompleteEvent, BMSegmentStartEvent, BMDestroyEvent, BMEnterFrameEvent, BMCompleteLoopEvent, BMCompleteEvent, BMSegmentStartEvent,
BMDestroyEvent, BMRenderFrameErrorEvent, BMConfigErrorEvent, markerParser */

var AnimationItem = function () {
  this._cbs = [];
  this.name = '';
  this.path = '';
  this.isLoaded = false;
  this.currentFrame = 0;
  this.currentRawFrame = 0;
  this.firstFrame = 0;
  this.totalFrames = 0;
  this.frameRate = 0;
  this.frameMult = 0;
  this.playSpeed = 1;
  this.playDirection = 1;
  this.playCount = 0;
  this.animationData = {};
  this.assets = [];
  this.isPaused = true;
  this.autoplay = false;
  this.loop = true;
  this.renderer = null;
  this.animationID = createElementID();
  this.assetsPath = '';
  this.timeCompleted = 0;
  this.segmentPos = 0;
  this.isSubframeEnabled = subframeEnabled;
  this.segments = [];
  this._idle = true;
  this._completedLoop = false;
  this.projectInterface = ProjectInterface();
  this.imagePreloader = new ImagePreloader();
  this.audioController = audioControllerFactory();
  this.markers = [];
};

extendPrototype([BaseEvent], AnimationItem);

AnimationItem.prototype.setParams = function (params) {
  if (params.wrapper || params.container) {
    this.wrapper = params.wrapper || params.container;
  }
  var animType = 'svg';
  if (params.animType) {
    animType = params.animType;
  } else if (params.renderer) {
    animType = params.renderer;
  }
  switch (animType) {
    case 'canvas':
      this.renderer = new CanvasRenderer(this, params.rendererSettings);
      break;
    case 'svg':
      this.renderer = new SVGRenderer(this, params.rendererSettings);
      break;
    default:
      this.renderer = new HybridRenderer(this, params.rendererSettings);
      break;
  }
  this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
  this.renderer.setProjectInterface(this.projectInterface);
  this.animType = animType;
  if (params.loop === ''
        || params.loop === null
        || params.loop === undefined
        || params.loop === true) {
    this.loop = true;
  } else if (params.loop === false) {
    this.loop = false;
  } else {
    this.loop = parseInt(params.loop, 10);
  }
  this.autoplay = 'autoplay' in params ? params.autoplay : true;
  this.name = params.name ? params.name : '';
  this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments') ? params.autoloadSegments : true;
  this.assetsPath = params.assetsPath;
  this.initialSegment = params.initialSegment;
  if (params.audioFactory) {
    this.audioController.setAudioFactory(params.audioFactory);
  }
  if (params.animationData) {
    this.configAnimation(params.animationData);
  } else if (params.path) {
    if (params.path.lastIndexOf('\\') !== -1) {
      this.path = params.path.substr(0, params.path.lastIndexOf('\\') + 1);
    } else {
      this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);
    }
    this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);
    this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));

    assetLoader.load(params.path, this.configAnimation.bind(this), function () {
      this.trigger('data_failed');
    }.bind(this));
  }
};

AnimationItem.prototype.setData = function (wrapper, animationData) {
  if (animationData) {
    if (typeof animationData !== 'object') {
      animationData = JSON.parse(animationData);
    }
  }
  var params = {
    wrapper: wrapper,
    animationData: animationData,
  };
  var wrapperAttributes = wrapper.attributes;

  params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary
    ? wrapperAttributes.getNamedItem('data-animation-path').value
    : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-path').value
      : wrapperAttributes.getNamedItem('bm-path')
        ? wrapperAttributes.getNamedItem('bm-path').value
        : '';
  params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary
    ? wrapperAttributes.getNamedItem('data-anim-type').value
    : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-type').value
      : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('bm-type').value
        : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary
          ? wrapperAttributes.getNamedItem('data-bm-renderer').value
          : wrapperAttributes.getNamedItem('bm-renderer')
            ? wrapperAttributes.getNamedItem('bm-renderer').value
            : 'canvas';

  var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary
    ? wrapperAttributes.getNamedItem('data-anim-loop').value
    : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-loop').value
      : wrapperAttributes.getNamedItem('bm-loop')
        ? wrapperAttributes.getNamedItem('bm-loop').value
        : '';
  if (loop === 'false') {
    params.loop = false;
  } else if (loop === 'true') {
    params.loop = true;
  } else if (loop !== '') {
    params.loop = parseInt(loop, 10);
  }
  var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary
    ? wrapperAttributes.getNamedItem('data-anim-autoplay').value
    : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-autoplay').value
      : wrapperAttributes.getNamedItem('bm-autoplay')
        ? wrapperAttributes.getNamedItem('bm-autoplay').value
        : true;
  params.autoplay = autoplay !== 'false';

  params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary
    ? wrapperAttributes.getNamedItem('data-name').value
    : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-name').value
      : wrapperAttributes.getNamedItem('bm-name')
        ? wrapperAttributes.getNamedItem('bm-name').value
        : '';
  var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary
    ? wrapperAttributes.getNamedItem('data-anim-prerender').value
    : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-prerender').value
      : wrapperAttributes.getNamedItem('bm-prerender')
        ? wrapperAttributes.getNamedItem('bm-prerender').value
        : '';

  if (prerender === 'false') {
    params.prerender = false;
  }
  this.setParams(params);
};

AnimationItem.prototype.includeLayers = function (data) {
  if (data.op > this.animationData.op) {
    this.animationData.op = data.op;
    this.totalFrames = Math.floor(data.op - this.animationData.ip);
  }
  var layers = this.animationData.layers;
  var i;
  var len = layers.length;
  var newLayers = data.layers;
  var j;
  var jLen = newLayers.length;
  for (j = 0; j < jLen; j += 1) {
    i = 0;
    while (i < len) {
      if (layers[i].id === newLayers[j].id) {
        layers[i] = newLayers[j];
        break;
      }
      i += 1;
    }
  }
  if (data.chars || data.fonts) {
    this.renderer.globalData.fontManager.addChars(data.chars);
    this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
  }
  if (data.assets) {
    len = data.assets.length;
    for (i = 0; i < len; i += 1) {
      this.animationData.assets.push(data.assets[i]);
    }
  }
  this.animationData.__complete = false;
  dataManager.completeData(this.animationData, this.renderer.globalData.fontManager);
  this.renderer.includeLayers(data.layers);
  if (expressionsPlugin) {
    expressionsPlugin.initExpressions(this);
  }
  this.loadNextSegment();
};

AnimationItem.prototype.loadNextSegment = function () {
  var segments = this.animationData.segments;
  if (!segments || segments.length === 0 || !this.autoloadSegments) {
    this.trigger('data_ready');
    this.timeCompleted = this.totalFrames;
    return;
  }
  var segment = segments.shift();
  this.timeCompleted = segment.time * this.frameRate;
  var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';
  this.segmentPos += 1;
  assetLoader.load(segmentPath, this.includeLayers.bind(this), function () {
    this.trigger('data_failed');
  }.bind(this));
};

AnimationItem.prototype.loadSegments = function () {
  var segments = this.animationData.segments;
  if (!segments) {
    this.timeCompleted = this.totalFrames;
  }
  this.loadNextSegment();
};

AnimationItem.prototype.imagesLoaded = function () {
  this.trigger('loaded_images');
  this.checkLoaded();
};

AnimationItem.prototype.preloadImages = function () {
  this.imagePreloader.setAssetsPath(this.assetsPath);
  this.imagePreloader.setPath(this.path);
  this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
};

AnimationItem.prototype.configAnimation = function (animData) {
  if (!this.renderer) {
    return;
  }
  try {
    this.animationData = animData;

    if (this.initialSegment) {
      this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
      this.firstFrame = Math.round(this.initialSegment[0]);
    } else {
      this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
      this.firstFrame = Math.round(this.animationData.ip);
    }
    this.renderer.configAnimation(animData);
    if (!animData.assets) {
      animData.assets = [];
    }

    this.assets = this.animationData.assets;
    this.frameRate = this.animationData.fr;
    this.frameMult = this.animationData.fr / 1000;
    this.renderer.searchExtraCompositions(animData.assets);
    this.markers = markerParser(animData.markers || []);
    this.trigger('config_ready');
    this.preloadImages();
    this.loadSegments();
    this.updaFrameModifier();
    this.waitForFontsLoaded();
    if (this.isPaused) {
      this.audioController.pause();
    }
  } catch (error) {
    this.triggerConfigError(error);
  }
};

AnimationItem.prototype.waitForFontsLoaded = function () {
  if (!this.renderer) {
    return;
  }
  if (this.renderer.globalData.fontManager.isLoaded) {
    this.checkLoaded();
  } else {
    setTimeout(this.waitForFontsLoaded.bind(this), 20);
  }
};

AnimationItem.prototype.checkLoaded = function () {
  if (!this.isLoaded
        && this.renderer.globalData.fontManager.isLoaded
        && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas')
        && (this.imagePreloader.loadedFootages())
  ) {
    this.isLoaded = true;
    dataManager.completeData(this.animationData, this.renderer.globalData.fontManager);
    if (expressionsPlugin) {
      expressionsPlugin.initExpressions(this);
    }
    this.renderer.initItems();
    setTimeout(function () {
      this.trigger('DOMLoaded');
    }.bind(this), 0);
    this.gotoFrame();
    if (this.autoplay) {
      this.play();
    }
  }
};

AnimationItem.prototype.resize = function () {
  this.renderer.updateContainerSize();
};

AnimationItem.prototype.setSubframe = function (flag) {
  this.isSubframeEnabled = !!flag;
};

AnimationItem.prototype.gotoFrame = function () {
  this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise

  if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
    this.currentFrame = this.timeCompleted;
  }
  this.trigger('enterFrame');
  this.renderFrame();
};

AnimationItem.prototype.renderFrame = function () {
  if (this.isLoaded === false || !this.renderer) {
    return;
  }
  try {
    this.renderer.renderFrame(this.currentFrame + this.firstFrame);
  } catch (error) {
    this.triggerRenderFrameError(error);
  }
};

AnimationItem.prototype.play = function (name) {
  if (name && this.name !== name) {
    return;
  }
  if (this.isPaused === true) {
    this.isPaused = false;
    this.audioController.resume();
    if (this._idle) {
      this._idle = false;
      this.trigger('_active');
    }
  }
};

AnimationItem.prototype.pause = function (name) {
  if (name && this.name !== name) {
    return;
  }
  if (this.isPaused === false) {
    this.isPaused = true;
    this._idle = true;
    this.trigger('_idle');
    this.audioController.pause();
  }
};

AnimationItem.prototype.togglePause = function (name) {
  if (name && this.name !== name) {
    return;
  }
  if (this.isPaused === true) {
    this.play();
  } else {
    this.pause();
  }
};

AnimationItem.prototype.stop = function (name) {
  if (name && this.name !== name) {
    return;
  }
  this.pause();
  this.playCount = 0;
  this._completedLoop = false;
  this.setCurrentRawFrameValue(0);
};

AnimationItem.prototype.getMarkerData = function (markerName) {
  var marker;
  for (var i = 0; i < this.markers.length; i += 1) {
    marker = this.markers[i];
    if (marker.payload && marker.payload.name === markerName) {
      return marker;
    }
  }
  return null;
};

AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
  if (name && this.name !== name) {
    return;
  }
  var numValue = Number(value);
  if (isNaN(numValue)) {
    var marker = this.getMarkerData(value);
    if (marker) {
      this.goToAndStop(marker.time, true);
    }
  } else if (isFrame) {
    this.setCurrentRawFrameValue(value);
  } else {
    this.setCurrentRawFrameValue(value * this.frameModifier);
  }
  this.pause();
};

AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
  if (name && this.name !== name) {
    return;
  }
  var numValue = Number(value);
  if (isNaN(numValue)) {
    var marker = this.getMarkerData(value);
    if (marker) {
      if (!marker.duration) {
        this.goToAndStop(marker.time, true);
      } else {
        this.playSegments([marker.time, marker.time + marker.duration], true);
      }
    }
  } else {
    this.goToAndStop(numValue, isFrame, name);
  }
  this.play();
};

AnimationItem.prototype.advanceTime = function (value) {
  if (this.isPaused === true || this.isLoaded === false) {
    return;
  }
  var nextValue = this.currentRawFrame + value * this.frameModifier;
  var _isComplete = false;
  // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
  // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.
  if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
    if (!this.loop || this.playCount === this.loop) {
      if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
        _isComplete = true;
        nextValue = this.totalFrames - 1;
      }
    } else if (nextValue >= this.totalFrames) {
      this.playCount += 1;
      if (!this.checkSegments(nextValue % this.totalFrames)) {
        this.setCurrentRawFrameValue(nextValue % this.totalFrames);
        this._completedLoop = true;
        this.trigger('loopComplete');
      }
    } else {
      this.setCurrentRawFrameValue(nextValue);
    }
  } else if (nextValue < 0) {
    if (!this.checkSegments(nextValue % this.totalFrames)) {
      if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) { // eslint-disable-line no-plusplus
        this.setCurrentRawFrameValue(this.totalFrames + (nextValue % this.totalFrames));
        if (!this._completedLoop) {
          this._completedLoop = true;
        } else {
          this.trigger('loopComplete');
        }
      } else {
        _isComplete = true;
        nextValue = 0;
      }
    }
  } else {
    this.setCurrentRawFrameValue(nextValue);
  }
  if (_isComplete) {
    this.setCurrentRawFrameValue(nextValue);
    this.pause();
    this.trigger('complete');
  }
};

AnimationItem.prototype.adjustSegment = function (arr, offset) {
  this.playCount = 0;
  if (arr[1] < arr[0]) {
    if (this.frameModifier > 0) {
      if (this.playSpeed < 0) {
        this.setSpeed(-this.playSpeed);
      } else {
        this.setDirection(-1);
      }
    }
    this.totalFrames = arr[0] - arr[1];
    this.timeCompleted = this.totalFrames;
    this.firstFrame = arr[1];
    this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
  } else if (arr[1] > arr[0]) {
    if (this.frameModifier < 0) {
      if (this.playSpeed < 0) {
        this.setSpeed(-this.playSpeed);
      } else {
        this.setDirection(1);
      }
    }
    this.totalFrames = arr[1] - arr[0];
    this.timeCompleted = this.totalFrames;
    this.firstFrame = arr[0];
    this.setCurrentRawFrameValue(0.001 + offset);
  }
  this.trigger('segmentStart');
};
AnimationItem.prototype.setSegment = function (init, end) {
  var pendingFrame = -1;
  if (this.isPaused) {
    if (this.currentRawFrame + this.firstFrame < init) {
      pendingFrame = init;
    } else if (this.currentRawFrame + this.firstFrame > end) {
      pendingFrame = end - init;
    }
  }

  this.firstFrame = init;
  this.totalFrames = end - init;
  this.timeCompleted = this.totalFrames;
  if (pendingFrame !== -1) {
    this.goToAndStop(pendingFrame, true);
  }
};

AnimationItem.prototype.playSegments = function (arr, forceFlag) {
  if (forceFlag) {
    this.segments.length = 0;
  }
  if (typeof arr[0] === 'object') {
    var i;
    var len = arr.length;
    for (i = 0; i < len; i += 1) {
      this.segments.push(arr[i]);
    }
  } else {
    this.segments.push(arr);
  }
  if (this.segments.length && forceFlag) {
    this.adjustSegment(this.segments.shift(), 0);
  }
  if (this.isPaused) {
    this.play();
  }
};

AnimationItem.prototype.resetSegments = function (forceFlag) {
  this.segments.length = 0;
  this.segments.push([this.animationData.ip, this.animationData.op]);
  // this.segments.push([this.animationData.ip*this.frameRate,Math.floor(this.animationData.op - this.animationData.ip+this.animationData.ip*this.frameRate)]);
  if (forceFlag) {
    this.checkSegments(0);
  }
};
AnimationItem.prototype.checkSegments = function (offset) {
  if (this.segments.length) {
    this.adjustSegment(this.segments.shift(), offset);
    return true;
  }
  return false;
};

AnimationItem.prototype.destroy = function (name) {
  if ((name && this.name !== name) || !this.renderer) {
    return;
  }
  this.renderer.destroy();
  this.imagePreloader.destroy();
  this.trigger('destroy');
  this._cbs = null;
  this.onEnterFrame = null;
  this.onLoopComplete = null;
  this.onComplete = null;
  this.onSegmentStart = null;
  this.onDestroy = null;
  this.renderer = null;
  this.renderer = null;
  this.imagePreloader = null;
  this.projectInterface = null;
};

AnimationItem.prototype.setCurrentRawFrameValue = function (value) {
  this.currentRawFrame = value;
  this.gotoFrame();
};

AnimationItem.prototype.setSpeed = function (val) {
  this.playSpeed = val;
  this.updaFrameModifier();
};

AnimationItem.prototype.setDirection = function (val) {
  this.playDirection = val < 0 ? -1 : 1;
  this.updaFrameModifier();
};

AnimationItem.prototype.setVolume = function (val, name) {
  if (name && this.name !== name) {
    return;
  }
  this.audioController.setVolume(val);
};

AnimationItem.prototype.getVolume = function () {
  return this.audioController.getVolume();
};

AnimationItem.prototype.mute = function (name) {
  if (name && this.name !== name) {
    return;
  }
  this.audioController.mute();
};

AnimationItem.prototype.unmute = function (name) {
  if (name && this.name !== name) {
    return;
  }
  this.audioController.unmute();
};

AnimationItem.prototype.updaFrameModifier = function () {
  this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
  this.audioController.setRate(this.playSpeed * this.playDirection);
};

AnimationItem.prototype.getPath = function () {
  return this.path;
};

AnimationItem.prototype.getAssetsPath = function (assetData) {
  var path = '';
  if (assetData.e) {
    path = assetData.p;
  } else if (this.assetsPath) {
    var imagePath = assetData.p;
    if (imagePath.indexOf('images/') !== -1) {
      imagePath = imagePath.split('/')[1];
    }
    path = this.assetsPath + imagePath;
  } else {
    path = this.path;
    path += assetData.u ? assetData.u : '';
    path += assetData.p;
  }
  return path;
};

AnimationItem.prototype.getAssetData = function (id) {
  var i = 0;
  var len = this.assets.length;
  while (i < len) {
    if (id === this.assets[i].id) {
      return this.assets[i];
    }
    i += 1;
  }
  return null;
};

AnimationItem.prototype.hide = function () {
  this.renderer.hide();
};

AnimationItem.prototype.show = function () {
  this.renderer.show();
};

AnimationItem.prototype.getDuration = function (isFrame) {
  return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
};

AnimationItem.prototype.trigger = function (name) {
  if (this._cbs && this._cbs[name]) {
    switch (name) {
      case 'enterFrame':
        this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
        break;
      case 'loopComplete':
        this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
        break;
      case 'complete':
        this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
        break;
      case 'segmentStart':
        this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
        break;
      case 'destroy':
        this.triggerEvent(name, new BMDestroyEvent(name, this));
        break;
      default:
        this.triggerEvent(name);
    }
  }
  if (name === 'enterFrame' && this.onEnterFrame) {
    this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
  }
  if (name === 'loopComplete' && this.onLoopComplete) {
    this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
  }
  if (name === 'complete' && this.onComplete) {
    this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
  }
  if (name === 'segmentStart' && this.onSegmentStart) {
    this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
  }
  if (name === 'destroy' && this.onDestroy) {
    this.onDestroy.call(this, new BMDestroyEvent(name, this));
  }
};

AnimationItem.prototype.triggerRenderFrameError = function (nativeError) {
  var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
  this.triggerEvent('error', error);

  if (this.onError) {
    this.onError.call(this, error);
  }
};

AnimationItem.prototype.triggerConfigError = function (nativeError) {
  var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
  this.triggerEvent('error', error);

  if (this.onError) {
    this.onError.call(this, error);
  }
};

/* global CompExpressionInterface, expressionsPlugin: writable */
/* exported expressionsPlugin */

var Expressions = (function () {
  var ob = {};
  ob.initExpressions = initExpressions;

  function initExpressions(animation) {
    var stackCount = 0;
    var registers = [];

    function pushExpression() {
      stackCount += 1;
    }

    function popExpression() {
      stackCount -= 1;
      if (stackCount === 0) {
        releaseInstances();
      }
    }

    function registerExpressionProperty(expression) {
      if (registers.indexOf(expression) === -1) {
        registers.push(expression);
      }
    }

    function releaseInstances() {
      var i;
      var len = registers.length;
      for (i = 0; i < len; i += 1) {
        registers[i].release();
      }
      registers.length = 0;
    }

    animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
    animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
    animation.renderer.globalData.pushExpression = pushExpression;
    animation.renderer.globalData.popExpression = popExpression;
    animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
  }
  return ob;
}());

expressionsPlugin = Expressions;

/* eslint-disable camelcase, no-unused-vars */
/* global BMMath, BezierFactory, createTypedArray, degToRads, shapePool */

var ExpressionManager = (function () {
  'use strict';

  var ob = {};
  var Math = BMMath;
  var window = null;
  var document = null;
  var XMLHttpRequest = null;
  var fetch = null;

  function $bm_isInstanceOfArray(arr) {
    return arr.constructor === Array || arr.constructor === Float32Array;
  }

  function isNumerable(tOfV, v) {
    return tOfV === 'number' || tOfV === 'boolean' || tOfV === 'string' || v instanceof Number;
  }

  function $bm_neg(a) {
    var tOfA = typeof a;
    if (tOfA === 'number' || tOfA === 'boolean' || a instanceof Number) {
      return -a;
    }
    if ($bm_isInstanceOfArray(a)) {
      var i;
      var lenA = a.length;
      var retArr = [];
      for (i = 0; i < lenA; i += 1) {
        retArr[i] = -a[i];
      }
      return retArr;
    }
    if (a.propType) {
      return a.v;
    }
    return -a;
  }

  var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;
  var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;
  var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;

  function sum(a, b) {
    var tOfA = typeof a;
    var tOfB = typeof b;
    if (tOfA === 'string' || tOfB === 'string') {
      return a + b;
    }
    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
      return a + b;
    }
    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
      a = a.slice(0);
      a[0] += b;
      return a;
    }
    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
      b = b.slice(0);
      b[0] = a + b[0];
      return b;
    }
    if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
      var i = 0;
      var lenA = a.length;
      var lenB = b.length;
      var retArr = [];
      while (i < lenA || i < lenB) {
        if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
          retArr[i] = a[i] + b[i];
        } else {
          retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
        }
        i += 1;
      }
      return retArr;
    }
    return 0;
  }
  var add = sum;

  function sub(a, b) {
    var tOfA = typeof a;
    var tOfB = typeof b;
    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
      if (tOfA === 'string') {
        a = parseInt(a, 10);
      }
      if (tOfB === 'string') {
        b = parseInt(b, 10);
      }
      return a - b;
    }
    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
      a = a.slice(0);
      a[0] -= b;
      return a;
    }
    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
      b = b.slice(0);
      b[0] = a - b[0];
      return b;
    }
    if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
      var i = 0;
      var lenA = a.length;
      var lenB = b.length;
      var retArr = [];
      while (i < lenA || i < lenB) {
        if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
          retArr[i] = a[i] - b[i];
        } else {
          retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
        }
        i += 1;
      }
      return retArr;
    }
    return 0;
  }

  function mul(a, b) {
    var tOfA = typeof a;
    var tOfB = typeof b;
    var arr;
    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
      return a * b;
    }

    var i;
    var len;
    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
      len = a.length;
      arr = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        arr[i] = a[i] * b;
      }
      return arr;
    }
    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
      len = b.length;
      arr = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        arr[i] = a * b[i];
      }
      return arr;
    }
    return 0;
  }

  function div(a, b) {
    var tOfA = typeof a;
    var tOfB = typeof b;
    var arr;
    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
      return a / b;
    }
    var i;
    var len;
    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
      len = a.length;
      arr = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        arr[i] = a[i] / b;
      }
      return arr;
    }
    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
      len = b.length;
      arr = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        arr[i] = a / b[i];
      }
      return arr;
    }
    return 0;
  }
  function mod(a, b) {
    if (typeof a === 'string') {
      a = parseInt(a, 10);
    }
    if (typeof b === 'string') {
      b = parseInt(b, 10);
    }
    return a % b;
  }
  var $bm_sum = sum;
  var $bm_sub = sub;
  var $bm_mul = mul;
  var $bm_div = div;
  var $bm_mod = mod;

  function clamp(num, min, max) {
    if (min > max) {
      var mm = max;
      max = min;
      min = mm;
    }
    return Math.min(Math.max(num, min), max);
  }

  function radiansToDegrees(val) {
    return val / degToRads;
  }
  var radians_to_degrees = radiansToDegrees;

  function degreesToRadians(val) {
    return val * degToRads;
  }
  var degrees_to_radians = radiansToDegrees;

  var helperLengthArray = [0, 0, 0, 0, 0, 0];

  function length(arr1, arr2) {
    if (typeof arr1 === 'number' || arr1 instanceof Number) {
      arr2 = arr2 || 0;
      return Math.abs(arr1 - arr2);
    }
    if (!arr2) {
      arr2 = helperLengthArray;
    }
    var i;
    var len = Math.min(arr1.length, arr2.length);
    var addedLength = 0;
    for (i = 0; i < len; i += 1) {
      addedLength += Math.pow(arr2[i] - arr1[i], 2);
    }
    return Math.sqrt(addedLength);
  }

  function normalize(vec) {
    return div(vec, length(vec));
  }

  function rgbToHsl(val) {
    var r = val[0]; var g = val[1]; var b = val[2];
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h;
    var s;
    var l = (max + min) / 2;

    if (max === min) {
      h = 0; // achromatic
      s = 0; // achromatic
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
        default: break;
      }
      h /= 6;
    }

    return [h, s, l, val[3]];
  }

  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }

  function hslToRgb(val) {
    var h = val[0];
    var s = val[1];
    var l = val[2];

    var r;
    var g;
    var b;

    if (s === 0) {
      r = l; // achromatic
      b = l; // achromatic
      g = l; // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r, g, b, val[3]];
  }

  function linear(t, tMin, tMax, value1, value2) {
    if (value1 === undefined || value2 === undefined) {
      value1 = tMin;
      value2 = tMax;
      tMin = 0;
      tMax = 1;
    }
    if (tMax < tMin) {
      var _tMin = tMax;
      tMax = tMin;
      tMin = _tMin;
    }
    if (t <= tMin) {
      return value1;
    } if (t >= tMax) {
      return value2;
    }
    var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
    if (!value1.length) {
      return value1 + (value2 - value1) * perc;
    }
    var i;
    var len = value1.length;
    var arr = createTypedArray('float32', len);
    for (i = 0; i < len; i += 1) {
      arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
    }
    return arr;
  }
  function random(min, max) {
    if (max === undefined) {
      if (min === undefined) {
        min = 0;
        max = 1;
      } else {
        max = min;
        min = undefined;
      }
    }
    if (max.length) {
      var i;
      var len = max.length;
      if (!min) {
        min = createTypedArray('float32', len);
      }
      var arr = createTypedArray('float32', len);
      var rnd = BMMath.random();
      for (i = 0; i < len; i += 1) {
        arr[i] = min[i] + rnd * (max[i] - min[i]);
      }
      return arr;
    }
    if (min === undefined) {
      min = 0;
    }
    var rndm = BMMath.random();
    return min + rndm * (max - min);
  }

  function createPath(points, inTangents, outTangents, closed) {
    var i;
    var len = points.length;
    var path = shapePool.newElement();
    path.setPathData(!!closed, len);
    var arrPlaceholder = [0, 0];
    var inVertexPoint;
    var outVertexPoint;
    for (i = 0; i < len; i += 1) {
      inVertexPoint = (inTangents && inTangents[i]) ? inTangents[i] : arrPlaceholder;
      outVertexPoint = (outTangents && outTangents[i]) ? outTangents[i] : arrPlaceholder;
      path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
    }
    return path;
  }

  function initiateExpression(elem, data, property) {
    var val = data.x;
    var needsVelocity = /velocity(?![\w\d])/.test(val);
    var _needsRandom = val.indexOf('random') !== -1;
    var elemType = elem.data.ty;
    var transform;
    var $bm_transform;
    var content;
    var effect;
    var thisProperty = property;
    thisProperty.valueAtTime = thisProperty.getValueAtTime;
    Object.defineProperty(thisProperty, 'value', {
      get: function () {
        return thisProperty.v;
      },
    });
    elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
    elem.comp.displayStartTime = 0;
    var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
    var outPoint = elem.data.op / elem.comp.globalData.frameRate;
    var width = elem.data.sw ? elem.data.sw : 0;
    var height = elem.data.sh ? elem.data.sh : 0;
    var name = elem.data.nm;
    var loopIn;
    var loop_in;
    var loopOut;
    var loop_out;
    var smooth;
    var toWorld;
    var fromWorld;
    var fromComp;
    var toComp;
    var fromCompToSurface;
    var position;
    var rotation;
    var anchorPoint;
    var scale;
    var thisLayer;
    var thisComp;
    var mask;
    var valueAtTime;
    var velocityAtTime;

    var scoped_bm_rt;
    // val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls
    var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0]; // eslint-disable-line no-eval
    var numKeys = property.kf ? data.k.length : 0;

    var active = !this.data || this.data.hd !== true;

    var wiggle = function wiggle(freq, amp) {
      var iWiggle;
      var j;
      var lenWiggle = this.pv.length ? this.pv.length : 1;
      var addedAmps = createTypedArray('float32', lenWiggle);
      freq = 5;
      var iterations = Math.floor(time * freq);
      iWiggle = 0;
      j = 0;
      while (iWiggle < iterations) {
        // var rnd = BMMath.random();
        for (j = 0; j < lenWiggle; j += 1) {
          addedAmps[j] += -amp + amp * 2 * BMMath.random();
          // addedAmps[j] += -amp + amp*2*rnd;
        }
        iWiggle += 1;
      }
      // var rnd2 = BMMath.random();
      var periods = time * freq;
      var perc = periods - Math.floor(periods);
      var arr = createTypedArray('float32', lenWiggle);
      if (lenWiggle > 1) {
        for (j = 0; j < lenWiggle; j += 1) {
          arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;
          // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
          // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
        }
        return arr;
      }
      return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
    }.bind(this);

    if (thisProperty.loopIn) {
      loopIn = thisProperty.loopIn.bind(thisProperty);
      loop_in = loopIn;
    }

    if (thisProperty.loopOut) {
      loopOut = thisProperty.loopOut.bind(thisProperty);
      loop_out = loopOut;
    }

    if (thisProperty.smooth) {
      smooth = thisProperty.smooth.bind(thisProperty);
    }

    function loopInDuration(type, duration) {
      return loopIn(type, duration, true);
    }

    function loopOutDuration(type, duration) {
      return loopOut(type, duration, true);
    }

    if (this.getValueAtTime) {
      valueAtTime = this.getValueAtTime.bind(this);
    }

    if (this.getVelocityAtTime) {
      velocityAtTime = this.getVelocityAtTime.bind(this);
    }

    var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);

    function lookAt(elem1, elem2) {
      var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
      var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
      var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
      return [yaw, pitch, 0];
    }

    function easeOut(t, tMin, tMax, val1, val2) {
      return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
    }

    function easeIn(t, tMin, tMax, val1, val2) {
      return applyEase(easeInBez, t, tMin, tMax, val1, val2);
    }

    function ease(t, tMin, tMax, val1, val2) {
      return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
    }

    function applyEase(fn, t, tMin, tMax, val1, val2) {
      if (val1 === undefined) {
        val1 = tMin;
        val2 = tMax;
      } else {
        t = (t - tMin) / (tMax - tMin);
      }
      if (t > 1) {
        t = 1;
      } else if (t < 0) {
        t = 0;
      }
      var mult = fn(t);
      if ($bm_isInstanceOfArray(val1)) {
        var iKey;
        var lenKey = val1.length;
        var arr = createTypedArray('float32', lenKey);
        for (iKey = 0; iKey < lenKey; iKey += 1) {
          arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
        }
        return arr;
      }
      return (val2 - val1) * mult + val1;
    }

    function nearestKey(time) {
      var iKey;
      var lenKey = data.k.length;
      var index;
      var keyTime;
      if (!data.k.length || typeof (data.k[0]) === 'number') {
        index = 0;
        keyTime = 0;
      } else {
        index = -1;
        time *= elem.comp.globalData.frameRate;
        if (time < data.k[0].t) {
          index = 1;
          keyTime = data.k[0].t;
        } else {
          for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
            if (time === data.k[iKey].t) {
              index = iKey + 1;
              keyTime = data.k[iKey].t;
              break;
            } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {
              if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {
                index = iKey + 2;
                keyTime = data.k[iKey + 1].t;
              } else {
                index = iKey + 1;
                keyTime = data.k[iKey].t;
              }
              break;
            }
          }
          if (index === -1) {
            index = iKey + 1;
            keyTime = data.k[iKey].t;
          }
        }
      }
      var obKey = {};
      obKey.index = index;
      obKey.time = keyTime / elem.comp.globalData.frameRate;
      return obKey;
    }

    function key(ind) {
      var obKey;
      var iKey;
      var lenKey;
      if (!data.k.length || typeof (data.k[0]) === 'number') {
        throw new Error('The property has no keyframe at index ' + ind);
      }
      ind -= 1;
      obKey = {
        time: data.k[ind].t / elem.comp.globalData.frameRate,
        value: [],
      };
      var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e;

      lenKey = arr.length;
      for (iKey = 0; iKey < lenKey; iKey += 1) {
        obKey[iKey] = arr[iKey];
        obKey.value[iKey] = arr[iKey];
      }
      return obKey;
    }

    function framesToTime(frames, fps) {
      if (!fps) {
        fps = elem.comp.globalData.frameRate;
      }
      return frames / fps;
    }

    function timeToFrames(t, fps) {
      if (!t && t !== 0) {
        t = time;
      }
      if (!fps) {
        fps = elem.comp.globalData.frameRate;
      }
      return t * fps;
    }

    function seedRandom(seed) {
      BMMath.seedrandom(randSeed + seed);
    }

    function sourceRectAtTime() {
      return elem.sourceRectAtTime();
    }

    function substring(init, end) {
      if (typeof value === 'string') {
        if (end === undefined) {
          return value.substring(init);
        }
        return value.substring(init, end);
      }
      return '';
    }

    function substr(init, end) {
      if (typeof value === 'string') {
        if (end === undefined) {
          return value.substr(init);
        }
        return value.substr(init, end);
      }
      return '';
    }

    function posterizeTime(framesPerSecond) {
      time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
      value = valueAtTime(time);
    }

    var time;
    var velocity;
    var value;
    var text;
    var textIndex;
    var textTotal;
    var selectorValue;
    var index = elem.data.ind;
    var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
    var parent;
    var randSeed = Math.floor(Math.random() * 1000000);
    var globalData = elem.globalData;
    function executeExpression(_value) {
      // globalData.pushExpression();
      value = _value;
      if (_needsRandom) {
        seedRandom(randSeed);
      }
      if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
        return value;
      }
      if (this.propType === 'textSelector') {
        textIndex = this.textIndex;
        textTotal = this.textTotal;
        selectorValue = this.selectorValue;
      }
      if (!thisLayer) {
        text = elem.layerInterface.text;
        thisLayer = elem.layerInterface;
        thisComp = elem.comp.compInterface;
        toWorld = thisLayer.toWorld.bind(thisLayer);
        fromWorld = thisLayer.fromWorld.bind(thisLayer);
        fromComp = thisLayer.fromComp.bind(thisLayer);
        toComp = thisLayer.toComp.bind(thisLayer);
        mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
        fromCompToSurface = fromComp;
      }
      if (!transform) {
        transform = elem.layerInterface('ADBE Transform Group');
        $bm_transform = transform;
        if (transform) {
          anchorPoint = transform.anchorPoint;
          /* position = transform.position;
                    rotation = transform.rotation;
                    scale = transform.scale; */
        }
      }

      if (elemType === 4 && !content) {
        content = thisLayer('ADBE Root Vectors Group');
      }
      if (!effect) {
        effect = thisLayer(4);
      }
      hasParent = !!(elem.hierarchy && elem.hierarchy.length);
      if (hasParent && !parent) {
        parent = elem.hierarchy[0].layerInterface;
      }
      time = this.comp.renderedFrame / this.comp.globalData.frameRate;
      if (needsVelocity) {
        velocity = velocityAtTime(time);
      }
      expression_function();
      this.frameExpressionId = elem.globalData.frameId;

      // TODO: Check if it's possible to return on ShapeInterface the .v value
      if (scoped_bm_rt.propType === 'shape') {
        scoped_bm_rt = scoped_bm_rt.v;
      }
      // globalData.popExpression();
      return scoped_bm_rt;
    }
    return executeExpression;
  }

  ob.initiateExpression = initiateExpression;
  return ob;
}());

/* global ExpressionManager, createTypedArray */
/* exported expressionHelpers */

var expressionHelpers = (function () {
  function searchExpressions(elem, data, prop) {
    if (data.x) {
      prop.k = true;
      prop.x = true;
      prop.initiateExpression = ExpressionManager.initiateExpression;
      prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
    }
  }

  function getValueAtTime(frameNum) {
    frameNum *= this.elem.globalData.frameRate;
    frameNum -= this.offsetTime;
    if (frameNum !== this._cachingAtTime.lastFrame) {
      this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
      this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
      this._cachingAtTime.lastFrame = frameNum;
    }
    return this._cachingAtTime.value;
  }

  function getSpeedAtTime(frameNum) {
    var delta = -0.01;
    var v1 = this.getValueAtTime(frameNum);
    var v2 = this.getValueAtTime(frameNum + delta);
    var speed = 0;
    if (v1.length) {
      var i;
      for (i = 0; i < v1.length; i += 1) {
        speed += Math.pow(v2[i] - v1[i], 2);
      }
      speed = Math.sqrt(speed) * 100;
    } else {
      speed = 0;
    }
    return speed;
  }

  function getVelocityAtTime(frameNum) {
    if (this.vel !== undefined) {
      return this.vel;
    }
    var delta = -0.001;
    // frameNum += this.elem.data.st;
    var v1 = this.getValueAtTime(frameNum);
    var v2 = this.getValueAtTime(frameNum + delta);
    var velocity;
    if (v1.length) {
      velocity = createTypedArray('float32', v1.length);
      var i;
      for (i = 0; i < v1.length; i += 1) {
        // removing frameRate
        // if needed, don't add it here
        // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
        velocity[i] = (v2[i] - v1[i]) / delta;
      }
    } else {
      velocity = (v2 - v1) / delta;
    }
    return velocity;
  }

  function getStaticValueAtTime() {
    return this.pv;
  }

  function setGroupProperty(propertyGroup) {
    this.propertyGroup = propertyGroup;
  }

  return {
    searchExpressions: searchExpressions,
    getSpeedAtTime: getSpeedAtTime,
    getVelocityAtTime: getVelocityAtTime,
    getValueAtTime: getValueAtTime,
    getStaticValueAtTime: getStaticValueAtTime,
    setGroupProperty: setGroupProperty,
  };
}());

/* global createTypedArray, Matrix, TransformPropertyFactory, expressionHelpers, PropertyFactory, expressionHelpers,
initialDefaultFrame, shapePool, ShapePropertyFactory, bez, extendPrototype, ExpressionManager, createSizedArray */

(function addPropertyDecorator() {
  function loopOut(type, duration, durationFlag) {
    if (!this.k || !this.keyframes) {
      return this.pv;
    }
    type = type ? type.toLowerCase() : '';
    var currentFrame = this.comp.renderedFrame;
    var keyframes = this.keyframes;
    var lastKeyFrame = keyframes[keyframes.length - 1].t;
    if (currentFrame <= lastKeyFrame) {
      return this.pv;
    }
    var cycleDuration;
    var firstKeyFrame;
    if (!durationFlag) {
      if (!duration || duration > keyframes.length - 1) {
        duration = keyframes.length - 1;
      }
      firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
      cycleDuration = lastKeyFrame - firstKeyFrame;
    } else {
      if (!duration) {
        cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
      } else {
        cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
      }
      firstKeyFrame = lastKeyFrame - cycleDuration;
    }
    var i;
    var len;
    var ret;
    if (type === 'pingpong') {
      var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
      if (iterations % 2 !== 0) {
          return this.getValueAtTime(((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
      }
    } else if (type === 'offset') {
      var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
      var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
        var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
      var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
      if (this.pv.length) {
        ret = new Array(initV.length);
        len = ret.length;
        for (i = 0; i < len; i += 1) {
          ret[i] = (endV[i] - initV[i]) * repeats + current[i];
        }
        return ret;
      }
      return (endV - initV) * repeats + current;
    } else if (type === 'continue') {
      var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
      var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
      if (this.pv.length) {
        ret = new Array(lastValue.length);
        len = ret.length;
        for (i = 0; i < len; i += 1) {
            ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line
        }
        return ret;
      }
      return lastValue + (lastValue - nextLastValue) * (((currentFrame - lastKeyFrame)) / 0.001);
    }
      return this.getValueAtTime((((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line

  }

  function loopIn(type, duration, durationFlag) {
    if (!this.k) {
      return this.pv;
    }
    type = type ? type.toLowerCase() : '';
    var currentFrame = this.comp.renderedFrame;
    var keyframes = this.keyframes;
    var firstKeyFrame = keyframes[0].t;
    if (currentFrame >= firstKeyFrame) {
      return this.pv;
    }
    var cycleDuration;
    var lastKeyFrame;
    if (!durationFlag) {
      if (!duration || duration > keyframes.length - 1) {
        duration = keyframes.length - 1;
      }
      lastKeyFrame = keyframes[duration].t;
      cycleDuration = lastKeyFrame - firstKeyFrame;
    } else {
      if (!duration) {
        cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
      } else {
        cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
      }
      lastKeyFrame = firstKeyFrame + cycleDuration;
    }
    var i;
    var len;
    var ret;
    if (type === 'pingpong') {
      var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
      if (iterations % 2 === 0) {
          return this.getValueAtTime((((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
      }
    } else if (type === 'offset') {
      var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
      var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
      var current = this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration) + firstKeyFrame) / this.comp.globalData.frameRate, 0);
      var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
      if (this.pv.length) {
        ret = new Array(initV.length);
        len = ret.length;
        for (i = 0; i < len; i += 1) {
          ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
        }
        return ret;
      }
      return current - (endV - initV) * repeats;
    } else if (type === 'continue') {
      var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
      var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
      if (this.pv.length) {
        ret = new Array(firstValue.length);
        len = ret.length;
        for (i = 0; i < len; i += 1) {
          ret[i] = firstValue[i] + ((firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame)) / 0.001;
        }
        return ret;
      }
      return firstValue + ((firstValue - nextFirstValue) * (firstKeyFrame - currentFrame)) / 0.001;
    }
      return this.getValueAtTime(((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame))) / this.comp.globalData.frameRate, 0); // eslint-disable-line

  }

  function smooth(width, samples) {
    if (!this.k) {
      return this.pv;
    }
    width = (width || 0.4) * 0.5;
    samples = Math.floor(samples || 5);
    if (samples <= 1) {
      return this.pv;
    }
    var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
    var initFrame = currentTime - width;
    var endFrame = currentTime + width;
    var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
    var i = 0;
    var j = 0;
    var value;
    if (this.pv.length) {
      value = createTypedArray('float32', this.pv.length);
    } else {
      value = 0;
    }
    var sampleValue;
    while (i < samples) {
      sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
      if (this.pv.length) {
        for (j = 0; j < this.pv.length; j += 1) {
          value[j] += sampleValue[j];
        }
      } else {
        value += sampleValue;
      }
      i += 1;
    }
    if (this.pv.length) {
      for (j = 0; j < this.pv.length; j += 1) {
        value[j] /= samples;
      }
    } else {
      value /= samples;
    }
    return value;
  }

  function getTransformValueAtTime(time) {
    if (!this._transformCachingAtTime) {
      this._transformCachingAtTime = {
        v: new Matrix(),
      };
    }
    /// /
    var matrix = this._transformCachingAtTime.v;
    matrix.cloneFromProps(this.pre.props);
    if (this.appliedTransformations < 1) {
      var anchor = this.a.getValueAtTime(time);
      matrix.translate(
        -anchor[0] * this.a.mult,
        -anchor[1] * this.a.mult,
        anchor[2] * this.a.mult
      );
    }
    if (this.appliedTransformations < 2) {
      var scale = this.s.getValueAtTime(time);
      matrix.scale(
        scale[0] * this.s.mult,
        scale[1] * this.s.mult,
        scale[2] * this.s.mult
      );
    }
    if (this.sk && this.appliedTransformations < 3) {
      var skew = this.sk.getValueAtTime(time);
      var skewAxis = this.sa.getValueAtTime(time);
      matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
    }
    if (this.r && this.appliedTransformations < 4) {
      var rotation = this.r.getValueAtTime(time);
      matrix.rotate(-rotation * this.r.mult);
    } else if (!this.r && this.appliedTransformations < 4) {
      var rotationZ = this.rz.getValueAtTime(time);
      var rotationY = this.ry.getValueAtTime(time);
      var rotationX = this.rx.getValueAtTime(time);
      var orientation = this.or.getValueAtTime(time);
      matrix.rotateZ(-rotationZ * this.rz.mult)
        .rotateY(rotationY * this.ry.mult)
        .rotateX(rotationX * this.rx.mult)
        .rotateZ(-orientation[2] * this.or.mult)
        .rotateY(orientation[1] * this.or.mult)
        .rotateX(orientation[0] * this.or.mult);
    }
    if (this.data.p && this.data.p.s) {
      var positionX = this.px.getValueAtTime(time);
      var positionY = this.py.getValueAtTime(time);
      if (this.data.p.z) {
        var positionZ = this.pz.getValueAtTime(time);
        matrix.translate(
          positionX * this.px.mult,
          positionY * this.py.mult,
          -positionZ * this.pz.mult
        );
      } else {
        matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
      }
    } else {
      var position = this.p.getValueAtTime(time);
      matrix.translate(
        position[0] * this.p.mult,
        position[1] * this.p.mult,
        -position[2] * this.p.mult
      );
    }
    return matrix;
    /// /
  }

  function getTransformStaticValueAtTime() {
    return this.v.clone(new Matrix());
  }

  var getTransformProperty = TransformPropertyFactory.getTransformProperty;
  TransformPropertyFactory.getTransformProperty = function (elem, data, container) {
    var prop = getTransformProperty(elem, data, container);
    if (prop.dynamicProperties.length) {
      prop.getValueAtTime = getTransformValueAtTime.bind(prop);
    } else {
      prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
    }
    prop.setGroupProperty = expressionHelpers.setGroupProperty;
    return prop;
  };

  var propertyGetProp = PropertyFactory.getProp;
  PropertyFactory.getProp = function (elem, data, type, mult, container) {
    var prop = propertyGetProp(elem, data, type, mult, container);
    // prop.getVelocityAtTime = getVelocityAtTime;
    // prop.loopOut = loopOut;
    // prop.loopIn = loopIn;
    if (prop.kf) {
      prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
    } else {
      prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
    }
    prop.setGroupProperty = expressionHelpers.setGroupProperty;
    prop.loopOut = loopOut;
    prop.loopIn = loopIn;
    prop.smooth = smooth;
    prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
    prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
    prop.numKeys = data.a === 1 ? data.k.length : 0;
    prop.propertyIndex = data.ix;
    var value = 0;
    if (type !== 0) {
      value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);
    }
    prop._cachingAtTime = {
      lastFrame: initialDefaultFrame,
      lastIndex: 0,
      value: value,
    };
    expressionHelpers.searchExpressions(elem, data, prop);
    if (prop.k) {
      container.addDynamicProperty(prop);
    }

    return prop;
  };

  function getShapeValueAtTime(frameNum) {
    // For now this caching object is created only when needed instead of creating it when the shape is initialized.
    if (!this._cachingAtTime) {
      this._cachingAtTime = {
        shapeValue: shapePool.clone(this.pv),
        lastIndex: 0,
        lastTime: initialDefaultFrame,
      };
    }

    frameNum *= this.elem.globalData.frameRate;
    frameNum -= this.offsetTime;
    if (frameNum !== this._cachingAtTime.lastTime) {
      this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
      this._cachingAtTime.lastTime = frameNum;
      this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
    }
    return this._cachingAtTime.shapeValue;
  }

  var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
  var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();

  function ShapeExpressions() {}
  ShapeExpressions.prototype = {
    vertices: function (prop, time) {
      if (this.k) {
        this.getValue();
      }
      var shapePath = this.v;
      if (time !== undefined) {
        shapePath = this.getValueAtTime(time, 0);
      }
      var i;
      var len = shapePath._length;
      var vertices = shapePath[prop];
      var points = shapePath.v;
      var arr = createSizedArray(len);
      for (i = 0; i < len; i += 1) {
        if (prop === 'i' || prop === 'o') {
          arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
        } else {
          arr[i] = [vertices[i][0], vertices[i][1]];
        }
      }
      return arr;
    },
    points: function (time) {
      return this.vertices('v', time);
    },
    inTangents: function (time) {
      return this.vertices('i', time);
    },
    outTangents: function (time) {
      return this.vertices('o', time);
    },
    isClosed: function () {
      return this.v.c;
    },
    pointOnPath: function (perc, time) {
      var shapePath = this.v;
      if (time !== undefined) {
        shapePath = this.getValueAtTime(time, 0);
      }
      if (!this._segmentsLength) {
        this._segmentsLength = bez.getSegmentsLength(shapePath);
      }

      var segmentsLength = this._segmentsLength;
      var lengths = segmentsLength.lengths;
      var lengthPos = segmentsLength.totalLength * perc;
      var i = 0;
      var len = lengths.length;
      var accumulatedLength = 0;
      var pt;
      while (i < len) {
        if (accumulatedLength + lengths[i].addedLength > lengthPos) {
          var initIndex = i;
          var endIndex = (shapePath.c && i === len - 1) ? 0 : i + 1;
          var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
          pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
          break;
        } else {
          accumulatedLength += lengths[i].addedLength;
        }
        i += 1;
      }
      if (!pt) {
        pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
      }
      return pt;
    },
    vectorOnPath: function (perc, time, vectorType) {
      // perc doesn't use triple equality because it can be a Number object as well as a primitive.
      if (perc == 1) { // eslint-disable-line eqeqeq
        perc = this.v.c;
      } else if (perc == 0) { // eslint-disable-line eqeqeq
        perc = 0.999;
      }
      var pt1 = this.pointOnPath(perc, time);
      var pt2 = this.pointOnPath(perc + 0.001, time);
      var xLength = pt2[0] - pt1[0];
      var yLength = pt2[1] - pt1[1];
      var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
      if (magnitude === 0) {
        return [0, 0];
      }
      var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
      return unitVector;
    },
    tangentOnPath: function (perc, time) {
      return this.vectorOnPath(perc, time, 'tangent');
    },
    normalOnPath: function (perc, time) {
      return this.vectorOnPath(perc, time, 'normal');
    },
    setGroupProperty: expressionHelpers.setGroupProperty,
    getValueAtTime: expressionHelpers.getStaticValueAtTime,
  };
  extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
  extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
  KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
  KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;

  var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
  ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {
    var prop = propertyGetShapeProp(elem, data, type, arr, trims);
    prop.propertyIndex = data.ix;
    prop.lock = false;
    if (type === 3) {
      expressionHelpers.searchExpressions(elem, data.pt, prop);
    } else if (type === 4) {
      expressionHelpers.searchExpressions(elem, data.ks, prop);
    }
    if (prop.k) {
      elem.addDynamicProperty(prop);
    }
    return prop;
  };
}());

/* global ExpressionManager, TextProperty */

(function addDecorator() {
  function searchExpressions() {
    if (this.data.d.x) {
      this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
      this.addEffect(this.getExpressionValue.bind(this));
      return true;
    }
    return null;
  }

  TextProperty.prototype.getExpressionValue = function (currentValue, text) {
    var newValue = this.calculateExpression(text);
    if (currentValue.t !== newValue) {
      var newData = {};
      this.copyData(newData, currentValue);
      newData.t = newValue.toString();
      newData.__complete = false;
      return newData;
    }
    return currentValue;
  };

  TextProperty.prototype.searchProperty = function () {
    var isKeyframed = this.searchKeyframes();
    var hasExpressions = this.searchExpressions();
    this.kf = isKeyframed || hasExpressions;
    return this.kf;
  };

  TextProperty.prototype.searchExpressions = searchExpressions;
}());

/* global propertyGroupFactory, PropertyInterface */
/* exported ShapePathInterface */

var ShapePathInterface = (

  function () {
    return function pathInterfaceFactory(shape, view, propertyGroup) {
      var prop = view.sh;

      function interfaceFunction(val) {
        if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {
          return interfaceFunction.path;
        }
        return null;
      }

      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
      prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));
      Object.defineProperties(interfaceFunction, {
        path: {
          get: function () {
            if (prop.k) {
              prop.getValue();
            }
            return prop;
          },
        },
        shape: {
          get: function () {
            if (prop.k) {
              prop.getValue();
            }
            return prop;
          },
        },
        _name: { value: shape.nm },
        ix: { value: shape.ix },
        propertyIndex: { value: shape.ix },
        mn: { value: shape.mn },
        propertyGroup: { value: propertyGroup },
      });
      return interfaceFunction;
    };
  }()
);

/* exported propertyGroupFactory */

var propertyGroupFactory = (function () {
  return function (interfaceFunction, parentPropertyGroup) {
    return function (val) {
      val = val === undefined ? 1 : val;
      if (val <= 0) {
        return interfaceFunction;
      }
      return parentPropertyGroup(val - 1);
    };
  };
}());

/* exported PropertyInterface */

var PropertyInterface = (function () {
  return function (propertyName, propertyGroup) {
    var interfaceFunction = {
      _name: propertyName,
    };

    function _propertyGroup(val) {
      val = val === undefined ? 1 : val;
      if (val <= 0) {
        return interfaceFunction;
      }
      return propertyGroup(val - 1);
    }

    return _propertyGroup;
  };
}());

/* global ExpressionPropertyInterface, PropertyInterface, propertyGroupFactory, ShapePathInterface */
/* exported ShapeExpressionInterface */

var ShapeExpressionInterface = (function () {
  function iterateElements(shapes, view, propertyGroup) {
    var arr = [];
    var i;
    var len = shapes ? shapes.length : 0;
    for (i = 0; i < len; i += 1) {
      if (shapes[i].ty === 'gr') {
        arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'fl') {
        arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'st') {
        arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'tm') {
        arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'tr') {
        // arr.push(transformInterfaceFactory(shapes[i],view[i],propertyGroup));
      } else if (shapes[i].ty === 'el') {
        arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'sr') {
        arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'sh') {
        arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'rc') {
        arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'rd') {
        arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'rp') {
        arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'gf') {
        arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else {
        arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup));
      }
    }
    return arr;
  }

  function contentsInterfaceFactory(shape, view, propertyGroup) {
    var interfaces;
    var interfaceFunction = function _interfaceFunction(value) {
      var i = 0;
      var len = interfaces.length;
      while (i < len) {
        if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {
          return interfaces[i];
        }
        i += 1;
      }
      if (typeof value === 'number') {
        return interfaces[value - 1];
      }
      return null;
    };

    interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
    interfaceFunction.numProperties = interfaces.length;
    var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
    interfaceFunction.transform = transformInterface;
    interfaceFunction.propertyIndex = shape.cix;
    interfaceFunction._name = shape.nm;

    return interfaceFunction;
  }

  function groupInterfaceFactory(shape, view, propertyGroup) {
    var interfaceFunction = function _interfaceFunction(value) {
      switch (value) {
        case 'ADBE Vectors Group':
        case 'Contents':
        case 2:
          return interfaceFunction.content;
          // Not necessary for now. Keeping them here in case a new case appears
          // case 'ADBE Vector Transform Group':
          // case 3:
        default:
          return interfaceFunction.transform;
      }
    };
    interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
    var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
    interfaceFunction.content = content;
    interfaceFunction.transform = transformInterface;
    Object.defineProperty(interfaceFunction, '_name', {
      get: function () {
        return shape.nm;
      },
    });
    // interfaceFunction.content = interfaceFunction;
    interfaceFunction.numProperties = shape.np;
    interfaceFunction.propertyIndex = shape.ix;
    interfaceFunction.nm = shape.nm;
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function fillInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(val) {
      if (val === 'Color' || val === 'color') {
        return interfaceFunction.color;
      } if (val === 'Opacity' || val === 'opacity') {
        return interfaceFunction.opacity;
      }
      return null;
    }
    Object.defineProperties(interfaceFunction, {
      color: {
        get: ExpressionPropertyInterface(view.c),
      },
      opacity: {
        get: ExpressionPropertyInterface(view.o),
      },
      _name: { value: shape.nm },
      mn: { value: shape.mn },
    });

    view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));
    view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
    return interfaceFunction;
  }

  function gradientFillInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(val) {
      if (val === 'Start Point' || val === 'start point') {
        return interfaceFunction.startPoint;
      }
      if (val === 'End Point' || val === 'end point') {
        return interfaceFunction.endPoint;
      }
      if (val === 'Opacity' || val === 'opacity') {
        return interfaceFunction.opacity;
      }
      return null;
    }
    Object.defineProperties(interfaceFunction, {
      startPoint: {
        get: ExpressionPropertyInterface(view.s),
      },
      endPoint: {
        get: ExpressionPropertyInterface(view.e),
      },
      opacity: {
        get: ExpressionPropertyInterface(view.o),
      },
      type: {
        get: function () {
          return 'a';
        },
      },
      _name: { value: shape.nm },
      mn: { value: shape.mn },
    });

    view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));
    view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));
    view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
    return interfaceFunction;
  }
  function defaultInterfaceFactory() {
    function interfaceFunction() {
      return null;
    }
    return interfaceFunction;
  }

  function strokeInterfaceFactory(shape, view, propertyGroup) {
    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
    function addPropertyToDashOb(i) {
      Object.defineProperty(dashOb, shape.d[i].nm, {
        get: ExpressionPropertyInterface(view.d.dataProps[i].p),
      });
    }
    var i;
    var len = shape.d ? shape.d.length : 0;
    var dashOb = {};
    for (i = 0; i < len; i += 1) {
      addPropertyToDashOb(i);
      view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
    }

    function interfaceFunction(val) {
      if (val === 'Color' || val === 'color') {
        return interfaceFunction.color;
      } if (val === 'Opacity' || val === 'opacity') {
        return interfaceFunction.opacity;
      } if (val === 'Stroke Width' || val === 'stroke width') {
        return interfaceFunction.strokeWidth;
      }
      return null;
    }
    Object.defineProperties(interfaceFunction, {
      color: {
        get: ExpressionPropertyInterface(view.c),
      },
      opacity: {
        get: ExpressionPropertyInterface(view.o),
      },
      strokeWidth: {
        get: ExpressionPropertyInterface(view.w),
      },
      dash: {
        get: function () {
          return dashOb;
        },
      },
      _name: { value: shape.nm },
      mn: { value: shape.mn },
    });

    view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));
    view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
    view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));
    return interfaceFunction;
  }

  function trimInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(val) {
      if (val === shape.e.ix || val === 'End' || val === 'end') {
        return interfaceFunction.end;
      }
      if (val === shape.s.ix) {
        return interfaceFunction.start;
      }
      if (val === shape.o.ix) {
        return interfaceFunction.offset;
      }
      return null;
    }

    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    interfaceFunction.propertyIndex = shape.ix;

    view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));
    view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));
    view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
    interfaceFunction.propertyIndex = shape.ix;
    interfaceFunction.propertyGroup = propertyGroup;

    Object.defineProperties(interfaceFunction, {
      start: {
        get: ExpressionPropertyInterface(view.s),
      },
      end: {
        get: ExpressionPropertyInterface(view.e),
      },
      offset: {
        get: ExpressionPropertyInterface(view.o),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function transformInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.a.ix === value || value === 'Anchor Point') {
        return interfaceFunction.anchorPoint;
      }
      if (shape.o.ix === value || value === 'Opacity') {
        return interfaceFunction.opacity;
      }
      if (shape.p.ix === value || value === 'Position') {
        return interfaceFunction.position;
      }
      if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {
        return interfaceFunction.rotation;
      }
      if (shape.s.ix === value || value === 'Scale') {
        return interfaceFunction.scale;
      }
      if ((shape.sk && shape.sk.ix === value) || value === 'Skew') {
        return interfaceFunction.skew;
      }
      if ((shape.sa && shape.sa.ix === value) || value === 'Skew Axis') {
        return interfaceFunction.skewAxis;
      }
      return null;
    }
    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
    view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
    view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));
    view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));
    view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
    if (view.transform.mProps.sk) {
      view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));
      view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));
    }
    view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
    Object.defineProperties(interfaceFunction, {
      opacity: {
        get: ExpressionPropertyInterface(view.transform.mProps.o),
      },
      position: {
        get: ExpressionPropertyInterface(view.transform.mProps.p),
      },
      anchorPoint: {
        get: ExpressionPropertyInterface(view.transform.mProps.a),
      },
      scale: {
        get: ExpressionPropertyInterface(view.transform.mProps.s),
      },
      rotation: {
        get: ExpressionPropertyInterface(view.transform.mProps.r),
      },
      skew: {
        get: ExpressionPropertyInterface(view.transform.mProps.sk),
      },
      skewAxis: {
        get: ExpressionPropertyInterface(view.transform.mProps.sa),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.ty = 'tr';
    interfaceFunction.mn = shape.mn;
    interfaceFunction.propertyGroup = propertyGroup;
    return interfaceFunction;
  }

  function ellipseInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.p.ix === value) {
        return interfaceFunction.position;
      }
      if (shape.s.ix === value) {
        return interfaceFunction.size;
      }
      return null;
    }
    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    interfaceFunction.propertyIndex = shape.ix;
    var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
    prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
    prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));

    Object.defineProperties(interfaceFunction, {
      size: {
        get: ExpressionPropertyInterface(prop.s),
      },
      position: {
        get: ExpressionPropertyInterface(prop.p),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function starInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.p.ix === value) {
        return interfaceFunction.position;
      }
      if (shape.r.ix === value) {
        return interfaceFunction.rotation;
      }
      if (shape.pt.ix === value) {
        return interfaceFunction.points;
      }
      if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {
        return interfaceFunction.outerRadius;
      }
      if (shape.os.ix === value) {
        return interfaceFunction.outerRoundness;
      }
      if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {
        return interfaceFunction.innerRadius;
      }
      if (shape.is && shape.is.ix === value) {
        return interfaceFunction.innerRoundness;
      }
      return null;
    }

    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
    interfaceFunction.propertyIndex = shape.ix;
    prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));
    prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));
    prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));
    prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
    prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
    if (shape.ir) {
      prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));
      prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));
    }

    Object.defineProperties(interfaceFunction, {
      position: {
        get: ExpressionPropertyInterface(prop.p),
      },
      rotation: {
        get: ExpressionPropertyInterface(prop.r),
      },
      points: {
        get: ExpressionPropertyInterface(prop.pt),
      },
      outerRadius: {
        get: ExpressionPropertyInterface(prop.or),
      },
      outerRoundness: {
        get: ExpressionPropertyInterface(prop.os),
      },
      innerRadius: {
        get: ExpressionPropertyInterface(prop.ir),
      },
      innerRoundness: {
        get: ExpressionPropertyInterface(prop.is),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function rectInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.p.ix === value) {
        return interfaceFunction.position;
      }
      if (shape.r.ix === value) {
        return interfaceFunction.roundness;
      }
      if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {
        return interfaceFunction.size;
      }
      return null;
    }
    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

    var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
    interfaceFunction.propertyIndex = shape.ix;
    prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
    prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
    prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));

    Object.defineProperties(interfaceFunction, {
      position: {
        get: ExpressionPropertyInterface(prop.p),
      },
      roundness: {
        get: ExpressionPropertyInterface(prop.r),
      },
      size: {
        get: ExpressionPropertyInterface(prop.s),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function roundedInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.r.ix === value || value === 'Round Corners 1') {
        return interfaceFunction.radius;
      }
      return null;
    }

    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var prop = view;
    interfaceFunction.propertyIndex = shape.ix;
    prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));

    Object.defineProperties(interfaceFunction, {
      radius: {
        get: ExpressionPropertyInterface(prop.rd),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function repeaterInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.c.ix === value || value === 'Copies') {
        return interfaceFunction.copies;
      } if (shape.o.ix === value || value === 'Offset') {
        return interfaceFunction.offset;
      }
      return null;
    }

    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var prop = view;
    interfaceFunction.propertyIndex = shape.ix;
    prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));
    prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
    Object.defineProperties(interfaceFunction, {
      copies: {
        get: ExpressionPropertyInterface(prop.c),
      },
      offset: {
        get: ExpressionPropertyInterface(prop.o),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  return function (shapes, view, propertyGroup) {
    var interfaces;
    function _interfaceFunction(value) {
      if (typeof value === 'number') {
        value = value === undefined ? 1 : value;
        if (value === 0) {
          return propertyGroup;
        }
        return interfaces[value - 1];
      }
      var i = 0;
      var len = interfaces.length;
      while (i < len) {
        if (interfaces[i]._name === value) {
          return interfaces[i];
        }
        i += 1;
      }
      return null;
    }
    function parentGroupWrapper() {
      return propertyGroup;
    }
    _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
    interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
    _interfaceFunction.numProperties = interfaces.length;
    _interfaceFunction._name = 'Contents';
    return _interfaceFunction;
  };
}());

/* exported TextExpressionInterface */

var TextExpressionInterface = (function () {
  return function (elem) {
    var _prevValue;
    var _sourceText;
    function _thisLayerFunction(name) {
      switch (name) {
        case 'ADBE Text Document':
          return _thisLayerFunction.sourceText;
        default:
          return null;
      }
    }
    Object.defineProperty(_thisLayerFunction, 'sourceText', {
      get: function () {
        elem.textProperty.getValue();
        var stringValue = elem.textProperty.currentData.t;
        if (stringValue !== _prevValue) {
          elem.textProperty.currentData.t = _prevValue;
          _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers
          // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive
          _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers
        }
        return _sourceText;
      },
    });
    return _thisLayerFunction;
  };
}());

/* global Matrix, MaskManagerInterface, TransformExpressionInterface, getDescriptor */
/* exported LayerExpressionInterface */

var LayerExpressionInterface = (function () {
  function getMatrix(time) {
    var toWorldMat = new Matrix();
    if (time !== undefined) {
      var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);
      propMatrix.clone(toWorldMat);
    } else {
      var transformMat = this._elem.finalTransform.mProp;
      transformMat.applyToMatrix(toWorldMat);
    }
    return toWorldMat;
  }

  function toWorldVec(arr, time) {
    var toWorldMat = this.getMatrix(time);
    toWorldMat.props[12] = 0;
    toWorldMat.props[13] = 0;
    toWorldMat.props[14] = 0;
    return this.applyPoint(toWorldMat, arr);
  }

  function toWorld(arr, time) {
    var toWorldMat = this.getMatrix(time);
    return this.applyPoint(toWorldMat, arr);
  }

  function fromWorldVec(arr, time) {
    var toWorldMat = this.getMatrix(time);
    toWorldMat.props[12] = 0;
    toWorldMat.props[13] = 0;
    toWorldMat.props[14] = 0;
    return this.invertPoint(toWorldMat, arr);
  }

  function fromWorld(arr, time) {
    var toWorldMat = this.getMatrix(time);
    return this.invertPoint(toWorldMat, arr);
  }

  function applyPoint(matrix, arr) {
    if (this._elem.hierarchy && this._elem.hierarchy.length) {
      var i;
      var len = this._elem.hierarchy.length;
      for (i = 0; i < len; i += 1) {
        this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
      }
    }
    return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
  }

  function invertPoint(matrix, arr) {
    if (this._elem.hierarchy && this._elem.hierarchy.length) {
      var i;
      var len = this._elem.hierarchy.length;
      for (i = 0; i < len; i += 1) {
        this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
      }
    }
    return matrix.inversePoint(arr);
  }

  function fromComp(arr) {
    var toWorldMat = new Matrix();
    toWorldMat.reset();
    this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
    if (this._elem.hierarchy && this._elem.hierarchy.length) {
      var i;
      var len = this._elem.hierarchy.length;
      for (i = 0; i < len; i += 1) {
        this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
      }
      return toWorldMat.inversePoint(arr);
    }
    return toWorldMat.inversePoint(arr);
  }

  function sampleImage() {
    return [1, 1, 1, 1];
  }

  return function (elem) {
    var transformInterface;

    function _registerMaskInterface(maskManager) {
      _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
    }
    function _registerEffectsInterface(effects) {
      _thisLayerFunction.effect = effects;
    }

    function _thisLayerFunction(name) {
      switch (name) {
        case 'ADBE Root Vectors Group':
        case 'Contents':
        case 2:
          return _thisLayerFunction.shapeInterface;
        case 1:
        case 6:
        case 'Transform':
        case 'transform':
        case 'ADBE Transform Group':
          return transformInterface;
        case 4:
        case 'ADBE Effect Parade':
        case 'effects':
        case 'Effects':
          return _thisLayerFunction.effect;
        case 'ADBE Text Properties':
          return _thisLayerFunction.textInterface;
        default:
          return null;
      }
    }
    _thisLayerFunction.getMatrix = getMatrix;
    _thisLayerFunction.invertPoint = invertPoint;
    _thisLayerFunction.applyPoint = applyPoint;
    _thisLayerFunction.toWorld = toWorld;
    _thisLayerFunction.toWorldVec = toWorldVec;
    _thisLayerFunction.fromWorld = fromWorld;
    _thisLayerFunction.fromWorldVec = fromWorldVec;
    _thisLayerFunction.toComp = toWorld;
    _thisLayerFunction.fromComp = fromComp;
    _thisLayerFunction.sampleImage = sampleImage;
    _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
    _thisLayerFunction._elem = elem;
    transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
    var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
    Object.defineProperties(_thisLayerFunction, {
      hasParent: {
        get: function () {
          return elem.hierarchy.length;
        },
      },
      parent: {
        get: function () {
          return elem.hierarchy[0].layerInterface;
        },
      },
      rotation: getDescriptor(transformInterface, 'rotation'),
      scale: getDescriptor(transformInterface, 'scale'),
      position: getDescriptor(transformInterface, 'position'),
      opacity: getDescriptor(transformInterface, 'opacity'),
      anchorPoint: anchorPointDescriptor,
      anchor_point: anchorPointDescriptor,
      transform: {
        get: function () {
          return transformInterface;
        },
      },
      active: {
        get: function () {
          return elem.isInRange;
        },
      },
    });

    _thisLayerFunction.startTime = elem.data.st;
    _thisLayerFunction.index = elem.data.ind;
    _thisLayerFunction.source = elem.data.refId;
    _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
    _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
    _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
    _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
    _thisLayerFunction._name = elem.data.nm;

    _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
    _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
    return _thisLayerFunction;
  };
}());

/* global */
/* exported FootageInterface */

var FootageInterface = (function () {
  var outlineInterfaceFactory = (function (elem) {
    var currentPropertyName = '';
    var currentProperty = elem.getFootageData();
    function init() {
      currentPropertyName = '';
      currentProperty = elem.getFootageData();
      return searchProperty;
    }
    function searchProperty(value) {
      if (currentProperty[value]) {
        currentPropertyName = value;
        currentProperty = currentProperty[value];
        if (typeof currentProperty === 'object') {
          return searchProperty;
        }
        return currentProperty;
      }
      var propertyNameIndex = value.indexOf(currentPropertyName);
      if (propertyNameIndex !== -1) {
        var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
        currentProperty = currentProperty[index];
        if (typeof currentProperty === 'object') {
          return searchProperty;
        }
        return currentProperty;
      }
      return '';
    }
    return init;
  });

  var dataInterfaceFactory = function (elem) {
    function interfaceFunction(value) {
      if (value === 'Outline') {
        return interfaceFunction.outlineInterface();
      }
      return null;
    }

    interfaceFunction._name = 'Outline';
    interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);
    return interfaceFunction;
  };

  return function (elem) {
    function _interfaceFunction(value) {
      if (value === 'Data') {
        return _interfaceFunction.dataInterface;
      }
      return null;
    }

    _interfaceFunction._name = 'Data';
    _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
    return _interfaceFunction;
  };
}());

/* exported CompExpressionInterface */

var CompExpressionInterface = (function () {
  return function (comp) {
    function _thisLayerFunction(name) {
      var i = 0;
      var len = comp.layers.length;
      while (i < len) {
        if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
          return comp.elements[i].layerInterface;
        }
        i += 1;
      }
      return null;
      // return {active:false};
    }
    Object.defineProperty(_thisLayerFunction, '_name', { value: comp.data.nm });
    _thisLayerFunction.layer = _thisLayerFunction;
    _thisLayerFunction.pixelAspect = 1;
    _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
    _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
    _thisLayerFunction.pixelAspect = 1;
    _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
    _thisLayerFunction.displayStartTime = 0;
    _thisLayerFunction.numLayers = comp.layers.length;
    return _thisLayerFunction;
  };
}());

/* global ExpressionPropertyInterface */
/* exported TransformExpressionInterface */

var TransformExpressionInterface = (function () {
  return function (transform) {
    function _thisFunction(name) {
      switch (name) {
        case 'scale':
        case 'Scale':
        case 'ADBE Scale':
        case 6:
          return _thisFunction.scale;
        case 'rotation':
        case 'Rotation':
        case 'ADBE Rotation':
        case 'ADBE Rotate Z':
        case 10:
          return _thisFunction.rotation;
        case 'ADBE Rotate X':
          return _thisFunction.xRotation;
        case 'ADBE Rotate Y':
          return _thisFunction.yRotation;
        case 'position':
        case 'Position':
        case 'ADBE Position':
        case 2:
          return _thisFunction.position;
        case 'ADBE Position_0':
          return _thisFunction.xPosition;
        case 'ADBE Position_1':
          return _thisFunction.yPosition;
        case 'ADBE Position_2':
          return _thisFunction.zPosition;
        case 'anchorPoint':
        case 'AnchorPoint':
        case 'Anchor Point':
        case 'ADBE AnchorPoint':
        case 1:
          return _thisFunction.anchorPoint;
        case 'opacity':
        case 'Opacity':
        case 11:
          return _thisFunction.opacity;
        default:
          return null;
      }
    }
    Object.defineProperty(_thisFunction, 'rotation', {
      get: ExpressionPropertyInterface(transform.r || transform.rz),
    });

    Object.defineProperty(_thisFunction, 'zRotation', {
      get: ExpressionPropertyInterface(transform.rz || transform.r),
    });

    Object.defineProperty(_thisFunction, 'xRotation', {
      get: ExpressionPropertyInterface(transform.rx),
    });

    Object.defineProperty(_thisFunction, 'yRotation', {
      get: ExpressionPropertyInterface(transform.ry),
    });
    Object.defineProperty(_thisFunction, 'scale', {
      get: ExpressionPropertyInterface(transform.s),
    });
    var _px;
    var _py;
    var _pz;
    var _transformFactory;
    if (transform.p) {
      _transformFactory = ExpressionPropertyInterface(transform.p);
    } else {
      _px = ExpressionPropertyInterface(transform.px);
      _py = ExpressionPropertyInterface(transform.py);
      if (transform.pz) {
        _pz = ExpressionPropertyInterface(transform.pz);
      }
    }
    Object.defineProperty(_thisFunction, 'position', {
      get: function () {
        if (transform.p) {
          return _transformFactory();
        }
        return [
          _px(),
          _py(),
          _pz ? _pz() : 0];
      },
    });

    Object.defineProperty(_thisFunction, 'xPosition', {
      get: ExpressionPropertyInterface(transform.px),
    });

    Object.defineProperty(_thisFunction, 'yPosition', {
      get: ExpressionPropertyInterface(transform.py),
    });

    Object.defineProperty(_thisFunction, 'zPosition', {
      get: ExpressionPropertyInterface(transform.pz),
    });

    Object.defineProperty(_thisFunction, 'anchorPoint', {
      get: ExpressionPropertyInterface(transform.a),
    });

    Object.defineProperty(_thisFunction, 'opacity', {
      get: ExpressionPropertyInterface(transform.o),
    });

    Object.defineProperty(_thisFunction, 'skew', {
      get: ExpressionPropertyInterface(transform.sk),
    });

    Object.defineProperty(_thisFunction, 'skewAxis', {
      get: ExpressionPropertyInterface(transform.sa),
    });

    Object.defineProperty(_thisFunction, 'orientation', {
      get: ExpressionPropertyInterface(transform.or),
    });

    return _thisFunction;
  };
}());

/* exported ProjectInterface */

var ProjectInterface = (function () {
  function registerComposition(comp) {
    this.compositions.push(comp);
  }

  return function () {
    function _thisProjectFunction(name) {
      var i = 0;
      var len = this.compositions.length;
      while (i < len) {
        if (this.compositions[i].data && this.compositions[i].data.nm === name) {
          if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
            this.compositions[i].prepareFrame(this.currentFrame);
          }
          return this.compositions[i].compInterface;
        }
        i += 1;
      }
      return null;
    }

    _thisProjectFunction.compositions = [];
    _thisProjectFunction.currentFrame = 0;

    _thisProjectFunction.registerComposition = registerComposition;

    return _thisProjectFunction;
  };
}());

/* global propertyGroupFactory, ExpressionPropertyInterface, PropertyInterface */
/* exported EffectsExpressionInterface */

var EffectsExpressionInterface = (function () {
  var ob = {
    createEffectsInterface: createEffectsInterface,
  };

  function createEffectsInterface(elem, propertyGroup) {
    if (elem.effectsManager) {
      var effectElements = [];
      var effectsData = elem.data.ef;
      var i;
      var len = elem.effectsManager.effectElements.length;
      for (i = 0; i < len; i += 1) {
        effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
      }

      var effects = elem.data.ef || [];
      var groupInterface = function (name) {
        i = 0;
        len = effects.length;
        while (i < len) {
          if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
            return effectElements[i];
          }
          i += 1;
        }
        return null;
      };
      Object.defineProperty(groupInterface, 'numProperties', {
        get: function () {
          return effects.length;
        },
      });
      return groupInterface;
    }
    return null;
  }

  function createGroupInterface(data, elements, propertyGroup, elem) {
    function groupInterface(name) {
      var effects = data.ef;
      var i = 0;
      var len = effects.length;
      while (i < len) {
        if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
          if (effects[i].ty === 5) {
            return effectElements[i];
          }
          return effectElements[i]();
        }
        i += 1;
      }
      throw new Error();
    }
    var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);

    var effectElements = [];
    var i;
    var len = data.ef.length;
    for (i = 0; i < len; i += 1) {
      if (data.ef[i].ty === 5) {
        effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));
      } else {
        effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
      }
    }

    if (data.mn === 'ADBE Color Control') {
      Object.defineProperty(groupInterface, 'color', {
        get: function () {
          return effectElements[0]();
        },
      });
    }
    Object.defineProperties(groupInterface, {
      numProperties: {
        get: function () {
          return data.np;
        },
      },
      _name: { value: data.nm },
      propertyGroup: { value: _propertyGroup },
    });
    groupInterface.enabled = data.en !== 0;
    groupInterface.active = groupInterface.enabled;
    return groupInterface;
  }

  function createValueInterface(element, type, elem, propertyGroup) {
    var expressionProperty = ExpressionPropertyInterface(element.p);
    function interfaceFunction() {
      if (type === 10) {
        return elem.comp.compInterface(element.p.v);
      }
      return expressionProperty();
    }

    if (element.p.setGroupProperty) {
      element.p.setGroupProperty(PropertyInterface('', propertyGroup));
    }

    return interfaceFunction;
  }

  return ob;
}());

/* global createSizedArray */
/* exported MaskManagerInterface */

var MaskManagerInterface = (function () {
  function MaskInterface(mask, data) {
    this._mask = mask;
    this._data = data;
  }
  Object.defineProperty(MaskInterface.prototype, 'maskPath', {
    get: function () {
      if (this._mask.prop.k) {
        this._mask.prop.getValue();
      }
      return this._mask.prop;
    },
  });
  Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {
    get: function () {
      if (this._mask.op.k) {
        this._mask.op.getValue();
      }
      return this._mask.op.v * 100;
    },
  });

  var MaskManager = function (maskManager) {
    var _masksInterfaces = createSizedArray(maskManager.viewData.length);
    var i;
    var len = maskManager.viewData.length;
    for (i = 0; i < len; i += 1) {
      _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
    }

    var maskFunction = function (name) {
      i = 0;
      while (i < len) {
        if (maskManager.masksProperties[i].nm === name) {
          return _masksInterfaces[i];
        }
        i += 1;
      }
      return null;
    };
    return maskFunction;
  };
  return MaskManager;
}());

/* global createTypedArray */
/* exported ExpressionPropertyInterface */

var ExpressionPropertyInterface = (function () {
  var defaultUnidimensionalValue = { pv: 0, v: 0, mult: 1 };
  var defaultMultidimensionalValue = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 };

  function completeProperty(expressionValue, property, type) {
    Object.defineProperty(expressionValue, 'velocity', {
      get: function () {
        return property.getVelocityAtTime(property.comp.currentFrame);
      },
    });
    expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
    expressionValue.key = function (pos) {
      if (!expressionValue.numKeys) {
        return 0;
      }
      var value = '';
      if ('s' in property.keyframes[pos - 1]) {
        value = property.keyframes[pos - 1].s;
      } else if ('e' in property.keyframes[pos - 2]) {
        value = property.keyframes[pos - 2].e;
      } else {
        value = property.keyframes[pos - 2].s;
      }
      var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers
      valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
      valueProp.value = type === 'unidimensional' ? value[0] : value;
      return valueProp;
    };
    expressionValue.valueAtTime = property.getValueAtTime;
    expressionValue.speedAtTime = property.getSpeedAtTime;
    expressionValue.velocityAtTime = property.getVelocityAtTime;
    expressionValue.propertyGroup = property.propertyGroup;
  }

  function UnidimensionalPropertyInterface(property) {
    if (!property || !('pv' in property)) {
      property = defaultUnidimensionalValue;
    }
    var mult = 1 / property.mult;
    var val = property.pv * mult;
    var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
    expressionValue.value = val;
    completeProperty(expressionValue, property, 'unidimensional');

    return function () {
      if (property.k) {
        property.getValue();
      }
      val = property.v * mult;
      if (expressionValue.value !== val) {
        expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
        expressionValue.value = val;
        completeProperty(expressionValue, property, 'unidimensional');
      }
      return expressionValue;
    };
  }

  function MultidimensionalPropertyInterface(property) {
    if (!property || !('pv' in property)) {
      property = defaultMultidimensionalValue;
    }
    var mult = 1 / property.mult;
    var len = (property.data && property.data.l) || property.pv.length;
    var expressionValue = createTypedArray('float32', len);
    var arrValue = createTypedArray('float32', len);
    expressionValue.value = arrValue;
    completeProperty(expressionValue, property, 'multidimensional');

    return function () {
      if (property.k) {
        property.getValue();
      }
      for (var i = 0; i < len; i += 1) {
        arrValue[i] = property.v[i] * mult;
        expressionValue[i] = arrValue[i];
      }
      return expressionValue;
    };
  }

  // TODO: try to avoid using this getter
  function defaultGetter() {
    return defaultUnidimensionalValue;
  }

  return function (property) {
    if (!property) {
      return defaultGetter;
    } if (property.propType === 'unidimensional') {
      return UnidimensionalPropertyInterface(property);
    }
    return MultidimensionalPropertyInterface(property);
  };
}());

/* global expressionHelpers, TextSelectorProp, ExpressionManager */
/* exported TextExpressionSelectorProp */

(function () {
  var TextExpressionSelectorProp = (function () { // eslint-disable-line no-unused-vars
    function getValueProxy(index, total) {
      this.textIndex = index + 1;
      this.textTotal = total;
      this.v = this.getValue() * this.mult;
      return this.v;
    }

    return function TextExpressionSelectorPropFactory(elem, data) {
      this.pv = 1;
      this.comp = elem.comp;
      this.elem = elem;
      this.mult = 0.01;
      this.propType = 'textSelector';
      this.textTotal = data.totalChars;
      this.selectorValue = 100;
      this.lastValue = [1, 1, 1];
      this.k = true;
      this.x = true;
      this.getValue = ExpressionManager.initiateExpression.bind(this)(elem, data, this);
      this.getMult = getValueProxy;
      this.getVelocityAtTime = expressionHelpers.getVelocityAtTime;
      if (this.kf) {
        this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this);
      } else {
        this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this);
      }
      this.setGroupProperty = expressionHelpers.setGroupProperty;
    };
  }());

  var propertyGetTextProp = TextSelectorProp.getTextSelectorProp;
  TextSelectorProp.getTextSelectorProp = function (elem, data, arr) {
    if (data.t === 1) {
      return new TextExpressionSelectorPropFactory(elem, data, arr); // eslint-disable-line no-undef
    }
    return propertyGetTextProp(elem, data, arr);
  };
}());

/* global PropertyFactory */
/* exported SliderEffect, AngleEffect, ColorEffect, PointEffect, LayerIndexEffect, MaskIndexEffect, CheckboxEffect, NoValueEffect */

function SliderEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
}
function AngleEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
}
function ColorEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
}
function PointEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
}
function LayerIndexEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
}
function MaskIndexEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
}
function CheckboxEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
}
function NoValueEffect() {
  this.p = {};
}

/* global extendPrototype, SliderEffect, AngleEffect, ColorEffect, PointEffect, CheckboxEffect, LayerIndexEffect,
MaskIndexEffect, NoValueEffect, DynamicPropertyContainer */

function EffectsManager(data, element) {
  var effects = data.ef || [];
  this.effectElements = [];
  var i;
  var len = effects.length;
  var effectItem;
  for (i = 0; i < len; i += 1) {
    effectItem = new GroupEffect(effects[i], element);
    this.effectElements.push(effectItem);
  }
}

function GroupEffect(data, element) {
  this.init(data, element);
}

extendPrototype([DynamicPropertyContainer], GroupEffect);

GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;

GroupEffect.prototype.init = function (data, element) {
  this.data = data;
  this.effectElements = [];
  this.initDynamicPropertyContainer(element);
  var i;
  var len = this.data.ef.length;
  var eff;
  var effects = this.data.ef;
  for (i = 0; i < len; i += 1) {
    eff = null;
    switch (effects[i].ty) {
      case 0:
        eff = new SliderEffect(effects[i], element, this);
        break;
      case 1:
        eff = new AngleEffect(effects[i], element, this);
        break;
      case 2:
        eff = new ColorEffect(effects[i], element, this);
        break;
      case 3:
        eff = new PointEffect(effects[i], element, this);
        break;
      case 4:
      case 7:
        eff = new CheckboxEffect(effects[i], element, this);
        break;
      case 10:
        eff = new LayerIndexEffect(effects[i], element, this);
        break;
      case 11:
        eff = new MaskIndexEffect(effects[i], element, this);
        break;
      case 5:
        eff = new EffectsManager(effects[i], element, this);
        break;
        // case 6:
      default:
        eff = new NoValueEffect(effects[i], element, this);
        break;
    }
    if (eff) {
      this.effectElements.push(eff);
    }
  }
};


var lottie = {};

function setLocationHref(href) {
  locationHref = href;
}

function searchAnimations() {
  if (standalone === true) {
    animationManager.searchAnimations(animationData, standalone, renderer);
  } else {
    animationManager.searchAnimations();
  }
}

function setSubframeRendering(flag) {
  subframeEnabled = flag;
}

function setIDPrefix(prefix) {
  idPrefix = prefix;
}

function loadAnimation(params) {
  if (standalone === true) {
    params.animationData = JSON.parse(animationData);
  }
  return animationManager.loadAnimation(params);
}

function setQuality(value) {
  if (typeof value === 'string') {
    switch (value) {
      case 'high':
        defaultCurveSegments = 200;
        break;
      default:
      case 'medium':
        defaultCurveSegments = 50;
        break;
      case 'low':
        defaultCurveSegments = 10;
        break;
    }
  } else if (!isNaN(value) && value > 1) {
    defaultCurveSegments = value;
  }
  if (defaultCurveSegments >= 50) {
    roundValues(false);
  } else {
    roundValues(true);
  }
}

function inBrowser() {
  return typeof navigator !== 'undefined';
}

function installPlugin(type, plugin) {
  if (type === 'expressions') {
    expressionsPlugin = plugin;
  }
}

function getFactory(name) {
  switch (name) {
    case 'propertyFactory':
      return PropertyFactory;
    case 'shapePropertyFactory':
      return ShapePropertyFactory;
    case 'matrix':
      return Matrix;
    default:
      return null;
  }
}

lottie.play = animationManager.play;
lottie.pause = animationManager.pause;
lottie.setLocationHref = setLocationHref;
lottie.togglePause = animationManager.togglePause;
lottie.setSpeed = animationManager.setSpeed;
lottie.setDirection = animationManager.setDirection;
lottie.stop = animationManager.stop;
lottie.searchAnimations = searchAnimations;
lottie.registerAnimation = animationManager.registerAnimation;
lottie.loadAnimation = loadAnimation;
lottie.setSubframeRendering = setSubframeRendering;
lottie.resize = animationManager.resize;
// lottie.start = start;
lottie.goToAndStop = animationManager.goToAndStop;
lottie.destroy = animationManager.destroy;
lottie.setQuality = setQuality;
lottie.inBrowser = inBrowser;
lottie.installPlugin = installPlugin;
lottie.freeze = animationManager.freeze;
lottie.unfreeze = animationManager.unfreeze;
lottie.setVolume = animationManager.setVolume;
lottie.mute = animationManager.mute;
lottie.unmute = animationManager.unmute;
lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
lottie.setIDPrefix = setIDPrefix;
lottie.__getFactory = getFactory;
lottie.version = '5.7.11';

function checkReady() {
  if (document.readyState === 'complete') {
    clearInterval(readyStateCheckInterval);
    searchAnimations();
  }
}

function getQueryVariable(variable) {
  var vars = queryString.split('&');
  for (var i = 0; i < vars.length; i += 1) {
    var pair = vars[i].split('=');
    if (decodeURIComponent(pair[0]) == variable) { // eslint-disable-line eqeqeq
      return decodeURIComponent(pair[1]);
    }
  }
  return null;
}
var standalone = '__[STANDALONE]__';
var animationData = '__[ANIMATIONDATA]__';
var renderer = '';
var queryString;
if (standalone) {
  var scripts = document.getElementsByTagName('script');
  var index = scripts.length - 1;
  var myScript = scripts[index] || {
    src: '',
  };
  queryString = myScript.src.replace(/^[^\?]+\??/, ''); // eslint-disable-line no-useless-escape
  renderer = getQueryVariable('renderer');
}
var readyStateCheckInterval = setInterval(checkReady, 100);

return lottie;
}));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/***/ (function(module) {

"use strict";
var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;
//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Ftesting&absolutePagePath=C%3A%5CUsers%5Crahul%5CDesktop%5CquizApp%5Cpages%5Ctesting.js!":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Ftesting&absolutePagePath=C%3A%5CUsers%5Crahul%5CDesktop%5CquizApp%5Cpages%5Ctesting.js! ***!
  \**********************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/testing",
      function () {
        return __webpack_require__(/*! ./pages/testing.js */ "./pages/testing.js");
      }
    ]);
  

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}
//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "./node_modules/next/router.js":
/*!*************************************!*\
  !*** ./node_modules/next/router.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/router */ "./node_modules/next/dist/client/router.js")


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ (function(module) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ (function(module) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/query-string/index.js":
/*!********************************************!*\
  !*** ./node_modules/query-string/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

const strictUriEncode = __webpack_require__(/*! strict-uri-encode */ "./node_modules/strict-uri-encode/index.js");
const decodeComponent = __webpack_require__(/*! decode-uri-component */ "./node_modules/decode-uri-component/index.js");
const splitOnFirst = __webpack_require__(/*! split-on-first */ "./node_modules/split-on-first/index.js");
const filterObject = __webpack_require__(/*! filter-obj */ "./node_modules/filter-obj/index.js");

const isNullOrUndefined = value => value === null || value === undefined;

function encoderForArrayFormat(options) {
	switch (options.arrayFormat) {
		case 'index':
			return key => (result, value) => {
				const index = result.length;

				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[', index, ']'].join('')];
				}

				return [
					...result,
					[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
				];
			};

		case 'bracket':
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[]'].join('')];
				}

				return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
			};

		case 'comma':
		case 'separator':
		case 'bracket-separator': {
			const keyValueSep = options.arrayFormat === 'bracket-separator' ?
				'[]=' :
				'=';

			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				// Translate null to an empty string so that it doesn't serialize as 'null'
				value = value === null ? '' : value;

				if (result.length === 0) {
					return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
				}

				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
			};
		}

		default:
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, encode(key, options)];
				}

				return [...result, [encode(key, options), '=', encode(value, options)].join('')];
			};
	}
}

function parserForArrayFormat(options) {
	let result;

	switch (options.arrayFormat) {
		case 'index':
			return (key, value, accumulator) => {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return (key, value, accumulator) => {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		case 'comma':
		case 'separator':
			return (key, value, accumulator) => {
				const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
				const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
				value = isEncodedArray ? decode(value, options) : value;
				const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
				accumulator[key] = newValue;
			};

		case 'bracket-separator':
			return (key, value, accumulator) => {
				const isArray = /(\[\])$/.test(key);
				key = key.replace(/\[\]$/, '');

				if (!isArray) {
					accumulator[key] = value ? decode(value, options) : value;
					return;
				}

				const arrayValue = value === null ?
					[] :
					value.split(options.arrayFormatSeparator).map(item => decode(item, options));

				if (accumulator[key] === undefined) {
					accumulator[key] = arrayValue;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], arrayValue);
			};

		default:
			return (key, value, accumulator) => {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function validateArrayFormatSeparator(value) {
	if (typeof value !== 'string' || value.length !== 1) {
		throw new TypeError('arrayFormatSeparator must be single character string');
	}
}

function encode(value, options) {
	if (options.encode) {
		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function decode(value, options) {
	if (options.decode) {
		return decodeComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	}

	if (typeof input === 'object') {
		return keysSorter(Object.keys(input))
			.sort((a, b) => Number(a) - Number(b))
			.map(key => input[key]);
	}

	return input;
}

function removeHash(input) {
	const hashStart = input.indexOf('#');
	if (hashStart !== -1) {
		input = input.slice(0, hashStart);
	}

	return input;
}

function getHash(url) {
	let hash = '';
	const hashStart = url.indexOf('#');
	if (hashStart !== -1) {
		hash = url.slice(hashStart);
	}

	return hash;
}

function extract(input) {
	input = removeHash(input);
	const queryStart = input.indexOf('?');
	if (queryStart === -1) {
		return '';
	}

	return input.slice(queryStart + 1);
}

function parseValue(value, options) {
	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		value = Number(value);
	} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
		value = value.toLowerCase() === 'true';
	}

	return value;
}

function parse(query, options) {
	options = Object.assign({
		decode: true,
		sort: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ',',
		parseNumbers: false,
		parseBooleans: false
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const formatter = parserForArrayFormat(options);

	// Create an object with no prototype
	const ret = Object.create(null);

	if (typeof query !== 'string') {
		return ret;
	}

	query = query.trim().replace(/^[?#&]/, '');

	if (!query) {
		return ret;
	}

	for (const param of query.split('&')) {
		if (param === '') {
			continue;
		}

		let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

		// Missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
		formatter(decode(key, options), value, ret);
	}

	for (const key of Object.keys(ret)) {
		const value = ret[key];
		if (typeof value === 'object' && value !== null) {
			for (const k of Object.keys(value)) {
				value[k] = parseValue(value[k], options);
			}
		} else {
			ret[key] = parseValue(value, options);
		}
	}

	if (options.sort === false) {
		return ret;
	}

	return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
		const value = ret[key];
		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
			// Sort object keys, not values
			result[key] = keysSorter(value);
		} else {
			result[key] = value;
		}

		return result;
	}, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = (object, options) => {
	if (!object) {
		return '';
	}

	options = Object.assign({
		encode: true,
		strict: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ','
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const shouldFilter = key => (
		(options.skipNull && isNullOrUndefined(object[key])) ||
		(options.skipEmptyString && object[key] === '')
	);

	const formatter = encoderForArrayFormat(options);

	const objectCopy = {};

	for (const key of Object.keys(object)) {
		if (!shouldFilter(key)) {
			objectCopy[key] = object[key];
		}
	}

	const keys = Object.keys(objectCopy);

	if (options.sort !== false) {
		keys.sort(options.sort);
	}

	return keys.map(key => {
		const value = object[key];

		if (value === undefined) {
			return '';
		}

		if (value === null) {
			return encode(key, options);
		}

		if (Array.isArray(value)) {
			if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
				return encode(key, options) + '[]';
			}

			return value
				.reduce(formatter(key), [])
				.join('&');
		}

		return encode(key, options) + '=' + encode(value, options);
	}).filter(x => x.length > 0).join('&');
};

exports.parseUrl = (url, options) => {
	options = Object.assign({
		decode: true
	}, options);

	const [url_, hash] = splitOnFirst(url, '#');

	return Object.assign(
		{
			url: url_.split('?')[0] || '',
			query: parse(extract(url), options)
		},
		options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
	);
};

exports.stringifyUrl = (object, options) => {
	options = Object.assign({
		encode: true,
		strict: true
	}, options);

	const url = removeHash(object.url).split('?')[0] || '';
	const queryFromUrl = exports.extract(object.url);
	const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

	const query = Object.assign(parsedQueryFromUrl, object.query);
	let queryString = exports.stringify(query, options);
	if (queryString) {
		queryString = `?${queryString}`;
	}

	let hash = getHash(object.url);
	if (object.fragmentIdentifier) {
		hash = `#${encode(object.fragmentIdentifier, options)}`;
	}

	return `${url}${queryString}${hash}`;
};

exports.pick = (input, filter, options) => {
	options = Object.assign({
		parseFragmentIdentifier: true
	}, options);

	const {url, query, fragmentIdentifier} = exports.parseUrl(input, options);
	return exports.stringifyUrl({
		url,
		query: filterObject(query, filter),
		fragmentIdentifier
	}, options);
};

exports.exclude = (input, filter, options) => {
	const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);

	return exports.pick(input, exclusionFilter, options);
};


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react-lottie/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-lottie/dist/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lottieWeb = __webpack_require__(/*! lottie-web */ "./node_modules/lottie-web/build/player/lottie.js");

var _lottieWeb2 = _interopRequireDefault(_lottieWeb);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Lottie = function (_React$Component) {
  (0, _inherits3.default)(Lottie, _React$Component);

  function Lottie() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, Lottie);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Lottie.__proto__ || (0, _getPrototypeOf2.default)(Lottie)).call.apply(_ref, [this].concat(args))), _this), _this.handleClickToPause = function () {
      // The pause() method is for handling pausing by passing a prop isPaused
      // This method is for handling the ability to pause by clicking on the animation
      if (_this.anim.isPaused) {
        _this.anim.play();
      } else {
        _this.anim.pause();
      }
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(Lottie, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _props = this.props,
          options = _props.options,
          eventListeners = _props.eventListeners;
      var loop = options.loop,
          autoplay = options.autoplay,
          animationData = options.animationData,
          rendererSettings = options.rendererSettings,
          segments = options.segments;


      this.options = {
        container: this.el,
        renderer: 'svg',
        loop: loop !== false,
        autoplay: autoplay !== false,
        segments: segments !== false,
        animationData: animationData,
        rendererSettings: rendererSettings
      };

      this.options = (0, _extends3.default)({}, this.options, options);

      this.anim = _lottieWeb2.default.loadAnimation(this.options);
      this.registerEvents(eventListeners);
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps /* , nextState */) {
      /* Recreate the animation handle if the data is changed */
      if (this.options.animationData !== nextProps.options.animationData) {
        this.deRegisterEvents(this.props.eventListeners);
        this.destroy();
        this.options = (0, _extends3.default)({}, this.options, nextProps.options);
        this.anim = _lottieWeb2.default.loadAnimation(this.options);
        this.registerEvents(nextProps.eventListeners);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.props.isStopped) {
        this.stop();
      } else if (this.props.segments) {
        this.playSegments();
      } else {
        this.play();
      }

      this.pause();
      this.setSpeed();
      this.setDirection();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.deRegisterEvents(this.props.eventListeners);
      this.destroy();
      this.options.animationData = null;
      this.anim = null;
    }
  }, {
    key: 'setSpeed',
    value: function setSpeed() {
      this.anim.setSpeed(this.props.speed);
    }
  }, {
    key: 'setDirection',
    value: function setDirection() {
      this.anim.setDirection(this.props.direction);
    }
  }, {
    key: 'play',
    value: function play() {
      this.anim.play();
    }
  }, {
    key: 'playSegments',
    value: function playSegments() {
      this.anim.playSegments(this.props.segments);
    }
  }, {
    key: 'stop',
    value: function stop() {
      this.anim.stop();
    }
  }, {
    key: 'pause',
    value: function pause() {
      if (this.props.isPaused && !this.anim.isPaused) {
        this.anim.pause();
      } else if (!this.props.isPaused && this.anim.isPaused) {
        this.anim.pause();
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.anim.destroy();
    }
  }, {
    key: 'registerEvents',
    value: function registerEvents(eventListeners) {
      var _this2 = this;

      eventListeners.forEach(function (eventListener) {
        _this2.anim.addEventListener(eventListener.eventName, eventListener.callback);
      });
    }
  }, {
    key: 'deRegisterEvents',
    value: function deRegisterEvents(eventListeners) {
      var _this3 = this;

      eventListeners.forEach(function (eventListener) {
        _this3.anim.removeEventListener(eventListener.eventName, eventListener.callback);
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var _props2 = this.props,
          width = _props2.width,
          height = _props2.height,
          ariaRole = _props2.ariaRole,
          ariaLabel = _props2.ariaLabel,
          isClickToPauseDisabled = _props2.isClickToPauseDisabled,
          title = _props2.title;


      var getSize = function getSize(initial) {
        var size = void 0;

        if (typeof initial === 'number') {
          size = initial + 'px';
        } else {
          size = initial || '100%';
        }

        return size;
      };

      var lottieStyles = (0, _extends3.default)({
        width: getSize(width),
        height: getSize(height),
        overflow: 'hidden',
        margin: '0 auto',
        outline: 'none'
      }, this.props.style);

      var onClickHandler = isClickToPauseDisabled ? function () {
        return null;
      } : this.handleClickToPause;

      return (
        // Bug with eslint rules https://github.com/airbnb/javascript/issues/1374
        // eslint-disable-next-line jsx-a11y/no-static-element-interactions
        _react2.default.createElement('div', {
          ref: function ref(c) {
            _this4.el = c;
          },
          style: lottieStyles,
          onClick: onClickHandler,
          title: title,
          role: ariaRole,
          'aria-label': ariaLabel,
          tabIndex: '0'
        })
      );
    }
  }]);
  return Lottie;
}(_react2.default.Component);

exports.default = Lottie;


Lottie.propTypes = {
  eventListeners: _propTypes2.default.arrayOf(_propTypes2.default.object),
  options: _propTypes2.default.object.isRequired,
  height: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  isStopped: _propTypes2.default.bool,
  isPaused: _propTypes2.default.bool,
  speed: _propTypes2.default.number,
  segments: _propTypes2.default.arrayOf(_propTypes2.default.number),
  direction: _propTypes2.default.number,
  ariaRole: _propTypes2.default.string,
  ariaLabel: _propTypes2.default.string,
  isClickToPauseDisabled: _propTypes2.default.bool,
  title: _propTypes2.default.string
};

Lottie.defaultProps = {
  eventListeners: [],
  isStopped: false,
  isPaused: false,
  speed: 1,
  ariaRole: 'button',
  ariaLabel: 'animation',
  isClickToPauseDisabled: false,
  title: ''
};

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.2
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.2';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ (function(module) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/split-on-first/index.js":
/*!**********************************************!*\
  !*** ./node_modules/split-on-first/index.js ***!
  \**********************************************/
/***/ (function(module) {

"use strict";


module.exports = (string, separator) => {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (separator === '') {
		return [string];
	}

	const separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [string];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
};


/***/ }),

/***/ "./node_modules/strict-uri-encode/index.js":
/*!*************************************************!*\
  !*** ./node_modules/strict-uri-encode/index.js ***!
  \*************************************************/
/***/ (function(module) {

"use strict";

module.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);


/***/ }),

/***/ "?ca47":
/*!******************************************!*\
  !*** ./utils/resolve-rewrites (ignored) ***!
  \******************************************/
/***/ (function() {

/* (ignored) */

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ // runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ 
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ var __webpack_exports__ = (__webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Ftesting&absolutePagePath=C%3A%5CUsers%5Crahul%5CDesktop%5CquizApp%5Cpages%5Ctesting.js!"));
/******/ _N_E = __webpack_exports__;
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0hlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9RdWVzdGlvbkNhcmQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvbG90dGllLmpzIiwid2VicGFjazovL19OX0UvLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uL2NsaWVudC9yZXF1ZXN0LWlkbGUtY2FsbGJhY2sudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi9jbGllbnQvcm91dGUtbG9hZGVyLnRzIiwid2VicGFjazovL19OX0UvLi4vY2xpZW50L3JvdXRlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uL2NsaWVudC93aXRoLXJvdXRlci50c3giLCJ3ZWJwYWNrOi8vX05fRS8uLi9uZXh0LXNlcnZlci9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi9uZXh0LXNlcnZlci9saWIvbWl0dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyLnRzIiwid2VicGFjazovL19OX0UvLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLnRzIiwid2VicGFjazovL19OX0UvLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9nZXQtYXNzZXQtcGF0aC1mcm9tLXJvdXRlLnRzIiwid2VicGFjazovL19OX0UvLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLnRzIiwid2VicGFjazovL19OX0UvLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLnRzIiwid2VicGFjazovL19OX0UvLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLnRzIiwid2VicGFjazovL19OX0UvLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uL25leHQtc2VydmVyL2xpYi91dGlscy50cyIsIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvdGVzdGluZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGVjb2RlLXVyaS1jb21wb25lbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9maWx0ZXItb2JqL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG90dGllLXdlYi9idWlsZC9wbGF5ZXIvbG90dGllLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovL19OX0UvIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L3JvdXRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcXVlcnktc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1sb3R0aWUvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NwbGl0LW9uLWZpcnN0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS9pZ25vcmVkfEM6XFxVc2Vyc1xccmFodWxcXERlc2t0b3BcXHF1aXpBcHBcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcbmV4dC1zZXJ2ZXJcXGxpYlxccm91dGVyfC4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcyJdLCJuYW1lcyI6WyJIZWFkZXIiLCJwcm9wcyIsInN0ciIsImNvbnNvbGUiLCJsb2ciLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInRleHQiLCJRdWVzdGlvbkNhcmQiLCJoYW5kbGVBbnN3ZXIiLCJkYXRhIiwicXVlc3Rpb24iLCJjb3JyZWN0X2Fuc3dlciIsImluY29ycmVjdF9hbnN3ZXJzIiwic2h1ZmZsZWRBbnN3ZXJzIiwic29ydCIsIk1hdGgiLCJyYW5kb20iLCJMb3R0aWVBbmltYXRpb24iLCJsb3R0aWUiLCJoZWlnaHQiLCJ3aWR0aCIsImRlZmF1bHRPcHRpb25zIiwibG9vcCIsImF1dG9wbGF5IiwiYW5pbWF0aW9uRGF0YSIsInBhdGgiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsInByb2Nlc3MiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwic2VsZiIsInN0YXJ0IiwiRGF0ZSIsInNldFRpbWVvdXQiLCJjYiIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwiY2xlYXJUaW1lb3V0IiwiTVNfTUFYX0lETEVfREVMQVkiLCJlbnRyeSIsIm1hcCIsIlByb21pc2UiLCJwcm9tIiwicmVzb2x2ZSIsInJlc29sdmVyIiwiZnV0dXJlIiwiZ2VuZXJhdG9yIiwidmFsdWUiLCJsaW5rIiwiZG9jdW1lbnQiLCJ3aW5kb3ciLCJjYW5QcmVmZXRjaCIsImhhc1ByZWZldGNoIiwicmVzIiwiQVNTRVRfTE9BRF9FUlJPUiIsIlN5bWJvbCIsImVyciIsInNjcmlwdCIsInJlamVjdCIsIm1hcmtBc3NldEVycm9yIiwiY2FuY2VsbGVkIiwiciIsIm9uQnVpbGRNYW5pZmVzdCIsInJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQiLCJzY3JpcHRzIiwiYXNzZXRQcmVmaXgiLCJlbmNvZGVVUkkiLCJjc3MiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwibWFuaWZlc3QiLCJyb3V0ZSIsImFsbEZpbGVzIiwidiIsImVudHJ5cG9pbnRzIiwibG9hZGVkU2NyaXB0cyIsInN0eWxlU2hlZXRzIiwicm91dGVzIiwiYXBwZW5kU2NyaXB0IiwiZmV0Y2giLCJocmVmIiwiY29udGVudCIsIndoZW5FbnRyeXBvaW50Iiwid2l0aEZ1dHVyZSIsIm9uRW50cnlwb2ludCIsImZuIiwiZXhwb3J0cyIsImNvbXBvbmVudCIsImVycm9yIiwiaW5wdXQiLCJvbGQiLCJsb2FkUm91dGUiLCJnZXRGaWxlc0ZvclJvdXRlIiwiZW50cnlwb2ludCIsInN0eWxlcyIsInByZWZldGNoIiwiY24iLCJuYXZpZ2F0b3IiLCJvdXRwdXQiLCJwcmVmZXRjaFZpYURvbSIsImNyZWF0ZVJvdXRlTG9hZGVyIiwic2luZ2xldG9uUm91dGVyIiwicm91dGVyIiwicmVhZHlDYWxsYmFja3MiLCJyZWFkeSIsInVybFByb3BlcnR5RmllbGRzIiwicm91dGVyRXZlbnRzIiwiY29yZU1ldGhvZEZpZWxkcyIsImdldCIsIlJvdXRlciIsImZpZWxkIiwiZ2V0Um91dGVyIiwiZXZlbnQiLCJldmVudEZpZWxkIiwiX3NpbmdsZXRvblJvdXRlciIsIm1lc3NhZ2UiLCJSZWFjdCIsIlJvdXRlckNvbnRleHQiLCJjcmVhdGVSb3V0ZXIiLCJfcm91dGVyIiwiaW5zdGFuY2UiLCJBcnJheSIsIkNvbXBvc2VkQ29tcG9uZW50IiwiZ2V0SW5pdGlhbFByb3BzIiwiV2l0aFJvdXRlcldyYXBwZXIiLCJuYW1lIiwicGF0aG5hbWVQYXJ0cyIsInBhdGhuYW1lIiwibG9jYWxlcyIsImxvY2FsZSIsImRldGVjdGVkTG9jYWxlIiwiYWxsIiwib24iLCJvZmYiLCJlbWl0IiwiaGFuZGxlciIsImJhc2VQYXRoIiwicHJlZml4IiwicGF0aE5vUXVlcnlIYXNoIiwicXVlcnlJbmRleCIsImhhc2hJbmRleCIsImFkZFBhdGhQcmVmaXgiLCJ1cmwiLCJsb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiaGFzQmFzZVBhdGgiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImR5bmFtaWNHcm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImFzUGF0aG5hbWUiLCJwYXJhbXMiLCJwYXJhbSIsInJlcGxhY2VkIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJzZWdtZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzdWx0IiwiZmlsdGVyZWRRdWVyeSIsImtleSIsInF1ZXJ5IiwiYmFzZSIsInVybEFzU3RyaW5nIiwiaXNMb2NhbFVSTCIsInJlc29sdmVBcyIsImZpbmFsVXJsIiwiaW50ZXJwb2xhdGVkQXMiLCJpbnRlcnBvbGF0ZUFzIiwiaGFzaCIsIm9taXRQYXJtc0Zyb21RdWVyeSIsInJlc29sdmVkSHJlZiIsIm9yaWdpbiIsInJlc29sdmVIcmVmIiwiaHJlZkhhZE9yaWdpbiIsImFzSGFkT3JpZ2luIiwicmVzb2x2ZWRBcyIsInN0cmlwT3JpZ2luIiwicHJlcGFyZWRVcmwiLCJhZGRCYXNlUGF0aCIsInByZXBhcmVkQXMiLCJhcyIsImNsZWFuUGF0aG5hbWUiLCJwYWdlcyIsInBhZ2UiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIlNTR19EQVRBX05PVF9GT1VORCIsImNyZWRlbnRpYWxzIiwiYXR0ZW1wdHMiLCJmZXRjaFJldHJ5Iiwibm90Rm91bmQiLCJpc1NlcnZlclJlbmRlciIsImNvbnN0cnVjdG9yIiwiYXNQYXRoIiwiY29tcG9uZW50cyIsInNkYyIsInNkciIsInN1YiIsImNsYyIsInBhZ2VMb2FkZXIiLCJfYnBzIiwiZXZlbnRzIiwiX3dyYXBBcHAiLCJpc1NzciIsImlzRmFsbGJhY2siLCJfaW5GbGlnaHRSb3V0ZSIsIl9zaGFsbG93IiwiZGVmYXVsdExvY2FsZSIsImRvbWFpbkxvY2FsZXMiLCJpc1JlYWR5IiwiaXNQcmV2aWV3IiwiaXNMb2NhbGVEb21haW4iLCJfaWR4IiwiZSIsInN0YXRlIiwic2hhbGxvdyIsIm9wdGlvbnMiLCJDb21wb25lbnQiLCJpbml0aWFsIiwiX19OX1NTRyIsImluaXRpYWxQcm9wcyIsIl9fTl9TU1AiLCJhdXRvRXhwb3J0RHluYW1pYyIsInJlbG9hZCIsInByZXBhcmVVcmxBcyIsInNob3VsZFJlc29sdmVIcmVmIiwibG9jYWxlQ2hhbmdlIiwicGFyc2VkQXMiLCJkZWxCYXNlUGF0aCIsImxvY2FsZVBhdGhSZXN1bHQiLCJkaWROYXZpZ2F0ZSIsImRldGVjdGVkRG9tYWluIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwiU1QiLCJwZXJmb3JtYW5jZSIsInJvdXRlUHJvcHMiLCJhZGRMb2NhbGUiLCJjbGVhbmVkQXMiLCJkZWxMb2NhbGUiLCJwYXJzZWQiLCJfX3Jld3JpdGVzIiwibWV0aG9kIiwicmVzb2x2ZUR5bmFtaWNSb3V0ZSIsInJvdXRlUmVnZXgiLCJyb3V0ZU1hdGNoIiwic2hvdWxkSW50ZXJwb2xhdGUiLCJtaXNzaW5nUGFyYW1zIiwicm91dGVJbmZvIiwiZGVzdGluYXRpb24iLCJwYXJzZWRIcmVmIiwibm90Rm91bmRSb3V0ZSIsImFwcENvbXAiLCJpc1ZhbGlkU2hhbGxvd1JvdXRlIiwiZm9yY2VkU2Nyb2xsIiwieCIsInkiLCJfX04iLCJpZHgiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiZXhpc3RpbmdSb3V0ZUluZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJyZXF1aXJlIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZGF0YUhyZWYiLCJvbmx5QUhhc2hDaGFuZ2UiLCJuZXdIYXNoIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsInNjcm9sbFRvSGFzaCIsImlkRWwiLCJuYW1lRWwiLCJ1cmxJc05ldyIsInJld3JpdGVzUmVzdWx0IiwicCIsImlzU3NnIiwiY2FuY2VsIiwiY29tcG9uZW50UmVzdWx0IiwiX2dldFN0YXRpY0RhdGEiLCJmZXRjaE5leHREYXRhIiwiX2dldFNlcnZlckRhdGEiLCJBcHBUcmVlIiwiY3R4IiwiYWJvcnRDb21wb25lbnRMb2FkIiwibm90aWZ5Iiwic2xhc2hlZFByb3RvY29scyIsInByb3RvY29sIiwidXJsT2JqIiwiaG9zdCIsImF1dGgiLCJob3N0bmFtZSIsIlN0cmluZyIsInF1ZXJ5c3RyaW5nIiwic2VhcmNoIiwiZXh0IiwiVEVTVF9ST1VURSIsImdsb2JhbEJhc2UiLCJyZXNvbHZlZEJhc2UiLCJzZWFyY2hQYXJhbXMiLCJpc05hTiIsIml0ZW0iLCJzdHJpbmdpZnlVcmxRdWVyeVBhcmFtIiwic2VhcmNoUGFyYW1zTGlzdCIsInRhcmdldCIsInJlIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic2x1Z05hbWUiLCJnIiwiZ3JvdXBzIiwibSIsInNlZ21lbnRzIiwibm9ybWFsaXplZFJvdXRlIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsInBhcnNlUGFyYW1ldGVyIiwicG9zIiwiZXNjYXBlUmVnZXgiLCJ1c2VkIiwicG9ydCIsImdldExvY2F0aW9uT3JpZ2luIiwiQXBwIiwiZ2V0RGlzcGxheU5hbWUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwicGFnZVByb3BzIiwiaXNSZXNTZW50IiwidXJsT2JqZWN0S2V5cyIsIlNQIiwidGVzdGluZyIsInVzZVN0YXRlIiwiYmdDb2xvciIsInNldEJnY29sb3IiLCJxdWVzdGlvbnMiLCJzZXRRdWVzdGlvbnMiLCJjdXJyZW50UXVlc3Rpb24iLCJzZXRjdXJyZW50UXVlc3Rpb24iLCJzY29yZSIsInNldFNjb3JlIiwidXNlUm91dGVyIiwieW91cm5hbWUiLCJjYXRlZ29yeSIsImRpZmZpY3VsdHkiLCJxdWVzdGlvbkRpZmZpY3VsdHkiLCJudW1iZXJPZlF1ZXN0aW9ucyIsInQiLCJ1c2VFZmZlY3QiLCJheGlvcyIsInRoZW4iLCJyZXNwIiwicmVzdWx0cyIsImFuc3dlciIsInRyb3BoeSIsImxlbmd0aCIsImNvdW50ZG93biJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQzs7Ozs7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QUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEIsOENBQThDLFlBQVk7QUFDMUQsZ0NBQWdDLFlBQVk7QUFDNUMsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSw0QkFBNEIsY0FBYztBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx3QkFBd0IsMEJBQTBCO0FBQy9EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLHdCQUF3QiwwQkFBMEI7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSw4QkFBOEI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGVBQWU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxT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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxPQUFPO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVk7QUFDWixHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNELG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILGtDQUFrQztBQUNsQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDhCQUE4QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsK0NBQStDOztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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SztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsT0FBTyxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1gsV0FBVztBQUNYLFdBQVc7O0FBRVg7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsYUFBYTs7QUFFcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFDQUFxQztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkZBQTZGOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxPQUFPLHNCQUFzQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLGNBQWMsa0JBQWtCO0FBQ2hDLFdBQVcsa0JBQWtCO0FBQzdCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxjQUFjLGtCQUFrQjtBQUNoQyxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxjQUFjLGtCQUFrQjtBQUNoQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsY0FBYyxrQkFBa0I7QUFDaEMsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLGNBQWMsa0JBQWtCO0FBQ2hDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsY0FBYyxrQkFBa0I7QUFDaEMsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsY0FBYyxrQkFBa0I7QUFDaEMsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsY0FBYyxrQkFBa0I7QUFDaEMsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esd0RBQXdELHNCQUFzQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsY0FBYyxpQkFBaUI7QUFDL0Isc0JBQXNCLHdCQUF3QjtBQUM5QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNGQUFzRixTQUFTO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxHOzs7Ozs7Ozs7OztBQ3gzZlksc0NBQXNDLHNC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Q0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVSxLQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sS0FBcUMsNEZBQTRGLENBQU07QUFDN0k7QUFDQTs7QUFFQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUM5a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLGtEQUFVOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBMkI7QUFDdEQsQ0FBQyxNQUFNLEVBSU47Ozs7Ozs7Ozs7OztBQ2xCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUE7Ozs7Ozs7Ozs7OztBQ1hhO0FBQ2Isd0JBQXdCLG1CQUFPLENBQUMsb0VBQW1CO0FBQ25ELHdCQUF3QixtQkFBTyxDQUFDLDBFQUFzQjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsc0RBQVk7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7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O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLGNBQWM7QUFDekIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLDJEQUEyRCxTQUFTO0FBQ3BFLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxFQUFFO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsRUFBRTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLGNBQWM7QUFDekIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlOztBQUVmLHdCQUF3QixpQkFBaUI7OztBQUd6QztBQUNBLHdCQUF3Qjs7QUFFeEIsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Esc0lBQXNJLHlDQUF5QztBQUMvSztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLEVBQUU7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsWUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx5QkFBeUI7QUFDekI7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQztBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUI7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOzs7QUFHakI7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUEwQixvQkFBb0IsQ0FBRTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzN1QmE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyQmE7QUFDYiw2RUFBNkUsMkNBQTJDOzs7Ozs7Ozs7OztBQ0R4SCxlIiwiZmlsZSI6InN0YXRpYy9jaHVua3MvcGFnZXMvdGVzdGluZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTsiLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzOyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0XCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0OyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufSIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheUxpa2VUb0FycmF5XCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59IiwiaW1wb3J0IGFycmF5V2l0aG91dEhvbGVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5XCI7XG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCI7XG5pbXBvcnQgbm9uSXRlcmFibGVTcHJlYWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheVwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn0iLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0OyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuICBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9O1xuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7XG4gIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7XG5cbiAgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChvYmopO1xuICB9XG5cbiAgdmFyIG5ld09iaiA9IHt9O1xuICB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDtcblxuICAgICAgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqO1xuXG4gIGlmIChjYWNoZSkge1xuICAgIGNhY2hlLnNldChvYmosIG5ld09iaik7XG4gIH1cblxuICByZXR1cm4gbmV3T2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkOyIsImZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0OyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OyIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mOyIsInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3RcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXk7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsImltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gXCJxdWVyeS1zdHJpbmdcIjtcclxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSGVhZGVyKHByb3BzKSB7XHJcbiAgdmFyIHN0ciA9IFwiXCI7XHJcbiAgY29uc29sZS5sb2cocHJvcHMpO1xyXG4gIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKCh0ZXh0KSA9PiB7XHJcbiAgICBzdHIgKz0gcHJvcHNbdGV4dF07XHJcbiAgfSk7XHJcblxyXG4gIGNvbnNvbGUubG9nKHN0cik7XHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwiaGVhZGVyXCI+XHJcbiAgICAgIDxkaXY+XHJcbiAgICAgICAgPGg0PlF1aXpJdDwvaDQ+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImxpLWRpdlwiPlxyXG4gICAgICAgIDx1bD5cclxuICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgPGE+e3N0cn08L2E+XHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgIDwvdWw+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufVxyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBRdWVzdGlvbkNhcmQoe1xyXG4gIGhhbmRsZUFuc3dlcixcclxuICBkYXRhOiB7IHF1ZXN0aW9uLCBjb3JyZWN0X2Fuc3dlciwgaW5jb3JyZWN0X2Fuc3dlcnMgfSxcclxufSkge1xyXG4gIGNvbnN0IHNodWZmbGVkQW5zd2VycyA9IFtjb3JyZWN0X2Fuc3dlciwgLi4uaW5jb3JyZWN0X2Fuc3dlcnNdLnNvcnQoXHJcbiAgICAoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41XHJcbiAgKTtcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJxdWVzLWNhcmRcIj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJxdWVzdGlvblwiPntxdWVzdGlvbn08L2Rpdj5cclxuXHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYW5zd2Vycy1ib3hcIj5cclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICBjbGFzc05hbWU9e2BhbnN3ZXJzIGFuc3dlcnMtd2hpdGVgfVxyXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gaGFuZGxlQW5zd2VyKHNodWZmbGVkQW5zd2Vyc1swXSl9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAge1wiIFwifVxyXG4gICAgICAgICAge3NodWZmbGVkQW5zd2Vyc1swXX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJhbnN3ZXJzIGFuc3dlcnMtd2hpdGVcIlxyXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gaGFuZGxlQW5zd2VyKHNodWZmbGVkQW5zd2Vyc1sxXSl9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAge1wiIFwifVxyXG4gICAgICAgICAge3NodWZmbGVkQW5zd2Vyc1sxXX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJhbnN3ZXJzIGFuc3dlcnMtd2hpdGVcIlxyXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gaGFuZGxlQW5zd2VyKHNodWZmbGVkQW5zd2Vyc1syXSl9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAge1wiIFwifVxyXG4gICAgICAgICAge3NodWZmbGVkQW5zd2Vyc1syXX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJhbnN3ZXJzIGFuc3dlcnMtd2hpdGVcIlxyXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gaGFuZGxlQW5zd2VyKHNodWZmbGVkQW5zd2Vyc1szXSl9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAge1wiIFwifVxyXG4gICAgICAgICAge3NodWZmbGVkQW5zd2Vyc1szXX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IExvdHRpZSBmcm9tIFwicmVhY3QtbG90dGllXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMb3R0aWVBbmltYXRpb24oeyBsb3R0aWUsIGhlaWdodCwgd2lkdGggfSkge1xyXG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgbG9vcDogdHJ1ZSxcclxuICAgIGF1dG9wbGF5OiB0cnVlLFxyXG4gICAgYW5pbWF0aW9uRGF0YTogbG90dGllLFxyXG4gIH07XHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXY+XHJcbiAgICAgIDxMb3R0aWUgb3B0aW9ucz17ZGVmYXVsdE9wdGlvbnN9IGhlaWdodD17aGVpZ2h0fSB3aWR0aD17d2lkdGh9IC8+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59XHJcbiIsIi8qKlxuICogUmVtb3ZlcyB0aGUgdHJhaWxpbmcgc2xhc2ggb2YgYSBwYXRoIGlmIHRoZXJlIGlzIG9uZS4gUHJlc2VydmVzIHRoZSByb290IHBhdGggYC9gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGguZW5kc1dpdGgoJy8nKSAmJiBwYXRoICE9PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGhcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSB0cmFpbGluZyBzbGFzaCBvZiBhIHBhdGggYWNjb3JkaW5nIHRvIHRoZSBgdHJhaWxpbmdTbGFzaGAgb3B0aW9uXG4gKiBpbiBgbmV4dC5jb25maWcuanNgLlxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2ggPSBwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0hcbiAgPyAocGF0aDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgIGlmICgvXFwuW14vXStcXC8/JC8udGVzdChwYXRoKSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aClcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgIHJldHVybiBwYXRoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aCArICcvJ1xuICAgICAgfVxuICAgIH1cbiAgOiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaFxuIiwidHlwZSBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlID0gYW55XG50eXBlIFJlcXVlc3RJZGxlQ2FsbGJhY2tPcHRpb25zID0ge1xuICB0aW1lb3V0OiBudW1iZXJcbn1cbnR5cGUgUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lID0ge1xuICByZWFkb25seSBkaWRUaW1lb3V0OiBib29sZWFuXG4gIHRpbWVSZW1haW5pbmc6ICgpID0+IG51bWJlclxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2s6IChcbiAgICAgIGNhbGxiYWNrOiAoZGVhZGxpbmU6IFJlcXVlc3RJZGxlQ2FsbGJhY2tEZWFkbGluZSkgPT4gdm9pZCxcbiAgICAgIG9wdHM/OiBSZXF1ZXN0SWRsZUNhbGxiYWNrT3B0aW9uc1xuICAgICkgPT4gUmVxdWVzdElkbGVDYWxsYmFja0hhbmRsZVxuICAgIGNhbmNlbElkbGVDYWxsYmFjazogKGlkOiBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlKSA9PiB2b2lkXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPVxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYucmVxdWVzdElkbGVDYWxsYmFjaykgfHxcbiAgZnVuY3Rpb24gKFxuICAgIGNiOiAoZGVhZGxpbmU6IFJlcXVlc3RJZGxlQ2FsbGJhY2tEZWFkbGluZSkgPT4gdm9pZFxuICApOiBOb2RlSlMuVGltZW91dCB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKHtcbiAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSlcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSwgMSlcbiAgfVxuXG5leHBvcnQgY29uc3QgY2FuY2VsSWRsZUNhbGxiYWNrID1cbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLmNhbmNlbElkbGVDYWxsYmFjaykgfHxcbiAgZnVuY3Rpb24gKGlkOiBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlKSB7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChpZClcbiAgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQ2xpZW50QnVpbGRNYW5pZmVzdCB9IGZyb20gJy4uL2J1aWxkL3dlYnBhY2svcGx1Z2lucy9idWlsZC1tYW5pZmVzdC1wbHVnaW4nXG5pbXBvcnQgZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvZ2V0LWFzc2V0LXBhdGgtZnJvbS1yb3V0ZSdcbmltcG9ydCB7IHJlcXVlc3RJZGxlQ2FsbGJhY2sgfSBmcm9tICcuL3JlcXVlc3QtaWRsZS1jYWxsYmFjaydcblxuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMFxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fQlVJTERfTUFOSUZFU1Q/OiBDbGllbnRCdWlsZE1hbmlmZXN0XG4gICAgX19CVUlMRF9NQU5JRkVTVF9DQj86IEZ1bmN0aW9uXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB7XG4gIGNvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICBleHBvcnRzOiBhbnlcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkRW50cnlwb2ludEZhaWx1cmUge1xuICBlcnJvcjogdW5rbm93blxufVxuZXhwb3J0IHR5cGUgUm91dGVFbnRyeXBvaW50ID0gTG9hZGVkRW50cnlwb2ludFN1Y2Nlc3MgfCBMb2FkZWRFbnRyeXBvaW50RmFpbHVyZVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlU3R5bGVTaGVldCB7XG4gIGhyZWY6IHN0cmluZ1xuICBjb250ZW50OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRSb3V0ZVN1Y2Nlc3MgZXh0ZW5kcyBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB7XG4gIHN0eWxlczogUm91dGVTdHlsZVNoZWV0W11cbn1cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkUm91dGVGYWlsdXJlIHtcbiAgZXJyb3I6IHVua25vd25cbn1cbmV4cG9ydCB0eXBlIFJvdXRlTG9hZGVyRW50cnkgPSBMb2FkZWRSb3V0ZVN1Y2Nlc3MgfCBMb2FkZWRSb3V0ZUZhaWx1cmVcblxuZXhwb3J0IHR5cGUgRnV0dXJlPFY+ID0ge1xuICByZXNvbHZlOiAoZW50cnlwb2ludDogVikgPT4gdm9pZFxuICBmdXR1cmU6IFByb21pc2U8Vj5cbn1cbmZ1bmN0aW9uIHdpdGhGdXR1cmU8VD4oXG4gIGtleTogc3RyaW5nLFxuICBtYXA6IE1hcDxzdHJpbmcsIEZ1dHVyZTxUPiB8IFQ+LFxuICBnZW5lcmF0b3I/OiAoKSA9PiBQcm9taXNlPFQ+XG4pOiBQcm9taXNlPFQ+IHtcbiAgbGV0IGVudHJ5OiBGdXR1cmU8VD4gfCBUIHwgdW5kZWZpbmVkID0gbWFwLmdldChrZXkpXG4gIGlmIChlbnRyeSkge1xuICAgIGlmICgnZnV0dXJlJyBpbiBlbnRyeSkge1xuICAgICAgcmV0dXJuIGVudHJ5LmZ1dHVyZVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVudHJ5KVxuICB9XG4gIGxldCByZXNvbHZlcjogKGVudHJ5cG9pbnQ6IFQpID0+IHZvaWRcbiAgY29uc3QgcHJvbTogUHJvbWlzZTxUPiA9IG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlKSA9PiB7XG4gICAgcmVzb2x2ZXIgPSByZXNvbHZlXG4gIH0pXG4gIG1hcC5zZXQoa2V5LCAoZW50cnkgPSB7IHJlc29sdmU6IHJlc29sdmVyISwgZnV0dXJlOiBwcm9tIH0pKVxuICByZXR1cm4gZ2VuZXJhdG9yXG4gICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICBnZW5lcmF0b3IoKS50aGVuKCh2YWx1ZSkgPT4gKHJlc29sdmVyKHZhbHVlKSwgdmFsdWUpKVxuICAgIDogcHJvbVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlTG9hZGVyIHtcbiAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8Um91dGVFbnRyeXBvaW50PlxuICBvbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZywgZXhlY3V0ZTogKCkgPT4gdW5rbm93bik6IHZvaWRcbiAgbG9hZFJvdXRlKHJvdXRlOiBzdHJpbmcsIHByZWZldGNoPzogYm9vbGVhbik6IFByb21pc2U8Um91dGVMb2FkZXJFbnRyeT5cbiAgcHJlZmV0Y2gocm91dGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD5cbn1cblxuZnVuY3Rpb24gaGFzUHJlZmV0Y2gobGluaz86IEhUTUxMaW5rRWxlbWVudCk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJylcbiAgICByZXR1cm4gKFxuICAgICAgLy8gZGV0ZWN0IElFMTEgc2luY2UgaXQgc3VwcG9ydHMgcHJlZmV0Y2ggYnV0IGlzbid0IGRldGVjdGVkXG4gICAgICAvLyB3aXRoIHJlbExpc3Quc3VwcG9ydFxuICAgICAgKCEhd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmICEhKGRvY3VtZW50IGFzIGFueSkuZG9jdW1lbnRNb2RlKSB8fFxuICAgICAgbGluay5yZWxMaXN0LnN1cHBvcnRzKCdwcmVmZXRjaCcpXG4gICAgKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5jb25zdCBjYW5QcmVmZXRjaDogYm9vbGVhbiA9IGhhc1ByZWZldGNoKClcblxuZnVuY3Rpb24gcHJlZmV0Y2hWaWFEb20oXG4gIGhyZWY6IHN0cmluZyxcbiAgYXM6IHN0cmluZyxcbiAgbGluaz86IEhUTUxMaW5rRWxlbWVudFxuKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBsaW5rW3JlbD1cInByZWZldGNoXCJdW2hyZWZePVwiJHtocmVmfVwiXWApKSB7XG4gICAgICByZXR1cm4gcmVzKClcbiAgICB9XG5cbiAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG5cbiAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsOlxuICAgIGlmIChhcykgbGluayEuYXMgPSBhc1xuICAgIGxpbmshLnJlbCA9IGBwcmVmZXRjaGBcbiAgICBsaW5rIS5jcm9zc09yaWdpbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DUk9TU19PUklHSU4hXG4gICAgbGluayEub25sb2FkID0gcmVzXG4gICAgbGluayEub25lcnJvciA9IHJlalxuXG4gICAgLy8gYGhyZWZgIHNob3VsZCBhbHdheXMgYmUgbGFzdDpcbiAgICBsaW5rIS5ocmVmID0gaHJlZlxuXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKVxuICB9KVxufVxuXG5jb25zdCBBU1NFVF9MT0FEX0VSUk9SID0gU3ltYm9sKCdBU1NFVF9MT0FEX0VSUk9SJylcbi8vIFRPRE86IHVuZXhwb3J0XG5leHBvcnQgZnVuY3Rpb24gbWFya0Fzc2V0RXJyb3IoZXJyOiBFcnJvcik6IEVycm9yIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsIEFTU0VUX0xPQURfRVJST1IsIHt9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBc3NldEVycm9yKGVycj86IEVycm9yKTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBlcnIgJiYgQVNTRVRfTE9BRF9FUlJPUiBpbiBlcnJcbn1cblxuZnVuY3Rpb24gYXBwZW5kU2NyaXB0KFxuICBzcmM6IHN0cmluZyxcbiAgc2NyaXB0PzogSFRNTFNjcmlwdEVsZW1lbnRcbik6IFByb21pc2U8dW5rbm93bj4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG5cbiAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsLlxuICAgIC8vIDEuIFNldHVwIHN1Y2Nlc3MvZmFpbHVyZSBob29rcyBpbiBjYXNlIHRoZSBicm93c2VyIHN5bmNocm9ub3VzbHlcbiAgICAvLyAgICBleGVjdXRlcyB3aGVuIGBzcmNgIGlzIHNldC5cbiAgICBzY3JpcHQub25sb2FkID0gcmVzb2x2ZVxuICAgIHNjcmlwdC5vbmVycm9yID0gKCkgPT5cbiAgICAgIHJlamVjdChtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHNjcmlwdDogJHtzcmN9YCkpKVxuXG4gICAgLy8gMi4gQ29uZmlndXJlIHRoZSBjcm9zcy1vcmlnaW4gYXR0cmlidXRlIGJlZm9yZSBzZXR0aW5nIGBzcmNgIGluIGNhc2UgdGhlXG4gICAgLy8gICAgYnJvd3NlciBiZWdpbnMgdG8gZmV0Y2guXG4gICAgc2NyaXB0LmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTiFcblxuICAgIC8vIDMuIEZpbmFsbHksIHNldCB0aGUgc291cmNlIGFuZCBpbmplY3QgaW50byB0aGUgRE9NIGluIGNhc2UgdGhlIGNoaWxkXG4gICAgLy8gICAgbXVzdCBiZSBhcHBlbmRlZCBmb3IgZmV0Y2hpbmcgdG8gc3RhcnQuXG4gICAgc2NyaXB0LnNyYyA9IHNyY1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuICB9KVxufVxuXG4vLyBSZXNvbHZlIGEgcHJvbWlzZSB0aGF0IHRpbWVzIG91dCBhZnRlciBnaXZlbiBhbW91bnQgb2YgbWlsbGlzZWNvbmRzLlxuZnVuY3Rpb24gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dDxUPihcbiAgcDogUHJvbWlzZTxUPixcbiAgbXM6IG51bWJlcixcbiAgZXJyOiBFcnJvclxuKTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG5cbiAgICBwLnRoZW4oKHIpID0+IHtcbiAgICAgIC8vIFJlc29sdmVkLCBjYW5jZWwgdGhlIHRpbWVvdXRcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICAgIHJlc29sdmUocilcbiAgICB9KS5jYXRjaChyZWplY3QpXG5cbiAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICB9XG4gICAgICB9LCBtcylcbiAgICApXG4gIH0pXG59XG5cbi8vIFRPRE86IHN0b3AgZXhwb3J0aW5nIG9yIGNhY2hlIHRoZSBmYWlsdXJlXG4vLyBJdCdkIGJlIGJlc3QgdG8gc3RvcCBleHBvcnRpbmcgdGhpcy4gSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuIFdlJ3JlXG4vLyBvbmx5IGV4cG9ydGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWx0eSB3aXRoIHRoZSBgcGFnZS1sb2FkZXJgLlxuLy8gT25seSBjYWNoZSB0aGlzIHJlc3BvbnNlIGFzIGEgbGFzdCByZXNvcnQgaWYgd2UgY2Fubm90IGVsaW1pbmF0ZSBhbGwgb3RoZXJcbi8vIGNvZGUgYnJhbmNoZXMgdGhhdCB1c2UgdGhlIEJ1aWxkIE1hbmlmZXN0IENhbGxiYWNrIGFuZCBwdXNoIHRoZW0gdGhyb3VnaFxuLy8gdGhlIFJvdXRlIExvYWRlciBpbnRlcmZhY2UuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpOiBQcm9taXNlPENsaWVudEJ1aWxkTWFuaWZlc3Q+IHtcbiAgaWYgKHNlbGYuX19CVUlMRF9NQU5JRkVTVCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKVxuICB9XG5cbiAgY29uc3Qgb25CdWlsZE1hbmlmZXN0OiBQcm9taXNlPENsaWVudEJ1aWxkTWFuaWZlc3Q+ID0gbmV3IFByb21pc2U8XG4gICAgQ2xpZW50QnVpbGRNYW5pZmVzdFxuICA+KChyZXNvbHZlKSA9PiB7XG4gICAgLy8gTWFuZGF0b3J5IGJlY2F1c2UgdGhpcyBpcyBub3QgY29uY3VycmVudCBzYWZlOlxuICAgIGNvbnN0IGNiID0gc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCXG4gICAgc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QhKVxuICAgICAgY2IgJiYgY2IoKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dDxDbGllbnRCdWlsZE1hbmlmZXN0PihcbiAgICBvbkJ1aWxkTWFuaWZlc3QsXG4gICAgTVNfTUFYX0lETEVfREVMQVksXG4gICAgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjbGllbnQgYnVpbGQgbWFuaWZlc3QnKSlcbiAgKVxufVxuXG5pbnRlcmZhY2UgUm91dGVGaWxlcyB7XG4gIHNjcmlwdHM6IHN0cmluZ1tdXG4gIGNzczogc3RyaW5nW11cbn1cbmZ1bmN0aW9uIGdldEZpbGVzRm9yUm91dGUoXG4gIGFzc2V0UHJlZml4OiBzdHJpbmcsXG4gIHJvdXRlOiBzdHJpbmdcbik6IFByb21pc2U8Um91dGVGaWxlcz4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHNjcmlwdHM6IFtcbiAgICAgICAgYXNzZXRQcmVmaXggK1xuICAgICAgICAgICcvX25leHQvc3RhdGljL2NodW5rcy9wYWdlcycgK1xuICAgICAgICAgIGVuY29kZVVSSShnZXRBc3NldFBhdGhGcm9tUm91dGUocm91dGUsICcuanMnKSksXG4gICAgICBdLFxuICAgICAgLy8gU3R5bGVzIGFyZSBoYW5kbGVkIGJ5IGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50OlxuICAgICAgY3NzOiBbXSxcbiAgICB9KVxuICB9XG4gIHJldHVybiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkudGhlbigobWFuaWZlc3QpID0+IHtcbiAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSlcbiAgICB9XG4gICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKFxuICAgICAgKGVudHJ5KSA9PiBhc3NldFByZWZpeCArICcvX25leHQvJyArIGVuY29kZVVSSShlbnRyeSlcbiAgICApXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmlwdHM6IGFsbEZpbGVzLmZpbHRlcigodikgPT4gdi5lbmRzV2l0aCgnLmpzJykpLFxuICAgICAgY3NzOiBhbGxGaWxlcy5maWx0ZXIoKHYpID0+IHYuZW5kc1dpdGgoJy5jc3MnKSksXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZUxvYWRlcihhc3NldFByZWZpeDogc3RyaW5nKTogUm91dGVMb2FkZXIge1xuICBjb25zdCBlbnRyeXBvaW50czogTWFwPFxuICAgIHN0cmluZyxcbiAgICBGdXR1cmU8Um91dGVFbnRyeXBvaW50PiB8IFJvdXRlRW50cnlwb2ludFxuICA+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IGxvYWRlZFNjcmlwdHM6IE1hcDxzdHJpbmcsIFByb21pc2U8dW5rbm93bj4+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IHN0eWxlU2hlZXRzOiBNYXA8c3RyaW5nLCBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IHJvdXRlczogTWFwPFxuICAgIHN0cmluZyxcbiAgICBGdXR1cmU8Um91dGVMb2FkZXJFbnRyeT4gfCBSb3V0ZUxvYWRlckVudHJ5XG4gID4gPSBuZXcgTWFwKClcblxuICBmdW5jdGlvbiBtYXliZUV4ZWN1dGVTY3JpcHQoc3JjOiBzdHJpbmcpOiBQcm9taXNlPHVua25vd24+IHtcbiAgICBsZXQgcHJvbTogUHJvbWlzZTx1bmtub3duPiB8IHVuZGVmaW5lZCA9IGxvYWRlZFNjcmlwdHMuZ2V0KHNyYylcbiAgICBpZiAocHJvbSkge1xuICAgICAgcmV0dXJuIHByb21cbiAgICB9XG5cbiAgICAvLyBTa2lwIGV4ZWN1dGluZyBzY3JpcHQgaWYgaXQncyBhbHJlYWR5IGluIHRoZSBET006XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmNePVwiJHtzcmN9XCJdYCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIGxvYWRlZFNjcmlwdHMuc2V0KHNyYywgKHByb20gPSBhcHBlbmRTY3JpcHQoc3JjKSkpXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoU3R5bGVTaGVldChocmVmOiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4ge1xuICAgIGxldCBwcm9tOiBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4gfCB1bmRlZmluZWQgPSBzdHlsZVNoZWV0cy5nZXQoaHJlZilcbiAgICBpZiAocHJvbSkge1xuICAgICAgcmV0dXJuIHByb21cbiAgICB9XG5cbiAgICBzdHlsZVNoZWV0cy5zZXQoXG4gICAgICBocmVmLFxuICAgICAgKHByb20gPSBmZXRjaChocmVmKVxuICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3R5bGVzaGVldDogJHtocmVmfWApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXMudGV4dCgpLnRoZW4oKHRleHQpID0+ICh7IGhyZWY6IGhyZWYsIGNvbnRlbnQ6IHRleHQgfSkpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKVxuICAgICAgICB9KSlcbiAgICApXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZykge1xuICAgICAgcmV0dXJuIHdpdGhGdXR1cmUocm91dGUsIGVudHJ5cG9pbnRzKVxuICAgIH0sXG4gICAgb25FbnRyeXBvaW50KHJvdXRlOiBzdHJpbmcsIGV4ZWN1dGU6ICgpID0+IHVua25vd24pIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZShleGVjdXRlKVxuICAgICAgICAudGhlbigoZm4pID0+IGZuKCkpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgIChleHBvcnRzOiBhbnkpID0+ICh7XG4gICAgICAgICAgICBjb21wb25lbnQ6IChleHBvcnRzICYmIGV4cG9ydHMuZGVmYXVsdCkgfHwgZXhwb3J0cyxcbiAgICAgICAgICAgIGV4cG9ydHM6IGV4cG9ydHMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgKGVycikgPT4gKHsgZXJyb3I6IGVyciB9KVxuICAgICAgICApXG4gICAgICAgIC50aGVuKChpbnB1dDogUm91dGVFbnRyeXBvaW50KSA9PiB7XG4gICAgICAgICAgY29uc3Qgb2xkID0gZW50cnlwb2ludHMuZ2V0KHJvdXRlKVxuICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpXG4gICAgICAgICAgaWYgKG9sZCAmJiAncmVzb2x2ZScgaW4gb2xkKSBvbGQucmVzb2x2ZShpbnB1dClcbiAgICAgICAgfSlcbiAgICB9LFxuICAgIGxvYWRSb3V0ZShyb3V0ZTogc3RyaW5nLCBwcmVmZXRjaD86IGJvb2xlYW4pIHtcbiAgICAgIHJldHVybiB3aXRoRnV0dXJlPFJvdXRlTG9hZGVyRW50cnk+KHJvdXRlLCByb3V0ZXMsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQoXG4gICAgICAgICAgZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpXG4gICAgICAgICAgICAudGhlbigoeyBzY3JpcHRzLCBjc3MgfSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmhhcyhyb3V0ZSlcbiAgICAgICAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgICAgICAgIDogUHJvbWlzZS5hbGwoc2NyaXB0cy5tYXAobWF5YmVFeGVjdXRlU2NyaXB0KSksXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoY3NzLm1hcChmZXRjaFN0eWxlU2hlZXQpKSxcbiAgICAgICAgICAgICAgXSBhcyBjb25zdClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZW5FbnRyeXBvaW50KHJvdXRlKS50aGVuKChlbnRyeXBvaW50KSA9PiAoe1xuICAgICAgICAgICAgICAgIGVudHJ5cG9pbnQsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiByZXNbMV0sXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgTVNfTUFYX0lETEVfREVMQVksXG4gICAgICAgICAgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBSb3V0ZSBkaWQgbm90IGNvbXBsZXRlIGxvYWRpbmc6ICR7cm91dGV9YCkpXG4gICAgICAgIClcbiAgICAgICAgICAudGhlbigoeyBlbnRyeXBvaW50LCBzdHlsZXMgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzOiBSb3V0ZUxvYWRlckVudHJ5ID0gT2JqZWN0LmFzc2lnbjxcbiAgICAgICAgICAgICAgeyBzdHlsZXM6IFJvdXRlU3R5bGVTaGVldFtdIH0sXG4gICAgICAgICAgICAgIFJvdXRlRW50cnlwb2ludFxuICAgICAgICAgICAgPih7IHN0eWxlczogc3R5bGVzISB9LCBlbnRyeXBvaW50KVxuICAgICAgICAgICAgcmV0dXJuICdlcnJvcicgaW4gZW50cnlwb2ludCA/IGVudHJ5cG9pbnQgOiByZXNcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJlZmV0Y2gpIHtcbiAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjYWNoZSBlcnJvcnMgZHVyaW5nIHByZWZldGNoXG4gICAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGVyciB9XG4gICAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICBwcmVmZXRjaChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy9xdWlja2xpbmsvYmxvYi80NTNhNjYxZmExZmE5NDBlMmQyZTA0NDQ1MjM5OGUzOGM2N2E5OGZiL3NyYy9pbmRleC5tanMjTDExNS1MMTE4XG4gICAgICAvLyBMaWNlbnNlOiBBcGFjaGUgMi4wXG4gICAgICBsZXQgY25cbiAgICAgIGlmICgoY24gPSAobmF2aWdhdG9yIGFzIGFueSkuY29ubmVjdGlvbikpIHtcbiAgICAgICAgLy8gRG9uJ3QgcHJlZmV0Y2ggaWYgdXNpbmcgMkcgb3IgaWYgU2F2ZS1EYXRhIGlzIGVuYWJsZWQuXG4gICAgICAgIGlmIChjbi5zYXZlRGF0YSB8fCAvMmcvLnRlc3QoY24uZWZmZWN0aXZlVHlwZSkpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEZpbGVzRm9yUm91dGUoYXNzZXRQcmVmaXgsIHJvdXRlKVxuICAgICAgICAudGhlbigob3V0cHV0KSA9PlxuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgY2FuUHJlZmV0Y2hcbiAgICAgICAgICAgICAgPyBvdXRwdXQuc2NyaXB0cy5tYXAoKHNjcmlwdCkgPT4gcHJlZmV0Y2hWaWFEb20oc2NyaXB0LCAnc2NyaXB0JykpXG4gICAgICAgICAgICAgIDogW11cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4gdGhpcy5sb2FkUm91dGUocm91dGUsIHRydWUpLmNhdGNoKCgpID0+IHt9KSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKFxuICAgICAgICAgIC8vIHN3YWxsb3cgcHJlZmV0Y2ggZXJyb3JzXG4gICAgICAgICAgKCkgPT4ge31cbiAgICAgICAgKVxuICAgIH0sXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUm91dGVMb2FkZXJcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBSb3V0ZXIsIHsgTmV4dFJvdXRlciB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgUm91dGVyQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dCdcblxudHlwZSBDbGFzc0FyZ3VtZW50czxUPiA9IFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGluZmVyIFUpID0+IGFueSA/IFUgOiBhbnlcblxudHlwZSBSb3V0ZXJBcmdzID0gQ2xhc3NBcmd1bWVudHM8dHlwZW9mIFJvdXRlcj5cblxudHlwZSBTaW5nbGV0b25Sb3V0ZXJCYXNlID0ge1xuICByb3V0ZXI6IFJvdXRlciB8IG51bGxcbiAgcmVhZHlDYWxsYmFja3M6IEFycmF5PCgpID0+IGFueT5cbiAgcmVhZHkoY2I6ICgpID0+IGFueSk6IHZvaWRcbn1cblxuZXhwb3J0IHsgUm91dGVyLCBOZXh0Um91dGVyIH1cblxuZXhwb3J0IHR5cGUgU2luZ2xldG9uUm91dGVyID0gU2luZ2xldG9uUm91dGVyQmFzZSAmIE5leHRSb3V0ZXJcblxuY29uc3Qgc2luZ2xldG9uUm91dGVyOiBTaW5nbGV0b25Sb3V0ZXJCYXNlID0ge1xuICByb3V0ZXI6IG51bGwsIC8vIGhvbGRzIHRoZSBhY3R1YWwgcm91dGVyIGluc3RhbmNlXG4gIHJlYWR5Q2FsbGJhY2tzOiBbXSxcbiAgcmVhZHkoY2I6ICgpID0+IHZvaWQpIHtcbiAgICBpZiAodGhpcy5yb3V0ZXIpIHJldHVybiBjYigpXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlYWR5Q2FsbGJhY2tzLnB1c2goY2IpXG4gICAgfVxuICB9LFxufVxuXG4vLyBDcmVhdGUgcHVibGljIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb2YgdGhlIHJvdXRlciBpbiB0aGUgc2luZ2xldG9uUm91dGVyXG5jb25zdCB1cmxQcm9wZXJ0eUZpZWxkcyA9IFtcbiAgJ3BhdGhuYW1lJyxcbiAgJ3JvdXRlJyxcbiAgJ3F1ZXJ5JyxcbiAgJ2FzUGF0aCcsXG4gICdjb21wb25lbnRzJyxcbiAgJ2lzRmFsbGJhY2snLFxuICAnYmFzZVBhdGgnLFxuICAnbG9jYWxlJyxcbiAgJ2xvY2FsZXMnLFxuICAnZGVmYXVsdExvY2FsZScsXG4gICdpc1JlYWR5JyxcbiAgJ2lzUHJldmlldycsXG4gICdpc0xvY2FsZURvbWFpbicsXG5dXG5jb25zdCByb3V0ZXJFdmVudHMgPSBbXG4gICdyb3V0ZUNoYW5nZVN0YXJ0JyxcbiAgJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLFxuICAncm91dGVDaGFuZ2VDb21wbGV0ZScsXG4gICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgJ2hhc2hDaGFuZ2VTdGFydCcsXG4gICdoYXNoQ2hhbmdlQ29tcGxldGUnLFxuXVxuY29uc3QgY29yZU1ldGhvZEZpZWxkcyA9IFtcbiAgJ3B1c2gnLFxuICAncmVwbGFjZScsXG4gICdyZWxvYWQnLFxuICAnYmFjaycsXG4gICdwcmVmZXRjaCcsXG4gICdiZWZvcmVQb3BTdGF0ZScsXG5dXG5cbi8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsICdldmVudHMnLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gUm91dGVyLmV2ZW50c1xuICB9LFxufSlcblxudXJsUHJvcGVydHlGaWVsZHMuZm9yRWFjaCgoZmllbGQ6IHN0cmluZykgPT4ge1xuICAvLyBIZXJlIHdlIG5lZWQgdG8gdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBiZWNhdXNlLCB3ZSBuZWVkIHRvIHJldHVyblxuICAvLyB0aGUgcHJvcGVydHkgYXNzaWduZWQgdG8gdGhlIGFjdHVhbCByb3V0ZXJcbiAgLy8gVGhlIHZhbHVlIG1pZ2h0IGdldCBjaGFuZ2VkIGFzIHdlIGNoYW5nZSByb3V0ZXMgYW5kIHRoaXMgaXMgdGhlXG4gIC8vIHByb3BlciB3YXkgdG8gYWNjZXNzIGl0XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsIGZpZWxkLCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSBhcyBzdHJpbmdcbiAgICB9LFxuICB9KVxufSlcblxuY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZDogc3RyaW5nKSA9PiB7XG4gIC8vIFdlIGRvbid0IHJlYWxseSBrbm93IHRoZSB0eXBlcyBoZXJlLCBzbyB3ZSBhZGQgdGhlbSBsYXRlciBpbnN0ZWFkXG4gIDsoc2luZ2xldG9uUm91dGVyIGFzIGFueSlbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgcmV0dXJuIHJvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgfVxufSlcblxucm91dGVyRXZlbnRzLmZvckVhY2goKGV2ZW50OiBzdHJpbmcpID0+IHtcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5KCgpID0+IHtcbiAgICBSb3V0ZXIuZXZlbnRzLm9uKGV2ZW50LCAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgZXZlbnRGaWVsZCA9IGBvbiR7ZXZlbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHtldmVudC5zdWJzdHJpbmcoXG4gICAgICAgIDFcbiAgICAgICl9YFxuICAgICAgY29uc3QgX3NpbmdsZXRvblJvdXRlciA9IHNpbmdsZXRvblJvdXRlciBhcyBhbnlcbiAgICAgIGlmIChfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSguLi5hcmdzKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGVuIHJ1bm5pbmcgdGhlIFJvdXRlciBldmVudDogJHtldmVudEZpZWxkfWApXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIGdldFJvdXRlcigpOiBSb3V0ZXIge1xuICBpZiAoIXNpbmdsZXRvblJvdXRlci5yb3V0ZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICdObyByb3V0ZXIgaW5zdGFuY2UgZm91bmQuXFxuJyArXG4gICAgICAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgaW5zaWRlIHRoZSBjbGllbnQgc2lkZSBvZiB5b3VyIGFwcC5cXG4nXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gRXhwb3J0IHRoZSBzaW5nbGV0b25Sb3V0ZXIgYW5kIHRoaXMgaXMgdGhlIHB1YmxpYyBBUEkuXG5leHBvcnQgZGVmYXVsdCBzaW5nbGV0b25Sb3V0ZXIgYXMgU2luZ2xldG9uUm91dGVyXG5cbi8vIFJlZXhwb3J0IHRoZSB3aXRoUm91dGUgSE9DXG5leHBvcnQgeyBkZWZhdWx0IGFzIHdpdGhSb3V0ZXIgfSBmcm9tICcuL3dpdGgtcm91dGVyJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyKCk6IE5leHRSb3V0ZXIge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KVxufVxuXG4vLyBJTlRFUk5BTCBBUElTXG4vLyAtLS0tLS0tLS0tLS0tXG4vLyAoZG8gbm90IHVzZSBmb2xsb3dpbmcgZXhwb3J0cyBpbnNpZGUgdGhlIGFwcClcblxuLy8gQ3JlYXRlIGEgcm91dGVyIGFuZCBhc3NpZ24gaXQgYXMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZS5cbi8vIFRoaXMgaXMgdXNlZCBpbiBjbGllbnQgc2lkZSB3aGVuIHdlIGFyZSBpbml0aWxpemluZyB0aGUgYXBwLlxuLy8gVGhpcyBzaG91bGQgKipub3QqKiB1c2UgaW5zaWRlIHRoZSBzZXJ2ZXIuXG5leHBvcnQgY29uc3QgY3JlYXRlUm91dGVyID0gKC4uLmFyZ3M6IFJvdXRlckFyZ3MpOiBSb3V0ZXIgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucm91dGVyID0gbmV3IFJvdXRlciguLi5hcmdzKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKCkpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcyA9IFtdXG5cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgYHdpdGhSb3V0ZXJgIHJvdXRlciBpbnN0YW5jZVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXI6IFJvdXRlcik6IE5leHRSb3V0ZXIge1xuICBjb25zdCBfcm91dGVyID0gcm91dGVyIGFzIGFueVxuICBjb25zdCBpbnN0YW5jZSA9IHt9IGFzIGFueVxuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdXJsUHJvcGVydHlGaWVsZHMpIHtcbiAgICBpZiAodHlwZW9mIF9yb3V0ZXJbcHJvcGVydHldID09PSAnb2JqZWN0Jykge1xuICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgQXJyYXkuaXNBcnJheShfcm91dGVyW3Byb3BlcnR5XSkgPyBbXSA6IHt9LFxuICAgICAgICBfcm91dGVyW3Byb3BlcnR5XVxuICAgICAgKSAvLyBtYWtlcyBzdXJlIHF1ZXJ5IGlzIG5vdCBzdGF0ZWZ1bFxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBfcm91dGVyW3Byb3BlcnR5XVxuICB9XG5cbiAgLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuICBpbnN0YW5jZS5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgIGluc3RhbmNlW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgcmV0dXJuIF9yb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBpbnN0YW5jZVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTmV4dENvbXBvbmVudFR5cGUsIE5leHRQYWdlQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi91dGlscydcbmltcG9ydCB7IE5leHRSb3V0ZXIsIHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuXG5leHBvcnQgdHlwZSBXaXRoUm91dGVyUHJvcHMgPSB7XG4gIHJvdXRlcjogTmV4dFJvdXRlclxufVxuXG5leHBvcnQgdHlwZSBFeGNsdWRlUm91dGVyUHJvcHM8UD4gPSBQaWNrPFxuICBQLFxuICBFeGNsdWRlPGtleW9mIFAsIGtleW9mIFdpdGhSb3V0ZXJQcm9wcz5cbj5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2l0aFJvdXRlcjxcbiAgUCBleHRlbmRzIFdpdGhSb3V0ZXJQcm9wcyxcbiAgQyA9IE5leHRQYWdlQ29udGV4dFxuPihcbiAgQ29tcG9zZWRDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPEMsIGFueSwgUD5cbik6IFJlYWN0LkNvbXBvbmVudFR5cGU8RXhjbHVkZVJvdXRlclByb3BzPFA+PiB7XG4gIGZ1bmN0aW9uIFdpdGhSb3V0ZXJXcmFwcGVyKHByb3BzOiBhbnkpOiBKU1guRWxlbWVudCB7XG4gICAgcmV0dXJuIDxDb21wb3NlZENvbXBvbmVudCByb3V0ZXI9e3VzZVJvdXRlcigpfSB7Li4ucHJvcHN9IC8+XG4gIH1cblxuICBXaXRoUm91dGVyV3JhcHBlci5nZXRJbml0aWFsUHJvcHMgPSBDb21wb3NlZENvbXBvbmVudC5nZXRJbml0aWFsUHJvcHNcbiAgLy8gVGhpcyBpcyBuZWVkZWQgdG8gYWxsb3cgY2hlY2tpbmcgZm9yIGN1c3RvbSBnZXRJbml0aWFsUHJvcHMgaW4gX2FwcFxuICA7KFdpdGhSb3V0ZXJXcmFwcGVyIGFzIGFueSkub3JpZ0dldEluaXRpYWxQcm9wcyA9IChDb21wb3NlZENvbXBvbmVudCBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHNcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBuYW1lID1cbiAgICAgIENvbXBvc2VkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvc2VkQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG4gICAgV2l0aFJvdXRlcldyYXBwZXIuZGlzcGxheU5hbWUgPSBgd2l0aFJvdXRlcigke25hbWV9KWBcbiAgfVxuXG4gIHJldHVybiBXaXRoUm91dGVyV3JhcHBlclxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gIHBhdGhuYW1lOiBzdHJpbmcsXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuKToge1xuICBkZXRlY3RlZExvY2FsZT86IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG59IHtcbiAgbGV0IGRldGVjdGVkTG9jYWxlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgLy8gZmlyc3QgaXRlbSB3aWxsIGJlIGVtcHR5IHN0cmluZyBmcm9tIHNwbGl0dGluZyBhdCBmaXJzdCBjaGFyXG4gIGNvbnN0IHBhdGhuYW1lUGFydHMgPSBwYXRobmFtZS5zcGxpdCgnLycpXG5cbiAgOyhsb2NhbGVzIHx8IFtdKS5zb21lKChsb2NhbGUpID0+IHtcbiAgICBpZiAocGF0aG5hbWVQYXJ0c1sxXS50b0xvd2VyQ2FzZSgpID09PSBsb2NhbGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgZGV0ZWN0ZWRMb2NhbGUgPSBsb2NhbGVcbiAgICAgIHBhdGhuYW1lUGFydHMuc3BsaWNlKDEsIDEpXG4gICAgICBwYXRobmFtZSA9IHBhdGhuYW1lUGFydHMuam9pbignLycpIHx8ICcvJ1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBkZXRlY3RlZExvY2FsZSxcbiAgfVxufVxuIiwiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgSmFzb24gTWlsbGVyIChodHRwczovL2phc29uZm9ybWF0LmNvbS8pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L21pdHQvYmxvYi92MS4xLjMvc3JjL2luZGV4LmpzXG4vLyBJdCdzIGJlZW4gZWRpdGVkIGZvciB0aGUgbmVlZHMgb2YgdGhpcyBzY3JpcHRcbi8vIFNlZSB0aGUgTElDRU5TRSBhdCB0aGUgdG9wIG9mIHRoZSBmaWxlXG5cbnR5cGUgSGFuZGxlciA9ICguLi5ldnRzOiBhbnlbXSkgPT4gdm9pZFxuXG5leHBvcnQgdHlwZSBNaXR0RW1pdHRlciA9IHtcbiAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pOiB2b2lkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pdHQoKTogTWl0dEVtaXR0ZXIge1xuICBjb25zdCBhbGw6IHsgW3M6IHN0cmluZ106IEhhbmRsZXJbXSB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIHJldHVybiB7XG4gICAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICA7KGFsbFt0eXBlXSB8fCAoYWxsW3R5cGVdID0gW10pKS5wdXNoKGhhbmRsZXIpXG4gICAgfSxcblxuICAgIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIGlmIChhbGxbdHlwZV0pIHtcbiAgICAgICAgYWxsW3R5cGVdLnNwbGljZShhbGxbdHlwZV0uaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICA7KGFsbFt0eXBlXSB8fCBbXSkuc2xpY2UoKS5tYXAoKGhhbmRsZXI6IEhhbmRsZXIpID0+IHtcbiAgICAgICAgaGFuZGxlciguLi5ldnRzKVxuICAgICAgfSlcbiAgICB9LFxuICB9XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuXG5leHBvcnQgY29uc3QgUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmV4dFJvdXRlcj4obnVsbCBhcyBhbnkpXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnUm91dGVyQ29udGV4dCdcbn1cbiIsIi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQge1xuICBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCxcbiAgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gsXG59IGZyb20gJy4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQgeyBHb29kUGFnZUNhY2hlLCBTdHlsZVNoZWV0VHVwbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcGFnZS1sb2FkZXInXG5pbXBvcnQge1xuICBnZXRDbGllbnRCdWlsZE1hbmlmZXN0LFxuICBpc0Fzc2V0RXJyb3IsXG4gIG1hcmtBc3NldEVycm9yLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyJ1xuaW1wb3J0IHsgRG9tYWluTG9jYWxlcyB9IGZyb20gJy4uLy4uL3NlcnZlci9jb25maWcnXG5pbXBvcnQgeyBkZW5vcm1hbGl6ZVBhZ2VQYXRoIH0gZnJvbSAnLi4vLi4vc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aCdcbmltcG9ydCB7IG5vcm1hbGl6ZUxvY2FsZVBhdGggfSBmcm9tICcuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCdcbmltcG9ydCBtaXR0LCB7IE1pdHRFbWl0dGVyIH0gZnJvbSAnLi4vbWl0dCdcbmltcG9ydCB7XG4gIEFwcENvbnRleHRUeXBlLFxuICBmb3JtYXRXaXRoVmFsaWRhdGlvbixcbiAgZ2V0TG9jYXRpb25PcmlnaW4sXG4gIGdldFVSTCxcbiAgbG9hZEdldEluaXRpYWxQcm9wcyxcbiAgTmV4dFBhZ2VDb250ZXh0LFxuICBTVCxcbiAgTkVYVF9EQVRBLFxufSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IGlzRHluYW1pY1JvdXRlIH0gZnJvbSAnLi91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJ1xuaW1wb3J0IHsgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSB9IGZyb20gJy4vdXRpbHMvcXVlcnlzdHJpbmcnXG5pbXBvcnQgcmVzb2x2ZVJld3JpdGVzIGZyb20gJy4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcydcbmltcG9ydCB7IGdldFJvdXRlTWF0Y2hlciB9IGZyb20gJy4vdXRpbHMvcm91dGUtbWF0Y2hlcidcbmltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3V0aWxzL3JvdXRlLXJlZ2V4J1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIC8qIHByb2QgKi9cbiAgICBfX05FWFRfREFUQV9fOiBORVhUX0RBVEFcbiAgfVxufVxuXG5pbnRlcmZhY2UgUm91dGVQcm9wZXJ0aWVzIHtcbiAgc2hhbGxvdzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgVHJhbnNpdGlvbk9wdGlvbnMge1xuICBzaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxuICBzY3JvbGw/OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBOZXh0SGlzdG9yeVN0YXRlIHtcbiAgdXJsOiBzdHJpbmdcbiAgYXM6IHN0cmluZ1xuICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9uc1xufVxuXG50eXBlIEhpc3RvcnlTdGF0ZSA9XG4gIHwgbnVsbFxuICB8IHsgX19OOiBmYWxzZSB9XG4gIHwgKHsgX19OOiB0cnVlOyBpZHg6IG51bWJlciB9ICYgTmV4dEhpc3RvcnlTdGF0ZSlcblxubGV0IGRldGVjdERvbWFpbkxvY2FsZTogdHlwZW9mIGltcG9ydCgnLi4vaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZScpLmRldGVjdERvbWFpbkxvY2FsZVxuXG5pZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICBkZXRlY3REb21haW5Mb2NhbGUgPSByZXF1aXJlKCcuLi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJylcbiAgICAuZGV0ZWN0RG9tYWluTG9jYWxlXG59XG5cbmNvbnN0IGJhc2VQYXRoID0gKHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggYXMgc3RyaW5nKSB8fCAnJ1xuXG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1JvdXRlIENhbmNlbGxlZCcpLCB7XG4gICAgY2FuY2VsbGVkOiB0cnVlLFxuICB9KVxufVxuXG5mdW5jdGlvbiBhZGRQYXRoUHJlZml4KHBhdGg6IHN0cmluZywgcHJlZml4Pzogc3RyaW5nKSB7XG4gIHJldHVybiBwcmVmaXggJiYgcGF0aC5zdGFydHNXaXRoKCcvJylcbiAgICA/IHBhdGggPT09ICcvJ1xuICAgICAgPyBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChwcmVmaXgpXG4gICAgICA6IGAke3ByZWZpeH0ke3BhdGhOb1F1ZXJ5SGFzaChwYXRoKSA9PT0gJy8nID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRofWBcbiAgICA6IHBhdGhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERvbWFpbkxvY2FsZShcbiAgcGF0aDogc3RyaW5nLFxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZSxcbiAgbG9jYWxlcz86IHN0cmluZ1tdLFxuICBkb21haW5Mb2NhbGVzPzogRG9tYWluTG9jYWxlc1xuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgbG9jYWxlID0gbG9jYWxlIHx8IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGVcblxuICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbG9jYWxlKVxuXG4gICAgaWYgKGRldGVjdGVkRG9tYWluKSB7XG4gICAgICByZXR1cm4gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke2RldGVjdGVkRG9tYWluLmRvbWFpbn0ke1xuICAgICAgICBiYXNlUGF0aCB8fCAnJ1xuICAgICAgfSR7bG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7bG9jYWxlfWB9JHtwYXRofWBcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExvY2FsZShcbiAgcGF0aDogc3RyaW5nLFxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZSxcbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgY29uc3QgcGF0aG5hbWUgPSBwYXRoTm9RdWVyeUhhc2gocGF0aClcbiAgICBjb25zdCBwYXRoTG93ZXIgPSBwYXRobmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgY29uc3QgbG9jYWxlTG93ZXIgPSBsb2NhbGUgJiYgbG9jYWxlLnRvTG93ZXJDYXNlKClcblxuICAgIHJldHVybiBsb2NhbGUgJiZcbiAgICAgIGxvY2FsZSAhPT0gZGVmYXVsdExvY2FsZSAmJlxuICAgICAgIXBhdGhMb3dlci5zdGFydHNXaXRoKCcvJyArIGxvY2FsZUxvd2VyICsgJy8nKSAmJlxuICAgICAgcGF0aExvd2VyICE9PSAnLycgKyBsb2NhbGVMb3dlclxuICAgICAgPyBhZGRQYXRoUHJlZml4KHBhdGgsICcvJyArIGxvY2FsZSlcbiAgICAgIDogcGF0aFxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxMb2NhbGUocGF0aDogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICBjb25zdCBwYXRobmFtZSA9IHBhdGhOb1F1ZXJ5SGFzaChwYXRoKVxuICAgIGNvbnN0IHBhdGhMb3dlciA9IHBhdGhuYW1lLnRvTG93ZXJDYXNlKClcbiAgICBjb25zdCBsb2NhbGVMb3dlciA9IGxvY2FsZSAmJiBsb2NhbGUudG9Mb3dlckNhc2UoKVxuXG4gICAgcmV0dXJuIGxvY2FsZSAmJlxuICAgICAgKHBhdGhMb3dlci5zdGFydHNXaXRoKCcvJyArIGxvY2FsZUxvd2VyICsgJy8nKSB8fFxuICAgICAgICBwYXRoTG93ZXIgPT09ICcvJyArIGxvY2FsZUxvd2VyKVxuICAgICAgPyAocGF0aG5hbWUubGVuZ3RoID09PSBsb2NhbGUubGVuZ3RoICsgMSA/ICcvJyA6ICcnKSArXG4gICAgICAgICAgcGF0aC5zdWJzdHIobG9jYWxlLmxlbmd0aCArIDEpXG4gICAgICA6IHBhdGhcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5mdW5jdGlvbiBwYXRoTm9RdWVyeUhhc2gocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKVxuICBjb25zdCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKVxuXG4gIGlmIChxdWVyeUluZGV4ID4gLTEgfHwgaGFzaEluZGV4ID4gLTEpIHtcbiAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcXVlcnlJbmRleCA+IC0xID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleClcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQmFzZVBhdGgocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHBhdGggPSBwYXRoTm9RdWVyeUhhc2gocGF0aClcbiAgcmV0dXJuIHBhdGggPT09IGJhc2VQYXRoIHx8IHBhdGguc3RhcnRzV2l0aChiYXNlUGF0aCArICcvJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIHdlIG9ubHkgYWRkIHRoZSBiYXNlcGF0aCBvbiByZWxhdGl2ZSB1cmxzXG4gIHJldHVybiBhZGRQYXRoUHJlZml4KHBhdGgsIGJhc2VQYXRoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKVxuICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSBwYXRoID0gYC8ke3BhdGh9YFxuICByZXR1cm4gcGF0aFxufVxuXG4vKipcbiAqIERldGVjdHMgd2hldGhlciBhIGdpdmVuIHVybCBpcyByb3V0YWJsZSBieSB0aGUgTmV4dC5qcyByb3V0ZXIgKGJyb3dzZXIgb25seSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2FsVVJMKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIHByZXZlbnQgYSBoeWRyYXRpb24gbWlzbWF0Y2ggb24gaHJlZiBmb3IgdXJsIHdpdGggYW5jaG9yIHJlZnNcbiAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykgfHwgdXJsLnN0YXJ0c1dpdGgoJyMnKSkgcmV0dXJuIHRydWVcbiAgdHJ5IHtcbiAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICBjb25zdCBsb2NhdGlvbk9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbilcbiAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiBoYXNCYXNlUGF0aChyZXNvbHZlZC5wYXRobmFtZSlcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbnR5cGUgVXJsID0gVXJsT2JqZWN0IHwgc3RyaW5nXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZUFzKFxuICByb3V0ZTogc3RyaW5nLFxuICBhc1BhdGhuYW1lOiBzdHJpbmcsXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuKSB7XG4gIGxldCBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnXG5cbiAgY29uc3QgZHluYW1pY1JlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHNcbiAgY29uc3QgZHluYW1pY01hdGNoZXMgPVxuICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZHluYW1pYyByb3V0ZSBhZ2FpbnN0IHRoZSBhc1BhdGhcbiAgICAoYXNQYXRobmFtZSAhPT0gcm91dGUgPyBnZXRSb3V0ZU1hdGNoZXIoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKSA6ICcnKSB8fFxuICAgIC8vIEZhbGwgYmFjayB0byByZWFkaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgaHJlZlxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIHRha2UgcHJpb3JpdHk7IGFsc28gbmVlZCB0byBjaGFuZ2UgaW4gdGhlIHJvdXRlci5cbiAgICBxdWVyeVxuXG4gIGludGVycG9sYXRlZFJvdXRlID0gcm91dGVcbiAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3VwcylcblxuICBpZiAoXG4gICAgIXBhcmFtcy5ldmVyeSgocGFyYW0pID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGR5bmFtaWNNYXRjaGVzW3BhcmFtXSB8fCAnJ1xuICAgICAgY29uc3QgeyByZXBlYXQsIG9wdGlvbmFsIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXVxuXG4gICAgICAvLyBzdXBwb3J0IHNpbmdsZS1sZXZlbCBjYXRjaC1hbGxcbiAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgIGxldCByZXBsYWNlZCA9IGBbJHtyZXBlYXQgPyAnLi4uJyA6ICcnfSR7cGFyYW19XWBcbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICByZXBsYWNlZCA9IGAkeyF2YWx1ZSA/ICcvJyA6ICcnfVske3JlcGxhY2VkfV1gXG4gICAgICB9XG4gICAgICBpZiAocmVwZWF0ICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbdmFsdWVdXG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIChvcHRpb25hbCB8fCBwYXJhbSBpbiBkeW5hbWljTWF0Y2hlcykgJiZcbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgZ3JvdXAgaW50byBkYXRhIFVSTCBpZiBwcmVzZW50XG4gICAgICAgIChpbnRlcnBvbGF0ZWRSb3V0ZSA9XG4gICAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUhLnJlcGxhY2UoXG4gICAgICAgICAgICByZXBsYWNlZCxcbiAgICAgICAgICAgIHJlcGVhdFxuICAgICAgICAgICAgICA/ICh2YWx1ZSBhcyBzdHJpbmdbXSlcbiAgICAgICAgICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIHZhbHVlcyBzaG91bGQgYmUgZnVsbHkgZW5jb2RlZCBpbnN0ZWFkIG9mIGp1c3RcbiAgICAgICAgICAgICAgICAgICAgLy8gcGF0aCBkZWxpbWl0ZXIgZXNjYXBlZCBzaW5jZSB0aGV5IGFyZSBiZWluZyBpbnNlcnRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIHRoZSBVUkwgYW5kIHdlIGV4cGVjdCBVUkwgZW5jb2RlZCBzZWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHBhcnNpbmcgZHluYW1pYyByb3V0ZSBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgKHNlZ21lbnQpID0+IGVuY29kZVVSSUNvbXBvbmVudChzZWdtZW50KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgLmpvaW4oJy8nKVxuICAgICAgICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSBhcyBzdHJpbmcpXG4gICAgICAgICAgKSB8fCAnLycpXG4gICAgICApXG4gICAgfSlcbiAgKSB7XG4gICAgaW50ZXJwb2xhdGVkUm91dGUgPSAnJyAvLyBkaWQgbm90IHNhdGlzZnkgYWxsIHJlcXVpcmVtZW50c1xuXG4gICAgLy8gbi5iLiBXZSBpZ25vcmUgdGhpcyBlcnJvciBiZWNhdXNlIHdlIGhhbmRsZSB3YXJuaW5nIGZvciB0aGlzIGNhc2UgaW5cbiAgICAvLyBkZXZlbG9wbWVudCBpbiB0aGUgYDxMaW5rPmAgY29tcG9uZW50IGRpcmVjdGx5LlxuICB9XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHJlc3VsdDogaW50ZXJwb2xhdGVkUm91dGUsXG4gIH1cbn1cblxuZnVuY3Rpb24gb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSwgcGFyYW1zOiBzdHJpbmdbXSkge1xuICBjb25zdCBmaWx0ZXJlZFF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSA9IHt9XG5cbiAgT2JqZWN0LmtleXMocXVlcnkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICghcGFyYW1zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGZpbHRlcmVkUXVlcnlba2V5XSA9IHF1ZXJ5W2tleV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBmaWx0ZXJlZFF1ZXJ5XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYSBnaXZlbiBoeXBlcmxpbmsgd2l0aCBhIGNlcnRhaW4gcm91dGVyIHN0YXRlIChiYXNlUGF0aCBub3QgaW5jbHVkZWQpLlxuICogUHJlc2VydmVzIGFic29sdXRlIHVybHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlSHJlZihcbiAgY3VycmVudFBhdGg6IHN0cmluZyxcbiAgaHJlZjogVXJsLFxuICByZXNvbHZlQXM/OiBib29sZWFuXG4pOiBzdHJpbmcge1xuICAvLyB3ZSB1c2UgYSBkdW1teSBiYXNlIHVybCBmb3IgcmVsYXRpdmUgdXJsc1xuICBsZXQgYmFzZTogVVJMXG5cbiAgdHJ5IHtcbiAgICBiYXNlID0gbmV3IFVSTChjdXJyZW50UGF0aCwgJ2h0dHA6Ly9uJylcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIGZhbGxiYWNrIHRvIC8gZm9yIGludmFsaWQgYXNQYXRoIHZhbHVlcyBlLmcuIC8vXG4gICAgYmFzZSA9IG5ldyBVUkwoJy8nLCAnaHR0cDovL24nKVxuICB9XG4gIGNvbnN0IHVybEFzU3RyaW5nID1cbiAgICB0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgPyBocmVmIDogZm9ybWF0V2l0aFZhbGlkYXRpb24oaHJlZilcbiAgLy8gUmV0dXJuIGJlY2F1c2UgaXQgY2Fubm90IGJlIHJvdXRlZCBieSB0aGUgTmV4dC5qcyByb3V0ZXJcbiAgaWYgKCFpc0xvY2FsVVJMKHVybEFzU3RyaW5nKSkge1xuICAgIHJldHVybiAocmVzb2x2ZUFzID8gW3VybEFzU3RyaW5nXSA6IHVybEFzU3RyaW5nKSBhcyBzdHJpbmdcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSlcbiAgICBmaW5hbFVybC5wYXRobmFtZSA9IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGZpbmFsVXJsLnBhdGhuYW1lKVxuICAgIGxldCBpbnRlcnBvbGF0ZWRBcyA9ICcnXG5cbiAgICBpZiAoXG4gICAgICBpc0R5bmFtaWNSb3V0ZShmaW5hbFVybC5wYXRobmFtZSkgJiZcbiAgICAgIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJlxuICAgICAgcmVzb2x2ZUFzXG4gICAgKSB7XG4gICAgICBjb25zdCBxdWVyeSA9IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoZmluYWxVcmwuc2VhcmNoUGFyYW1zKVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCwgcGFyYW1zIH0gPSBpbnRlcnBvbGF0ZUFzKFxuICAgICAgICBmaW5hbFVybC5wYXRobmFtZSxcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5XG4gICAgICApXG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkQXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgcGF0aG5hbWU6IHJlc3VsdCxcbiAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIHBhcmFtcyksXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICBjb25zdCByZXNvbHZlZEhyZWYgPVxuICAgICAgZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpblxuICAgICAgICA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aClcbiAgICAgICAgOiBmaW5hbFVybC5ocmVmXG5cbiAgICByZXR1cm4gKHJlc29sdmVBc1xuICAgICAgPyBbcmVzb2x2ZWRIcmVmLCBpbnRlcnBvbGF0ZWRBcyB8fCByZXNvbHZlZEhyZWZdXG4gICAgICA6IHJlc29sdmVkSHJlZikgYXMgc3RyaW5nXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gKHJlc29sdmVBcyA/IFt1cmxBc1N0cmluZ10gOiB1cmxBc1N0cmluZykgYXMgc3RyaW5nXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBPcmlnaW4odXJsOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuXG4gIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybFxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyOiBOZXh0Um91dGVyLCB1cmw6IFVybCwgYXM/OiBVcmwpIHtcbiAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXG4gIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHJvdXRlci5hc1BhdGgsIHVybCwgdHJ1ZSlcbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICBjb25zdCBocmVmSGFkT3JpZ2luID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKVxuICBjb25zdCBhc0hhZE9yaWdpbiA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbilcblxuICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpXG4gIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzXG5cbiAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmSGFkT3JpZ2luID8gcmVzb2x2ZWRIcmVmIDogYWRkQmFzZVBhdGgocmVzb2x2ZWRIcmVmKVxuICBjb25zdCBwcmVwYXJlZEFzID0gYXNcbiAgICA/IHN0cmlwT3JpZ2luKHJlc29sdmVIcmVmKHJvdXRlci5hc1BhdGgsIGFzKSlcbiAgICA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmXG5cbiAgcmV0dXJuIHtcbiAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgIGFzOiBhc0hhZE9yaWdpbiA/IHByZXBhcmVkQXMgOiBhZGRCYXNlUGF0aChwcmVwYXJlZEFzKSxcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lOiBzdHJpbmcsIHBhZ2VzOiBzdHJpbmdbXSkge1xuICBjb25zdCBjbGVhblBhdGhuYW1lID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goZGVub3JtYWxpemVQYWdlUGF0aChwYXRobmFtZSEpKVxuXG4gIGlmIChjbGVhblBhdGhuYW1lID09PSAnLzQwNCcgfHwgY2xlYW5QYXRobmFtZSA9PT0gJy9fZXJyb3InKSB7XG4gICAgcmV0dXJuIHBhdGhuYW1lXG4gIH1cblxuICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXG4gIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSEpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgIHBhZ2VzLnNvbWUoKHBhZ2UpID0+IHtcbiAgICAgIGlmIChpc0R5bmFtaWNSb3V0ZShwYWdlKSAmJiBnZXRSb3V0ZVJlZ2V4KHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSEpKSB7XG4gICAgICAgIHBhdGhuYW1lID0gcGFnZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxufVxuXG5leHBvcnQgdHlwZSBCYXNlUm91dGVyID0ge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG4gIGlzTG9jYWxlRG9tYWluOiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIE5leHRSb3V0ZXIgPSBCYXNlUm91dGVyICZcbiAgUGljazxcbiAgICBSb3V0ZXIsXG4gICAgfCAncHVzaCdcbiAgICB8ICdyZXBsYWNlJ1xuICAgIHwgJ3JlbG9hZCdcbiAgICB8ICdiYWNrJ1xuICAgIHwgJ3ByZWZldGNoJ1xuICAgIHwgJ2JlZm9yZVBvcFN0YXRlJ1xuICAgIHwgJ2V2ZW50cydcbiAgICB8ICdpc0ZhbGxiYWNrJ1xuICAgIHwgJ2lzUmVhZHknXG4gICAgfCAnaXNQcmV2aWV3J1xuICA+XG5cbmV4cG9ydCB0eXBlIFByZWZldGNoT3B0aW9ucyA9IHtcbiAgcHJpb3JpdHk/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG59XG5cbmV4cG9ydCB0eXBlIFByaXZhdGVSb3V0ZUluZm8gPVxuICB8IChPbWl0PENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbywgJ3N0eWxlU2hlZXRzJz4gJiB7IGluaXRpYWw6IHRydWUgfSlcbiAgfCBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm9cblxuZXhwb3J0IHR5cGUgQ29tcGxldGVQcml2YXRlUm91dGVJbmZvID0ge1xuICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG4gIHByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICBlcnI/OiBFcnJvclxuICBlcnJvcj86IGFueVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wcyA9IFBpY2s8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvLCAnQ29tcG9uZW50JyB8ICdlcnInPiAmIHtcbiAgcm91dGVyOiBSb3V0ZXJcbn0gJiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5leHBvcnQgdHlwZSBBcHBDb21wb25lbnQgPSBDb21wb25lbnRUeXBlPEFwcFByb3BzPlxuXG50eXBlIFN1YnNjcmlwdGlvbiA9IChcbiAgZGF0YTogUHJpdmF0ZVJvdXRlSW5mbyxcbiAgQXBwOiBBcHBDb21wb25lbnQsXG4gIHJlc2V0U2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4pID0+IFByb21pc2U8dm9pZD5cblxudHlwZSBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrID0gKHN0YXRlOiBOZXh0SGlzdG9yeVN0YXRlKSA9PiBib29sZWFuXG5cbnR5cGUgQ29tcG9uZW50TG9hZENhbmNlbCA9ICgoKSA9PiB2b2lkKSB8IG51bGxcblxudHlwZSBIaXN0b3J5TWV0aG9kID0gJ3JlcGxhY2VTdGF0ZScgfCAncHVzaFN0YXRlJ1xuXG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiZcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeSAmJlxuICAhIShmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB2ID0gJ19fbmV4dCdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHYsIHYpLCBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHYpLCB0cnVlXG4gICAgfSBjYXRjaCAobikge31cbiAgfSkoKVxuXG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkQgPSBTeW1ib2woJ1NTR19EQVRBX05PVF9GT1VORCcpXG5cbmZ1bmN0aW9uIGZldGNoUmV0cnkodXJsOiBzdHJpbmcsIGF0dGVtcHRzOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgLy9cbiAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgLy8gPiBvcHRpb24uXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgIC8vXG4gICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICB9KS50aGVuKChyZXMpID0+IHtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgaWYgKGF0dGVtcHRzID4gMSAmJiByZXMuc3RhdHVzID49IDUwMCkge1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzIC0gMSlcbiAgICAgIH1cbiAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5qc29uKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgIGlmIChkYXRhLm5vdEZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpzb24oKVxuICB9KVxufVxuXG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKGRhdGFIcmVmOiBzdHJpbmcsIGlzU2VydmVyUmVuZGVyOiBib29sZWFuKSB7XG4gIHJldHVybiBmZXRjaFJldHJ5KGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciA/IDMgOiAxKS5jYXRjaCgoZXJyOiBFcnJvcikgPT4ge1xuICAgIC8vIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzIGNhdXNlZFxuICAgIC8vIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvIGFuIGluZmluaXRlXG4gICAgLy8gbG9vcC5cblxuICAgIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgIG1hcmtBc3NldEVycm9yKGVycilcbiAgICB9XG4gICAgdGhyb3cgZXJyXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdXRlciBpbXBsZW1lbnRzIEJhc2VSb3V0ZXIge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcblxuICAvKipcbiAgICogTWFwIG9mIGFsbCBjb21wb25lbnRzIGxvYWRlZCBpbiBgUm91dGVyYFxuICAgKi9cbiAgY29tcG9uZW50czogeyBbcGF0aG5hbWU6IHN0cmluZ106IFByaXZhdGVSb3V0ZUluZm8gfVxuICAvLyBTdGF0aWMgRGF0YSBDYWNoZVxuICBzZGM6IHsgW2FzUGF0aDogc3RyaW5nXTogb2JqZWN0IH0gPSB7fVxuICAvLyBJbi1mbGlnaHQgU2VydmVyIERhdGEgUmVxdWVzdHMsIGZvciBkZWR1cGluZ1xuICBzZHI6IHsgW2FzUGF0aDogc3RyaW5nXTogUHJvbWlzZTxvYmplY3Q+IH0gPSB7fVxuXG4gIHN1YjogU3Vic2NyaXB0aW9uXG4gIGNsYzogQ29tcG9uZW50TG9hZENhbmNlbFxuICBwYWdlTG9hZGVyOiBhbnlcbiAgX2JwczogQmVmb3JlUG9wU3RhdGVDYWxsYmFjayB8IHVuZGVmaW5lZFxuICBldmVudHM6IE1pdHRFbWl0dGVyXG4gIF93cmFwQXBwOiAoQXBwOiBBcHBDb21wb25lbnQpID0+IGFueVxuICBpc1NzcjogYm9vbGVhblxuICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gIF9pbkZsaWdodFJvdXRlPzogc3RyaW5nXG4gIF9zaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbiAgaXNSZWFkeTogYm9vbGVhblxuICBpc1ByZXZpZXc6IGJvb2xlYW5cbiAgaXNMb2NhbGVEb21haW46IGJvb2xlYW5cblxuICBwcml2YXRlIF9pZHg6IG51bWJlciA9IDBcblxuICBzdGF0aWMgZXZlbnRzOiBNaXR0RW1pdHRlciA9IG1pdHQoKVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAge1xuICAgICAgaW5pdGlhbFByb3BzLFxuICAgICAgcGFnZUxvYWRlcixcbiAgICAgIEFwcCxcbiAgICAgIHdyYXBBcHAsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBlcnIsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgICAgbG9jYWxlLFxuICAgICAgbG9jYWxlcyxcbiAgICAgIGRlZmF1bHRMb2NhbGUsXG4gICAgICBkb21haW5Mb2NhbGVzLFxuICAgICAgaXNQcmV2aWV3LFxuICAgIH06IHtcbiAgICAgIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uXG4gICAgICBpbml0aWFsUHJvcHM6IGFueVxuICAgICAgcGFnZUxvYWRlcjogYW55XG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIEFwcDogQXBwQ29tcG9uZW50XG4gICAgICB3cmFwQXBwOiAoV3JhcEFwcENvbXBvbmVudDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgICAgIGVycj86IEVycm9yXG4gICAgICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gICAgICBsb2NhbGU/OiBzdHJpbmdcbiAgICAgIGxvY2FsZXM/OiBzdHJpbmdbXVxuICAgICAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAgICAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbiAgICAgIGlzUHJldmlldz86IGJvb2xlYW5cbiAgICB9XG4gICkge1xuICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgIHRoaXMucm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcblxuICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgIHRoaXMuY29tcG9uZW50cyA9IHt9XG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgIGlmIChwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0gPSB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgZXJyLFxuICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICBDb21wb25lbnQ6IEFwcCBhcyBDb21wb25lbnRUeXBlLFxuICAgICAgc3R5bGVTaGVldHM6IFtcbiAgICAgICAgLyogL19hcHAgZG9lcyBub3QgbmVlZCBpdHMgc3R5bGVzaGVldHMgbWFuYWdlZCAqL1xuICAgICAgXSxcbiAgICB9XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID1cbiAgICAgIGlzRHluYW1pY1JvdXRlKHBhdGhuYW1lKSAmJiBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydFxuXG4gICAgdGhpcy5hc1BhdGggPSBhdXRvRXhwb3J0RHluYW1pYyA/IHBhdGhuYW1lIDogYXNcbiAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGhcbiAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvblxuICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwXG4gICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgdGhpcy5pc1NzciA9IHRydWVcblxuICAgIHRoaXMuaXNGYWxsYmFjayA9IGlzRmFsbGJhY2tcblxuICAgIHRoaXMuaXNSZWFkeSA9ICEhKFxuICAgICAgc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHxcbiAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHxcbiAgICAgICghYXV0b0V4cG9ydER5bmFtaWMgJiZcbiAgICAgICAgIXNlbGYubG9jYXRpb24uc2VhcmNoICYmXG4gICAgICAgICFwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKVxuICAgIClcbiAgICB0aGlzLmlzUHJldmlldyA9ICEhaXNQcmV2aWV3XG4gICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVcbiAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXNcbiAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGVcbiAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXNcbiAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhIWRldGVjdERvbWFpbkxvY2FsZShcbiAgICAgICAgZG9tYWluTG9jYWxlcyxcbiAgICAgICAgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZVxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICBpZiAoYXMuc3Vic3RyKDAsIDIpICE9PSAnLy8nKSB7XG4gICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgICAgZ2V0VVJMKCksXG4gICAgICAgICAgeyBsb2NhbGUgfVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSlcblxuICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Qb3BTdGF0ZSA9IChlOiBQb3BTdGF0ZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlIGFzIEhpc3RvcnlTdGF0ZVxuXG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLCBxdWVyeSB9KSxcbiAgICAgICAgZ2V0VVJMKClcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgZm9yY2VkU2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCB1bmRlZmluZWRcbiAgICBjb25zdCB7IHVybCwgYXMsIG9wdGlvbnMsIGlkeCB9ID0gc3RhdGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZHggIT09IGlkeCkge1xuICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgICAnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHg6IHNlbGYucGFnZVhPZmZzZXQsIHk6IHNlbGYucGFnZVlPZmZzZXQgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGNhdGNoIHt9XG5cbiAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyBpZHgpXG4gICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYhKVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0geyB4OiAwLCB5OiAwIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faWR4ID0gaWR4XG5cbiAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSB0aGlzLmFzUGF0aCAmJiBwYXRobmFtZSA9PT0gdGhpcy5wYXRobmFtZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jaGFuZ2UoXG4gICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgIHVybCxcbiAgICAgIGFzLFxuICAgICAgT2JqZWN0LmFzc2lnbjx7fSwgVHJhbnNpdGlvbk9wdGlvbnMsIFRyYW5zaXRpb25PcHRpb25zPih7fSwgb3B0aW9ucywge1xuICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICB9KSxcbiAgICAgIGZvcmNlZFNjcm9sbFxuICAgIClcbiAgfVxuXG4gIHJlbG9hZCgpOiB2b2lkIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovXG4gIGJhY2soKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuYmFjaygpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcHVzaFN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHB1c2godXJsOiBVcmwsIGFzPzogVXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICAnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyB4OiBzZWxmLnBhZ2VYT2Zmc2V0LCB5OiBzZWxmLnBhZ2VZT2Zmc2V0IH0pXG4gICAgICAgICAgKVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICByZXBsYWNlKHVybDogVXJsLCBhcz86IFVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjaGFuZ2UoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMsXG4gICAgZm9yY2VkU2Nyb2xsPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9XG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghaXNMb2NhbFVSTCh1cmwpKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybFxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGNvbnN0IHNob3VsZFJlc29sdmVIcmVmID0gdXJsID09PSBhcyB8fCAob3B0aW9ucyBhcyBhbnkpLl9oXG5cbiAgICAvLyBmb3Igc3RhdGljIHBhZ2VzIHdpdGggcXVlcnkgcGFyYW1zIGluIHRoZSBVUkwgd2UgZGVsYXlcbiAgICAvLyBtYXJraW5nIHRoZSByb3V0ZXIgcmVhZHkgdW50aWwgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIHVwZGF0ZWRcbiAgICBpZiAoKG9wdGlvbnMgYXMgYW55KS5faCkge1xuICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gc2Nyb2xsIHJlc2V0IGJlaGF2aW9yIHVubGVzcyBleHBsaWNpdGx5IHNwZWNpZmllZCB0byBiZVxuICAgIC8vIGBmYWxzZWAhIFRoaXMgbWFrZXMgdGhlIGJlaGF2aW9yIGJldHdlZW4gdXNpbmcgYFJvdXRlciNwdXNoYCBhbmQgYVxuICAgIC8vIGA8TGluayAvPmAgY29uc2lzdGVudC5cbiAgICBvcHRpb25zLnNjcm9sbCA9ICEhKG9wdGlvbnMuc2Nyb2xsID8/IHRydWUpXG5cbiAgICBsZXQgbG9jYWxlQ2hhbmdlID0gb3B0aW9ucy5sb2NhbGUgIT09IHRoaXMubG9jYWxlXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgdGhpcy5sb2NhbGUgPVxuICAgICAgICBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2VcbiAgICAgICAgICA/IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgIDogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5sb2NhbGVcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSB0aGlzLmxvY2FsZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMpXG4gICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUsXG4gICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgKVxuXG4gICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGVcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRCYXNlUGF0aChwYXJzZWRBcy5wYXRobmFtZSlcbiAgICAgICAgYXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcylcbiAgICAgICAgdXJsID0gYWRkQmFzZVBhdGgoXG4gICAgICAgICAgbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgICAgIGhhc0Jhc2VQYXRoKHVybCkgPyBkZWxCYXNlUGF0aCh1cmwpIDogdXJsLFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICAgICAgKS5wYXRobmFtZVxuICAgICAgICApXG4gICAgICB9XG4gICAgICBsZXQgZGlkTmF2aWdhdGUgPSBmYWxzZVxuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxvY2FsZSBpc24ndCBjb25maWd1cmVkIGhhcmQgbmF2aWdhdGUgdG8gc2hvdyA0MDQgcGFnZVxuICAgICAgICBpZiAoIXRoaXMubG9jYWxlcz8uaW5jbHVkZXModGhpcy5sb2NhbGUhKSkge1xuICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkTG9jYWxlKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZSlcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKVxuICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShcbiAgICAgICAgdGhpcy5kb21haW5Mb2NhbGVzLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHRoaXMubG9jYWxlXG4gICAgICApXG5cbiAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgbmF2aWdhdGluZyB0byBhIGRvbWFpbiBsb2NhbGUgZW5zdXJlIHdlIHJlZGlyZWN0IHRvIHRoZVxuICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWRpZE5hdmlnYXRlICYmXG4gICAgICAgICAgZGV0ZWN0ZWREb21haW4gJiZcbiAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluICYmXG4gICAgICAgICAgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gZGV0ZWN0ZWREb21haW4uZG9tYWluXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGFzTm9CYXNlUGF0aCA9IGRlbEJhc2VQYXRoKGFzKVxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke1xuICAgICAgICAgICAgZGV0ZWN0ZWREb21haW4uZG9tYWluXG4gICAgICAgICAgfSR7YWRkQmFzZVBhdGgoXG4gICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgdGhpcy5sb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgOiBgLyR7dGhpcy5sb2NhbGV9YFxuICAgICAgICAgICAgfSR7YXNOb0Jhc2VQYXRoID09PSAnLycgPyAnJyA6IGFzTm9CYXNlUGF0aH1gIHx8ICcvJ1xuICAgICAgICAgICl9YFxuICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKG9wdGlvbnMgYXMgYW55KS5faCkge1xuICAgICAgdGhpcy5pc1NzciA9IGZhbHNlXG4gICAgfVxuICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICBpZiAoU1QpIHtcbiAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3JvdXRlQ2hhbmdlJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNoYWxsb3cgPSBmYWxzZSB9ID0gb3B0aW9uc1xuICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7IHNoYWxsb3cgfVxuXG4gICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUpIHtcbiAgICAgIHRoaXMuYWJvcnRDb21wb25lbnRMb2FkKHRoaXMuX2luRmxpZ2h0Um91dGUsIHJvdXRlUHJvcHMpXG4gICAgfVxuXG4gICAgYXMgPSBhZGRCYXNlUGF0aChcbiAgICAgIGFkZExvY2FsZShcbiAgICAgICAgaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsXG4gICAgICAgIG9wdGlvbnMubG9jYWxlLFxuICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgIClcbiAgICApXG4gICAgY29uc3QgY2xlYW5lZEFzID0gZGVsTG9jYWxlKFxuICAgICAgaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsXG4gICAgICB0aGlzLmxvY2FsZVxuICAgIClcbiAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXNcblxuICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuXG4gICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICBpZiAoIShvcHRpb25zIGFzIGFueSkuX2ggJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSkge1xuICAgICAgdGhpcy5hc1BhdGggPSBjbGVhbmVkQXNcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpXG4gICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpXG4gICAgICB0aGlzLm5vdGlmeSh0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0sIG51bGwpXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG4gICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWRcblxuICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgIGxldCBwYWdlczogYW55LCByZXdyaXRlczogYW55XG4gICAgdHJ5IHtcbiAgICAgIHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcbiAgICAgIDsoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAvLyBkbyBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb246XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJ1xuICAgIH1cblxuICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgIGxldCByZXNvbHZlZEFzID0gYXNcblxuICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICA/IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKGRlbEJhc2VQYXRoKHBhdGhuYW1lKSlcbiAgICAgIDogcGF0aG5hbWVcblxuICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSByZXNvbHZlUmV3cml0ZXMoXG4gICAgICAgICAgYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGNsZWFuZWRBcywgdGhpcy5sb2NhbGUpKSxcbiAgICAgICAgICBwYWdlcyxcbiAgICAgICAgICByZXdyaXRlcyxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAocDogc3RyaW5nKSA9PiByZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSxcbiAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgKVxuICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoXG5cbiAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmXG4gICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKVxuXG4gICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgaWYgKCFpc0xvY2FsVVJMKGFzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGhyZWY6IFwiJHt1cmx9XCIgYW5kIGFzOiBcIiR7YXN9XCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzYCArXG4gICAgICAgICAgICBgXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNgXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmVzb2x2ZWRBcyA9IGRlbExvY2FsZShkZWxCYXNlUGF0aChyZXNvbHZlZEFzKSwgdGhpcy5sb2NhbGUpXG5cbiAgICBpZiAoaXNEeW5hbWljUm91dGUocm91dGUpKSB7XG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwocmVzb2x2ZWRBcylcbiAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZVxuXG4gICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSlcbiAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWVcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZEFzID0gc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgPyBpbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSlcbiAgICAgICAgOiAoe30gYXMgeyByZXN1bHQ6IHVuZGVmaW5lZDsgcGFyYW1zOiB1bmRlZmluZWQgfSlcblxuICAgICAgaWYgKCFyb3V0ZU1hdGNoIHx8IChzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSkge1xuICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcihcbiAgICAgICAgICAocGFyYW0pID0+ICFxdWVyeVtwYXJhbV1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgPyBgSW50ZXJwb2xhdGluZyBocmVmYFxuICAgICAgICAgICAgICAgICAgOiBgTWlzbWF0Y2hpbmcgXFxgYXNcXGAgYW5kIFxcYGhyZWZcXGBgXG4gICAgICAgICAgICAgIH0gZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArXG4gICAgICAgICAgICAgICAgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9IGluIHRoZSBcXGBocmVmXFxgJ3MgXFxgcXVlcnlcXGBgXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgKHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgID8gYFRoZSBwcm92aWRlZCBcXGBocmVmXFxgICgke3VybH0pIHZhbHVlIGlzIG1pc3NpbmcgcXVlcnkgdmFsdWVzICgke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgXG4gICAgICAgICAgICAgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgK1xuICAgICAgICAgICAgICBgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy8ke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/ICdocmVmLWludGVycG9sYXRpb24tZmFpbGVkJ1xuICAgICAgICAgICAgICAgICAgOiAnaW5jb21wYXRpYmxlLWhyZWYtYXMnXG4gICAgICAgICAgICAgIH1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgIGFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMhKSxcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKVxuICAgICAgfVxuICAgIH1cblxuICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYXMsXG4gICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgIHJvdXRlUHJvcHNcbiAgICAgIClcbiAgICAgIGxldCB7IGVycm9yLCBwcm9wcywgX19OX1NTRywgX19OX1NTUCB9ID0gcm91dGVJbmZvXG5cbiAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgaWYgKChfX05fU1NHIHx8IF9fTl9TU1ApICYmIHByb3BzKSB7XG4gICAgICAgIGlmICgocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMgJiYgKHByb3BzIGFzIGFueSkucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gKHByb3BzIGFzIGFueSkucGFnZVByb3BzLl9fTl9SRURJUkVDVFxuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gcGFyc2VSZWxhdGl2ZVVybChkZXN0aW5hdGlvbilcbiAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKFxuICAgICAgICAgICAgICBwYXJzZWRIcmVmLnBhdGhuYW1lLFxuICAgICAgICAgICAgICBwYWdlc1xuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMocGFyc2VkSHJlZi5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCwgYXM6IG5ld0FzIH0gPSBwcmVwYXJlVXJsQXMoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZXN0aW5hdGlvblxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNQcmV2aWV3ID0gISFwcm9wcy5fX05fUFJFVklFV1xuXG4gICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgaWYgKHByb3BzLm5vdEZvdW5kID09PSBTU0dfREFUQV9OT1RfRk9VTkQpIHtcbiAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKVxuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvNDA0J1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcidcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICB7IHNoYWxsb3c6IGZhbHNlIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgYXBwQ29tcDogYW55ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudFxuICAgICAgICA7KHdpbmRvdyBhcyBhbnkpLm5leHQuaXNQcmVyZW5kZXJlZCA9XG4gICAgICAgICAgYXBwQ29tcC5nZXRJbml0aWFsUHJvcHMgPT09IGFwcENvbXAub3JpZ0dldEluaXRpYWxQcm9wcyAmJlxuICAgICAgICAgICEocm91dGVJbmZvLkNvbXBvbmVudCBhcyBhbnkpLmdldEluaXRpYWxQcm9wc1xuICAgICAgfVxuXG4gICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICBjb25zdCBpc1ZhbGlkU2hhbGxvd1JvdXRlID0gb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMucm91dGUgPT09IHJvdXRlXG5cbiAgICAgIGlmIChcbiAgICAgICAgKG9wdGlvbnMgYXMgYW55KS5faCAmJlxuICAgICAgICBwYXRobmFtZSA9PT0gJy9fZXJyb3InICYmXG4gICAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcz8ucGFnZVByb3BzPy5zdGF0dXNDb2RlID09PSA1MDAgJiZcbiAgICAgICAgcHJvcHM/LnBhZ2VQcm9wc1xuICAgICAgKSB7XG4gICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgIHByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuc2V0KFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUhLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgY2xlYW5lZEFzLFxuICAgICAgICByb3V0ZUluZm8sXG4gICAgICAgIGZvcmNlZFNjcm9sbCB8fFxuICAgICAgICAgIChpc1ZhbGlkU2hhbGxvd1JvdXRlIHx8ICFvcHRpb25zLnNjcm9sbCA/IG51bGwgOiB7IHg6IDAsIHk6IDAgfSlcbiAgICAgICkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgaWYgKGUuY2FuY2VsbGVkKSBlcnJvciA9IGVycm9yIHx8IGVcbiAgICAgICAgZWxzZSB0aHJvdyBlXG4gICAgICB9KVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcylcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSB0aGlzLmxvY2FsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcylcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgY2hhbmdlU3RhdGUoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fVxuICApOiB2b2lkIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS4ke21ldGhvZH0gaXMgbm90IGF2YWlsYWJsZWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8IGdldFVSTCgpICE9PSBhcykge1xuICAgICAgdGhpcy5fc2hhbGxvdyA9IG9wdGlvbnMuc2hhbGxvd1xuICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXShcbiAgICAgICAge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBhcyxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIF9fTjogdHJ1ZSxcbiAgICAgICAgICBpZHg6IHRoaXMuX2lkeCA9IG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgPyB0aGlzLl9pZHggOiB0aGlzLl9pZHggKyAxLFxuICAgICAgICB9IGFzIEhpc3RvcnlTdGF0ZSxcbiAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICcnLFxuICAgICAgICBhc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgIGVycjogRXJyb3IgJiB7IGNvZGU6IGFueTsgY2FuY2VsbGVkOiBib29sZWFuIH0sXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICByb3V0ZVByb3BzOiBSb3V0ZVByb3BlcnRpZXMsXG4gICAgbG9hZEVycm9yRmFpbD86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIGlmIChpc0Fzc2V0RXJyb3IoZXJyKSB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGFzLCByb3V0ZVByb3BzKVxuXG4gICAgICAvLyBJZiB3ZSBjYW4ndCBsb2FkIHRoZSBwYWdlIGl0IGNvdWxkIGJlIG9uZSBvZiBmb2xsb3dpbmcgcmVhc29uc1xuICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgLy8gIDMuIEludGVybmFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIHBhZ2VcblxuICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzXG5cbiAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgLy8gU28gbGV0J3MgdGhyb3cgYSBjYW5jZWxsYXRpb24gZXJyb3Igc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgIHRocm93IGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBsZXQgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gICAgICBsZXQgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gICAgICBsZXQgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWRcblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgQ29tcG9uZW50ISA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgdHlwZW9mIHN0eWxlU2hlZXRzISA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICA7KHsgcGFnZTogQ29tcG9uZW50LCBzdHlsZVNoZWV0cyB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcbiAgICAgICAgICAnL19lcnJvcidcbiAgICAgICAgKSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSB7XG4gICAgICAgIHByb3BzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICBlcnIsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICB9XG5cbiAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIH0gYXMgYW55KVxuICAgICAgICB9IGNhdGNoIChnaXBFcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiAnLCBnaXBFcnIpXG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAocm91dGVJbmZvRXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihcbiAgICAgICAgcm91dGVJbmZvRXJyLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFzLFxuICAgICAgICByb3V0ZVByb3BzLFxuICAgICAgICB0cnVlXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0Um91dGVJbmZvKFxuICAgIHJvdXRlOiBzdHJpbmcsXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogYW55LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgcmVzb2x2ZWRBczogc3RyaW5nLFxuICAgIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllc1xuICApOiBQcm9taXNlPFByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXhpc3RpbmdSb3V0ZUluZm86IFByaXZhdGVSb3V0ZUluZm8gfCB1bmRlZmluZWQgPSB0aGlzLmNvbXBvbmVudHNbXG4gICAgICAgIHJvdXRlXG4gICAgICBdXG4gICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWNoZWRSb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyB8IHVuZGVmaW5lZCA9XG4gICAgICAgIGV4aXN0aW5nUm91dGVJbmZvICYmICdpbml0aWFsJyBpbiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgY29uc3Qgcm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgPyBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgOiBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKChyZXMpID0+ICh7XG4gICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUCxcbiAgICAgICAgICB9KSlcblxuICAgICAgY29uc3QgeyBDb21wb25lbnQsIF9fTl9TU0csIF9fTl9TU1AgfSA9IHJvdXRlSW5mb1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKVxuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YUhyZWY6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICBpZiAoX19OX1NTRyB8fCBfX05fU1NQKSB7XG4gICAgICAgIGRhdGFIcmVmID0gdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWUsIHF1ZXJ5IH0pLFxuICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgX19OX1NTRyxcbiAgICAgICAgICB0aGlzLmxvY2FsZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BzID0gYXdhaXQgdGhpcy5fZ2V0RGF0YTxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8+KCgpID0+XG4gICAgICAgIF9fTl9TU0dcbiAgICAgICAgICA/IHRoaXMuX2dldFN0YXRpY0RhdGEoZGF0YUhyZWYhKVxuICAgICAgICAgIDogX19OX1NTUFxuICAgICAgICAgID8gdGhpcy5fZ2V0U2VydmVyRGF0YShkYXRhSHJlZiEpXG4gICAgICAgICAgOiB0aGlzLmdldEluaXRpYWxQcm9wcyhcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICAgICAgICAgIGxvY2FsZXM6IHRoaXMubG9jYWxlcyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgIH0gYXMgYW55XG4gICAgICAgICAgICApXG4gICAgICApXG5cbiAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzXG4gICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMpXG4gICAgfVxuICB9XG5cbiAgc2V0KFxuICAgIHJvdXRlOiBzdHJpbmcsXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBkYXRhOiBQcml2YXRlUm91dGVJbmZvLFxuICAgIHJlc2V0U2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuaXNGYWxsYmFjayA9IGZhbHNlXG5cbiAgICB0aGlzLnJvdXRlID0gcm91dGVcbiAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgICB0aGlzLmFzUGF0aCA9IGFzXG4gICAgcmV0dXJuIHRoaXMubm90aWZ5KGRhdGEsIHJlc2V0U2Nyb2xsKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqL1xuICBiZWZvcmVQb3BTdGF0ZShjYjogQmVmb3JlUG9wU3RhdGVDYWxsYmFjaykge1xuICAgIHRoaXMuX2JwcyA9IGNiXG4gIH1cblxuICBvbmx5QUhhc2hDaGFuZ2UoYXM6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IFtvbGRVcmxOb0hhc2gsIG9sZEhhc2hdID0gdGhpcy5hc1BhdGguc3BsaXQoJyMnKVxuICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoJyMnKVxuXG4gICAgLy8gTWFrZXMgc3VyZSB3ZSBzY3JvbGwgdG8gdGhlIHByb3ZpZGVkIGhhc2ggaWYgdGhlIHVybC9oYXNoIGFyZSB0aGUgc2FtZVxuICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXG4gICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaFxuICB9XG5cbiAgc2Nyb2xsVG9IYXNoKGFzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBbLCBoYXNoXSA9IGFzLnNwbGl0KCcjJylcbiAgICAvLyBTY3JvbGwgdG8gdG9wIGlmIHRoZSBoYXNoIGlzIGp1c3QgYCNgIHdpdGggbm8gdmFsdWUgb3IgYCN0b3BgXG4gICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgaWYgKGhhc2ggPT09ICcnIHx8IGhhc2ggPT09ICd0b3AnKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpXG4gICAgaWYgKGlkRWwpIHtcbiAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpWzBdXG4gICAgaWYgKG5hbWVFbCkge1xuICAgICAgbmFtZUVsLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG4gIH1cblxuICB1cmxJc05ldyhhc1BhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoXG4gIH1cblxuICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqL1xuICBhc3luYyBwcmVmZXRjaChcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhc1BhdGg6IHN0cmluZyA9IHVybCxcbiAgICBvcHRpb25zOiBQcmVmZXRjaE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICBsZXQgeyBwYXRobmFtZSB9ID0gcGFyc2VkXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICBwYXRobmFtZSA9IG5vcm1hbGl6ZUxvY2FsZVBhdGghKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lXG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcblxuICAgICAgICBsZXQgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGFzUGF0aClcbiAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGghKFxuICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lLFxuICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICApXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZVxuICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgIGFzUGF0aCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcbiAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aFxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgbGV0IHJld3JpdGVzOiBhbnlcbiAgICAgIDsoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKVxuXG4gICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9IHJlc29sdmVSZXdyaXRlcyhcbiAgICAgICAgYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGFzUGF0aCwgdGhpcy5sb2NhbGUpKSxcbiAgICAgICAgcGFnZXMsXG4gICAgICAgIHJld3JpdGVzLFxuICAgICAgICBwYXJzZWQucXVlcnksXG4gICAgICAgIChwOiBzdHJpbmcpID0+IHJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLFxuICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgIClcbiAgICAgIHJlc29sdmVkQXMgPSBkZWxMb2NhbGUoZGVsQmFzZVBhdGgocmV3cml0ZXNSZXN1bHQuYXNQYXRoKSwgdGhpcy5sb2NhbGUpXG5cbiAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZlxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkLnBhdGhuYW1lLCBwYWdlcylcblxuICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHJvdXRlKS50aGVuKChpc1NzZzogYm9vbGVhbikgPT4ge1xuICAgICAgICByZXR1cm4gaXNTc2dcbiAgICAgICAgICA/IHRoaXMuX2dldFN0YXRpY0RhdGEoXG4gICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZihcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5sb2NhbGVcbiAgICAgICAgICAgICAgICAgIDogdGhpcy5sb2NhbGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyAnbG9hZFBhZ2UnIDogJ3ByZWZldGNoJ10ocm91dGUpLFxuICAgIF0pXG4gIH1cblxuICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTxHb29kUGFnZUNhY2hlPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKHRoaXMuY2xjID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpXG5cbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKFxuICAgICAgICBgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYFxuICAgICAgKVxuICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdFxuICB9XG5cbiAgX2dldERhdGE8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlXG4gICAgfVxuICAgIHRoaXMuY2xjID0gY2FuY2VsXG4gICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgY29uc3QgZXJyOiBhbnkgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKVxuICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgX2dldFN0YXRpY0RhdGEoZGF0YUhyZWY6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiB7XG4gICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgIXRoaXMuaXNQcmV2aWV3ICYmXG4gICAgICB0aGlzLnNkY1tjYWNoZUtleV1cbiAgICApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zZGNbY2FjaGVLZXldKVxuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzcikudGhlbigoZGF0YSkgPT4ge1xuICAgICAgdGhpcy5zZGNbY2FjaGVLZXldID0gZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgX2dldFNlcnZlckRhdGEoZGF0YUhyZWY6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiB7XG4gICAgY29uc3QgeyBocmVmOiByZXNvdXJjZUtleSB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgaWYgKHRoaXMuc2RyW3Jlc291cmNlS2V5XSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2RyW3Jlc291cmNlS2V5XVxuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuc2RyW3Jlc291cmNlS2V5XSA9IGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRoaXMuaXNTc3IpXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5zZHJbcmVzb3VyY2VLZXldXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2RyW3Jlc291cmNlS2V5XVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pKVxuICB9XG5cbiAgZ2V0SW5pdGlhbFByb3BzKFxuICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZSxcbiAgICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXVxuICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcCBhcyBBcHBDb21wb25lbnQpXG4gICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlXG4gICAgcmV0dXJuIGxvYWRHZXRJbml0aWFsUHJvcHM8QXBwQ29udGV4dFR5cGU8Um91dGVyPj4oQXBwLCB7XG4gICAgICBBcHBUcmVlLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgY3R4LFxuICAgIH0pXG4gIH1cblxuICBhYm9ydENvbXBvbmVudExvYWQoYXM6IHN0cmluZywgcm91dGVQcm9wczogUm91dGVQcm9wZXJ0aWVzKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xjKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXG4gICAgICAgICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgICAgICAgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLFxuICAgICAgICBhcyxcbiAgICAgICAgcm91dGVQcm9wc1xuICAgICAgKVxuICAgICAgdGhpcy5jbGMoKVxuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgbm90aWZ5KFxuICAgIGRhdGE6IFByaXZhdGVSb3V0ZUluZm8sXG4gICAgcmVzZXRTY3JvbGw6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuc3ViKFxuICAgICAgZGF0YSxcbiAgICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQgYXMgQXBwQ29tcG9uZW50LFxuICAgICAgcmVzZXRTY3JvbGxcbiAgICApXG4gIH1cbn1cbiIsIi8vIEZvcm1hdCBmdW5jdGlvbiBtb2RpZmllZCBmcm9tIG5vZGVqc1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqOiBVcmxPYmplY3QpIHtcbiAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9ialxuICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJydcbiAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnXG4gIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJydcbiAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnXG4gIGxldCBob3N0OiBzdHJpbmcgfCBmYWxzZSA9IGZhbHNlXG5cbiAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJ1xuXG4gIGlmICh1cmxPYmouaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3RcbiAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSlcbiAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdXJsT2JqLnBvcnRcbiAgICB9XG4gIH1cblxuICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkgYXMgUGFyc2VkVXJsUXVlcnkpKVxuICB9XG5cbiAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmIGA/JHtxdWVyeX1gKSB8fCAnJ1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6J1xuXG4gIGlmIChcbiAgICB1cmxPYmouc2xhc2hlcyB8fFxuICAgICgoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbHMudGVzdChwcm90b2NvbCkpICYmIGhvc3QgIT09IGZhbHNlKVxuICApIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKVxuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lXG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJydcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2hbMF0gIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2hcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2hbMF0gIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoXG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudClcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJylcblxuICByZXR1cm4gYCR7cHJvdG9jb2x9JHtob3N0fSR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofWBcbn1cbiIsIi8vIFRyYW5zbGF0ZXMgYSBsb2dpY2FsIHJvdXRlIGludG8gaXRzIHBhZ2VzIGFzc2V0IHBhdGggKHJlbGF0aXZlIGZyb20gYSBjb21tb24gcHJlZml4KVxuLy8gXCJhc3NldCBwYXRoXCIgYmVpbmcgaXRzIGphdmFzY3JpcHQgZmlsZSwgZGF0YSBmaWxlLCBwcmVyZW5kZXJlZCBodG1sLC4uLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHQ6IHN0cmluZyA9ICcnXG4pOiBzdHJpbmcge1xuICBjb25zdCBwYXRoID1cbiAgICByb3V0ZSA9PT0gJy8nXG4gICAgICA/ICcvaW5kZXgnXG4gICAgICA6IC9eXFwvaW5kZXgoXFwvfCQpLy50ZXN0KHJvdXRlKVxuICAgICAgPyBgL2luZGV4JHtyb3V0ZX1gXG4gICAgICA6IGAke3JvdXRlfWBcbiAgcmV0dXJuIHBhdGggKyBleHRcbn1cbiIsIi8vIElkZW50aWZ5IC9bcGFyYW1dLyBpbiByb3V0ZSBzdHJpbmdcbmNvbnN0IFRFU1RfUk9VVEUgPSAvXFwvXFxbW14vXSs/XFxdKD89XFwvfCQpL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gVEVTVF9ST1VURS50ZXN0KHJvdXRlKVxufVxuIiwiaW1wb3J0IHsgZ2V0TG9jYXRpb25PcmlnaW4gfSBmcm9tICcuLi8uLi91dGlscydcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG4vKipcbiAqIFBhcnNlcyBwYXRoLXJlbGF0aXZlIHVybHMgKGUuZy4gYC9oZWxsby93b3JsZD9mb289YmFyYCkuIElmIHVybCBpc24ndCBwYXRoLXJlbGF0aXZlXG4gKiAoZS5nLiBgLi9oZWxsb2ApIHRoZW4gYXQgbGVhc3QgYmFzZSBtdXN0IGJlLlxuICogQWJzb2x1dGUgdXJscyBhcmUgcmVqZWN0ZWQgd2l0aCBvbmUgZXhjZXB0aW9uLCBpbiB0aGUgYnJvd3NlciwgYWJzb2x1dGUgdXJscyB0aGF0IGFyZSBvblxuICogdGhlIGN1cnJlbnQgb3JpZ2luIHdpbGwgYmUgcGFyc2VkIGFzIHJlbGF0aXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlbGF0aXZlVXJsKHVybDogc3RyaW5nLCBiYXNlPzogc3RyaW5nKSB7XG4gIGNvbnN0IGdsb2JhbEJhc2UgPSBuZXcgVVJMKFxuICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ2h0dHA6Ly9uJyA6IGdldExvY2F0aW9uT3JpZ2luKClcbiAgKVxuICBjb25zdCByZXNvbHZlZEJhc2UgPSBiYXNlID8gbmV3IFVSTChiYXNlLCBnbG9iYWxCYXNlKSA6IGdsb2JhbEJhc2VcbiAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoUGFyYW1zLCBzZWFyY2gsIGhhc2gsIGhyZWYsIG9yaWdpbiB9ID0gbmV3IFVSTChcbiAgICB1cmwsXG4gICAgcmVzb2x2ZWRCYXNlXG4gIClcbiAgaWYgKG9yaWdpbiAhPT0gZ2xvYmFsQmFzZS5vcmlnaW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFyaWFudDogaW52YWxpZCByZWxhdGl2ZSBVUkwsIHJvdXRlciByZWNlaXZlZCAke3VybH1gKVxuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgcXVlcnk6IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSxcbiAgICBzZWFyY2gsXG4gICAgaGFzaCxcbiAgICBocmVmOiBocmVmLnNsaWNlKGdsb2JhbEJhc2Uub3JpZ2luLmxlbmd0aCksXG4gIH1cbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogUGFyc2VkVXJsUXVlcnkge1xuICBjb25zdCBxdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgOyhxdWVyeVtrZXldIGFzIHN0cmluZ1tdKS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeVtrZXldID0gW3F1ZXJ5W2tleV0gYXMgc3RyaW5nLCB2YWx1ZV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBxdWVyeVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoXG4gICAgdHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyB8fFxuICAgICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInICYmICFpc05hTihwYXJhbSkpIHx8XG4gICAgdHlwZW9mIHBhcmFtID09PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgcmV0dXJuIFN0cmluZyhwYXJhbSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhcbiAgdXJsUXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgT2JqZWN0LmVudHJpZXModXJsUXVlcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4gcmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24oXG4gIHRhcmdldDogVVJMU2VhcmNoUGFyYW1zLFxuICAuLi5zZWFyY2hQYXJhbXNMaXN0OiBVUkxTZWFyY2hQYXJhbXNbXVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgc2VhcmNoUGFyYW1zTGlzdC5mb3JFYWNoKChzZWFyY2hQYXJhbXMpID0+IHtcbiAgICBBcnJheS5mcm9tKHNlYXJjaFBhcmFtcy5rZXlzKCkpLmZvckVhY2goKGtleSkgPT4gdGFyZ2V0LmRlbGV0ZShrZXkpKVxuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0YXJnZXQuYXBwZW5kKGtleSwgdmFsdWUpKVxuICB9KVxuICByZXR1cm4gdGFyZ2V0XG59XG4iLCJpbXBvcnQgeyBnZXRSb3V0ZVJlZ2V4IH0gZnJvbSAnLi9yb3V0ZS1yZWdleCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4OiBSZXR1cm5UeXBlPHR5cGVvZiBnZXRSb3V0ZVJlZ2V4Pikge1xuICBjb25zdCB7IHJlLCBncm91cHMgfSA9IHJvdXRlUmVnZXhcbiAgcmV0dXJuIChwYXRobmFtZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lISlcbiAgICBpZiAoIXJvdXRlTWF0Y2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGRlY29kZSA9IChwYXJhbTogc3RyaW5nKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKVxuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICBjb25zdCBlcnI6IEVycm9yICYgeyBjb2RlPzogc3RyaW5nIH0gPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2ZhaWxlZCB0byBkZWNvZGUgcGFyYW0nXG4gICAgICAgIClcbiAgICAgICAgZXJyLmNvZGUgPSAnREVDT0RFX0ZBSUxFRCdcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtczogeyBbcGFyYW1OYW1lOiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXSB9ID0ge31cblxuICAgIE9iamVjdC5rZXlzKGdyb3VwcykuZm9yRWFjaCgoc2x1Z05hbWU6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgZyA9IGdyb3Vwc1tzbHVnTmFtZV1cbiAgICAgIGNvbnN0IG0gPSByb3V0ZU1hdGNoW2cucG9zXVxuICAgICAgaWYgKG0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXNbc2x1Z05hbWVdID0gfm0uaW5kZXhPZignLycpXG4gICAgICAgICAgPyBtLnNwbGl0KCcvJykubWFwKChlbnRyeSkgPT4gZGVjb2RlKGVudHJ5KSlcbiAgICAgICAgICA6IGcucmVwZWF0XG4gICAgICAgICAgPyBbZGVjb2RlKG0pXVxuICAgICAgICAgIDogZGVjb2RlKG0pXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gcGFyYW1zXG4gIH1cbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgR3JvdXAge1xuICBwb3M6IG51bWJlclxuICByZXBlYXQ6IGJvb2xlYW5cbiAgb3B0aW9uYWw6IGJvb2xlYW5cbn1cblxuLy8gdGhpcyBpc24ndCBpbXBvcnRpbmcgdGhlIGVzY2FwZS1zdHJpbmctcmVnZXggbW9kdWxlXG4vLyB0byByZWR1Y2UgYnl0ZXNcbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy4tXS9nLCAnXFxcXCQmJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXIocGFyYW06IHN0cmluZykge1xuICBjb25zdCBvcHRpb25hbCA9IHBhcmFtLnN0YXJ0c1dpdGgoJ1snKSAmJiBwYXJhbS5lbmRzV2l0aCgnXScpXG4gIGlmIChvcHRpb25hbCkge1xuICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMSwgLTEpXG4gIH1cbiAgY29uc3QgcmVwZWF0ID0gcGFyYW0uc3RhcnRzV2l0aCgnLi4uJylcbiAgaWYgKHJlcGVhdCkge1xuICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMylcbiAgfVxuICByZXR1cm4geyBrZXk6IHBhcmFtLCByZXBlYXQsIG9wdGlvbmFsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdXRlUmVnZXgoXG4gIG5vcm1hbGl6ZWRSb3V0ZTogc3RyaW5nXG4pOiB7XG4gIHJlOiBSZWdFeHBcbiAgbmFtZWRSZWdleD86IHN0cmluZ1xuICByb3V0ZUtleXM/OiB7IFtuYW1lZDogc3RyaW5nXTogc3RyaW5nIH1cbiAgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IEdyb3VwIH1cbn0ge1xuICBjb25zdCBzZWdtZW50cyA9IChub3JtYWxpemVkUm91dGUucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLycpXG4gICAgLnNsaWNlKDEpXG4gICAgLnNwbGl0KCcvJylcblxuICBjb25zdCBncm91cHM6IHsgW2dyb3VwTmFtZTogc3RyaW5nXTogR3JvdXAgfSA9IHt9XG4gIGxldCBncm91cEluZGV4ID0gMVxuICBjb25zdCBwYXJhbWV0ZXJpemVkUm91dGUgPSBzZWdtZW50c1xuICAgIC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgY29uc3QgeyBrZXksIG9wdGlvbmFsLCByZXBlYXQgfSA9IHBhcnNlUGFyYW1ldGVyKHNlZ21lbnQuc2xpY2UoMSwgLTEpKVxuICAgICAgICBncm91cHNba2V5XSA9IHsgcG9zOiBncm91cEluZGV4KyssIHJlcGVhdCwgb3B0aW9uYWwgfVxuICAgICAgICByZXR1cm4gcmVwZWF0ID8gKG9wdGlvbmFsID8gJyg/Oi8oLis/KSk/JyA6ICcvKC4rPyknKSA6ICcvKFteL10rPyknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYC8ke2VzY2FwZVJlZ2V4KHNlZ21lbnQpfWBcbiAgICAgIH1cbiAgICB9KVxuICAgIC5qb2luKCcnKVxuXG4gIC8vIGRlYWQgY29kZSBlbGltaW5hdGUgZm9yIGJyb3dzZXIgc2luY2UgaXQncyBvbmx5IG5lZWRlZFxuICAvLyB3aGlsZSBnZW5lcmF0aW5nIHJvdXRlcy1tYW5pZmVzdFxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgcm91dGVLZXlDaGFyQ29kZSA9IDk3XG4gICAgbGV0IHJvdXRlS2V5Q2hhckxlbmd0aCA9IDFcblxuICAgIC8vIGJ1aWxkcyBhIG1pbmltYWwgcm91dGVLZXkgdXNpbmcgb25seSBhLXogYW5kIG1pbmltYWwgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICBjb25zdCBnZXRTYWZlUm91dGVLZXkgPSAoKSA9PiB7XG4gICAgICBsZXQgcm91dGVLZXkgPSAnJ1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlS2V5Q2hhckxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvdXRlS2V5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocm91dGVLZXlDaGFyQ29kZSlcbiAgICAgICAgcm91dGVLZXlDaGFyQ29kZSsrXG5cbiAgICAgICAgaWYgKHJvdXRlS2V5Q2hhckNvZGUgPiAxMjIpIHtcbiAgICAgICAgICByb3V0ZUtleUNoYXJMZW5ndGgrK1xuICAgICAgICAgIHJvdXRlS2V5Q2hhckNvZGUgPSA5N1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91dGVLZXlcbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZUtleXM6IHsgW25hbWVkOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9XG5cbiAgICBsZXQgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgPSBzZWdtZW50c1xuICAgICAgLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgICAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgY29uc3QgeyBrZXksIG9wdGlvbmFsLCByZXBlYXQgfSA9IHBhcnNlUGFyYW1ldGVyKHNlZ21lbnQuc2xpY2UoMSwgLTEpKVxuICAgICAgICAgIC8vIHJlcGxhY2UgYW55IG5vbi13b3JkIGNoYXJhY3RlcnMgc2luY2UgdGhleSBjYW4gYnJlYWtcbiAgICAgICAgICAvLyB0aGUgbmFtZWQgcmVnZXhcbiAgICAgICAgICBsZXQgY2xlYW5lZEtleSA9IGtleS5yZXBsYWNlKC9cXFcvZywgJycpXG4gICAgICAgICAgbGV0IGludmFsaWRLZXkgPSBmYWxzZVxuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGtleSBpcyBzdGlsbCBpbnZhbGlkIGFuZCBmYWxsYmFjayB0byB1c2luZyBhIGtub3duXG4gICAgICAgICAgLy8gc2FmZSBrZXlcbiAgICAgICAgICBpZiAoY2xlYW5lZEtleS5sZW5ndGggPT09IDAgfHwgY2xlYW5lZEtleS5sZW5ndGggPiAzMCkge1xuICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc05hTihwYXJzZUludChjbGVhbmVkS2V5LnN1YnN0cigwLCAxKSkpKSB7XG4gICAgICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnZhbGlkS2V5KSB7XG4gICAgICAgICAgICBjbGVhbmVkS2V5ID0gZ2V0U2FmZVJvdXRlS2V5KClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBrZXlcbiAgICAgICAgICByZXR1cm4gcmVwZWF0XG4gICAgICAgICAgICA/IG9wdGlvbmFsXG4gICAgICAgICAgICAgID8gYCg/Oi8oPzwke2NsZWFuZWRLZXl9Pi4rPykpP2BcbiAgICAgICAgICAgICAgOiBgLyg/PCR7Y2xlYW5lZEtleX0+Lis/KWBcbiAgICAgICAgICAgIDogYC8oPzwke2NsZWFuZWRLZXl9PlteL10rPylgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGAvJHtlc2NhcGVSZWdleChzZWdtZW50KX1gXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuam9pbignJylcblxuICAgIHJldHVybiB7XG4gICAgICByZTogbmV3IFJlZ0V4cChgXiR7cGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgKSxcbiAgICAgIGdyb3VwcyxcbiAgICAgIHJvdXRlS2V5cyxcbiAgICAgIG5hbWVkUmVnZXg6IGBeJHtuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCxcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlOiBuZXcgUmVnRXhwKGBeJHtwYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGApLFxuICAgIGdyb3VwcyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW5jb21pbmdNZXNzYWdlLCBTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJ2h0dHAnXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgZm9ybWF0VXJsIH0gZnJvbSAnLi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybCdcbmltcG9ydCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyBFbnYgfSBmcm9tICdAbmV4dC9lbnYnXG5pbXBvcnQgeyBCdWlsZE1hbmlmZXN0IH0gZnJvbSAnLi4vc2VydmVyL2dldC1wYWdlLWZpbGVzJ1xuaW1wb3J0IHsgRG9tYWluTG9jYWxlcyB9IGZyb20gJy4uL3NlcnZlci9jb25maWcnXG5pbXBvcnQgeyBQcmV2aWV3RGF0YSB9IGZyb20gJ25leHQvdHlwZXMnXG5cbi8qKlxuICogVHlwZXMgdXNlZCBieSBib3RoIG5leHQgYW5kIG5leHQtc2VydmVyXG4gKi9cblxuZXhwb3J0IHR5cGUgTmV4dENvbXBvbmVudFR5cGU8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCA9IE5leHRQYWdlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+ID0gQ29tcG9uZW50VHlwZTxQPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGN0eCBDb250ZXh0IG9mIGBwYWdlYFxuICAgKi9cbiAgZ2V0SW5pdGlhbFByb3BzPyhjb250ZXh0OiBDKTogSVAgfCBQcm9taXNlPElQPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPiAmIHtcbiAgcmVuZGVyRG9jdW1lbnQoXG4gICAgRG9jdW1lbnQ6IERvY3VtZW50VHlwZSxcbiAgICBwcm9wczogRG9jdW1lbnRQcm9wc1xuICApOiBSZWFjdC5SZWFjdEVsZW1lbnRcbn1cblxuZXhwb3J0IHR5cGUgQXBwVHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBBcHBDb250ZXh0VHlwZSxcbiAgQXBwSW5pdGlhbFByb3BzLFxuICBBcHBQcm9wc1R5cGVcbj5cblxuZXhwb3J0IHR5cGUgQXBwVHJlZVR5cGUgPSBDb21wb25lbnRUeXBlPFxuICBBcHBJbml0aWFsUHJvcHMgJiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfVxuPlxuXG4vKipcbiAqIFdlYiB2aXRhbHMgcHJvdmlkZWQgdG8gX2FwcC5yZXBvcnRXZWJWaXRhbHMgYnkgQ29yZSBXZWIgVml0YWxzIHBsdWdpbiBkZXZlbG9wZWQgYnkgR29vZ2xlIENocm9tZSB0ZWFtLlxuICogaHR0cHM6Ly9uZXh0anMub3JnL2Jsb2cvbmV4dC05LTQjaW50ZWdyYXRlZC13ZWItdml0YWxzLXJlcG9ydGluZ1xuICovXG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIGxhYmVsOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBSZW5kZXJQYWdlUmVzdWx0IHwgUHJvbWlzZTxSZW5kZXJQYWdlUmVzdWx0PlxuXG5leHBvcnQgdHlwZSBCYXNlQ29udGV4dCA9IHtcbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgW2s6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgdHlwZSBORVhUX0RBVEEgPSB7XG4gIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHBhZ2U6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYnVpbGRJZDogc3RyaW5nXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIHJ1bnRpbWVDb25maWc/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIG5leHRFeHBvcnQ/OiBib29sZWFuXG4gIGF1dG9FeHBvcnQ/OiBib29sZWFuXG4gIGlzRmFsbGJhY2s/OiBib29sZWFuXG4gIGR5bmFtaWNJZHM/OiAoc3RyaW5nIHwgbnVtYmVyKVtdXG4gIGVycj86IEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH1cbiAgZ3NwPzogYm9vbGVhblxuICBnc3NwPzogYm9vbGVhblxuICBjdXN0b21TZXJ2ZXI/OiBib29sZWFuXG4gIGdpcD86IGJvb2xlYW5cbiAgYXBwR2lwPzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbiAgc2NyaXB0TG9hZGVyPzogYW55W11cbiAgaXNQcmV2aWV3PzogYm9vbGVhblxufVxuXG4vKipcbiAqIGBOZXh0YCBjb250ZXh0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dFBhZ2VDb250ZXh0IHtcbiAgLyoqXG4gICAqIEVycm9yIG9iamVjdCBpZiBlbmNvdW50ZXJlZCBkdXJpbmcgcmVuZGVyaW5nXG4gICAqL1xuICBlcnI/OiAoRXJyb3IgJiB7IHN0YXR1c0NvZGU/OiBudW1iZXIgfSkgfCBudWxsXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVxdWVzdCBvYmplY3QuXG4gICAqL1xuICByZXE/OiBJbmNvbWluZ01lc3NhZ2VcbiAgLyoqXG4gICAqIGBIVFRQYCByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICAvKipcbiAgICogUGF0aCBzZWN0aW9uIG9mIGBVUkxgLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZ1xuICAvKipcbiAgICogUXVlcnkgc3RyaW5nIHNlY3Rpb24gb2YgYFVSTGAgcGFyc2VkIGFzIGFuIG9iamVjdC5cbiAgICovXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICAvKipcbiAgICogYFN0cmluZ2Agb2YgdGhlIGFjdHVhbCBwYXRoIGluY2x1ZGluZyBxdWVyeS5cbiAgICovXG4gIGFzUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgbG9jYWxlXG4gICAqL1xuICBsb2NhbGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEFsbCBjb25maWd1cmVkIGxvY2FsZXNcbiAgICovXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICAvKipcbiAgICogVGhlIGNvbmZpZ3VyZWQgZGVmYXVsdCBsb2NhbGVcbiAgICovXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIGBDb21wb25lbnRgIHRoZSB0cmVlIG9mIHRoZSBBcHAgdG8gdXNlIGlmIG5lZWRpbmcgdG8gcmVuZGVyIHNlcGFyYXRlbHlcbiAgICovXG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG59XG5cbmV4cG9ydCB0eXBlIEFwcENvbnRleHRUeXBlPFIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcj4gPSB7XG4gIENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8TmV4dFBhZ2VDb250ZXh0PlxuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxuICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICByb3V0ZXI6IFJcbn1cblxuZXhwb3J0IHR5cGUgQXBwSW5pdGlhbFByb3BzID0ge1xuICBwYWdlUHJvcHM6IGFueVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wc1R5cGU8XG4gIFIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcixcbiAgUCA9IHt9XG4+ID0gQXBwSW5pdGlhbFByb3BzICYge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dCwgYW55LCBQPlxuICByb3V0ZXI6IFJcbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0ICYge1xuICByZW5kZXJQYWdlOiBSZW5kZXJQYWdlXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50SW5pdGlhbFByb3BzID0gUmVuZGVyUGFnZVJlc3VsdCAmIHtcbiAgc3R5bGVzPzogUmVhY3QuUmVhY3RFbGVtZW50W10gfCBSZWFjdC5SZWFjdEZyYWdtZW50XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50UHJvcHMgPSBEb2N1bWVudEluaXRpYWxQcm9wcyAmIHtcbiAgX19ORVhUX0RBVEFfXzogTkVYVF9EQVRBXG4gIGRhbmdlcm91c0FzUGF0aDogc3RyaW5nXG4gIGRvY0NvbXBvbmVudHNSZW5kZXJlZDoge1xuICAgIEh0bWw/OiBib29sZWFuXG4gICAgTWFpbj86IGJvb2xlYW5cbiAgICBIZWFkPzogYm9vbGVhblxuICAgIE5leHRTY3JpcHQ/OiBib29sZWFuXG4gIH1cbiAgYnVpbGRNYW5pZmVzdDogQnVpbGRNYW5pZmVzdFxuICBhbXBQYXRoOiBzdHJpbmdcbiAgaW5BbXBNb2RlOiBib29sZWFuXG4gIGh5YnJpZEFtcDogYm9vbGVhblxuICBpc0RldmVsb3BtZW50OiBib29sZWFuXG4gIGR5bmFtaWNJbXBvcnRzOiBzdHJpbmdbXVxuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBjYW5vbmljYWxCYXNlOiBzdHJpbmdcbiAgaGVhZFRhZ3M6IGFueVtdXG4gIHVuc3RhYmxlX3J1bnRpbWVKUz86IGZhbHNlXG4gIHVuc3RhYmxlX0pzUHJlbG9hZD86IGZhbHNlXG4gIGRldk9ubHlDYWNoZUJ1c3RlclF1ZXJ5U3RyaW5nOiBzdHJpbmdcbiAgc2NyaXB0TG9hZGVyOiB7IGFmdGVySW50ZXJhY3RpdmU/OiBzdHJpbmdbXTsgYmVmb3JlSW50ZXJhY3RpdmU/OiBhbnlbXSB9XG4gIGxvY2FsZT86IHN0cmluZ1xuICBkaXNhYmxlT3B0aW1pemVkTG9hZGluZz86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0QXBpUmVxdWVzdCBleHRlbmRzIEluY29taW5nTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYHF1ZXJ5YCB2YWx1ZXMgZnJvbSB1cmxcbiAgICovXG4gIHF1ZXJ5OiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW11cbiAgfVxuICAvKipcbiAgICogT2JqZWN0IG9mIGBjb29raWVzYCBmcm9tIGhlYWRlclxuICAgKi9cbiAgY29va2llczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG5cbiAgYm9keTogYW55XG5cbiAgZW52OiBFbnZcblxuICBwcmV2aWV3PzogYm9vbGVhblxuICAvKipcbiAgICogUHJldmlldyBkYXRhIHNldCBvbiB0aGUgcmVxdWVzdCwgaWYgYW55XG4gICAqICovXG4gIHByZXZpZXdEYXRhPzogUHJldmlld0RhdGFcbn1cblxuLyoqXG4gKiBTZW5kIGJvZHkgb2YgcmVzcG9uc2VcbiAqL1xudHlwZSBTZW5kPFQ+ID0gKGJvZHk6IFQpID0+IHZvaWRcblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlSZXNwb25zZTxUID0gYW55PiA9IFNlcnZlclJlc3BvbnNlICYge1xuICAvKipcbiAgICogU2VuZCBkYXRhIGBhbnlgIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIHNlbmQ6IFNlbmQ8VD5cbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBganNvbmAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAganNvbjogU2VuZDxUPlxuICBzdGF0dXM6IChzdGF0dXNDb2RlOiBudW1iZXIpID0+IE5leHRBcGlSZXNwb25zZTxUPlxuICByZWRpcmVjdCh1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxUPlxuICByZWRpcmVjdChzdGF0dXM6IG51bWJlciwgdXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8VD5cblxuICAvKipcbiAgICogU2V0IHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIHNldFByZXZpZXdEYXRhOiAoXG4gICAgZGF0YTogb2JqZWN0IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIChpbiBzZWNvbmRzKSBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byBsYXN0IGZvci5cbiAgICAgICAqIFRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBieSByb3VuZGluZyBkb3duLlxuICAgICAgICogQnkgZGVmYXVsdCwgbm8gbWF4aW11bSBhZ2UgaXMgc2V0IGFuZCB0aGUgcHJldmlldyBzZXNzaW9uIGZpbmlzaGVzXG4gICAgICAgKiB3aGVuIHRoZSBjbGllbnQgc2h1dHMgZG93biAoYnJvd3NlciBpcyBjbG9zZWQpLlxuICAgICAgICovXG4gICAgICBtYXhBZ2U/OiBudW1iZXJcbiAgICB9XG4gICkgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIGNsZWFyUHJldmlld0RhdGE6ICgpID0+IE5leHRBcGlSZXNwb25zZTxUPlxufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgaGFuZGxlclxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpSGFuZGxlcjxUID0gYW55PiA9IChcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2U8VD5cbikgPT4gdm9pZCB8IFByb21pc2U8dm9pZD5cblxuLyoqXG4gKiBVdGlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY09uY2U8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gUmV0dXJuVHlwZTxUPj4oXG4gIGZuOiBUXG4pOiBUIHtcbiAgbGV0IHVzZWQgPSBmYWxzZVxuICBsZXQgcmVzdWx0OiBSZXR1cm5UeXBlPFQ+XG5cbiAgcmV0dXJuICgoLi4uYXJnczogYW55W10pID0+IHtcbiAgICBpZiAoIXVzZWQpIHtcbiAgICAgIHVzZWQgPSB0cnVlXG4gICAgICByZXN1bHQgPSBmbiguLi5hcmdzKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pIGFzIFRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uXG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdG5hbWV9JHtwb3J0ID8gJzonICsgcG9ydCA6ICcnfWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgY29uc3QgeyBocmVmIH0gPSB3aW5kb3cubG9jYXRpb25cbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICByZXR1cm4gaHJlZi5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lPFA+KENvbXBvbmVudDogQ29tcG9uZW50VHlwZTxQPikge1xuICByZXR1cm4gdHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZydcbiAgICA/IENvbXBvbmVudFxuICAgIDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXNTZW50KHJlczogU2VydmVyUmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlcy5maW5pc2hlZCB8fCByZXMuaGVhZGVyc1NlbnRcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRHZXRJbml0aWFsUHJvcHM8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+KEFwcDogTmV4dENvbXBvbmVudFR5cGU8QywgSVAsIFA+LCBjdHg6IEMpOiBQcm9taXNlPElQPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKEFwcC5wcm90b3R5cGU/LmdldEluaXRpYWxQcm9wcykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgIEFwcFxuICAgICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAtIHZpc2l0IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gIH1cbiAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKVxuXG4gIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgcGFnZVByb3BzIGRlZmF1bHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9IGFzIElQXG4gIH1cblxuICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KVxuXG4gIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIGlmICghcHJvcHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgIEFwcFxuICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCIke3Byb3BzfVwiIGluc3RlYWQuYFxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgICBBcHBcbiAgICAgICAgKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBjb25zdCB1cmxPYmplY3RLZXlzID0gW1xuICAnYXV0aCcsXG4gICdoYXNoJyxcbiAgJ2hvc3QnLFxuICAnaG9zdG5hbWUnLFxuICAnaHJlZicsXG4gICdwYXRoJyxcbiAgJ3BhdGhuYW1lJyxcbiAgJ3BvcnQnLFxuICAncHJvdG9jb2wnLFxuICAncXVlcnknLFxuICAnc2VhcmNoJyxcbiAgJ3NsYXNoZXMnLFxuXVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0V2l0aFZhbGlkYXRpb24odXJsOiBVcmxPYmplY3QpOiBzdHJpbmcge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyh1cmwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAodXJsT2JqZWN0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogJHtrZXl9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9ybWF0VXJsKHVybClcbn1cblxuZXhwb3J0IGNvbnN0IFNQID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJ1xuZXhwb3J0IGNvbnN0IFNUID1cbiAgU1AgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbidcbiIsImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L3JvdXRlclwiO1xyXG5pbXBvcnQgSGVhZGVyIGZyb20gXCIuLi9jb21wb25lbnRzL0hlYWRlclwiO1xyXG5pbXBvcnQgY291bnRkb3duIGZyb20gXCIuLi9BbmltYXRpb25zLzY1NTA5LTMtMi0xLWdvLmpzb25cIjtcclxuaW1wb3J0IHRyb3BoeSBmcm9tIFwiLi4vQW5pbWF0aW9ucy80MzQ0NC10cm9waHktYW5pbWF0aW9uLmpzb25cIjtcclxuXHJcbmltcG9ydCBMb3R0aWVBbmltYXRpb24gZnJvbSBcIi4uL2NvbXBvbmVudHMvbG90dGllXCI7XHJcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcclxuaW1wb3J0IFF1ZXN0aW9uQ2FyZCBmcm9tIFwiLi4vY29tcG9uZW50cy9RdWVzdGlvbkNhcmRcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRlc3RpbmcoKSB7XHJcbiAgY29uc3QgW2JnQ29sb3IsIHNldEJnY29sb3JdID0gdXNlU3RhdGUoXCJhbnN3ZXJzLXdoaXRlXCIpO1xyXG4gIGNvbnN0IFtxdWVzdGlvbnMsIHNldFF1ZXN0aW9uc10gPSB1c2VTdGF0ZShbXSk7XHJcbiAgY29uc3QgW2N1cnJlbnRRdWVzdGlvbiwgc2V0Y3VycmVudFF1ZXN0aW9uXSA9IHVzZVN0YXRlKDApO1xyXG4gIGNvbnN0IFtzY29yZSwgc2V0U2NvcmVdID0gdXNlU3RhdGUoMCk7XHJcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XHJcbiAgY29uc3QgeW91cm5hbWUgPSByb3V0ZXIucXVlcnkubmFtZTtcclxuICBjb25zdCBjYXRlZ29yeSA9IHJvdXRlci5xdWVyeS5jYXRlZ29yeTtcclxuICBjb25zdCBkaWZmaWN1bHR5ID0gcm91dGVyLnF1ZXJ5LnF1ZXN0aW9uRGlmZmljdWx0eTtcclxuICBjb25zdCBudW1iZXJPZlF1ZXN0aW9ucyA9IHJvdXRlci5xdWVyeS5udW1iZXJPZlF1ZXN0aW9ucztcclxuICBjb25zdCB0ID0gXCJtdWx0aXBsZVwiO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgYXhpb3NcclxuICAgICAgLmdldChcclxuICAgICAgICBgaHR0cHM6Ly9vcGVudGRiLmNvbS9hcGkucGhwP2Ftb3VudD0ke251bWJlck9mUXVlc3Rpb25zfSZjYXRlZ29yeT0ke2NhdGVnb3J5fSZkaWZmaWN1bHR5PSR7ZGlmZmljdWx0eX0mdHlwZT0ke3R9YFxyXG4gICAgICApXHJcbiAgICAgIC50aGVuKChyZXNwKSA9PiB7XHJcbiAgICAgICAgc2V0UXVlc3Rpb25zKHJlc3AuZGF0YS5yZXN1bHRzKTtcclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgIH0pO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3QgaGFuZGxlQW5zd2VyID0gKGFuc3dlcikgPT4ge1xyXG4gICAgaWYgKGFuc3dlciA9PT0gcXVlc3Rpb25zW2N1cnJlbnRRdWVzdGlvbl0uY29ycmVjdF9hbnN3ZXIpIHtcclxuICAgICAgc2V0U2NvcmUoc2NvcmUgKyAxKTtcclxuICAgICAgc2V0Y3VycmVudFF1ZXN0aW9uKGN1cnJlbnRRdWVzdGlvbiArIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coXCJmYWxzZVwiKTtcclxuICAgICAgc2V0Y3VycmVudFF1ZXN0aW9uKGN1cnJlbnRRdWVzdGlvbiArIDEpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBjdXJyZW50UXVlc3Rpb24gPj0gbnVtYmVyT2ZRdWVzdGlvbnMgPyAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInNjb3JlXCI+XHJcbiAgICAgIDxkaXY+XHJcbiAgICAgICAgPExvdHRpZUFuaW1hdGlvbiBsb3R0aWU9e3Ryb3BoeX0gaGVpZ2h0PXsyMDB9IHdpZHRoPXsyMDB9IC8+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2PlxyXG4gICAgICAgIDxoND5cclxuICAgICAgICAgIFlvdXIgc2NvcmUgaXMge3Njb3JlfSBvdXQgb2Yge251bWJlck9mUXVlc3Rpb25zfVxyXG4gICAgICAgIDwvaDQ+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKSA6IHF1ZXN0aW9ucy5sZW5ndGggPiAwID8gKFxyXG4gICAgPGRpdj5cclxuICAgICAgPEhlYWRlciB7Li4ueW91cm5hbWV9IC8+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2NvcmUtZGl2XCI+U2NvcmU6IHtzY29yZX08L2Rpdj5cclxuXHJcbiAgICAgIDxRdWVzdGlvbkNhcmRcclxuICAgICAgICBoYW5kbGVBbnN3ZXI9e2hhbmRsZUFuc3dlcn1cclxuICAgICAgICBkYXRhPXtxdWVzdGlvbnNbY3VycmVudFF1ZXN0aW9uXX1cclxuICAgICAgLz5cclxuICAgIDwvZGl2PlxyXG4gICkgOiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImxvdHRpZXNcIj5cclxuICAgICAgPExvdHRpZUFuaW1hdGlvbiBsb3R0aWU9e2NvdW50ZG93bn0gaGVpZ2h0PXs2NTB9IHdpZHRoPXs3MDB9IC8+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCc7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKHRpbWVvdXRFcnJvck1lc3NhZ2UsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihmdWxsUGF0aCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFjb25maWcud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeHBlY3RlZCBET01FeGNlcHRpb24gdGhyb3duIGJ5IGJyb3dzZXJzIG5vdCBjb21wYXRpYmxlIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIuXG4gICAgICAgIC8vIEJ1dCwgdGhpcyBjYW4gYmUgc3VwcHJlc3NlZCBmb3IgJ2pzb24nIHR5cGUgYXMgaXQgY2FuIGJlIHBhcnNlZCBieSBkZWZhdWx0ICd0cmFuc2Zvcm1SZXNwb25zZScgZnVuY3Rpb24uXG4gICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0RGF0YSkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGF4aW9zLmRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQXhpb3NFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB9XG5cbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICBpZiAoY29uZmlnLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gdGhpcy5kZWZhdWx0cy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcubWV0aG9kID0gJ2dldCc7XG4gIH1cblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuQXhpb3MucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uIGdldFVyaShjb25maWcpIHtcbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgcmV0dXJuIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKS5yZXBsYWNlKC9eXFw/LywgJycpO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG5cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XG5cbiAgZXJyb3IudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgY29kZTogdGhpcy5jb2RlXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGVycm9yO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICB2YXIgdmFsdWVGcm9tQ29uZmlnMktleXMgPSBbJ3VybCcsICdtZXRob2QnLCAnZGF0YSddO1xuICB2YXIgbWVyZ2VEZWVwUHJvcGVydGllc0tleXMgPSBbJ2hlYWRlcnMnLCAnYXV0aCcsICdwcm94eScsICdwYXJhbXMnXTtcbiAgdmFyIGRlZmF1bHRUb0NvbmZpZzJLZXlzID0gW1xuICAgICdiYXNlVVJMJywgJ3RyYW5zZm9ybVJlcXVlc3QnLCAndHJhbnNmb3JtUmVzcG9uc2UnLCAncGFyYW1zU2VyaWFsaXplcicsXG4gICAgJ3RpbWVvdXQnLCAndGltZW91dE1lc3NhZ2UnLCAnd2l0aENyZWRlbnRpYWxzJywgJ2FkYXB0ZXInLCAncmVzcG9uc2VUeXBlJywgJ3hzcmZDb29raWVOYW1lJyxcbiAgICAneHNyZkhlYWRlck5hbWUnLCAnb25VcGxvYWRQcm9ncmVzcycsICdvbkRvd25sb2FkUHJvZ3Jlc3MnLCAnZGVjb21wcmVzcycsXG4gICAgJ21heENvbnRlbnRMZW5ndGgnLCAnbWF4Qm9keUxlbmd0aCcsICdtYXhSZWRpcmVjdHMnLCAndHJhbnNwb3J0JywgJ2h0dHBBZ2VudCcsXG4gICAgJ2h0dHBzQWdlbnQnLCAnY2FuY2VsVG9rZW4nLCAnc29ja2V0UGF0aCcsICdyZXNwb25zZUVuY29kaW5nJ1xuICBdO1xuICB2YXIgZGlyZWN0TWVyZ2VLZXlzID0gWyd2YWxpZGF0ZVN0YXR1cyddO1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgdXRpbHMuZm9yRWFjaCh2YWx1ZUZyb21Db25maWcyS2V5cywgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gobWVyZ2VEZWVwUHJvcGVydGllc0tleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHV0aWxzLmZvckVhY2goZGVmYXVsdFRvQ29uZmlnMktleXMsIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKGRpcmVjdE1lcmdlS2V5cywgZnVuY3Rpb24gbWVyZ2UocHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGF4aW9zS2V5cyA9IHZhbHVlRnJvbUNvbmZpZzJLZXlzXG4gICAgLmNvbmNhdChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cylcbiAgICAuY29uY2F0KGRlZmF1bHRUb0NvbmZpZzJLZXlzKVxuICAgIC5jb25jYXQoZGlyZWN0TWVyZ2VLZXlzKTtcblxuICB2YXIgb3RoZXJLZXlzID0gT2JqZWN0XG4gICAgLmtleXMoY29uZmlnMSlcbiAgICAuY29uY2F0KE9iamVjdC5rZXlzKGNvbmZpZzIpKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyQXhpb3NLZXlzKGtleSkge1xuICAgICAgcmV0dXJuIGF4aW9zS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gob3RoZXJLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKTtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gKHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JykgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWwpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW0sXG4gIHN0cmlwQk9NOiBzdHJpcEJPTVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9hc3NpZ25cIik7XG5cbnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9hc3NpZ24yLmRlZmF1bHQgfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3NldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIik7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9jcmVhdGVcIik7XG5cbnZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKHN1cGVyQ2xhc3MpKSk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCA/ICgwLCBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHtcbiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xufTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNi4xMicgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBoYXMoZXhwb3J0cywga2V5KSkgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG4iLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IGlzRW51bS5jYWxsKFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcbiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG4iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG4iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXG4gIG1vZGU6IHJlcXVpcmUoJy4vX2xpYnJhcnknKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDIwIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcbiIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJEdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbicgJiYgISEkR09QUy5mO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICAkR09QUy5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyBDaHJvbWUgMzggYW5kIDM5IGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBmYWlscyBvbiBwcmltaXRpdmVzXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNDQzXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9ICRmYWlscyhmdW5jdGlvbiAoKSB7ICRHT1BTLmYoMSk7IH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIEZBSUxTX09OX1BSSU1JVElWRVMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5U3ltYm9sczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gICAgcmV0dXJuICRHT1BTLmYodG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcbiIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9rZW4gPSAnJVthLWYwLTldezJ9JztcbnZhciBzaW5nbGVNYXRjaGVyID0gbmV3IFJlZ0V4cCh0b2tlbiwgJ2dpJyk7XG52YXIgbXVsdGlNYXRjaGVyID0gbmV3IFJlZ0V4cCgnKCcgKyB0b2tlbiArICcpKycsICdnaScpO1xuXG5mdW5jdGlvbiBkZWNvZGVDb21wb25lbnRzKGNvbXBvbmVudHMsIHNwbGl0KSB7XG5cdHRyeSB7XG5cdFx0Ly8gVHJ5IHRvIGRlY29kZSB0aGUgZW50aXJlIHN0cmluZyBmaXJzdFxuXHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoY29tcG9uZW50cy5qb2luKCcnKSk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIERvIG5vdGhpbmdcblx0fVxuXG5cdGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdHJldHVybiBjb21wb25lbnRzO1xuXHR9XG5cblx0c3BsaXQgPSBzcGxpdCB8fCAxO1xuXG5cdC8vIFNwbGl0IHRoZSBhcnJheSBpbiAyIHBhcnRzXG5cdHZhciBsZWZ0ID0gY29tcG9uZW50cy5zbGljZSgwLCBzcGxpdCk7XG5cdHZhciByaWdodCA9IGNvbXBvbmVudHMuc2xpY2Uoc3BsaXQpO1xuXG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwoW10sIGRlY29kZUNvbXBvbmVudHMobGVmdCksIGRlY29kZUNvbXBvbmVudHMocmlnaHQpKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdHZhciB0b2tlbnMgPSBpbnB1dC5tYXRjaChzaW5nbGVNYXRjaGVyKTtcblxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpbnB1dCA9IGRlY29kZUNvbXBvbmVudHModG9rZW5zLCBpKS5qb2luKCcnKTtcblxuXHRcdFx0dG9rZW5zID0gaW5wdXQubWF0Y2goc2luZ2xlTWF0Y2hlcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGlucHV0O1xuXHR9XG59XG5cbmZ1bmN0aW9uIGN1c3RvbURlY29kZVVSSUNvbXBvbmVudChpbnB1dCkge1xuXHQvLyBLZWVwIHRyYWNrIG9mIGFsbCB0aGUgcmVwbGFjZW1lbnRzIGFuZCBwcmVmaWxsIHRoZSBtYXAgd2l0aCB0aGUgYEJPTWBcblx0dmFyIHJlcGxhY2VNYXAgPSB7XG5cdFx0JyVGRSVGRic6ICdcXHVGRkZEXFx1RkZGRCcsXG5cdFx0JyVGRiVGRSc6ICdcXHVGRkZEXFx1RkZGRCdcblx0fTtcblxuXHR2YXIgbWF0Y2ggPSBtdWx0aU1hdGNoZXIuZXhlYyhpbnB1dCk7XG5cdHdoaWxlIChtYXRjaCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBEZWNvZGUgYXMgYmlnIGNodW5rcyBhcyBwb3NzaWJsZVxuXHRcdFx0cmVwbGFjZU1hcFttYXRjaFswXV0gPSBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMF0pO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IGRlY29kZShtYXRjaFswXSk7XG5cblx0XHRcdGlmIChyZXN1bHQgIT09IG1hdGNoWzBdKSB7XG5cdFx0XHRcdHJlcGxhY2VNYXBbbWF0Y2hbMF1dID0gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1hdGNoID0gbXVsdGlNYXRjaGVyLmV4ZWMoaW5wdXQpO1xuXHR9XG5cblx0Ly8gQWRkIGAlQzJgIGF0IHRoZSBlbmQgb2YgdGhlIG1hcCB0byBtYWtlIHN1cmUgaXQgZG9lcyBub3QgcmVwbGFjZSB0aGUgY29tYmluYXRvciBiZWZvcmUgZXZlcnl0aGluZyBlbHNlXG5cdHJlcGxhY2VNYXBbJyVDMiddID0gJ1xcdUZGRkQnO1xuXG5cdHZhciBlbnRyaWVzID0gT2JqZWN0LmtleXMocmVwbGFjZU1hcCk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Ly8gUmVwbGFjZSBhbGwgZGVjb2RlZCBjb21wb25lbnRzXG5cdFx0dmFyIGtleSA9IGVudHJpZXNbaV07XG5cdFx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKG5ldyBSZWdFeHAoa2V5LCAnZycpLCByZXBsYWNlTWFwW2tleV0pO1xuXHR9XG5cblx0cmV0dXJuIGlucHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbmNvZGVkVVJJKSB7XG5cdGlmICh0eXBlb2YgZW5jb2RlZFVSSSAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgZW5jb2RlZFVSSWAgdG8gYmUgb2YgdHlwZSBgc3RyaW5nYCwgZ290IGAnICsgdHlwZW9mIGVuY29kZWRVUkkgKyAnYCcpO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRlbmNvZGVkVVJJID0gZW5jb2RlZFVSSS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcblxuXHRcdC8vIFRyeSB0aGUgYnVpbHQgaW4gZGVjb2RlciBmaXJzdFxuXHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlZFVSSSk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIEZhbGxiYWNrIHRvIGEgbW9yZSBhZHZhbmNlZCBkZWNvZGVyXG5cdFx0cmV0dXJuIGN1c3RvbURlY29kZVVSSUNvbXBvbmVudChlbmNvZGVkVVJJKTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgcHJlZGljYXRlKSB7XG5cdHZhciByZXQgPSB7fTtcblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHR2YXIgaXNBcnIgPSBBcnJheS5pc0FycmF5KHByZWRpY2F0ZSk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0dmFyIHZhbCA9IG9ialtrZXldO1xuXG5cdFx0aWYgKGlzQXJyID8gcHJlZGljYXRlLmluZGV4T2Yoa2V5KSAhPT0gLTEgOiBwcmVkaWNhdGUoa2V5LCB2YWwsIG9iaikpIHtcblx0XHRcdHJldFtrZXldID0gdmFsO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuIiwiKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIpICYmIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KHJvb3QpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJvb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG90dGllID0gZmFjdG9yeShyb290KTtcbiAgICAgICAgcm9vdC5ib2R5bW92aW4gPSByb290LmxvdHRpZTtcbiAgICB9XG59KCh3aW5kb3cgfHwge30pLCBmdW5jdGlvbih3aW5kb3cpIHtcblx0LyogZ2xvYmFsIGxvY2F0aW9uSHJlZjp3cml0YWJsZSwgYW5pbWF0aW9uTWFuYWdlciwgc3ViZnJhbWVFbmFibGVkOndyaXRhYmxlLCBkZWZhdWx0Q3VydmVTZWdtZW50czp3cml0YWJsZSwgcm91bmRWYWx1ZXMsXHJcbmV4cHJlc3Npb25zUGx1Z2luOndyaXRhYmxlLCBQcm9wZXJ0eUZhY3RvcnksIFNoYXBlUHJvcGVydHlGYWN0b3J5LCBNYXRyaXgsIGlkUHJlZml4OndyaXRhYmxlICovXHJcbi8qIGV4cG9ydGVkIGxvY2F0aW9uSHJlZiwgc3ViZnJhbWVFbmFibGVkLCBleHByZXNzaW9uc1BsdWdpbiwgaWRQcmVmaXggKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qIGV4cG9ydGVkIHN2Z05TLCBsb2NhdGlvbkhyZWYsIGluaXRpYWxEZWZhdWx0RnJhbWUgKi9cclxuXHJcbnZhciBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcblxyXG52YXIgbG9jYXRpb25IcmVmID0gJyc7XHJcblxyXG52YXIgaW5pdGlhbERlZmF1bHRGcmFtZSA9IC05OTk5OTk7XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlU2l6ZWRBcnJheSAqL1xyXG4vKiBleHBvcnRlZCBzdWJmcmFtZUVuYWJsZWQsIGV4cHJlc3Npb25zUGx1Z2luLCBpc1NhZmFyaSwgY2FjaGVkQ29sb3JzLCBibVBvdywgYm1TcXJ0LCBibUZsb29yLCBibU1heCwgYm1NaW4sIFByb2plY3RJbnRlcmZhY2UsXHJcbmRlZmF1bHRDdXJ2ZVNlZ21lbnRzLCBkZWdUb1JhZHMsIHJvdW5kQ29ybmVyLCBibVJuZCwgc3R5bGVEaXYsIEJNRW50ZXJGcmFtZUV2ZW50LCBCTUNvbXBsZXRlRXZlbnQsIEJNQ29tcGxldGVMb29wRXZlbnQsXHJcbkJNU2VnbWVudFN0YXJ0RXZlbnQsIEJNRGVzdHJveUV2ZW50LCBCTVJlbmRlckZyYW1lRXJyb3JFdmVudCwgQk1Db25maWdFcnJvckV2ZW50LCBCTUFuaW1hdGlvbkNvbmZpZ0Vycm9yRXZlbnQsIGNyZWF0ZUVsZW1lbnRJRCxcclxuYWRkU2F0dXJhdGlvblRvUkdCLCBhZGRCcmlnaHRuZXNzVG9SR0IsIGFkZEh1ZVRvUkdCLCByZ2JUb0hleCAqL1xyXG5cclxudmFyIHN1YmZyYW1lRW5hYmxlZCA9IHRydWU7XHJcbnZhciBpZFByZWZpeCA9ICcnO1xyXG52YXIgZXhwcmVzc2lvbnNQbHVnaW47XHJcbnZhciBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbnZhciBjYWNoZWRDb2xvcnMgPSB7fTtcclxudmFyIGJtUm5kO1xyXG52YXIgYm1Qb3cgPSBNYXRoLnBvdztcclxudmFyIGJtU3FydCA9IE1hdGguc3FydDtcclxudmFyIGJtRmxvb3IgPSBNYXRoLmZsb29yO1xyXG52YXIgYm1NYXggPSBNYXRoLm1heDtcclxudmFyIGJtTWluID0gTWF0aC5taW47XHJcblxyXG52YXIgQk1NYXRoID0ge307XHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHByb3BlcnR5TmFtZXMgPSBbJ2FicycsICdhY29zJywgJ2Fjb3NoJywgJ2FzaW4nLCAnYXNpbmgnLCAnYXRhbicsICdhdGFuaCcsICdhdGFuMicsICdjZWlsJywgJ2NicnQnLCAnZXhwbTEnLCAnY2x6MzInLCAnY29zJywgJ2Nvc2gnLCAnZXhwJywgJ2Zsb29yJywgJ2Zyb3VuZCcsICdoeXBvdCcsICdpbXVsJywgJ2xvZycsICdsb2cxcCcsICdsb2cyJywgJ2xvZzEwJywgJ21heCcsICdtaW4nLCAncG93JywgJ3JhbmRvbScsICdyb3VuZCcsICdzaWduJywgJ3NpbicsICdzaW5oJywgJ3NxcnQnLCAndGFuJywgJ3RhbmgnLCAndHJ1bmMnLCAnRScsICdMTjEwJywgJ0xOMicsICdMT0cxMEUnLCAnTE9HMkUnLCAnUEknLCAnU1FSVDFfMicsICdTUVJUMiddO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBwcm9wZXJ0eU5hbWVzLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIEJNTWF0aFtwcm9wZXJ0eU5hbWVzW2ldXSA9IE1hdGhbcHJvcGVydHlOYW1lc1tpXV07XHJcbiAgfVxyXG59KCkpO1xyXG5cclxuZnVuY3Rpb24gUHJvamVjdEludGVyZmFjZSgpIHsgcmV0dXJuIHt9OyB9XHJcblxyXG5CTU1hdGgucmFuZG9tID0gTWF0aC5yYW5kb207XHJcbkJNTWF0aC5hYnMgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgdmFyIHRPZlZhbCA9IHR5cGVvZiB2YWw7XHJcbiAgaWYgKHRPZlZhbCA9PT0gJ29iamVjdCcgJiYgdmFsLmxlbmd0aCkge1xyXG4gICAgdmFyIGFic0FyciA9IGNyZWF0ZVNpemVkQXJyYXkodmFsLmxlbmd0aCk7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGFic0FycltpXSA9IE1hdGguYWJzKHZhbFtpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWJzQXJyO1xyXG4gIH1cclxuICByZXR1cm4gTWF0aC5hYnModmFsKTtcclxufTtcclxudmFyIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gMTUwO1xyXG52YXIgZGVnVG9SYWRzID0gTWF0aC5QSSAvIDE4MDtcclxudmFyIHJvdW5kQ29ybmVyID0gMC41NTE5O1xyXG5cclxuZnVuY3Rpb24gcm91bmRWYWx1ZXMoZmxhZykge1xyXG4gIGlmIChmbGFnKSB7XHJcbiAgICBibVJuZCA9IE1hdGgucm91bmQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIGJtUm5kID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICByZXR1cm4gdmFsO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxucm91bmRWYWx1ZXMoZmFsc2UpO1xyXG5cclxuZnVuY3Rpb24gc3R5bGVEaXYoZWxlbWVudCkge1xyXG4gIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gIGVsZW1lbnQuc3R5bGUudG9wID0gMDtcclxuICBlbGVtZW50LnN0eWxlLmxlZnQgPSAwO1xyXG4gIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAwJztcclxuICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9ICcwIDAnO1xyXG4gIGVsZW1lbnQuc3R5bGUuYmFja2ZhY2VWaXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xyXG4gIGVsZW1lbnQuc3R5bGUud2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xyXG4gIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtU3R5bGUgPSAncHJlc2VydmUtM2QnO1xyXG4gIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtU3R5bGUgPSAncHJlc2VydmUtM2QnO1xyXG4gIGVsZW1lbnQuc3R5bGUubW96VHJhbnNmb3JtU3R5bGUgPSAncHJlc2VydmUtM2QnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBCTUVudGVyRnJhbWVFdmVudCh0eXBlLCBjdXJyZW50VGltZSwgdG90YWxUaW1lLCBmcmFtZU11bHRpcGxpZXIpIHtcclxuICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gIHRoaXMuY3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcclxuICB0aGlzLnRvdGFsVGltZSA9IHRvdGFsVGltZTtcclxuICB0aGlzLmRpcmVjdGlvbiA9IGZyYW1lTXVsdGlwbGllciA8IDAgPyAtMSA6IDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJNQ29tcGxldGVFdmVudCh0eXBlLCBmcmFtZU11bHRpcGxpZXIpIHtcclxuICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gIHRoaXMuZGlyZWN0aW9uID0gZnJhbWVNdWx0aXBsaWVyIDwgMCA/IC0xIDogMTtcclxufVxyXG5cclxuZnVuY3Rpb24gQk1Db21wbGV0ZUxvb3BFdmVudCh0eXBlLCB0b3RhbExvb3BzLCBjdXJyZW50TG9vcCwgZnJhbWVNdWx0aXBsaWVyKSB7XHJcbiAgdGhpcy50eXBlID0gdHlwZTtcclxuICB0aGlzLmN1cnJlbnRMb29wID0gY3VycmVudExvb3A7XHJcbiAgdGhpcy50b3RhbExvb3BzID0gdG90YWxMb29wcztcclxuICB0aGlzLmRpcmVjdGlvbiA9IGZyYW1lTXVsdGlwbGllciA8IDAgPyAtMSA6IDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJNU2VnbWVudFN0YXJ0RXZlbnQodHlwZSwgZmlyc3RGcmFtZSwgdG90YWxGcmFtZXMpIHtcclxuICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gIHRoaXMuZmlyc3RGcmFtZSA9IGZpcnN0RnJhbWU7XHJcbiAgdGhpcy50b3RhbEZyYW1lcyA9IHRvdGFsRnJhbWVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBCTURlc3Ryb3lFdmVudCh0eXBlLCB0YXJnZXQpIHtcclxuICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBCTVJlbmRlckZyYW1lRXJyb3JFdmVudChuYXRpdmVFcnJvciwgY3VycmVudFRpbWUpIHtcclxuICB0aGlzLnR5cGUgPSAncmVuZGVyRnJhbWVFcnJvcic7XHJcbiAgdGhpcy5uYXRpdmVFcnJvciA9IG5hdGl2ZUVycm9yO1xyXG4gIHRoaXMuY3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcclxufVxyXG5cclxuZnVuY3Rpb24gQk1Db25maWdFcnJvckV2ZW50KG5hdGl2ZUVycm9yKSB7XHJcbiAgdGhpcy50eXBlID0gJ2NvbmZpZ0Vycm9yJztcclxuICB0aGlzLm5hdGl2ZUVycm9yID0gbmF0aXZlRXJyb3I7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJNQW5pbWF0aW9uQ29uZmlnRXJyb3JFdmVudCh0eXBlLCBuYXRpdmVFcnJvcikge1xyXG4gIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgdGhpcy5uYXRpdmVFcnJvciA9IG5hdGl2ZUVycm9yO1xyXG59XHJcblxyXG52YXIgY3JlYXRlRWxlbWVudElEID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgX2NvdW50ID0gMDtcclxuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlSUQoKSB7XHJcbiAgICBfY291bnQgKz0gMTtcclxuICAgIHJldHVybiBpZFByZWZpeCArICdfX2xvdHRpZV9lbGVtZW50XycgKyBfY291bnQ7XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbmZ1bmN0aW9uIEhTVnRvUkdCKGgsIHMsIHYpIHtcclxuICB2YXIgcjtcclxuICB2YXIgZztcclxuICB2YXIgYjtcclxuICB2YXIgaTtcclxuICB2YXIgZjtcclxuICB2YXIgcDtcclxuICB2YXIgcTtcclxuICB2YXIgdDtcclxuICBpID0gTWF0aC5mbG9vcihoICogNik7XHJcbiAgZiA9IGggKiA2IC0gaTtcclxuICBwID0gdiAqICgxIC0gcyk7XHJcbiAgcSA9IHYgKiAoMSAtIGYgKiBzKTtcclxuICB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpO1xyXG4gIHN3aXRjaCAoaSAlIDYpIHtcclxuICAgIGNhc2UgMDogciA9IHY7IGcgPSB0OyBiID0gcDsgYnJlYWs7XHJcbiAgICBjYXNlIDE6IHIgPSBxOyBnID0gdjsgYiA9IHA7IGJyZWFrO1xyXG4gICAgY2FzZSAyOiByID0gcDsgZyA9IHY7IGIgPSB0OyBicmVhaztcclxuICAgIGNhc2UgMzogciA9IHA7IGcgPSBxOyBiID0gdjsgYnJlYWs7XHJcbiAgICBjYXNlIDQ6IHIgPSB0OyBnID0gcDsgYiA9IHY7IGJyZWFrO1xyXG4gICAgY2FzZSA1OiByID0gdjsgZyA9IHA7IGIgPSBxOyBicmVhaztcclxuICAgIGRlZmF1bHQ6IGJyZWFrO1xyXG4gIH1cclxuICByZXR1cm4gW3IsXHJcbiAgICBnLFxyXG4gICAgYl07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFJHQnRvSFNWKHIsIGcsIGIpIHtcclxuICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XHJcbiAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG4gIHZhciBkID0gbWF4IC0gbWluO1xyXG4gIHZhciBoO1xyXG4gIHZhciBzID0gKG1heCA9PT0gMCA/IDAgOiBkIC8gbWF4KTtcclxuICB2YXIgdiA9IG1heCAvIDI1NTtcclxuXHJcbiAgc3dpdGNoIChtYXgpIHtcclxuICAgIGNhc2UgbWluOiBoID0gMDsgYnJlYWs7XHJcbiAgICBjYXNlIHI6IGggPSAoZyAtIGIpICsgZCAqIChnIDwgYiA/IDYgOiAwKTsgaCAvPSA2ICogZDsgYnJlYWs7XHJcbiAgICBjYXNlIGc6IGggPSAoYiAtIHIpICsgZCAqIDI7IGggLz0gNiAqIGQ7IGJyZWFrO1xyXG4gICAgY2FzZSBiOiBoID0gKHIgLSBnKSArIGQgKiA0OyBoIC89IDYgKiBkOyBicmVhaztcclxuICAgIGRlZmF1bHQ6IGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFtcclxuICAgIGgsXHJcbiAgICBzLFxyXG4gICAgdixcclxuICBdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTYXR1cmF0aW9uVG9SR0IoY29sb3IsIG9mZnNldCkge1xyXG4gIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1KTtcclxuICBoc3ZbMV0gKz0gb2Zmc2V0O1xyXG4gIGlmIChoc3ZbMV0gPiAxKSB7XHJcbiAgICBoc3ZbMV0gPSAxO1xyXG4gIH0gZWxzZSBpZiAoaHN2WzFdIDw9IDApIHtcclxuICAgIGhzdlsxXSA9IDA7XHJcbiAgfVxyXG4gIHJldHVybiBIU1Z0b1JHQihoc3ZbMF0sIGhzdlsxXSwgaHN2WzJdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQnJpZ2h0bmVzc1RvUkdCKGNvbG9yLCBvZmZzZXQpIHtcclxuICB2YXIgaHN2ID0gUkdCdG9IU1YoY29sb3JbMF0gKiAyNTUsIGNvbG9yWzFdICogMjU1LCBjb2xvclsyXSAqIDI1NSk7XHJcbiAgaHN2WzJdICs9IG9mZnNldDtcclxuICBpZiAoaHN2WzJdID4gMSkge1xyXG4gICAgaHN2WzJdID0gMTtcclxuICB9IGVsc2UgaWYgKGhzdlsyXSA8IDApIHtcclxuICAgIGhzdlsyXSA9IDA7XHJcbiAgfVxyXG4gIHJldHVybiBIU1Z0b1JHQihoc3ZbMF0sIGhzdlsxXSwgaHN2WzJdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkSHVlVG9SR0IoY29sb3IsIG9mZnNldCkge1xyXG4gIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1KTtcclxuICBoc3ZbMF0gKz0gb2Zmc2V0IC8gMzYwO1xyXG4gIGlmIChoc3ZbMF0gPiAxKSB7XHJcbiAgICBoc3ZbMF0gLT0gMTtcclxuICB9IGVsc2UgaWYgKGhzdlswXSA8IDApIHtcclxuICAgIGhzdlswXSArPSAxO1xyXG4gIH1cclxuICByZXR1cm4gSFNWdG9SR0IoaHN2WzBdLCBoc3ZbMV0sIGhzdlsyXSk7XHJcbn1cclxuXHJcbnZhciByZ2JUb0hleCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGNvbG9yTWFwID0gW107XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGhleDtcclxuICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpICs9IDEpIHtcclxuICAgIGhleCA9IGkudG9TdHJpbmcoMTYpO1xyXG4gICAgY29sb3JNYXBbaV0gPSBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChyLCBnLCBiKSB7XHJcbiAgICBpZiAociA8IDApIHtcclxuICAgICAgciA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAoZyA8IDApIHtcclxuICAgICAgZyA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAoYiA8IDApIHtcclxuICAgICAgYiA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJyMnICsgY29sb3JNYXBbcl0gKyBjb2xvck1hcFtnXSArIGNvbG9yTWFwW2JdO1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG5mdW5jdGlvbiBCYXNlRXZlbnQoKSB7fVxyXG5CYXNlRXZlbnQucHJvdG90eXBlID0ge1xyXG4gIHRyaWdnZXJFdmVudDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgYXJncykge1xyXG4gICAgaWYgKHRoaXMuX2Nic1tldmVudE5hbWVdKSB7XHJcbiAgICAgIHZhciBsZW4gPSB0aGlzLl9jYnNbZXZlbnROYW1lXS5sZW5ndGg7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXVtpXShhcmdzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcclxuICAgIGlmICghdGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0gPSBbXTtcclxuICAgIH1cclxuICAgIHRoaXMuX2Nic1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuICB9LFxyXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoIWNhbGxiYWNrKSB7XHJcbiAgICAgIHRoaXMuX2Nic1tldmVudE5hbWVdID0gbnVsbDtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICB2YXIgbGVuID0gdGhpcy5fY2JzW2V2ZW50TmFtZV0ubGVuZ3RoO1xyXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYnNbZXZlbnROYW1lXVtpXSA9PT0gY2FsbGJhY2spIHtcclxuICAgICAgICAgIHRoaXMuX2Nic1tldmVudE5hbWVdLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgIGkgLT0gMTtcclxuICAgICAgICAgIGxlbiAtPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLl9jYnNbZXZlbnROYW1lXS5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG59O1xyXG5cclxuLyogZXhwb3J0ZWQgY3JlYXRlVHlwZWRBcnJheSwgY3JlYXRlU2l6ZWRBcnJheSAqL1xyXG5cclxudmFyIGNyZWF0ZVR5cGVkQXJyYXkgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZ3VsYXJBcnJheSh0eXBlLCBsZW4pIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBhcnIgPSBbXTtcclxuICAgIHZhciB2YWx1ZTtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlICdpbnQxNic6XHJcbiAgICAgIGNhc2UgJ3VpbnQ4Yyc6XHJcbiAgICAgICAgdmFsdWUgPSAxO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHZhbHVlID0gMS4xO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGFyci5wdXNoKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnI7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNyZWF0ZVR5cGVkQXJyYXlGYWN0b3J5KHR5cGUsIGxlbikge1xyXG4gICAgaWYgKHR5cGUgPT09ICdmbG9hdDMyJykge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xyXG4gICAgfSBpZiAodHlwZSA9PT0gJ2ludDE2Jykge1xyXG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkobGVuKTtcclxuICAgIH0gaWYgKHR5cGUgPT09ICd1aW50OGMnKSB7XHJcbiAgICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkobGVuKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWd1bGFyQXJyYXkodHlwZSwgbGVuKTtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlVHlwZWRBcnJheUZhY3Rvcnk7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVSZWd1bGFyQXJyYXk7XHJcbn0oKSk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTaXplZEFycmF5KGxlbikge1xyXG4gIHJldHVybiBBcnJheS5hcHBseShudWxsLCB7IGxlbmd0aDogbGVuIH0pO1xyXG59XHJcblxyXG4vKiBnbG9iYWwgc3ZnTlMgKi9cclxuLyogZXhwb3J0ZWQgY3JlYXRlTlMgKi9cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU5TKHR5cGUpIHtcclxuICAvLyByZXR1cm4ge2FwcGVuZENoaWxkOmZ1bmN0aW9uKCl7fSxzZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oKXt9LHN0eWxlOnt9fVxyXG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHR5cGUpO1xyXG59XHJcblxyXG4vKiBleHBvcnRlZCBjcmVhdGVUYWcgKi9cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRhZyh0eXBlKSB7XHJcbiAgLy8gcmV0dXJuIHthcHBlbmRDaGlsZDpmdW5jdGlvbigpe30sc2V0QXR0cmlidXRlOmZ1bmN0aW9uKCl7fSxzdHlsZTp7fX1cclxuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKCkge31cclxuRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyLnByb3RvdHlwZSA9IHtcclxuICBhZGREeW5hbWljUHJvcGVydHk6IGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xyXG4gICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLnB1c2gocHJvcCk7XHJcbiAgICAgIHRoaXMuY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcclxuICAgICAgdGhpcy5faXNBbmltYXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfSxcclxuICBpdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5nZXRWYWx1ZSgpO1xyXG4gICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5fbWRmKSB7XHJcbiAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xyXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XHJcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSBmYWxzZTtcclxuICB9LFxyXG59O1xyXG5cclxuLyogZXhwb3J0ZWQgZ2V0QmxlbmRNb2RlICovXHJcblxyXG52YXIgZ2V0QmxlbmRNb2RlID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgYmxlbmRNb2RlRW51bXMgPSB7XHJcbiAgICAwOiAnc291cmNlLW92ZXInLFxyXG4gICAgMTogJ211bHRpcGx5JyxcclxuICAgIDI6ICdzY3JlZW4nLFxyXG4gICAgMzogJ292ZXJsYXknLFxyXG4gICAgNDogJ2RhcmtlbicsXHJcbiAgICA1OiAnbGlnaHRlbicsXHJcbiAgICA2OiAnY29sb3ItZG9kZ2UnLFxyXG4gICAgNzogJ2NvbG9yLWJ1cm4nLFxyXG4gICAgODogJ2hhcmQtbGlnaHQnLFxyXG4gICAgOTogJ3NvZnQtbGlnaHQnLFxyXG4gICAgMTA6ICdkaWZmZXJlbmNlJyxcclxuICAgIDExOiAnZXhjbHVzaW9uJyxcclxuICAgIDEyOiAnaHVlJyxcclxuICAgIDEzOiAnc2F0dXJhdGlvbicsXHJcbiAgICAxNDogJ2NvbG9yJyxcclxuICAgIDE1OiAnbHVtaW5vc2l0eScsXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChtb2RlKSB7XHJcbiAgICByZXR1cm4gYmxlbmRNb2RlRW51bXNbbW9kZV0gfHwgJyc7XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVUeXBlZEFycmF5ICovXHJcblxyXG4vKiFcclxuIFRyYW5zZm9ybWF0aW9uIE1hdHJpeCB2Mi4wXHJcbiAoYykgRXBpc3RlbWV4IDIwMTQtMjAxNVxyXG4gd3d3LmVwaXN0ZW1leC5jb21cclxuIEJ5IEtlbiBGeXJzdGVuYmVyZ1xyXG4gQ29udHJpYnV0aW9ucyBieSBsZWVvbml5YS5cclxuIExpY2Vuc2U6IE1JVCwgaGVhZGVyIHJlcXVpcmVkLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiAyRCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2JqZWN0IGluaXRpYWxpemVkIHdpdGggaWRlbnRpdHkgbWF0cml4LlxyXG4gKlxyXG4gKiBUaGUgbWF0cml4IGNhbiBzeW5jaHJvbml6ZSBhIGNhbnZhcyBjb250ZXh0IGJ5IHN1cHBseWluZyB0aGUgY29udGV4dFxyXG4gKiBhcyBhbiBhcmd1bWVudCwgb3IgbGF0ZXIgYXBwbHkgY3VycmVudCBhYnNvbHV0ZSB0cmFuc2Zvcm0gdG8gYW5cclxuICogZXhpc3RpbmcgY29udGV4dC5cclxuICpcclxuICogQWxsIHZhbHVlcyBhcmUgaGFuZGxlZCBhcyBmbG9hdGluZyBwb2ludCB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbY29udGV4dF0gLSBPcHRpb25hbCBjb250ZXh0IHRvIHN5bmMgd2l0aCBNYXRyaXhcclxuICogQHByb3Age251bWJlcn0gYSAtIHNjYWxlIHhcclxuICogQHByb3Age251bWJlcn0gYiAtIHNoZWFyIHlcclxuICogQHByb3Age251bWJlcn0gYyAtIHNoZWFyIHhcclxuICogQHByb3Age251bWJlcn0gZCAtIHNjYWxlIHlcclxuICogQHByb3Age251bWJlcn0gZSAtIHRyYW5zbGF0ZSB4XHJcbiAqIEBwcm9wIHtudW1iZXJ9IGYgLSB0cmFuc2xhdGUgeVxyXG4gKiBAcHJvcCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx9IFtjb250ZXh0PW51bGxdIC0gc2V0IG9yIGdldCBjdXJyZW50IGNhbnZhcyBjb250ZXh0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuXHJcbnZhciBNYXRyaXggPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBfY29zID0gTWF0aC5jb3M7XHJcbiAgdmFyIF9zaW4gPSBNYXRoLnNpbjtcclxuICB2YXIgX3RhbiA9IE1hdGgudGFuO1xyXG4gIHZhciBfcm5kID0gTWF0aC5yb3VuZDtcclxuXHJcbiAgZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgICB0aGlzLnByb3BzWzBdID0gMTtcclxuICAgIHRoaXMucHJvcHNbMV0gPSAwO1xyXG4gICAgdGhpcy5wcm9wc1syXSA9IDA7XHJcbiAgICB0aGlzLnByb3BzWzNdID0gMDtcclxuICAgIHRoaXMucHJvcHNbNF0gPSAwO1xyXG4gICAgdGhpcy5wcm9wc1s1XSA9IDE7XHJcbiAgICB0aGlzLnByb3BzWzZdID0gMDtcclxuICAgIHRoaXMucHJvcHNbN10gPSAwO1xyXG4gICAgdGhpcy5wcm9wc1s4XSA9IDA7XHJcbiAgICB0aGlzLnByb3BzWzldID0gMDtcclxuICAgIHRoaXMucHJvcHNbMTBdID0gMTtcclxuICAgIHRoaXMucHJvcHNbMTFdID0gMDtcclxuICAgIHRoaXMucHJvcHNbMTJdID0gMDtcclxuICAgIHRoaXMucHJvcHNbMTNdID0gMDtcclxuICAgIHRoaXMucHJvcHNbMTRdID0gMDtcclxuICAgIHRoaXMucHJvcHNbMTVdID0gMTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcm90YXRlKGFuZ2xlKSB7XHJcbiAgICBpZiAoYW5nbGUgPT09IDApIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xyXG4gICAgdmFyIG1TaW4gPSBfc2luKGFuZ2xlKTtcclxuICAgIHJldHVybiB0aGlzLl90KG1Db3MsIC1tU2luLCAwLCAwLCBtU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJvdGF0ZVgoYW5nbGUpIHtcclxuICAgIGlmIChhbmdsZSA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHZhciBtQ29zID0gX2NvcyhhbmdsZSk7XHJcbiAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3QoMSwgMCwgMCwgMCwgMCwgbUNvcywgLW1TaW4sIDAsIDAsIG1TaW4sIG1Db3MsIDAsIDAsIDAsIDAsIDEpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcm90YXRlWShhbmdsZSkge1xyXG4gICAgaWYgKGFuZ2xlID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdmFyIG1Db3MgPSBfY29zKGFuZ2xlKTtcclxuICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XHJcbiAgICByZXR1cm4gdGhpcy5fdChtQ29zLCAwLCBtU2luLCAwLCAwLCAxLCAwLCAwLCAtbVNpbiwgMCwgbUNvcywgMCwgMCwgMCwgMCwgMSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByb3RhdGVaKGFuZ2xlKSB7XHJcbiAgICBpZiAoYW5nbGUgPT09IDApIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xyXG4gICAgdmFyIG1TaW4gPSBfc2luKGFuZ2xlKTtcclxuICAgIHJldHVybiB0aGlzLl90KG1Db3MsIC1tU2luLCAwLCAwLCBtU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNoZWFyKHN4LCBzeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3QoMSwgc3ksIHN4LCAxLCAwLCAwKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNrZXcoYXgsIGF5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5zaGVhcihfdGFuKGF4KSwgX3RhbihheSkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2tld0Zyb21BeGlzKGF4LCBhbmdsZSkge1xyXG4gICAgdmFyIG1Db3MgPSBfY29zKGFuZ2xlKTtcclxuICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XHJcbiAgICByZXR1cm4gdGhpcy5fdChtQ29zLCBtU2luLCAwLCAwLCAtbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcclxuICAgICAgLl90KDEsIDAsIDAsIDAsIF90YW4oYXgpLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVxyXG4gICAgICAuX3QobUNvcywgLW1TaW4sIDAsIDAsIG1TaW4sIG1Db3MsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpO1xyXG4gICAgLy8gcmV0dXJuIHRoaXMuX3QobUNvcywgbVNpbiwgLW1TaW4sIG1Db3MsIDAsIDApLl90KDEsIDAsIF90YW4oYXgpLCAxLCAwLCAwKS5fdChtQ29zLCAtbVNpbiwgbVNpbiwgbUNvcywgMCwgMCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzY2FsZShzeCwgc3ksIHN6KSB7XHJcbiAgICBpZiAoIXN6ICYmIHN6ICE9PSAwKSB7XHJcbiAgICAgIHN6ID0gMTtcclxuICAgIH1cclxuICAgIGlmIChzeCA9PT0gMSAmJiBzeSA9PT0gMSAmJiBzeiA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl90KHN4LCAwLCAwLCAwLCAwLCBzeSwgMCwgMCwgMCwgMCwgc3osIDAsIDAsIDAsIDAsIDEpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4sIG8sIHApIHtcclxuICAgIHRoaXMucHJvcHNbMF0gPSBhO1xyXG4gICAgdGhpcy5wcm9wc1sxXSA9IGI7XHJcbiAgICB0aGlzLnByb3BzWzJdID0gYztcclxuICAgIHRoaXMucHJvcHNbM10gPSBkO1xyXG4gICAgdGhpcy5wcm9wc1s0XSA9IGU7XHJcbiAgICB0aGlzLnByb3BzWzVdID0gZjtcclxuICAgIHRoaXMucHJvcHNbNl0gPSBnO1xyXG4gICAgdGhpcy5wcm9wc1s3XSA9IGg7XHJcbiAgICB0aGlzLnByb3BzWzhdID0gaTtcclxuICAgIHRoaXMucHJvcHNbOV0gPSBqO1xyXG4gICAgdGhpcy5wcm9wc1sxMF0gPSBrO1xyXG4gICAgdGhpcy5wcm9wc1sxMV0gPSBsO1xyXG4gICAgdGhpcy5wcm9wc1sxMl0gPSBtO1xyXG4gICAgdGhpcy5wcm9wc1sxM10gPSBuO1xyXG4gICAgdGhpcy5wcm9wc1sxNF0gPSBvO1xyXG4gICAgdGhpcy5wcm9wc1sxNV0gPSBwO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0cmFuc2xhdGUodHgsIHR5LCB0eikge1xyXG4gICAgdHogPSB0eiB8fCAwO1xyXG4gICAgaWYgKHR4ICE9PSAwIHx8IHR5ICE9PSAwIHx8IHR6ICE9PSAwKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl90KDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIHR4LCB0eSwgdHosIDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0cmFuc2Zvcm0oYTIsIGIyLCBjMiwgZDIsIGUyLCBmMiwgZzIsIGgyLCBpMiwgajIsIGsyLCBsMiwgbTIsIG4yLCBvMiwgcDIpIHtcclxuICAgIHZhciBfcCA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgaWYgKGEyID09PSAxICYmIGIyID09PSAwICYmIGMyID09PSAwICYmIGQyID09PSAwICYmIGUyID09PSAwICYmIGYyID09PSAxICYmIGcyID09PSAwICYmIGgyID09PSAwICYmIGkyID09PSAwICYmIGoyID09PSAwICYmIGsyID09PSAxICYmIGwyID09PSAwKSB7XHJcbiAgICAgIC8vIE5PVEU6IGNvbW1lbnRpbmcgdGhpcyBjb25kaXRpb24gYmVjYXVzZSBUdXJib0ZhbiBkZW9wdGltaXplcyBjb2RlIHdoZW4gcHJlc2VudFxyXG4gICAgICAvLyBpZihtMiAhPT0gMCB8fCBuMiAhPT0gMCB8fCBvMiAhPT0gMCl7XHJcbiAgICAgIF9wWzEyXSA9IF9wWzEyXSAqIGEyICsgX3BbMTVdICogbTI7XHJcbiAgICAgIF9wWzEzXSA9IF9wWzEzXSAqIGYyICsgX3BbMTVdICogbjI7XHJcbiAgICAgIF9wWzE0XSA9IF9wWzE0XSAqIGsyICsgX3BbMTVdICogbzI7XHJcbiAgICAgIF9wWzE1XSAqPSBwMjtcclxuICAgICAgLy8gfVxyXG4gICAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGExID0gX3BbMF07XHJcbiAgICB2YXIgYjEgPSBfcFsxXTtcclxuICAgIHZhciBjMSA9IF9wWzJdO1xyXG4gICAgdmFyIGQxID0gX3BbM107XHJcbiAgICB2YXIgZTEgPSBfcFs0XTtcclxuICAgIHZhciBmMSA9IF9wWzVdO1xyXG4gICAgdmFyIGcxID0gX3BbNl07XHJcbiAgICB2YXIgaDEgPSBfcFs3XTtcclxuICAgIHZhciBpMSA9IF9wWzhdO1xyXG4gICAgdmFyIGoxID0gX3BbOV07XHJcbiAgICB2YXIgazEgPSBfcFsxMF07XHJcbiAgICB2YXIgbDEgPSBfcFsxMV07XHJcbiAgICB2YXIgbTEgPSBfcFsxMl07XHJcbiAgICB2YXIgbjEgPSBfcFsxM107XHJcbiAgICB2YXIgbzEgPSBfcFsxNF07XHJcbiAgICB2YXIgcDEgPSBfcFsxNV07XHJcblxyXG4gICAgLyogbWF0cml4IG9yZGVyIChjYW52YXMgY29tcGF0aWJsZSk6XHJcbiAgICAgICAgICogYWNlXHJcbiAgICAgICAgICogYmRmXHJcbiAgICAgICAgICogMDAxXHJcbiAgICAgICAgICovXHJcbiAgICBfcFswXSA9IGExICogYTIgKyBiMSAqIGUyICsgYzEgKiBpMiArIGQxICogbTI7XHJcbiAgICBfcFsxXSA9IGExICogYjIgKyBiMSAqIGYyICsgYzEgKiBqMiArIGQxICogbjI7XHJcbiAgICBfcFsyXSA9IGExICogYzIgKyBiMSAqIGcyICsgYzEgKiBrMiArIGQxICogbzI7XHJcbiAgICBfcFszXSA9IGExICogZDIgKyBiMSAqIGgyICsgYzEgKiBsMiArIGQxICogcDI7XHJcblxyXG4gICAgX3BbNF0gPSBlMSAqIGEyICsgZjEgKiBlMiArIGcxICogaTIgKyBoMSAqIG0yO1xyXG4gICAgX3BbNV0gPSBlMSAqIGIyICsgZjEgKiBmMiArIGcxICogajIgKyBoMSAqIG4yO1xyXG4gICAgX3BbNl0gPSBlMSAqIGMyICsgZjEgKiBnMiArIGcxICogazIgKyBoMSAqIG8yO1xyXG4gICAgX3BbN10gPSBlMSAqIGQyICsgZjEgKiBoMiArIGcxICogbDIgKyBoMSAqIHAyO1xyXG5cclxuICAgIF9wWzhdID0gaTEgKiBhMiArIGoxICogZTIgKyBrMSAqIGkyICsgbDEgKiBtMjtcclxuICAgIF9wWzldID0gaTEgKiBiMiArIGoxICogZjIgKyBrMSAqIGoyICsgbDEgKiBuMjtcclxuICAgIF9wWzEwXSA9IGkxICogYzIgKyBqMSAqIGcyICsgazEgKiBrMiArIGwxICogbzI7XHJcbiAgICBfcFsxMV0gPSBpMSAqIGQyICsgajEgKiBoMiArIGsxICogbDIgKyBsMSAqIHAyO1xyXG5cclxuICAgIF9wWzEyXSA9IG0xICogYTIgKyBuMSAqIGUyICsgbzEgKiBpMiArIHAxICogbTI7XHJcbiAgICBfcFsxM10gPSBtMSAqIGIyICsgbjEgKiBmMiArIG8xICogajIgKyBwMSAqIG4yO1xyXG4gICAgX3BbMTRdID0gbTEgKiBjMiArIG4xICogZzIgKyBvMSAqIGsyICsgcDEgKiBvMjtcclxuICAgIF9wWzE1XSA9IG0xICogZDIgKyBuMSAqIGgyICsgbzEgKiBsMiArIHAxICogcDI7XHJcblxyXG4gICAgdGhpcy5faWRlbnRpdHlDYWxjdWxhdGVkID0gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzSWRlbnRpdHkoKSB7XHJcbiAgICBpZiAoIXRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCkge1xyXG4gICAgICB0aGlzLl9pZGVudGl0eSA9ICEodGhpcy5wcm9wc1swXSAhPT0gMSB8fCB0aGlzLnByb3BzWzFdICE9PSAwIHx8IHRoaXMucHJvcHNbMl0gIT09IDAgfHwgdGhpcy5wcm9wc1szXSAhPT0gMCB8fCB0aGlzLnByb3BzWzRdICE9PSAwIHx8IHRoaXMucHJvcHNbNV0gIT09IDEgfHwgdGhpcy5wcm9wc1s2XSAhPT0gMCB8fCB0aGlzLnByb3BzWzddICE9PSAwIHx8IHRoaXMucHJvcHNbOF0gIT09IDAgfHwgdGhpcy5wcm9wc1s5XSAhPT0gMCB8fCB0aGlzLnByb3BzWzEwXSAhPT0gMSB8fCB0aGlzLnByb3BzWzExXSAhPT0gMCB8fCB0aGlzLnByb3BzWzEyXSAhPT0gMCB8fCB0aGlzLnByb3BzWzEzXSAhPT0gMCB8fCB0aGlzLnByb3BzWzE0XSAhPT0gMCB8fCB0aGlzLnByb3BzWzE1XSAhPT0gMSk7XHJcbiAgICAgIHRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5faWRlbnRpdHk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlcXVhbHMobWF0cikge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCAxNikge1xyXG4gICAgICBpZiAobWF0ci5wcm9wc1tpXSAhPT0gdGhpcy5wcm9wc1tpXSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsb25lKG1hdHIpIHtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcclxuICAgICAgbWF0ci5wcm9wc1tpXSA9IHRoaXMucHJvcHNbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0cjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsb25lRnJvbVByb3BzKHByb3BzKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XHJcbiAgICAgIHRoaXMucHJvcHNbaV0gPSBwcm9wc1tpXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludCh4LCB5LCB6KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiB4ICogdGhpcy5wcm9wc1swXSArIHkgKiB0aGlzLnByb3BzWzRdICsgeiAqIHRoaXMucHJvcHNbOF0gKyB0aGlzLnByb3BzWzEyXSxcclxuICAgICAgeTogeCAqIHRoaXMucHJvcHNbMV0gKyB5ICogdGhpcy5wcm9wc1s1XSArIHogKiB0aGlzLnByb3BzWzldICsgdGhpcy5wcm9wc1sxM10sXHJcbiAgICAgIHo6IHggKiB0aGlzLnByb3BzWzJdICsgeSAqIHRoaXMucHJvcHNbNl0gKyB6ICogdGhpcy5wcm9wc1sxMF0gKyB0aGlzLnByb3BzWzE0XSxcclxuICAgIH07XHJcbiAgICAvKiByZXR1cm4ge1xyXG4gICAgICAgICB4OiB4ICogbWUuYSArIHkgKiBtZS5jICsgbWUuZSxcclxuICAgICAgICAgeTogeCAqIG1lLmIgKyB5ICogbWUuZCArIG1lLmZcclxuICAgICAgICAgfTsgKi9cclxuICB9XHJcbiAgZnVuY3Rpb24gYXBwbHlUb1goeCwgeSwgeikge1xyXG4gICAgcmV0dXJuIHggKiB0aGlzLnByb3BzWzBdICsgeSAqIHRoaXMucHJvcHNbNF0gKyB6ICogdGhpcy5wcm9wc1s4XSArIHRoaXMucHJvcHNbMTJdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBhcHBseVRvWSh4LCB5LCB6KSB7XHJcbiAgICByZXR1cm4geCAqIHRoaXMucHJvcHNbMV0gKyB5ICogdGhpcy5wcm9wc1s1XSArIHogKiB0aGlzLnByb3BzWzldICsgdGhpcy5wcm9wc1sxM107XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGFwcGx5VG9aKHgsIHksIHopIHtcclxuICAgIHJldHVybiB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRJbnZlcnNlTWF0cml4KCkge1xyXG4gICAgdmFyIGRldGVybWluYW50ID0gdGhpcy5wcm9wc1swXSAqIHRoaXMucHJvcHNbNV0gLSB0aGlzLnByb3BzWzFdICogdGhpcy5wcm9wc1s0XTtcclxuICAgIHZhciBhID0gdGhpcy5wcm9wc1s1XSAvIGRldGVybWluYW50O1xyXG4gICAgdmFyIGIgPSAtdGhpcy5wcm9wc1sxXSAvIGRldGVybWluYW50O1xyXG4gICAgdmFyIGMgPSAtdGhpcy5wcm9wc1s0XSAvIGRldGVybWluYW50O1xyXG4gICAgdmFyIGQgPSB0aGlzLnByb3BzWzBdIC8gZGV0ZXJtaW5hbnQ7XHJcbiAgICB2YXIgZSA9ICh0aGlzLnByb3BzWzRdICogdGhpcy5wcm9wc1sxM10gLSB0aGlzLnByb3BzWzVdICogdGhpcy5wcm9wc1sxMl0pIC8gZGV0ZXJtaW5hbnQ7XHJcbiAgICB2YXIgZiA9IC0odGhpcy5wcm9wc1swXSAqIHRoaXMucHJvcHNbMTNdIC0gdGhpcy5wcm9wc1sxXSAqIHRoaXMucHJvcHNbMTJdKSAvIGRldGVybWluYW50O1xyXG4gICAgdmFyIGludmVyc2VNYXRyaXggPSBuZXcgTWF0cml4KCk7XHJcbiAgICBpbnZlcnNlTWF0cml4LnByb3BzWzBdID0gYTtcclxuICAgIGludmVyc2VNYXRyaXgucHJvcHNbMV0gPSBiO1xyXG4gICAgaW52ZXJzZU1hdHJpeC5wcm9wc1s0XSA9IGM7XHJcbiAgICBpbnZlcnNlTWF0cml4LnByb3BzWzVdID0gZDtcclxuICAgIGludmVyc2VNYXRyaXgucHJvcHNbMTJdID0gZTtcclxuICAgIGludmVyc2VNYXRyaXgucHJvcHNbMTNdID0gZjtcclxuICAgIHJldHVybiBpbnZlcnNlTWF0cml4O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW52ZXJzZVBvaW50KHB0KSB7XHJcbiAgICB2YXIgaW52ZXJzZU1hdHJpeCA9IHRoaXMuZ2V0SW52ZXJzZU1hdHJpeCgpO1xyXG4gICAgcmV0dXJuIGludmVyc2VNYXRyaXguYXBwbHlUb1BvaW50QXJyYXkocHRbMF0sIHB0WzFdLCBwdFsyXSB8fCAwKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGludmVyc2VQb2ludHMocHRzKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBwdHMubGVuZ3RoO1xyXG4gICAgdmFyIHJldFB0cyA9IFtdO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHJldFB0c1tpXSA9IGludmVyc2VQb2ludChwdHNbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldFB0cztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5VG9UcmlwbGVQb2ludHMocHQxLCBwdDIsIHB0Mykge1xyXG4gICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCA2KTtcclxuICAgIGlmICh0aGlzLmlzSWRlbnRpdHkoKSkge1xyXG4gICAgICBhcnJbMF0gPSBwdDFbMF07XHJcbiAgICAgIGFyclsxXSA9IHB0MVsxXTtcclxuICAgICAgYXJyWzJdID0gcHQyWzBdO1xyXG4gICAgICBhcnJbM10gPSBwdDJbMV07XHJcbiAgICAgIGFycls0XSA9IHB0M1swXTtcclxuICAgICAgYXJyWzVdID0gcHQzWzFdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHAwID0gdGhpcy5wcm9wc1swXTtcclxuICAgICAgdmFyIHAxID0gdGhpcy5wcm9wc1sxXTtcclxuICAgICAgdmFyIHA0ID0gdGhpcy5wcm9wc1s0XTtcclxuICAgICAgdmFyIHA1ID0gdGhpcy5wcm9wc1s1XTtcclxuICAgICAgdmFyIHAxMiA9IHRoaXMucHJvcHNbMTJdO1xyXG4gICAgICB2YXIgcDEzID0gdGhpcy5wcm9wc1sxM107XHJcbiAgICAgIGFyclswXSA9IHB0MVswXSAqIHAwICsgcHQxWzFdICogcDQgKyBwMTI7XHJcbiAgICAgIGFyclsxXSA9IHB0MVswXSAqIHAxICsgcHQxWzFdICogcDUgKyBwMTM7XHJcbiAgICAgIGFyclsyXSA9IHB0MlswXSAqIHAwICsgcHQyWzFdICogcDQgKyBwMTI7XHJcbiAgICAgIGFyclszXSA9IHB0MlswXSAqIHAxICsgcHQyWzFdICogcDUgKyBwMTM7XHJcbiAgICAgIGFycls0XSA9IHB0M1swXSAqIHAwICsgcHQzWzFdICogcDQgKyBwMTI7XHJcbiAgICAgIGFycls1XSA9IHB0M1swXSAqIHAxICsgcHQzWzFdICogcDUgKyBwMTM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYXBwbHlUb1BvaW50QXJyYXkoeCwgeSwgeikge1xyXG4gICAgdmFyIGFycjtcclxuICAgIGlmICh0aGlzLmlzSWRlbnRpdHkoKSkge1xyXG4gICAgICBhcnIgPSBbeCwgeSwgel07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhcnIgPSBbXHJcbiAgICAgICAgeCAqIHRoaXMucHJvcHNbMF0gKyB5ICogdGhpcy5wcm9wc1s0XSArIHogKiB0aGlzLnByb3BzWzhdICsgdGhpcy5wcm9wc1sxMl0sXHJcbiAgICAgICAgeCAqIHRoaXMucHJvcHNbMV0gKyB5ICogdGhpcy5wcm9wc1s1XSArIHogKiB0aGlzLnByb3BzWzldICsgdGhpcy5wcm9wc1sxM10sXHJcbiAgICAgICAgeCAqIHRoaXMucHJvcHNbMl0gKyB5ICogdGhpcy5wcm9wc1s2XSArIHogKiB0aGlzLnByb3BzWzEwXSArIHRoaXMucHJvcHNbMTRdLFxyXG4gICAgICBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKHgsIHkpIHtcclxuICAgIGlmICh0aGlzLmlzSWRlbnRpdHkoKSkge1xyXG4gICAgICByZXR1cm4geCArICcsJyArIHk7XHJcbiAgICB9XHJcbiAgICB2YXIgX3AgPSB0aGlzLnByb3BzO1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKHggKiBfcFswXSArIHkgKiBfcFs0XSArIF9wWzEyXSkgKiAxMDApIC8gMTAwICsgJywnICsgTWF0aC5yb3VuZCgoeCAqIF9wWzFdICsgeSAqIF9wWzVdICsgX3BbMTNdKSAqIDEwMCkgLyAxMDA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0b0NTUygpIHtcclxuICAgIC8vIERvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIHRvIGFkZCB0aGlzIG9wdGltaXphdGlvbi4gSWYgaXQgaXMgYW4gaWRlbnRpdHkgbWF0cml4LCBpdCdzIHZlcnkgbGlrZWx5IHRoaXMgd2lsbCBnZXQgY2FsbGVkIG9ubHkgb25jZSBzaW5jZSBpdCB3b24ndCBiZSBrZXlmcmFtZWQuXHJcbiAgICAvKiBpZih0aGlzLmlzSWRlbnRpdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfSAqL1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgIHZhciBjc3NWYWx1ZSA9ICdtYXRyaXgzZCgnO1xyXG4gICAgdmFyIHYgPSAxMDAwMDtcclxuICAgIHdoaWxlIChpIDwgMTYpIHtcclxuICAgICAgY3NzVmFsdWUgKz0gX3JuZChwcm9wc1tpXSAqIHYpIC8gdjtcclxuICAgICAgY3NzVmFsdWUgKz0gaSA9PT0gMTUgPyAnKScgOiAnLCc7XHJcbiAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiBjc3NWYWx1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJvdW5kTWF0cml4UHJvcGVydHkodmFsKSB7XHJcbiAgICB2YXIgdiA9IDEwMDAwO1xyXG4gICAgaWYgKCh2YWwgPCAwLjAwMDAwMSAmJiB2YWwgPiAwKSB8fCAodmFsID4gLTAuMDAwMDAxICYmIHZhbCA8IDApKSB7XHJcbiAgICAgIHJldHVybiBfcm5kKHZhbCAqIHYpIC8gdjtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0bzJkQ1NTKCkge1xyXG4gICAgLy8gRG9lc24ndCBtYWtlIG11Y2ggc2Vuc2UgdG8gYWRkIHRoaXMgb3B0aW1pemF0aW9uLiBJZiBpdCBpcyBhbiBpZGVudGl0eSBtYXRyaXgsIGl0J3MgdmVyeSBsaWtlbHkgdGhpcyB3aWxsIGdldCBjYWxsZWQgb25seSBvbmNlIHNpbmNlIGl0IHdvbid0IGJlIGtleWZyYW1lZC5cclxuICAgIC8qIGlmKHRoaXMuaXNJZGVudGl0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9ICovXHJcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgdmFyIF9hID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1swXSk7XHJcbiAgICB2YXIgX2IgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzFdKTtcclxuICAgIHZhciBfYyA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbNF0pO1xyXG4gICAgdmFyIF9kID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1s1XSk7XHJcbiAgICB2YXIgX2UgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzEyXSk7XHJcbiAgICB2YXIgX2YgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzEzXSk7XHJcbiAgICByZXR1cm4gJ21hdHJpeCgnICsgX2EgKyAnLCcgKyBfYiArICcsJyArIF9jICsgJywnICsgX2QgKyAnLCcgKyBfZSArICcsJyArIF9mICsgJyknO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVzZXQgPSByZXNldDtcclxuICAgIHRoaXMucm90YXRlID0gcm90YXRlO1xyXG4gICAgdGhpcy5yb3RhdGVYID0gcm90YXRlWDtcclxuICAgIHRoaXMucm90YXRlWSA9IHJvdGF0ZVk7XHJcbiAgICB0aGlzLnJvdGF0ZVogPSByb3RhdGVaO1xyXG4gICAgdGhpcy5za2V3ID0gc2tldztcclxuICAgIHRoaXMuc2tld0Zyb21BeGlzID0gc2tld0Zyb21BeGlzO1xyXG4gICAgdGhpcy5zaGVhciA9IHNoZWFyO1xyXG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm0gPSBzZXRUcmFuc2Zvcm07XHJcbiAgICB0aGlzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcclxuICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgdGhpcy5hcHBseVRvUG9pbnQgPSBhcHBseVRvUG9pbnQ7XHJcbiAgICB0aGlzLmFwcGx5VG9YID0gYXBwbHlUb1g7XHJcbiAgICB0aGlzLmFwcGx5VG9ZID0gYXBwbHlUb1k7XHJcbiAgICB0aGlzLmFwcGx5VG9aID0gYXBwbHlUb1o7XHJcbiAgICB0aGlzLmFwcGx5VG9Qb2ludEFycmF5ID0gYXBwbHlUb1BvaW50QXJyYXk7XHJcbiAgICB0aGlzLmFwcGx5VG9UcmlwbGVQb2ludHMgPSBhcHBseVRvVHJpcGxlUG9pbnRzO1xyXG4gICAgdGhpcy5hcHBseVRvUG9pbnRTdHJpbmdpZmllZCA9IGFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkO1xyXG4gICAgdGhpcy50b0NTUyA9IHRvQ1NTO1xyXG4gICAgdGhpcy50bzJkQ1NTID0gdG8yZENTUztcclxuICAgIHRoaXMuY2xvbmUgPSBjbG9uZTtcclxuICAgIHRoaXMuY2xvbmVGcm9tUHJvcHMgPSBjbG9uZUZyb21Qcm9wcztcclxuICAgIHRoaXMuZXF1YWxzID0gZXF1YWxzO1xyXG4gICAgdGhpcy5pbnZlcnNlUG9pbnRzID0gaW52ZXJzZVBvaW50cztcclxuICAgIHRoaXMuaW52ZXJzZVBvaW50ID0gaW52ZXJzZVBvaW50O1xyXG4gICAgdGhpcy5nZXRJbnZlcnNlTWF0cml4ID0gZ2V0SW52ZXJzZU1hdHJpeDtcclxuICAgIHRoaXMuX3QgPSB0aGlzLnRyYW5zZm9ybTtcclxuICAgIHRoaXMuaXNJZGVudGl0eSA9IGlzSWRlbnRpdHk7XHJcbiAgICB0aGlzLl9pZGVudGl0eSA9IHRydWU7XHJcbiAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnByb3BzID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDE2KTtcclxuICAgIHRoaXMucmVzZXQoKTtcclxuICB9O1xyXG59KCkpO1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuLypcclxuIENvcHlyaWdodCAyMDE0IERhdmlkIEJhdS5cclxuXHJcbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xyXG4gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWVxyXG4gQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcclxuIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXHJcbiBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uIChwb29sLCBtYXRoKSB7XHJcbi8vXHJcbi8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cclxuLy9cclxuICAgIHZhciBnbG9iYWwgPSB0aGlzLFxyXG4gICAgICAgIHdpZHRoID0gMjU2LCAgICAgICAgLy8gZWFjaCBSQzQgb3V0cHV0IGlzIDAgPD0geCA8IDI1NlxyXG4gICAgICAgIGNodW5rcyA9IDYsICAgICAgICAgLy8gYXQgbGVhc3Qgc2l4IFJDNCBvdXRwdXRzIGZvciBlYWNoIGRvdWJsZVxyXG4gICAgICAgIGRpZ2l0cyA9IDUyLCAgICAgICAgLy8gdGhlcmUgYXJlIDUyIHNpZ25pZmljYW50IGRpZ2l0cyBpbiBhIGRvdWJsZVxyXG4gICAgICAgIHJuZ25hbWUgPSAncmFuZG9tJywgLy8gcm5nbmFtZTogbmFtZSBmb3IgTWF0aC5yYW5kb20gYW5kIE1hdGguc2VlZHJhbmRvbVxyXG4gICAgICAgIHN0YXJ0ZGVub20gPSBtYXRoLnBvdyh3aWR0aCwgY2h1bmtzKSxcclxuICAgICAgICBzaWduaWZpY2FuY2UgPSBtYXRoLnBvdygyLCBkaWdpdHMpLFxyXG4gICAgICAgIG92ZXJmbG93ID0gc2lnbmlmaWNhbmNlICogMixcclxuICAgICAgICBtYXNrID0gd2lkdGggLSAxLFxyXG4gICAgICAgIG5vZGVjcnlwdG87ICAgICAgICAgLy8gbm9kZS5qcyBjcnlwdG8gbW9kdWxlLCBpbml0aWFsaXplZCBhdCB0aGUgYm90dG9tLlxyXG5cclxuLy9cclxuLy8gc2VlZHJhbmRvbSgpXHJcbi8vIFRoaXMgaXMgdGhlIHNlZWRyYW5kb20gZnVuY3Rpb24gZGVzY3JpYmVkIGFib3ZlLlxyXG4vL1xyXG4gICAgZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBrZXkgPSBbXTtcclxuICAgICAgICBvcHRpb25zID0gKG9wdGlvbnMgPT09IHRydWUpID8geyBlbnRyb3B5OiB0cnVlIH0gOiAob3B0aW9ucyB8fCB7fSk7XHJcblxyXG4gICAgICAgIC8vIEZsYXR0ZW4gdGhlIHNlZWQgc3RyaW5nIG9yIGJ1aWxkIG9uZSBmcm9tIGxvY2FsIGVudHJvcHkgaWYgbmVlZGVkLlxyXG4gICAgICAgIHZhciBzaG9ydHNlZWQgPSBtaXhrZXkoZmxhdHRlbihcclxuICAgICAgICAgICAgb3B0aW9ucy5lbnRyb3B5ID8gW3NlZWQsIHRvc3RyaW5nKHBvb2wpXSA6XHJcbiAgICAgICAgICAgICAgICAoc2VlZCA9PT0gbnVsbCkgPyBhdXRvc2VlZCgpIDogc2VlZCwgMyksIGtleSk7XHJcblxyXG4gICAgICAgIC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxyXG4gICAgICAgIHZhciBhcmM0ID0gbmV3IEFSQzQoa2V5KTtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcmFuZG9tIGRvdWJsZSBpbiBbMCwgMSkgdGhhdCBjb250YWluc1xyXG4gICAgICAgIC8vIHJhbmRvbW5lc3MgaW4gZXZlcnkgYml0IG9mIHRoZSBtYW50aXNzYSBvZiB0aGUgSUVFRSA3NTQgdmFsdWUuXHJcbiAgICAgICAgdmFyIHBybmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBhcmM0LmcoY2h1bmtzKSwgICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG51bWVyYXRvciBuIDwgMiBeIDQ4XHJcbiAgICAgICAgICAgICAgICBkID0gc3RhcnRkZW5vbSwgICAgICAgICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXHJcbiAgICAgICAgICAgICAgICB4ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYW5kIG5vICdleHRyYSBsYXN0IGJ5dGUnLlxyXG4gICAgICAgICAgICB3aGlsZSAobiA8IHNpZ25pZmljYW5jZSkgeyAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcclxuICAgICAgICAgICAgICAgIG4gPSAobiArIHgpICogd2lkdGg7ICAgICAgICAgICAgICAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcclxuICAgICAgICAgICAgICAgIGQgKj0gd2lkdGg7ICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGRlbm9taW5hdG9yIGFuZCBnZW5lcmF0aW5nIGFcclxuICAgICAgICAgICAgICAgIHggPSBhcmM0LmcoMSk7ICAgICAgICAgICAgICAgICAgICAvLyAgIG5ldyBsZWFzdC1zaWduaWZpY2FudC1ieXRlLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChuID49IG92ZXJmbG93KSB7ICAgICAgICAgICAgIC8vIFRvIGF2b2lkIHJvdW5kaW5nIHVwLCBiZWZvcmUgYWRkaW5nXHJcbiAgICAgICAgICAgICAgICBuIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBsYXN0IGJ5dGUsIHNoaWZ0IGV2ZXJ5dGhpbmdcclxuICAgICAgICAgICAgICAgIGQgLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHJpZ2h0IHVzaW5nIGludGVnZXIgbWF0aCB1bnRpbFxyXG4gICAgICAgICAgICAgICAgeCA+Pj49IDE7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgd2UgaGF2ZSBleGFjdGx5IHRoZSBkZXNpcmVkIGJpdHMuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIChuICsgeCkgLyBkOyAgICAgICAgICAgICAgICAgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIHwgMDsgfTtcclxuICAgICAgICBwcm5nLnF1aWNrID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgLyAweDEwMDAwMDAwMDsgfTtcclxuICAgICAgICBwcm5nLmRvdWJsZSA9IHBybmc7XHJcblxyXG4gICAgICAgIC8vIE1peCB0aGUgcmFuZG9tbmVzcyBpbnRvIGFjY3VtdWxhdGVkIGVudHJvcHkuXHJcbiAgICAgICAgbWl4a2V5KHRvc3RyaW5nKGFyYzQuUyksIHBvb2wpO1xyXG5cclxuICAgICAgICAvLyBDYWxsaW5nIGNvbnZlbnRpb246IHdoYXQgdG8gcmV0dXJuIGFzIGEgZnVuY3Rpb24gb2YgcHJuZywgc2VlZCwgaXNfbWF0aC5cclxuICAgICAgICByZXR1cm4gKG9wdGlvbnMucGFzcyB8fCBjYWxsYmFjayB8fFxyXG4gICAgICAgIGZ1bmN0aW9uKHBybmcsIHNlZWQsIGlzX21hdGhfY2FsbCwgc3RhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBhcmM0IHN0YXRlIGZyb20gdGhlIGdpdmVuIHN0YXRlIGlmIGl0IGhhcyBhbiBTIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLlMpIHsgY29weShzdGF0ZSwgYXJjNCk7IH1cclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcHJvdmlkZSB0aGUgLnN0YXRlIG1ldGhvZCBpZiByZXF1ZXN0ZWQgdmlhIG9wdGlvbnMuc3RhdGUuXHJcbiAgICAgICAgICAgICAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KGFyYzQsIHt9KTsgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgY2FsbGVkIGFzIGEgbWV0aG9kIG9mIE1hdGggKE1hdGguc2VlZHJhbmRvbSgpKSwgbXV0YXRlXHJcbiAgICAgICAgICAgIC8vIE1hdGgucmFuZG9tIGJlY2F1c2UgdGhhdCBpcyBob3cgc2VlZHJhbmRvbS5qcyBoYXMgd29ya2VkIHNpbmNlIHYxLjAuXHJcbiAgICAgICAgICAgIGlmIChpc19tYXRoX2NhbGwpIHsgbWF0aFtybmduYW1lXSA9IHBybmc7IHJldHVybiBzZWVkOyB9XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGl0IGlzIGEgbmV3ZXIgY2FsbGluZyBjb252ZW50aW9uLCBzbyByZXR1cm4gdGhlXHJcbiAgICAgICAgICAgIC8vIHBybmcgZGlyZWN0bHkuXHJcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIHBybmc7XHJcbiAgICAgICAgfSkoXHJcbiAgICAgICAgICAgIHBybmcsXHJcbiAgICAgICAgICAgIHNob3J0c2VlZCxcclxuICAgICAgICAgICAgJ2dsb2JhbCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZ2xvYmFsIDogKHRoaXMgPT0gbWF0aCksXHJcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgbWF0aFsnc2VlZCcgKyBybmduYW1lXSA9IHNlZWRyYW5kb207XHJcblxyXG4vL1xyXG4vLyBBUkM0XHJcbi8vXHJcbi8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2ZcclxuLy8gYW4gYXJyYXkgb2YgYXQgbW9zdCAod2lkdGgpIGludGVnZXJzIHRoYXQgc2hvdWxkIGJlIDAgPD0geCA8ICh3aWR0aCkuXHJcbi8vXHJcbi8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXHJcbi8vIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBmcm9tIEFSQzQuICBJdHMgcmV0dXJuIHZhbHVlIGlzIGEgbnVtYmVyIHhcclxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxyXG4vL1xyXG4gICAgZnVuY3Rpb24gQVJDNChrZXkpIHtcclxuICAgICAgICB2YXIgdCwga2V5bGVuID0ga2V5Lmxlbmd0aCxcclxuICAgICAgICAgICAgbWUgPSB0aGlzLCBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gMCwgcyA9IG1lLlMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gVGhlIGVtcHR5IGtleSBbXSBpcyB0cmVhdGVkIGFzIFswXS5cclxuICAgICAgICBpZiAoIWtleWxlbikgeyBrZXkgPSBba2V5bGVuKytdOyB9XHJcblxyXG4gICAgICAgIC8vIFNldCB1cCBTIHVzaW5nIHRoZSBzdGFuZGFyZCBrZXkgc2NoZWR1bGluZyBhbGdvcml0aG0uXHJcbiAgICAgICAgd2hpbGUgKGkgPCB3aWR0aCkge1xyXG4gICAgICAgICAgICBzW2ldID0gaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xyXG4gICAgICAgICAgICBzW2ldID0gc1tqID0gbWFzayAmIChqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKSldO1xyXG4gICAgICAgICAgICBzW2pdID0gdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBcImdcIiBtZXRob2QgcmV0dXJucyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgYXMgb25lIG51bWJlci5cclxuICAgICAgICBtZS5nID0gZnVuY3Rpb24oY291bnQpIHtcclxuICAgICAgICAgICAgLy8gVXNpbmcgaW5zdGFuY2UgbWVtYmVycyBpbnN0ZWFkIG9mIGNsb3N1cmUgc3RhdGUgbmVhcmx5IGRvdWJsZXMgc3BlZWQuXHJcbiAgICAgICAgICAgIHZhciB0LCByID0gMCxcclxuICAgICAgICAgICAgICAgIGkgPSBtZS5pLCBqID0gbWUuaiwgcyA9IG1lLlM7XHJcbiAgICAgICAgICAgIHdoaWxlIChjb3VudC0tKSB7XHJcbiAgICAgICAgICAgICAgICB0ID0gc1tpID0gbWFzayAmIChpICsgMSldO1xyXG4gICAgICAgICAgICAgICAgciA9IHIgKiB3aWR0aCArIHNbbWFzayAmICgoc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIHQpXSkgKyAoc1tqXSA9IHQpKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWUuaSA9IGk7IG1lLmogPSBqO1xyXG4gICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICAgICAgLy8gRm9yIHJvYnVzdCB1bnByZWRpY3RhYmlsaXR5LCB0aGUgZnVuY3Rpb24gY2FsbCBiZWxvdyBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgICAgIC8vIGRpc2NhcmRzIGFuIGluaXRpYWwgYmF0Y2ggb2YgdmFsdWVzLiAgVGhpcyBpcyBjYWxsZWQgUkM0LWRyb3BbMjU2XS5cclxuICAgICAgICAgICAgLy8gU2VlIGh0dHA6Ly9nb29nbGUuY29tL3NlYXJjaD9xPXJzYStmbHVocmVyK3Jlc3BvbnNlJmJ0bklcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuLy9cclxuLy8gY29weSgpXHJcbi8vIENvcGllcyBpbnRlcm5hbCBzdGF0ZSBvZiBBUkM0IHRvIG9yIGZyb20gYSBwbGFpbiBvYmplY3QuXHJcbi8vXHJcbiAgICBmdW5jdGlvbiBjb3B5KGYsIHQpIHtcclxuICAgICAgICB0LmkgPSBmLmk7XHJcbiAgICAgICAgdC5qID0gZi5qO1xyXG4gICAgICAgIHQuUyA9IGYuUy5zbGljZSgpO1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG5cclxuLy9cclxuLy8gZmxhdHRlbigpXHJcbi8vIENvbnZlcnRzIGFuIG9iamVjdCB0cmVlIHRvIG5lc3RlZCBhcnJheXMgb2Ygc3RyaW5ncy5cclxuLy9cclxuICAgIGZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgdHlwID0gKHR5cGVvZiBvYmopLCBwcm9wO1xyXG4gICAgICAgIGlmIChkZXB0aCAmJiB0eXAgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZm9yIChwcm9wIGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHsgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpOyB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAocmVzdWx0Lmxlbmd0aCA/IHJlc3VsdCA6IHR5cCA9PSAnc3RyaW5nJyA/IG9iaiA6IG9iaiArICdcXDAnKTtcclxuICAgIH1cclxuXHJcbi8vXHJcbi8vIG1peGtleSgpXHJcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcclxuLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXHJcbi8vXHJcbiAgICBmdW5jdGlvbiBtaXhrZXkoc2VlZCwga2V5KSB7XHJcbiAgICAgICAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsIHNtZWFyLCBqID0gMDtcclxuICAgICAgICB3aGlsZSAoaiA8IHN0cmluZ3NlZWQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGtleVttYXNrICYgal0gPVxyXG4gICAgICAgICAgICAgICAgbWFzayAmICgoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvc3RyaW5nKGtleSk7XHJcbiAgICB9XHJcblxyXG4vL1xyXG4vLyBhdXRvc2VlZCgpXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cclxuLy8gbW9kdWxlIGlmIGF2YWlsYWJsZS5cclxuLy9cclxuICAgIGZ1bmN0aW9uIGF1dG9zZWVkKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlY3J5cHRvKSB7IHJldHVybiB0b3N0cmluZyhub2RlY3J5cHRvLnJhbmRvbUJ5dGVzKHdpZHRoKSk7IH1cclxuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcclxuICAgICAgICAgICAgKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMob3V0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRvc3RyaW5nKG91dCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB2YXIgYnJvd3NlciA9IGdsb2JhbC5uYXZpZ2F0b3IsXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5zID0gYnJvd3NlciAmJiBicm93c2VyLnBsdWdpbnM7XHJcbiAgICAgICAgICAgIHJldHVybiBbK25ldyBEYXRlKCksIGdsb2JhbCwgcGx1Z2lucywgZ2xvYmFsLnNjcmVlbiwgdG9zdHJpbmcocG9vbCldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbi8vXHJcbi8vIHRvc3RyaW5nKClcclxuLy8gQ29udmVydHMgYW4gYXJyYXkgb2YgY2hhcmNvZGVzIHRvIGEgc3RyaW5nXHJcbi8vXHJcbiAgICBmdW5jdGlvbiB0b3N0cmluZyhhKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCwgYSk7XHJcbiAgICB9XHJcblxyXG4vL1xyXG4vLyBXaGVuIHNlZWRyYW5kb20uanMgaXMgbG9hZGVkLCB3ZSBpbW1lZGlhdGVseSBtaXggYSBmZXcgYml0c1xyXG4vLyBmcm9tIHRoZSBidWlsdC1pbiBSTkcgaW50byB0aGUgZW50cm9weSBwb29sLiAgQmVjYXVzZSB3ZSBkb1xyXG4vLyBub3Qgd2FudCB0byBpbnRlcmZlcmUgd2l0aCBkZXRlcm1pbmlzdGljIFBSTkcgc3RhdGUgbGF0ZXIsXHJcbi8vIHNlZWRyYW5kb20gd2lsbCBub3QgY2FsbCBtYXRoLnJhbmRvbSBvbiBpdHMgb3duIGFnYWluIGFmdGVyXHJcbi8vIGluaXRpYWxpemF0aW9uLlxyXG4vL1xyXG4gICAgbWl4a2V5KG1hdGgucmFuZG9tKCksIHBvb2wpO1xyXG5cclxuLy9cclxuLy8gTm9kZWpzIGFuZCBBTUQgc3VwcG9ydDogZXhwb3J0IHRoZSBpbXBsZW1lbnRhdGlvbiBhcyBhIG1vZHVsZSB1c2luZ1xyXG4vLyBlaXRoZXIgY29udmVudGlvbi5cclxuLy9cclxuXHJcbi8vIEVuZCBhbm9ueW1vdXMgc2NvcGUsIGFuZCBwYXNzIGluaXRpYWwgdmFsdWVzLlxyXG59KShcclxuICAgIFtdLCAgICAgLy8gcG9vbDogZW50cm9weSBwb29sIHN0YXJ0cyBlbXB0eVxyXG4gICAgQk1NYXRoICAgIC8vIG1hdGg6IHBhY2thZ2UgY29udGFpbmluZyByYW5kb20sIHBvdywgYW5kIHNlZWRyYW5kb21cclxuKTtcclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxudmFyIEJlemllckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gIC8qKlxyXG4gICAgICogQmV6aWVyRWFzaW5nIC0gdXNlIGJlemllciBjdXJ2ZSBmb3IgdHJhbnNpdGlvbiBlYXNpbmcgZnVuY3Rpb25cclxuICAgICAqIGJ5IEdhw6t0YW4gUmVuYXVkZWF1IDIwMTQgLSAyMDE1IOKAkyBNSVQgTGljZW5zZVxyXG4gICAgICpcclxuICAgICAqIENyZWRpdHM6IGlzIGJhc2VkIG9uIEZpcmVmb3gncyBuc1NNSUxLZXlTcGxpbmUuY3BwXHJcbiAgICAgKiBVc2FnZTpcclxuICAgICAqIHZhciBzcGxpbmUgPSBCZXppZXJFYXNpbmcoWyAwLjI1LCAwLjEsIDAuMjUsIDEuMCBdKVxyXG4gICAgICogc3BsaW5lLmdldCh4KSA9PiByZXR1cm5zIHRoZSBlYXNpbmcgdmFsdWUgfCB4IG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlXHJcbiAgICAgKlxyXG4gICAgICovXHJcblxyXG4gIHZhciBvYiA9IHt9O1xyXG4gIG9iLmdldEJlemllckVhc2luZyA9IGdldEJlemllckVhc2luZztcclxuICB2YXIgYmV6aWVycyA9IHt9O1xyXG5cclxuICBmdW5jdGlvbiBnZXRCZXppZXJFYXNpbmcoYSwgYiwgYywgZCwgbm0pIHtcclxuICAgIHZhciBzdHIgPSBubSB8fCAoJ2Jlel8nICsgYSArICdfJyArIGIgKyAnXycgKyBjICsgJ18nICsgZCkucmVwbGFjZSgvXFwuL2csICdwJyk7XHJcbiAgICBpZiAoYmV6aWVyc1tzdHJdKSB7XHJcbiAgICAgIHJldHVybiBiZXppZXJzW3N0cl07XHJcbiAgICB9XHJcbiAgICB2YXIgYmV6RWFzaW5nID0gbmV3IEJlemllckVhc2luZyhbYSwgYiwgYywgZF0pO1xyXG4gICAgYmV6aWVyc1tzdHJdID0gYmV6RWFzaW5nO1xyXG4gICAgcmV0dXJuIGJlekVhc2luZztcclxuICB9XHJcblxyXG4gIC8vIFRoZXNlIHZhbHVlcyBhcmUgZXN0YWJsaXNoZWQgYnkgZW1waXJpY2lzbSB3aXRoIHRlc3RzICh0cmFkZW9mZjogcGVyZm9ybWFuY2UgVlMgcHJlY2lzaW9uKVxyXG4gIHZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XHJcbiAgdmFyIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMTtcclxuICB2YXIgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxO1xyXG4gIHZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xyXG5cclxuICB2YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xyXG4gIHZhciBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XHJcblxyXG4gIHZhciBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nO1xyXG5cclxuICBmdW5jdGlvbiBBKGFBMSwgYUEyKSB7IHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7IH1cclxuICBmdW5jdGlvbiBCKGFBMSwgYUEyKSB7IHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTE7IH1cclxuICBmdW5jdGlvbiBDKGFBMSkgeyByZXR1cm4gMy4wICogYUExOyB9XHJcblxyXG4gIC8vIFJldHVybnMgeCh0KSBnaXZlbiB0LCB4MSwgYW5kIHgyLCBvciB5KHQpIGdpdmVuIHQsIHkxLCBhbmQgeTIuXHJcbiAgZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHtcclxuICAgIHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVDtcclxuICB9XHJcblxyXG4gIC8vIFJldHVybnMgZHgvZHQgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgZHkvZHQgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cclxuICBmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcclxuICAgIHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XHJcbiAgICB2YXIgY3VycmVudFgsXHJcbiAgICAgIGN1cnJlbnRULFxyXG4gICAgICBpID0gMDtcclxuICAgIGRvIHtcclxuICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcclxuICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcclxuICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XHJcbiAgICAgICAgYUIgPSBjdXJyZW50VDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhQSA9IGN1cnJlbnRUO1xyXG4gICAgICB9XHJcbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRUO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGFHdWVzc1QsIG1YMSwgbVgyKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK2kpIHtcclxuICAgICAgdmFyIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcclxuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSByZXR1cm4gYUd1ZXNzVDtcclxuICAgICAgdmFyIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcclxuICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcclxuICAgIH1cclxuICAgIHJldHVybiBhR3Vlc3NUO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiBwb2ludHMgaXMgYW4gYXJyYXkgb2YgWyBtWDEsIG1ZMSwgbVgyLCBtWTIgXVxyXG4gICAgICovXHJcbiAgZnVuY3Rpb24gQmV6aWVyRWFzaW5nKHBvaW50cykge1xyXG4gICAgdGhpcy5fcCA9IHBvaW50cztcclxuICAgIHRoaXMuX21TYW1wbGVWYWx1ZXMgPSBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPyBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpIDogbmV3IEFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xyXG4gICAgdGhpcy5fcHJlY29tcHV0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmdldCA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICBCZXppZXJFYXNpbmcucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgdmFyIG1YMSA9IHRoaXMuX3BbMF0sXHJcbiAgICAgICAgbVkxID0gdGhpcy5fcFsxXSxcclxuICAgICAgICBtWDIgPSB0aGlzLl9wWzJdLFxyXG4gICAgICAgIG1ZMiA9IHRoaXMuX3BbM107XHJcbiAgICAgIGlmICghdGhpcy5fcHJlY29tcHV0ZWQpIHRoaXMuX3ByZWNvbXB1dGUoKTtcclxuICAgICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSByZXR1cm4geDsgLy8gbGluZWFyXHJcbiAgICAgIC8vIEJlY2F1c2UgSmF2YVNjcmlwdCBudW1iZXIgYXJlIGltcHJlY2lzZSwgd2Ugc2hvdWxkIGd1YXJhbnRlZSB0aGUgZXh0cmVtZXMgYXJlIHJpZ2h0LlxyXG4gICAgICBpZiAoeCA9PT0gMCkgcmV0dXJuIDA7XHJcbiAgICAgIGlmICh4ID09PSAxKSByZXR1cm4gMTtcclxuICAgICAgcmV0dXJuIGNhbGNCZXppZXIodGhpcy5fZ2V0VEZvclgoeCksIG1ZMSwgbVkyKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUHJpdmF0ZSBwYXJ0XHJcblxyXG4gICAgX3ByZWNvbXB1dGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG1YMSA9IHRoaXMuX3BbMF0sXHJcbiAgICAgICAgbVkxID0gdGhpcy5fcFsxXSxcclxuICAgICAgICBtWDIgPSB0aGlzLl9wWzJdLFxyXG4gICAgICAgIG1ZMiA9IHRoaXMuX3BbM107XHJcbiAgICAgIHRoaXMuX3ByZWNvbXB1dGVkID0gdHJ1ZTtcclxuICAgICAgaWYgKG1YMSAhPT0gbVkxIHx8IG1YMiAhPT0gbVkyKSB7IHRoaXMuX2NhbGNTYW1wbGVWYWx1ZXMoKTsgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfY2FsY1NhbXBsZVZhbHVlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbVgxID0gdGhpcy5fcFswXSxcclxuICAgICAgICBtWDIgPSB0aGlzLl9wWzJdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xyXG4gICAgICAgIHRoaXMuX21TYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAgICAgKiBnZXRURm9yWCBjaG9zZSB0aGUgZmFzdGVzdCBoZXVyaXN0aWMgdG8gZGV0ZXJtaW5lIHRoZSBwZXJjZW50YWdlIHZhbHVlIHByZWNpc2VseSBmcm9tIGEgZ2l2ZW4gWCBwcm9qZWN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgX2dldFRGb3JYOiBmdW5jdGlvbiAoYVgpIHtcclxuICAgICAgdmFyIG1YMSA9IHRoaXMuX3BbMF0sXHJcbiAgICAgICAgbVgyID0gdGhpcy5fcFsyXSxcclxuICAgICAgICBtU2FtcGxlVmFsdWVzID0gdGhpcy5fbVNhbXBsZVZhbHVlcztcclxuXHJcbiAgICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMC4wO1xyXG4gICAgICB2YXIgY3VycmVudFNhbXBsZSA9IDE7XHJcbiAgICAgIHZhciBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XHJcblxyXG4gICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcclxuICAgICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcclxuICAgICAgfVxyXG4gICAgICAtLWN1cnJlbnRTYW1wbGU7XHJcblxyXG4gICAgICAvLyBJbnRlcnBvbGF0ZSB0byBwcm92aWRlIGFuIGluaXRpYWwgZ3Vlc3MgZm9yIHRcclxuICAgICAgdmFyIGRpc3QgPSAoYVggLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xyXG4gICAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XHJcblxyXG4gICAgICB2YXIgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XHJcbiAgICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xyXG4gICAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JULCBtWDEsIG1YMik7XHJcbiAgICAgIH0gaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XHJcbiAgICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIHJldHVybiBvYjtcclxufSgpKTtcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGxhc3RUaW1lID0gMDtcclxuICB2YXIgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGx1c3BsdXNcclxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcclxuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XHJcbiAgfVxyXG4gIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xyXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XHJcbiAgICAgIHZhciBpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVUb0NhbGwpO1xyXG4gICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcclxuICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfTtcclxuICB9XHJcbiAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcclxuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgfTtcclxuICB9XHJcbn0oKSk7XHJcblxyXG4vKiBleHBvcnRlZCBleHRlbmRQcm90b3R5cGUsIGdldERlc2NyaXB0b3IsIGNyZWF0ZVByb3h5RnVuY3Rpb24gKi9cclxuXHJcbmZ1bmN0aW9uIGV4dGVuZFByb3RvdHlwZShzb3VyY2VzLCBkZXN0aW5hdGlvbikge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBzb3VyY2VzLmxlbmd0aDtcclxuICB2YXIgc291cmNlUHJvdG90eXBlO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgc291cmNlUHJvdG90eXBlID0gc291cmNlc1tpXS5wcm90b3R5cGU7XHJcbiAgICBmb3IgKHZhciBhdHRyIGluIHNvdXJjZVByb3RvdHlwZSkge1xyXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZVByb3RvdHlwZSwgYXR0cikpIGRlc3RpbmF0aW9uLnByb3RvdHlwZVthdHRyXSA9IHNvdXJjZVByb3RvdHlwZVthdHRyXTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERlc2NyaXB0b3Iob2JqZWN0LCBwcm9wKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUHJveHlGdW5jdGlvbihwcm90b3R5cGUpIHtcclxuICBmdW5jdGlvbiBQcm94eUZ1bmN0aW9uKCkge31cclxuICBQcm94eUZ1bmN0aW9uLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcclxuICByZXR1cm4gUHJveHlGdW5jdGlvbjtcclxufVxyXG5cclxuLyogZ2xvYmFsIHNlZ21lbnRzTGVuZ3RoUG9vbCwgZGVmYXVsdEN1cnZlU2VnbWVudHMsIGNyZWF0ZVNpemVkQXJyYXksIGJtUG93LCBibVNxcnQsIGJtRmxvb3IsIGNyZWF0ZVR5cGVkQXJyYXksIGJlemllckxlbmd0aFBvb2wgKi9cclxuLyogZXhwb3J0ZWQgYmV6ICovXHJcblxyXG5mdW5jdGlvbiBiZXpGdW5jdGlvbigpIHtcclxuICB2YXIgbWF0aCA9IE1hdGg7XHJcblxyXG4gIGZ1bmN0aW9uIHBvaW50T25MaW5lMkQoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xyXG4gICAgdmFyIGRldDEgPSAoeDEgKiB5MikgKyAoeTEgKiB4MykgKyAoeDIgKiB5MykgLSAoeDMgKiB5MikgLSAoeTMgKiB4MSkgLSAoeDIgKiB5MSk7XHJcbiAgICByZXR1cm4gZGV0MSA+IC0wLjAwMSAmJiBkZXQxIDwgMC4wMDE7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwb2ludE9uTGluZTNEKHgxLCB5MSwgejEsIHgyLCB5MiwgejIsIHgzLCB5MywgejMpIHtcclxuICAgIGlmICh6MSA9PT0gMCAmJiB6MiA9PT0gMCAmJiB6MyA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gcG9pbnRPbkxpbmUyRCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcclxuICAgIH1cclxuICAgIHZhciBkaXN0MSA9IG1hdGguc3FydChtYXRoLnBvdyh4MiAtIHgxLCAyKSArIG1hdGgucG93KHkyIC0geTEsIDIpICsgbWF0aC5wb3coejIgLSB6MSwgMikpO1xyXG4gICAgdmFyIGRpc3QyID0gbWF0aC5zcXJ0KG1hdGgucG93KHgzIC0geDEsIDIpICsgbWF0aC5wb3coeTMgLSB5MSwgMikgKyBtYXRoLnBvdyh6MyAtIHoxLCAyKSk7XHJcbiAgICB2YXIgZGlzdDMgPSBtYXRoLnNxcnQobWF0aC5wb3coeDMgLSB4MiwgMikgKyBtYXRoLnBvdyh5MyAtIHkyLCAyKSArIG1hdGgucG93KHozIC0gejIsIDIpKTtcclxuICAgIHZhciBkaWZmRGlzdDtcclxuICAgIGlmIChkaXN0MSA+IGRpc3QyKSB7XHJcbiAgICAgIGlmIChkaXN0MSA+IGRpc3QzKSB7XHJcbiAgICAgICAgZGlmZkRpc3QgPSBkaXN0MSAtIGRpc3QyIC0gZGlzdDM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGlmZkRpc3QgPSBkaXN0MyAtIGRpc3QyIC0gZGlzdDE7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZGlzdDMgPiBkaXN0Mikge1xyXG4gICAgICBkaWZmRGlzdCA9IGRpc3QzIC0gZGlzdDIgLSBkaXN0MTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRpZmZEaXN0ID0gZGlzdDIgLSBkaXN0MSAtIGRpc3QzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpZmZEaXN0ID4gLTAuMDAwMSAmJiBkaWZmRGlzdCA8IDAuMDAwMTtcclxuICB9XHJcblxyXG4gIHZhciBnZXRCZXppZXJMZW5ndGggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwdDEsIHB0MiwgcHQzLCBwdDQpIHtcclxuICAgICAgdmFyIGN1cnZlU2VnbWVudHMgPSBkZWZhdWx0Q3VydmVTZWdtZW50cztcclxuICAgICAgdmFyIGs7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuO1xyXG4gICAgICB2YXIgcHRDb29yZDtcclxuICAgICAgdmFyIHBlcmM7XHJcbiAgICAgIHZhciBhZGRlZExlbmd0aCA9IDA7XHJcbiAgICAgIHZhciBwdERpc3RhbmNlO1xyXG4gICAgICB2YXIgcG9pbnQgPSBbXTtcclxuICAgICAgdmFyIGxhc3RQb2ludCA9IFtdO1xyXG4gICAgICB2YXIgbGVuZ3RoRGF0YSA9IGJlemllckxlbmd0aFBvb2wubmV3RWxlbWVudCgpO1xyXG4gICAgICBsZW4gPSBwdDMubGVuZ3RoO1xyXG4gICAgICBmb3IgKGsgPSAwOyBrIDwgY3VydmVTZWdtZW50czsgayArPSAxKSB7XHJcbiAgICAgICAgcGVyYyA9IGsgLyAoY3VydmVTZWdtZW50cyAtIDEpO1xyXG4gICAgICAgIHB0RGlzdGFuY2UgPSAwO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgcHRDb29yZCA9IGJtUG93KDEgLSBwZXJjLCAzKSAqIHB0MVtpXSArIDMgKiBibVBvdygxIC0gcGVyYywgMikgKiBwZXJjICogcHQzW2ldICsgMyAqICgxIC0gcGVyYykgKiBibVBvdyhwZXJjLCAyKSAqIHB0NFtpXSArIGJtUG93KHBlcmMsIDMpICogcHQyW2ldO1xyXG4gICAgICAgICAgcG9pbnRbaV0gPSBwdENvb3JkO1xyXG4gICAgICAgICAgaWYgKGxhc3RQb2ludFtpXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwdERpc3RhbmNlICs9IGJtUG93KHBvaW50W2ldIC0gbGFzdFBvaW50W2ldLCAyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxhc3RQb2ludFtpXSA9IHBvaW50W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHREaXN0YW5jZSkge1xyXG4gICAgICAgICAgcHREaXN0YW5jZSA9IGJtU3FydChwdERpc3RhbmNlKTtcclxuICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IHB0RGlzdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxlbmd0aERhdGEucGVyY2VudHNba10gPSBwZXJjO1xyXG4gICAgICAgIGxlbmd0aERhdGEubGVuZ3Roc1trXSA9IGFkZGVkTGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIGxlbmd0aERhdGEuYWRkZWRMZW5ndGggPSBhZGRlZExlbmd0aDtcclxuICAgICAgcmV0dXJuIGxlbmd0aERhdGE7XHJcbiAgICB9O1xyXG4gIH0oKSk7XHJcblxyXG4gIGZ1bmN0aW9uIGdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlRGF0YSkge1xyXG4gICAgdmFyIHNlZ21lbnRzTGVuZ3RoID0gc2VnbWVudHNMZW5ndGhQb29sLm5ld0VsZW1lbnQoKTtcclxuICAgIHZhciBjbG9zZWQgPSBzaGFwZURhdGEuYztcclxuICAgIHZhciBwYXRoViA9IHNoYXBlRGF0YS52O1xyXG4gICAgdmFyIHBhdGhPID0gc2hhcGVEYXRhLm87XHJcbiAgICB2YXIgcGF0aEkgPSBzaGFwZURhdGEuaTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHNoYXBlRGF0YS5fbGVuZ3RoO1xyXG4gICAgdmFyIGxlbmd0aHMgPSBzZWdtZW50c0xlbmd0aC5sZW5ndGhzO1xyXG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gMDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpICs9IDEpIHtcclxuICAgICAgbGVuZ3Roc1tpXSA9IGdldEJlemllckxlbmd0aChwYXRoVltpXSwgcGF0aFZbaSArIDFdLCBwYXRoT1tpXSwgcGF0aElbaSArIDFdKTtcclxuICAgICAgdG90YWxMZW5ndGggKz0gbGVuZ3Roc1tpXS5hZGRlZExlbmd0aDtcclxuICAgIH1cclxuICAgIGlmIChjbG9zZWQgJiYgbGVuKSB7XHJcbiAgICAgIGxlbmd0aHNbaV0gPSBnZXRCZXppZXJMZW5ndGgocGF0aFZbaV0sIHBhdGhWWzBdLCBwYXRoT1tpXSwgcGF0aElbMF0pO1xyXG4gICAgICB0b3RhbExlbmd0aCArPSBsZW5ndGhzW2ldLmFkZGVkTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgc2VnbWVudHNMZW5ndGgudG90YWxMZW5ndGggPSB0b3RhbExlbmd0aDtcclxuICAgIHJldHVybiBzZWdtZW50c0xlbmd0aDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIEJlemllckRhdGEobGVuZ3RoKSB7XHJcbiAgICB0aGlzLnNlZ21lbnRMZW5ndGggPSAwO1xyXG4gICAgdGhpcy5wb2ludHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIFBvaW50RGF0YShwYXJ0aWFsLCBwb2ludCkge1xyXG4gICAgdGhpcy5wYXJ0aWFsTGVuZ3RoID0gcGFydGlhbDtcclxuICAgIHRoaXMucG9pbnQgPSBwb2ludDtcclxuICB9XHJcblxyXG4gIHZhciBidWlsZEJlemllckRhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHN0b3JlZERhdGEgPSB7fTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHB0MSwgcHQyLCBwdDMsIHB0NCkge1xyXG4gICAgICB2YXIgYmV6aWVyTmFtZSA9IChwdDFbMF0gKyAnXycgKyBwdDFbMV0gKyAnXycgKyBwdDJbMF0gKyAnXycgKyBwdDJbMV0gKyAnXycgKyBwdDNbMF0gKyAnXycgKyBwdDNbMV0gKyAnXycgKyBwdDRbMF0gKyAnXycgKyBwdDRbMV0pLnJlcGxhY2UoL1xcLi9nLCAncCcpO1xyXG4gICAgICBpZiAoIXN0b3JlZERhdGFbYmV6aWVyTmFtZV0pIHtcclxuICAgICAgICB2YXIgY3VydmVTZWdtZW50cyA9IGRlZmF1bHRDdXJ2ZVNlZ21lbnRzO1xyXG4gICAgICAgIHZhciBrO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBsZW47XHJcbiAgICAgICAgdmFyIHB0Q29vcmQ7XHJcbiAgICAgICAgdmFyIHBlcmM7XHJcbiAgICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcclxuICAgICAgICB2YXIgcHREaXN0YW5jZTtcclxuICAgICAgICB2YXIgcG9pbnQ7XHJcbiAgICAgICAgdmFyIGxhc3RQb2ludCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHB0MS5sZW5ndGggPT09IDIgJiYgKHB0MVswXSAhPT0gcHQyWzBdIHx8IHB0MVsxXSAhPT0gcHQyWzFdKSAmJiBwb2ludE9uTGluZTJEKHB0MVswXSwgcHQxWzFdLCBwdDJbMF0sIHB0MlsxXSwgcHQxWzBdICsgcHQzWzBdLCBwdDFbMV0gKyBwdDNbMV0pICYmIHBvaW50T25MaW5lMkQocHQxWzBdLCBwdDFbMV0sIHB0MlswXSwgcHQyWzFdLCBwdDJbMF0gKyBwdDRbMF0sIHB0MlsxXSArIHB0NFsxXSkpIHtcclxuICAgICAgICAgIGN1cnZlU2VnbWVudHMgPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmV6aWVyRGF0YSA9IG5ldyBCZXppZXJEYXRhKGN1cnZlU2VnbWVudHMpO1xyXG4gICAgICAgIGxlbiA9IHB0My5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGN1cnZlU2VnbWVudHM7IGsgKz0gMSkge1xyXG4gICAgICAgICAgcG9pbnQgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XHJcbiAgICAgICAgICBwZXJjID0gayAvIChjdXJ2ZVNlZ21lbnRzIC0gMSk7XHJcbiAgICAgICAgICBwdERpc3RhbmNlID0gMDtcclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBwdENvb3JkID0gYm1Qb3coMSAtIHBlcmMsIDMpICogcHQxW2ldICsgMyAqIGJtUG93KDEgLSBwZXJjLCAyKSAqIHBlcmMgKiAocHQxW2ldICsgcHQzW2ldKSArIDMgKiAoMSAtIHBlcmMpICogYm1Qb3cocGVyYywgMikgKiAocHQyW2ldICsgcHQ0W2ldKSArIGJtUG93KHBlcmMsIDMpICogcHQyW2ldO1xyXG4gICAgICAgICAgICBwb2ludFtpXSA9IHB0Q29vcmQ7XHJcbiAgICAgICAgICAgIGlmIChsYXN0UG9pbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICBwdERpc3RhbmNlICs9IGJtUG93KHBvaW50W2ldIC0gbGFzdFBvaW50W2ldLCAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcHREaXN0YW5jZSA9IGJtU3FydChwdERpc3RhbmNlKTtcclxuICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IHB0RGlzdGFuY2U7XHJcbiAgICAgICAgICBiZXppZXJEYXRhLnBvaW50c1trXSA9IG5ldyBQb2ludERhdGEocHREaXN0YW5jZSwgcG9pbnQpO1xyXG4gICAgICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJlemllckRhdGEuc2VnbWVudExlbmd0aCA9IGFkZGVkTGVuZ3RoO1xyXG4gICAgICAgIHN0b3JlZERhdGFbYmV6aWVyTmFtZV0gPSBiZXppZXJEYXRhO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzdG9yZWREYXRhW2Jlemllck5hbWVdO1xyXG4gICAgfTtcclxuICB9KCkpO1xyXG5cclxuICBmdW5jdGlvbiBnZXREaXN0YW5jZVBlcmMocGVyYywgYmV6aWVyRGF0YSkge1xyXG4gICAgdmFyIHBlcmNlbnRzID0gYmV6aWVyRGF0YS5wZXJjZW50cztcclxuICAgIHZhciBsZW5ndGhzID0gYmV6aWVyRGF0YS5sZW5ndGhzO1xyXG4gICAgdmFyIGxlbiA9IHBlcmNlbnRzLmxlbmd0aDtcclxuICAgIHZhciBpbml0UG9zID0gYm1GbG9vcigobGVuIC0gMSkgKiBwZXJjKTtcclxuICAgIHZhciBsZW5ndGhQb3MgPSBwZXJjICogYmV6aWVyRGF0YS5hZGRlZExlbmd0aDtcclxuICAgIHZhciBsUGVyYyA9IDA7XHJcbiAgICBpZiAoaW5pdFBvcyA9PT0gbGVuIC0gMSB8fCBpbml0UG9zID09PSAwIHx8IGxlbmd0aFBvcyA9PT0gbGVuZ3Roc1tpbml0UG9zXSkge1xyXG4gICAgICByZXR1cm4gcGVyY2VudHNbaW5pdFBvc107XHJcbiAgICB9XHJcbiAgICB2YXIgZGlyID0gbGVuZ3Roc1tpbml0UG9zXSA+IGxlbmd0aFBvcyA/IC0xIDogMTtcclxuICAgIHZhciBmbGFnID0gdHJ1ZTtcclxuICAgIHdoaWxlIChmbGFnKSB7XHJcbiAgICAgIGlmIChsZW5ndGhzW2luaXRQb3NdIDw9IGxlbmd0aFBvcyAmJiBsZW5ndGhzW2luaXRQb3MgKyAxXSA+IGxlbmd0aFBvcykge1xyXG4gICAgICAgIGxQZXJjID0gKGxlbmd0aFBvcyAtIGxlbmd0aHNbaW5pdFBvc10pIC8gKGxlbmd0aHNbaW5pdFBvcyArIDFdIC0gbGVuZ3Roc1tpbml0UG9zXSk7XHJcbiAgICAgICAgZmxhZyA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluaXRQb3MgKz0gZGlyO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbml0UG9zIDwgMCB8fCBpbml0UG9zID49IGxlbiAtIDEpIHtcclxuICAgICAgICAvLyBGSVggZm9yIFR5cGVkQXJyYXlzIHRoYXQgZG9uJ3Qgc3RvcmUgZmxvYXRpbmcgcG9pbnQgdmFsdWVzIHdpdGggZW5vdWdoIGFjY3VyYWN5XHJcbiAgICAgICAgaWYgKGluaXRQb3MgPT09IGxlbiAtIDEpIHtcclxuICAgICAgICAgIHJldHVybiBwZXJjZW50c1tpbml0UG9zXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmxhZyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGVyY2VudHNbaW5pdFBvc10gKyAocGVyY2VudHNbaW5pdFBvcyArIDFdIC0gcGVyY2VudHNbaW5pdFBvc10pICogbFBlcmM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRQb2ludEluU2VnbWVudChwdDEsIHB0MiwgcHQzLCBwdDQsIHBlcmNlbnQsIGJlemllckRhdGEpIHtcclxuICAgIHZhciB0MSA9IGdldERpc3RhbmNlUGVyYyhwZXJjZW50LCBiZXppZXJEYXRhKTtcclxuICAgIHZhciB1MSA9IDEgLSB0MTtcclxuICAgIHZhciBwdFggPSBtYXRoLnJvdW5kKCh1MSAqIHUxICogdTEgKiBwdDFbMF0gKyAodDEgKiB1MSAqIHUxICsgdTEgKiB0MSAqIHUxICsgdTEgKiB1MSAqIHQxKSAqIHB0M1swXSArICh0MSAqIHQxICogdTEgKyB1MSAqIHQxICogdDEgKyB0MSAqIHUxICogdDEpICogcHQ0WzBdICsgdDEgKiB0MSAqIHQxICogcHQyWzBdKSAqIDEwMDApIC8gMTAwMDtcclxuICAgIHZhciBwdFkgPSBtYXRoLnJvdW5kKCh1MSAqIHUxICogdTEgKiBwdDFbMV0gKyAodDEgKiB1MSAqIHUxICsgdTEgKiB0MSAqIHUxICsgdTEgKiB1MSAqIHQxKSAqIHB0M1sxXSArICh0MSAqIHQxICogdTEgKyB1MSAqIHQxICogdDEgKyB0MSAqIHUxICogdDEpICogcHQ0WzFdICsgdDEgKiB0MSAqIHQxICogcHQyWzFdKSAqIDEwMDApIC8gMTAwMDtcclxuICAgIHJldHVybiBbcHRYLCBwdFldO1xyXG4gIH1cclxuXHJcbiAgdmFyIGJlemllclNlZ21lbnRQb2ludHMgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgOCk7XHJcblxyXG4gIGZ1bmN0aW9uIGdldE5ld1NlZ21lbnQocHQxLCBwdDIsIHB0MywgcHQ0LCBzdGFydFBlcmMsIGVuZFBlcmMsIGJlemllckRhdGEpIHtcclxuICAgIGlmIChzdGFydFBlcmMgPCAwKSB7XHJcbiAgICAgIHN0YXJ0UGVyYyA9IDA7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXJ0UGVyYyA+IDEpIHtcclxuICAgICAgc3RhcnRQZXJjID0gMTtcclxuICAgIH1cclxuICAgIHZhciB0MCA9IGdldERpc3RhbmNlUGVyYyhzdGFydFBlcmMsIGJlemllckRhdGEpO1xyXG4gICAgZW5kUGVyYyA9IGVuZFBlcmMgPiAxID8gMSA6IGVuZFBlcmM7XHJcbiAgICB2YXIgdDEgPSBnZXREaXN0YW5jZVBlcmMoZW5kUGVyYywgYmV6aWVyRGF0YSk7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBwdDEubGVuZ3RoO1xyXG4gICAgdmFyIHUwID0gMSAtIHQwO1xyXG4gICAgdmFyIHUxID0gMSAtIHQxO1xyXG4gICAgdmFyIHUwdTB1MCA9IHUwICogdTAgKiB1MDtcclxuICAgIHZhciB0MHUwdTBfMyA9IHQwICogdTAgKiB1MCAqIDM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXHJcbiAgICB2YXIgdDB0MHUwXzMgPSB0MCAqIHQwICogdTAgKiAzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG4gICAgdmFyIHQwdDB0MCA9IHQwICogdDAgKiB0MDtcclxuICAgIC8vXHJcbiAgICB2YXIgdTB1MHUxID0gdTAgKiB1MCAqIHUxO1xyXG4gICAgdmFyIHQwdTB1MV8zID0gdDAgKiB1MCAqIHUxICsgdTAgKiB0MCAqIHUxICsgdTAgKiB1MCAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG4gICAgdmFyIHQwdDB1MV8zID0gdDAgKiB0MCAqIHUxICsgdTAgKiB0MCAqIHQxICsgdDAgKiB1MCAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG4gICAgdmFyIHQwdDB0MSA9IHQwICogdDAgKiB0MTtcclxuICAgIC8vXHJcbiAgICB2YXIgdTB1MXUxID0gdTAgKiB1MSAqIHUxO1xyXG4gICAgdmFyIHQwdTF1MV8zID0gdDAgKiB1MSAqIHUxICsgdTAgKiB0MSAqIHUxICsgdTAgKiB1MSAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG4gICAgdmFyIHQwdDF1MV8zID0gdDAgKiB0MSAqIHUxICsgdTAgKiB0MSAqIHQxICsgdDAgKiB1MSAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG4gICAgdmFyIHQwdDF0MSA9IHQwICogdDEgKiB0MTtcclxuICAgIC8vXHJcbiAgICB2YXIgdTF1MXUxID0gdTEgKiB1MSAqIHUxO1xyXG4gICAgdmFyIHQxdTF1MV8zID0gdDEgKiB1MSAqIHUxICsgdTEgKiB0MSAqIHUxICsgdTEgKiB1MSAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG4gICAgdmFyIHQxdDF1MV8zID0gdDEgKiB0MSAqIHUxICsgdTEgKiB0MSAqIHQxICsgdDEgKiB1MSAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG4gICAgdmFyIHQxdDF0MSA9IHQxICogdDEgKiB0MTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBiZXppZXJTZWdtZW50UG9pbnRzW2kgKiA0XSA9IG1hdGgucm91bmQoKHUwdTB1MCAqIHB0MVtpXSArIHQwdTB1MF8zICogcHQzW2ldICsgdDB0MHUwXzMgKiBwdDRbaV0gKyB0MHQwdDAgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG4gICAgICBiZXppZXJTZWdtZW50UG9pbnRzW2kgKiA0ICsgMV0gPSBtYXRoLnJvdW5kKCh1MHUwdTEgKiBwdDFbaV0gKyB0MHUwdTFfMyAqIHB0M1tpXSArIHQwdDB1MV8zICogcHQ0W2ldICsgdDB0MHQxICogcHQyW2ldKSAqIDEwMDApIC8gMTAwMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuICAgICAgYmV6aWVyU2VnbWVudFBvaW50c1tpICogNCArIDJdID0gbWF0aC5yb3VuZCgodTB1MXUxICogcHQxW2ldICsgdDB1MXUxXzMgKiBwdDNbaV0gKyB0MHQxdTFfMyAqIHB0NFtpXSArIHQwdDF0MSAqIHB0MltpXSkgKiAxMDAwKSAvIDEwMDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXHJcbiAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDQgKyAzXSA9IG1hdGgucm91bmQoKHUxdTF1MSAqIHB0MVtpXSArIHQxdTF1MV8zICogcHQzW2ldICsgdDF0MXUxXzMgKiBwdDRbaV0gKyB0MXQxdDEgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBiZXppZXJTZWdtZW50UG9pbnRzO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGdldFNlZ21lbnRzTGVuZ3RoOiBnZXRTZWdtZW50c0xlbmd0aCxcclxuICAgIGdldE5ld1NlZ21lbnQ6IGdldE5ld1NlZ21lbnQsXHJcbiAgICBnZXRQb2ludEluU2VnbWVudDogZ2V0UG9pbnRJblNlZ21lbnQsXHJcbiAgICBidWlsZEJlemllckRhdGE6IGJ1aWxkQmV6aWVyRGF0YSxcclxuICAgIHBvaW50T25MaW5lMkQ6IHBvaW50T25MaW5lMkQsXHJcbiAgICBwb2ludE9uTGluZTNEOiBwb2ludE9uTGluZTNELFxyXG4gIH07XHJcbn1cclxuXHJcbnZhciBiZXogPSBiZXpGdW5jdGlvbigpO1xyXG5cclxuLyogZXhwb3J0ZWQgZGF0YU1hbmFnZXIgKi9cclxuXHJcbmZ1bmN0aW9uIGRhdGFGdW5jdGlvbk1hbmFnZXIoKSB7XHJcbiAgLy8gdmFyIHRDYW52YXNIZWxwZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXBsZXRlTGF5ZXJzKGxheWVycywgY29tcHMsIGZvbnRNYW5hZ2VyKSB7XHJcbiAgICB2YXIgbGF5ZXJEYXRhO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcclxuICAgIHZhciBqO1xyXG4gICAgdmFyIGpMZW47XHJcbiAgICB2YXIgaztcclxuICAgIHZhciBrTGVuO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGxheWVyRGF0YSA9IGxheWVyc1tpXTtcclxuICAgICAgaWYgKCgna3MnIGluIGxheWVyRGF0YSkgJiYgIWxheWVyRGF0YS5jb21wbGV0ZWQpIHtcclxuICAgICAgICBsYXllckRhdGEuY29tcGxldGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAobGF5ZXJEYXRhLnR0KSB7XHJcbiAgICAgICAgICBsYXllcnNbaSAtIDFdLnRkID0gbGF5ZXJEYXRhLnR0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGF5ZXJEYXRhLmhhc01hc2spIHtcclxuICAgICAgICAgIHZhciBtYXNrUHJvcHMgPSBsYXllckRhdGEubWFza3NQcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgakxlbiA9IG1hc2tQcm9wcy5sZW5ndGg7XHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChtYXNrUHJvcHNbal0ucHQuay5pKSB7XHJcbiAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhtYXNrUHJvcHNbal0ucHQuayk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAga0xlbiA9IG1hc2tQcm9wc1tqXS5wdC5rLmxlbmd0aDtcclxuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0Lmtba10ucykge1xyXG4gICAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnNbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLmUpIHtcclxuICAgICAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhtYXNrUHJvcHNbal0ucHQua1trXS5lWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxheWVyRGF0YS50eSA9PT0gMCkge1xyXG4gICAgICAgICAgbGF5ZXJEYXRhLmxheWVycyA9IGZpbmRDb21wTGF5ZXJzKGxheWVyRGF0YS5yZWZJZCwgY29tcHMpO1xyXG4gICAgICAgICAgY29tcGxldGVMYXllcnMobGF5ZXJEYXRhLmxheWVycywgY29tcHMsIGZvbnRNYW5hZ2VyKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxheWVyRGF0YS50eSA9PT0gNCkge1xyXG4gICAgICAgICAgY29tcGxldGVTaGFwZXMobGF5ZXJEYXRhLnNoYXBlcyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXllckRhdGEudHkgPT09IDUpIHtcclxuICAgICAgICAgIGNvbXBsZXRlVGV4dChsYXllckRhdGEsIGZvbnRNYW5hZ2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZpbmRDb21wTGF5ZXJzKGlkLCBjb21wcykge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIGxlbiA9IGNvbXBzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgIGlmIChjb21wc1tpXS5pZCA9PT0gaWQpIHtcclxuICAgICAgICBpZiAoIWNvbXBzW2ldLmxheWVycy5fX3VzZWQpIHtcclxuICAgICAgICAgIGNvbXBzW2ldLmxheWVycy5fX3VzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgcmV0dXJuIGNvbXBzW2ldLmxheWVycztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29tcHNbaV0ubGF5ZXJzKSk7XHJcbiAgICAgIH1cclxuICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21wbGV0ZVNoYXBlcyhhcnIpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XHJcbiAgICB2YXIgajtcclxuICAgIHZhciBqTGVuO1xyXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgaWYgKGFycltpXS50eSA9PT0gJ3NoJykge1xyXG4gICAgICAgIGlmIChhcnJbaV0ua3Muay5pKSB7XHJcbiAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKGFycltpXS5rcy5rKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgakxlbiA9IGFycltpXS5rcy5rLmxlbmd0aDtcclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rW2pdLnMpIHtcclxuICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKGFycltpXS5rcy5rW2pdLnNbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhcnJbaV0ua3Mua1tqXS5lKSB7XHJcbiAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhhcnJbaV0ua3Mua1tqXS5lWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdncicpIHtcclxuICAgICAgICBjb21wbGV0ZVNoYXBlcyhhcnJbaV0uaXQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKHBhdGgpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHBhdGguaS5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgcGF0aC5pW2ldWzBdICs9IHBhdGgudltpXVswXTtcclxuICAgICAgcGF0aC5pW2ldWzFdICs9IHBhdGgudltpXVsxXTtcclxuICAgICAgcGF0aC5vW2ldWzBdICs9IHBhdGgudltpXVswXTtcclxuICAgICAgcGF0aC5vW2ldWzFdICs9IHBhdGgudltpXVsxXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNoZWNrVmVyc2lvbihtaW5pbXVtLCBhbmltVmVyc2lvblN0cmluZykge1xyXG4gICAgdmFyIGFuaW1WZXJzaW9uID0gYW5pbVZlcnNpb25TdHJpbmcgPyBhbmltVmVyc2lvblN0cmluZy5zcGxpdCgnLicpIDogWzEwMCwgMTAwLCAxMDBdO1xyXG4gICAgaWYgKG1pbmltdW1bMF0gPiBhbmltVmVyc2lvblswXSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gaWYgKGFuaW1WZXJzaW9uWzBdID4gbWluaW11bVswXSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAobWluaW11bVsxXSA+IGFuaW1WZXJzaW9uWzFdKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBpZiAoYW5pbVZlcnNpb25bMV0gPiBtaW5pbXVtWzFdKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChtaW5pbXVtWzJdID4gYW5pbVZlcnNpb25bMl0pIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGlmIChhbmltVmVyc2lvblsyXSA+IG1pbmltdW1bMl0pIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB2YXIgY2hlY2tUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtaW5pbXVtVmVyc2lvbiA9IFs0LCA0LCAxNF07XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlVGV4dExheWVyKHRleHRMYXllcikge1xyXG4gICAgICB2YXIgZG9jdW1lbnREYXRhID0gdGV4dExheWVyLnQuZDtcclxuICAgICAgdGV4dExheWVyLnQuZCA9IHtcclxuICAgICAgICBrOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHM6IGRvY3VtZW50RGF0YSxcclxuICAgICAgICAgICAgdDogMCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIGlmIChsYXllcnNbaV0udHkgPT09IDUpIHtcclxuICAgICAgICAgIHVwZGF0ZVRleHRMYXllcihsYXllcnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xyXG4gICAgICBpZiAoY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLCBhbmltYXRpb25EYXRhLnYpKSB7XHJcbiAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycyk7XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzKSB7XHJcbiAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xyXG4gICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KCkpO1xyXG5cclxuICB2YXIgY2hlY2tDaGFycyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgNywgOTldO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltYXRpb25EYXRhKSB7XHJcbiAgICAgIGlmIChhbmltYXRpb25EYXRhLmNoYXJzICYmICFjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgbGVuID0gYW5pbWF0aW9uRGF0YS5jaGFycy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgdmFyIGpMZW47XHJcbiAgICAgICAgdmFyIHBhdGhEYXRhO1xyXG4gICAgICAgIHZhciBwYXRocztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmNoYXJzW2ldLmRhdGEgJiYgYW5pbWF0aW9uRGF0YS5jaGFyc1tpXS5kYXRhLnNoYXBlcykge1xyXG4gICAgICAgICAgICBwYXRocyA9IGFuaW1hdGlvbkRhdGEuY2hhcnNbaV0uZGF0YS5zaGFwZXNbMF0uaXQ7XHJcbiAgICAgICAgICAgIGpMZW4gPSBwYXRocy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICAgICAgcGF0aERhdGEgPSBwYXRoc1tqXS5rcy5rO1xyXG4gICAgICAgICAgICAgIGlmICghcGF0aERhdGEuX19jb252ZXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMocGF0aHNbal0ua3Muayk7XHJcbiAgICAgICAgICAgICAgICBwYXRoRGF0YS5fX2NvbnZlcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0oKSk7XHJcblxyXG4gIHZhciBjaGVja0NvbG9ycyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgMSwgOV07XHJcblxyXG4gICAgZnVuY3Rpb24gaXRlcmF0ZVNoYXBlcyhzaGFwZXMpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsZW4gPSBzaGFwZXMubGVuZ3RoO1xyXG4gICAgICB2YXIgajtcclxuICAgICAgdmFyIGpMZW47XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIGlmIChzaGFwZXNbaV0udHkgPT09ICdncicpIHtcclxuICAgICAgICAgIGl0ZXJhdGVTaGFwZXMoc2hhcGVzW2ldLml0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2ZsJyB8fCBzaGFwZXNbaV0udHkgPT09ICdzdCcpIHtcclxuICAgICAgICAgIGlmIChzaGFwZXNbaV0uYy5rICYmIHNoYXBlc1tpXS5jLmtbMF0uaSkge1xyXG4gICAgICAgICAgICBqTGVuID0gc2hhcGVzW2ldLmMuay5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgICAgICBpZiAoc2hhcGVzW2ldLmMua1tqXS5zKSB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMF0gLz0gMjU1O1xyXG4gICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1tqXS5zWzFdIC89IDI1NTtcclxuICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uc1syXSAvPSAyNTU7XHJcbiAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbM10gLz0gMjU1O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoc2hhcGVzW2ldLmMua1tqXS5lKSB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLmVbMF0gLz0gMjU1O1xyXG4gICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1tqXS5lWzFdIC89IDI1NTtcclxuICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVsyXSAvPSAyNTU7XHJcbiAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLmVbM10gLz0gMjU1O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2hhcGVzW2ldLmMua1swXSAvPSAyNTU7XHJcbiAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbMV0gLz0gMjU1O1xyXG4gICAgICAgICAgICBzaGFwZXNbaV0uYy5rWzJdIC89IDI1NTtcclxuICAgICAgICAgICAgc2hhcGVzW2ldLmMua1szXSAvPSAyNTU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXRlcmF0ZUxheWVycyhsYXllcnMpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBpZiAobGF5ZXJzW2ldLnR5ID09PSA0KSB7XHJcbiAgICAgICAgICBpdGVyYXRlU2hhcGVzKGxheWVyc1tpXS5zaGFwZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xyXG4gICAgICBpZiAoY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLCBhbmltYXRpb25EYXRhLnYpKSB7XHJcbiAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycyk7XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzKSB7XHJcbiAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xyXG4gICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KCkpO1xyXG5cclxuICB2YXIgY2hlY2tTaGFwZXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG1pbmltdW1WZXJzaW9uID0gWzQsIDQsIDE4XTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb21wbGV0ZUNsb3NpbmdTaGFwZXMoYXJyKSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcclxuICAgICAgdmFyIGo7XHJcbiAgICAgIHZhciBqTGVuO1xyXG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgICAgIGlmIChhcnJbaV0udHkgPT09ICdzaCcpIHtcclxuICAgICAgICAgIGlmIChhcnJbaV0ua3Muay5pKSB7XHJcbiAgICAgICAgICAgIGFycltpXS5rcy5rLmMgPSBhcnJbaV0uY2xvc2VkO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgakxlbiA9IGFycltpXS5rcy5rLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Mua1tqXS5zKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJbaV0ua3Mua1tqXS5zWzBdLmMgPSBhcnJbaV0uY2xvc2VkO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoYXJyW2ldLmtzLmtbal0uZSkge1xyXG4gICAgICAgICAgICAgICAgYXJyW2ldLmtzLmtbal0uZVswXS5jID0gYXJyW2ldLmNsb3NlZDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ2dyJykge1xyXG4gICAgICAgICAgY29tcGxldGVDbG9zaW5nU2hhcGVzKGFycltpXS5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXRlcmF0ZUxheWVycyhsYXllcnMpIHtcclxuICAgICAgdmFyIGxheWVyRGF0YTtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xyXG4gICAgICB2YXIgajtcclxuICAgICAgdmFyIGpMZW47XHJcbiAgICAgIHZhciBrO1xyXG4gICAgICB2YXIga0xlbjtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgbGF5ZXJEYXRhID0gbGF5ZXJzW2ldO1xyXG4gICAgICAgIGlmIChsYXllckRhdGEuaGFzTWFzaykge1xyXG4gICAgICAgICAgdmFyIG1hc2tQcm9wcyA9IGxheWVyRGF0YS5tYXNrc1Byb3BlcnRpZXM7XHJcbiAgICAgICAgICBqTGVuID0gbWFza1Byb3BzLmxlbmd0aDtcclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rLmkpIHtcclxuICAgICAgICAgICAgICBtYXNrUHJvcHNbal0ucHQuay5jID0gbWFza1Byb3BzW2pdLmNsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGtMZW4gPSBtYXNrUHJvcHNbal0ucHQuay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnMpIHtcclxuICAgICAgICAgICAgICAgICAgbWFza1Byb3BzW2pdLnB0Lmtba10uc1swXS5jID0gbWFza1Byb3BzW2pdLmNsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLmUpIHtcclxuICAgICAgICAgICAgICAgICAgbWFza1Byb3BzW2pdLnB0Lmtba10uZVswXS5jID0gbWFza1Byb3BzW2pdLmNsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGF5ZXJEYXRhLnR5ID09PSA0KSB7XHJcbiAgICAgICAgICBjb21wbGV0ZUNsb3NpbmdTaGFwZXMobGF5ZXJEYXRhLnNoYXBlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltYXRpb25EYXRhKSB7XHJcbiAgICAgIGlmIChjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcclxuICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEubGF5ZXJzKTtcclxuICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHMpIHtcclxuICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdGlvbkRhdGEuYXNzZXRzLmxlbmd0aDtcclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKSB7XHJcbiAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0oKSk7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXBsZXRlRGF0YShhbmltYXRpb25EYXRhLCBmb250TWFuYWdlcikge1xyXG4gICAgaWYgKGFuaW1hdGlvbkRhdGEuX19jb21wbGV0ZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjaGVja0NvbG9ycyhhbmltYXRpb25EYXRhKTtcclxuICAgIGNoZWNrVGV4dChhbmltYXRpb25EYXRhKTtcclxuICAgIGNoZWNrQ2hhcnMoYW5pbWF0aW9uRGF0YSk7XHJcbiAgICBjaGVja1NoYXBlcyhhbmltYXRpb25EYXRhKTtcclxuICAgIGNvbXBsZXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEubGF5ZXJzLCBhbmltYXRpb25EYXRhLmFzc2V0cywgZm9udE1hbmFnZXIpO1xyXG4gICAgYW5pbWF0aW9uRGF0YS5fX2NvbXBsZXRlID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXBsZXRlVGV4dChkYXRhKSB7XHJcbiAgICBpZiAoZGF0YS50LmEubGVuZ3RoID09PSAwICYmICEoJ20nIGluIGRhdGEudC5wKSkge1xyXG4gICAgICBkYXRhLnNpbmdsZVNoYXBlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBtb2R1bGVPYiA9IHt9O1xyXG4gIG1vZHVsZU9iLmNvbXBsZXRlRGF0YSA9IGNvbXBsZXRlRGF0YTtcclxuICBtb2R1bGVPYi5jaGVja0NvbG9ycyA9IGNoZWNrQ29sb3JzO1xyXG4gIG1vZHVsZU9iLmNoZWNrQ2hhcnMgPSBjaGVja0NoYXJzO1xyXG4gIG1vZHVsZU9iLmNoZWNrU2hhcGVzID0gY2hlY2tTaGFwZXM7XHJcbiAgbW9kdWxlT2IuY29tcGxldGVMYXllcnMgPSBjb21wbGV0ZUxheWVycztcclxuXHJcbiAgcmV0dXJuIG1vZHVsZU9iO1xyXG59XHJcblxyXG52YXIgZGF0YU1hbmFnZXIgPSBkYXRhRnVuY3Rpb25NYW5hZ2VyKCk7XHJcblxyXG4vKiBleHBvcnRlZCBnZXRGb250UHJvcGVydGllcyAqL1xyXG5cclxuZnVuY3Rpb24gZ2V0Rm9udFByb3BlcnRpZXMoZm9udERhdGEpIHtcclxuICB2YXIgc3R5bGVzID0gZm9udERhdGEuZlN0eWxlID8gZm9udERhdGEuZlN0eWxlLnNwbGl0KCcgJykgOiBbXTtcclxuXHJcbiAgdmFyIGZXZWlnaHQgPSAnbm9ybWFsJzsgdmFyXHJcbiAgICBmU3R5bGUgPSAnbm9ybWFsJztcclxuICB2YXIgbGVuID0gc3R5bGVzLmxlbmd0aDtcclxuICB2YXIgc3R5bGVOYW1lO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIHN0eWxlTmFtZSA9IHN0eWxlc1tpXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgc3dpdGNoIChzdHlsZU5hbWUpIHtcclxuICAgICAgY2FzZSAnaXRhbGljJzpcclxuICAgICAgICBmU3R5bGUgPSAnaXRhbGljJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYm9sZCc6XHJcbiAgICAgICAgZldlaWdodCA9ICc3MDAnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdibGFjayc6XHJcbiAgICAgICAgZldlaWdodCA9ICc5MDAnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdtZWRpdW0nOlxyXG4gICAgICAgIGZXZWlnaHQgPSAnNTAwJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAncmVndWxhcic6XHJcbiAgICAgIGNhc2UgJ25vcm1hbCc6XHJcbiAgICAgICAgZldlaWdodCA9ICc0MDAnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdsaWdodCc6XHJcbiAgICAgIGNhc2UgJ3RoaW4nOlxyXG4gICAgICAgIGZXZWlnaHQgPSAnMjAwJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzdHlsZTogZlN0eWxlLFxyXG4gICAgd2VpZ2h0OiBmb250RGF0YS5mV2VpZ2h0IHx8IGZXZWlnaHQsXHJcbiAgfTtcclxufVxyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZU5TLCBjcmVhdGVUYWcsIGdldEZvbnRQcm9wZXJ0aWVzICovXHJcbi8qIGV4cG9ydGVkIEZvbnRNYW5hZ2VyICovXHJcblxyXG52YXIgRm9udE1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtYXhXYWl0aW5nVGltZSA9IDUwMDA7XHJcbiAgdmFyIGVtcHR5Q2hhciA9IHtcclxuICAgIHc6IDAsXHJcbiAgICBzaXplOiAwLFxyXG4gICAgc2hhcGVzOiBbXSxcclxuICB9O1xyXG4gIHZhciBjb21iaW5lZENoYXJhY3RlcnMgPSBbXTtcclxuICAvLyBIaW5kaSBjaGFyYWN0ZXJzXHJcbiAgY29tYmluZWRDaGFyYWN0ZXJzID0gY29tYmluZWRDaGFyYWN0ZXJzLmNvbmNhdChbMjMwNCwgMjMwNSwgMjMwNiwgMjMwNywgMjM2MiwgMjM2MywgMjM2NCwgMjM2NCwgMjM2NixcclxuICAgIDIzNjcsIDIzNjgsIDIzNjksIDIzNzAsIDIzNzEsIDIzNzIsIDIzNzMsIDIzNzQsIDIzNzUsIDIzNzYsIDIzNzcsIDIzNzgsIDIzNzksXHJcbiAgICAyMzgwLCAyMzgxLCAyMzgyLCAyMzgzLCAyMzg3LCAyMzg4LCAyMzg5LCAyMzkwLCAyMzkxLCAyNDAyLCAyNDAzXSk7XHJcblxyXG4gIGZ1bmN0aW9uIHRyaW1Gb250T3B0aW9ucyhmb250KSB7XHJcbiAgICB2YXIgZmFtaWx5QXJyYXkgPSBmb250LnNwbGl0KCcsJyk7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBmYW1pbHlBcnJheS5sZW5ndGg7XHJcbiAgICB2YXIgZW5hYmxlZEZhbWlsaWVzID0gW107XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgaWYgKGZhbWlseUFycmF5W2ldICE9PSAnc2Fucy1zZXJpZicgJiYgZmFtaWx5QXJyYXlbaV0gIT09ICdtb25vc3BhY2UnKSB7XHJcbiAgICAgICAgZW5hYmxlZEZhbWlsaWVzLnB1c2goZmFtaWx5QXJyYXlbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW5hYmxlZEZhbWlsaWVzLmpvaW4oJywnKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldFVwTm9kZShmb250LCBmYW1pbHkpIHtcclxuICAgIHZhciBwYXJlbnROb2RlID0gY3JlYXRlVGFnKCdzcGFuJyk7XHJcbiAgICAvLyBOb2RlIGlzIGludmlzaWJsZSB0byBzY3JlZW4gcmVhZGVycy5cclxuICAgIHBhcmVudE5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xyXG4gICAgcGFyZW50Tm9kZS5zdHlsZS5mb250RmFtaWx5ID0gZmFtaWx5O1xyXG4gICAgdmFyIG5vZGUgPSBjcmVhdGVUYWcoJ3NwYW4nKTtcclxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCB2YXJ5IHNpZ25pZmljYW50bHkgYW1vbmcgZGlmZmVyZW50IGZvbnRzXHJcbiAgICBub2RlLmlubmVyVGV4dCA9ICdnaUl0VDFXUXlAIS0vIyc7XHJcbiAgICAvLyBWaXNpYmxlIC0gc28gd2UgY2FuIG1lYXN1cmUgaXQgLSBidXQgbm90IG9uIHRoZSBzY3JlZW5cclxuICAgIHBhcmVudE5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgcGFyZW50Tm9kZS5zdHlsZS5sZWZ0ID0gJy0xMDAwMHB4JztcclxuICAgIHBhcmVudE5vZGUuc3R5bGUudG9wID0gJy0xMDAwMHB4JztcclxuICAgIC8vIExhcmdlIGZvbnQgc2l6ZSBtYWtlcyBldmVuIHN1YnRsZSBjaGFuZ2VzIG9idmlvdXNcclxuICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFNpemUgPSAnMzAwcHgnO1xyXG4gICAgLy8gUmVzZXQgYW55IGZvbnQgcHJvcGVydGllc1xyXG4gICAgcGFyZW50Tm9kZS5zdHlsZS5mb250VmFyaWFudCA9ICdub3JtYWwnO1xyXG4gICAgcGFyZW50Tm9kZS5zdHlsZS5mb250U3R5bGUgPSAnbm9ybWFsJztcclxuICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFdlaWdodCA9ICdub3JtYWwnO1xyXG4gICAgcGFyZW50Tm9kZS5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gJzAnO1xyXG4gICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlKTtcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGFyZW50Tm9kZSk7XHJcblxyXG4gICAgLy8gUmVtZW1iZXIgd2lkdGggd2l0aCBubyBhcHBsaWVkIHdlYiBmb250XHJcbiAgICB2YXIgd2lkdGggPSBub2RlLm9mZnNldFdpZHRoO1xyXG4gICAgbm9kZS5zdHlsZS5mb250RmFtaWx5ID0gdHJpbUZvbnRPcHRpb25zKGZvbnQpICsgJywgJyArIGZhbWlseTtcclxuICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIHc6IHdpZHRoLCBwYXJlbnQ6IHBhcmVudE5vZGUgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNoZWNrTG9hZGVkRm9udHMoKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSB0aGlzLmZvbnRzLmxlbmd0aDtcclxuICAgIHZhciBub2RlO1xyXG4gICAgdmFyIHc7XHJcbiAgICB2YXIgbG9hZGVkQ291bnQgPSBsZW47XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgaWYgKHRoaXMuZm9udHNbaV0ubG9hZGVkKSB7XHJcbiAgICAgICAgbG9hZGVkQ291bnQgLT0gMTtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmZvbnRzW2ldLmZPcmlnaW4gPT09ICduJyB8fCB0aGlzLmZvbnRzW2ldLm9yaWdpbiA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuZm9udHNbaV0ubG9hZGVkID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub2RlID0gdGhpcy5mb250c1tpXS5tb25vQ2FzZS5ub2RlO1xyXG4gICAgICAgIHcgPSB0aGlzLmZvbnRzW2ldLm1vbm9DYXNlLnc7XHJcbiAgICAgICAgaWYgKG5vZGUub2Zmc2V0V2lkdGggIT09IHcpIHtcclxuICAgICAgICAgIGxvYWRlZENvdW50IC09IDE7XHJcbiAgICAgICAgICB0aGlzLmZvbnRzW2ldLmxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5vZGUgPSB0aGlzLmZvbnRzW2ldLnNhbnNDYXNlLm5vZGU7XHJcbiAgICAgICAgICB3ID0gdGhpcy5mb250c1tpXS5zYW5zQ2FzZS53O1xyXG4gICAgICAgICAgaWYgKG5vZGUub2Zmc2V0V2lkdGggIT09IHcpIHtcclxuICAgICAgICAgICAgbG9hZGVkQ291bnQgLT0gMTtcclxuICAgICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5mb250c1tpXS5sb2FkZWQpIHtcclxuICAgICAgICAgIHRoaXMuZm9udHNbaV0uc2Fuc0Nhc2UucGFyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb250c1tpXS5zYW5zQ2FzZS5wYXJlbnQpO1xyXG4gICAgICAgICAgdGhpcy5mb250c1tpXS5tb25vQ2FzZS5wYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvbnRzW2ldLm1vbm9DYXNlLnBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGxvYWRlZENvdW50ICE9PSAwICYmIERhdGUubm93KCkgLSB0aGlzLmluaXRUaW1lIDwgbWF4V2FpdGluZ1RpbWUpIHtcclxuICAgICAgc2V0VGltZW91dCh0aGlzLmNoZWNrTG9hZGVkRm9udHNCaW5kZWQsIDIwKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNldFRpbWVvdXQodGhpcy5zZXRJc0xvYWRlZEJpbmRlZCwgMTApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlSGVscGVyKGRlZiwgZm9udERhdGEpIHtcclxuICAgIHZhciB0SGVscGVyID0gY3JlYXRlTlMoJ3RleHQnKTtcclxuICAgIHRIZWxwZXIuc3R5bGUuZm9udFNpemUgPSAnMTAwcHgnO1xyXG4gICAgLy8gdEhlbHBlci5zdHlsZS5mb250RmFtaWx5ID0gZm9udERhdGEuZkZhbWlseTtcclxuXHJcbiAgICB2YXIgZm9udFByb3BzID0gZ2V0Rm9udFByb3BlcnRpZXMoZm9udERhdGEpO1xyXG4gICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2ZvbnQtZmFtaWx5JywgZm9udERhdGEuZkZhbWlseSk7XHJcbiAgICB0SGVscGVyLnNldEF0dHJpYnV0ZSgnZm9udC1zdHlsZScsIGZvbnRQcm9wcy5zdHlsZSk7XHJcbiAgICB0SGVscGVyLnNldEF0dHJpYnV0ZSgnZm9udC13ZWlnaHQnLCBmb250UHJvcHMud2VpZ2h0KTtcclxuICAgIHRIZWxwZXIudGV4dENvbnRlbnQgPSAnMSc7XHJcbiAgICBpZiAoZm9udERhdGEuZkNsYXNzKSB7XHJcbiAgICAgIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9ICdpbmhlcml0JztcclxuICAgICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZm9udERhdGEuZkNsYXNzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9IGZvbnREYXRhLmZGYW1pbHk7XHJcbiAgICB9XHJcbiAgICBkZWYuYXBwZW5kQ2hpbGQodEhlbHBlcik7XHJcbiAgICB2YXIgdENhbnZhc0hlbHBlciA9IGNyZWF0ZVRhZygnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIHRDYW52YXNIZWxwZXIuZm9udCA9IGZvbnREYXRhLmZXZWlnaHQgKyAnICcgKyBmb250RGF0YS5mU3R5bGUgKyAnIDEwMHB4ICcgKyBmb250RGF0YS5mRmFtaWx5O1xyXG4gICAgLy8gdENhbnZhc0hlbHBlci5mb250ID0gJyAxMDBweCAnKyBmb250RGF0YS5mRmFtaWx5O1xyXG4gICAgcmV0dXJuIHRIZWxwZXI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGRGb250cyhmb250RGF0YSwgZGVmcykge1xyXG4gICAgaWYgKCFmb250RGF0YSkge1xyXG4gICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY2hhcnMpIHtcclxuICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgIHRoaXMuZm9udHMgPSBmb250RGF0YS5saXN0O1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZvbnRBcnIgPSBmb250RGF0YS5saXN0O1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gZm9udEFyci5sZW5ndGg7XHJcbiAgICB2YXIgX3BlbmRpbmdGb250cyA9IGxlbjtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICB2YXIgc2hvdWxkTG9hZEZvbnQgPSB0cnVlO1xyXG4gICAgICB2YXIgbG9hZGVkU2VsZWN0b3I7XHJcbiAgICAgIHZhciBqO1xyXG4gICAgICBmb250QXJyW2ldLmxvYWRlZCA9IGZhbHNlO1xyXG4gICAgICBmb250QXJyW2ldLm1vbm9DYXNlID0gc2V0VXBOb2RlKGZvbnRBcnJbaV0uZkZhbWlseSwgJ21vbm9zcGFjZScpO1xyXG4gICAgICBmb250QXJyW2ldLnNhbnNDYXNlID0gc2V0VXBOb2RlKGZvbnRBcnJbaV0uZkZhbWlseSwgJ3NhbnMtc2VyaWYnKTtcclxuICAgICAgaWYgKCFmb250QXJyW2ldLmZQYXRoKSB7XHJcbiAgICAgICAgZm9udEFycltpXS5sb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgIF9wZW5kaW5nRm9udHMgLT0gMTtcclxuICAgICAgfSBlbHNlIGlmIChmb250QXJyW2ldLmZPcmlnaW4gPT09ICdwJyB8fCBmb250QXJyW2ldLm9yaWdpbiA9PT0gMykge1xyXG4gICAgICAgIGxvYWRlZFNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZi1mb3JpZ2luPVwicFwiXVtmLWZhbWlseT1cIicgKyBmb250QXJyW2ldLmZGYW1pbHkgKyAnXCJdLCBzdHlsZVtmLW9yaWdpbj1cIjNcIl1bZi1mYW1pbHk9XCInICsgZm9udEFycltpXS5mRmFtaWx5ICsgJ1wiXScpO1xyXG5cclxuICAgICAgICBpZiAobG9hZGVkU2VsZWN0b3IubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgc2hvdWxkTG9hZEZvbnQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaG91bGRMb2FkRm9udCkge1xyXG4gICAgICAgICAgdmFyIHMgPSBjcmVhdGVUYWcoJ3N0eWxlJyk7XHJcbiAgICAgICAgICBzLnNldEF0dHJpYnV0ZSgnZi1mb3JpZ2luJywgZm9udEFycltpXS5mT3JpZ2luKTtcclxuICAgICAgICAgIHMuc2V0QXR0cmlidXRlKCdmLW9yaWdpbicsIGZvbnRBcnJbaV0ub3JpZ2luKTtcclxuICAgICAgICAgIHMuc2V0QXR0cmlidXRlKCdmLWZhbWlseScsIGZvbnRBcnJbaV0uZkZhbWlseSk7XHJcbiAgICAgICAgICBzLnR5cGUgPSAndGV4dC9jc3MnO1xyXG4gICAgICAgICAgcy5pbm5lclRleHQgPSAnQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6ICcgKyBmb250QXJyW2ldLmZGYW1pbHkgKyBcIjsgZm9udC1zdHlsZTogbm9ybWFsOyBzcmM6IHVybCgnXCIgKyBmb250QXJyW2ldLmZQYXRoICsgXCInKTt9XCI7XHJcbiAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChmb250QXJyW2ldLmZPcmlnaW4gPT09ICdnJyB8fCBmb250QXJyW2ldLm9yaWdpbiA9PT0gMSkge1xyXG4gICAgICAgIGxvYWRlZFNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGlua1tmLWZvcmlnaW49XCJnXCJdLCBsaW5rW2Ytb3JpZ2luPVwiMVwiXScpO1xyXG5cclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbG9hZGVkU2VsZWN0b3IubGVuZ3RoOyBqICs9IDEpIHtcclxuICAgICAgICAgIGlmIChsb2FkZWRTZWxlY3RvcltqXS5ocmVmLmluZGV4T2YoZm9udEFycltpXS5mUGF0aCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIEZvbnQgaXMgYWxyZWFkeSBsb2FkZWRcclxuICAgICAgICAgICAgc2hvdWxkTG9hZEZvbnQgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaG91bGRMb2FkRm9udCkge1xyXG4gICAgICAgICAgdmFyIGwgPSBjcmVhdGVUYWcoJ2xpbmsnKTtcclxuICAgICAgICAgIGwuc2V0QXR0cmlidXRlKCdmLWZvcmlnaW4nLCBmb250QXJyW2ldLmZPcmlnaW4pO1xyXG4gICAgICAgICAgbC5zZXRBdHRyaWJ1dGUoJ2Ytb3JpZ2luJywgZm9udEFycltpXS5vcmlnaW4pO1xyXG4gICAgICAgICAgbC50eXBlID0gJ3RleHQvY3NzJztcclxuICAgICAgICAgIGwucmVsID0gJ3N0eWxlc2hlZXQnO1xyXG4gICAgICAgICAgbC5ocmVmID0gZm9udEFycltpXS5mUGF0aDtcclxuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGZvbnRBcnJbaV0uZk9yaWdpbiA9PT0gJ3QnIHx8IGZvbnRBcnJbaV0ub3JpZ2luID09PSAyKSB7XHJcbiAgICAgICAgbG9hZGVkU2VsZWN0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHRbZi1mb3JpZ2luPVwidFwiXSwgc2NyaXB0W2Ytb3JpZ2luPVwiMlwiXScpO1xyXG5cclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbG9hZGVkU2VsZWN0b3IubGVuZ3RoOyBqICs9IDEpIHtcclxuICAgICAgICAgIGlmIChmb250QXJyW2ldLmZQYXRoID09PSBsb2FkZWRTZWxlY3RvcltqXS5zcmMpIHtcclxuICAgICAgICAgICAgLy8gRm9udCBpcyBhbHJlYWR5IGxvYWRlZFxyXG4gICAgICAgICAgICBzaG91bGRMb2FkRm9udCA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNob3VsZExvYWRGb250KSB7XHJcbiAgICAgICAgICB2YXIgc2MgPSBjcmVhdGVUYWcoJ2xpbmsnKTtcclxuICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgnZi1mb3JpZ2luJywgZm9udEFycltpXS5mT3JpZ2luKTtcclxuICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgnZi1vcmlnaW4nLCBmb250QXJyW2ldLm9yaWdpbik7XHJcbiAgICAgICAgICBzYy5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XHJcbiAgICAgICAgICBzYy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBmb250QXJyW2ldLmZQYXRoKTtcclxuICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmb250QXJyW2ldLmhlbHBlciA9IGNyZWF0ZUhlbHBlcihkZWZzLCBmb250QXJyW2ldKTtcclxuICAgICAgZm9udEFycltpXS5jYWNoZSA9IHt9O1xyXG4gICAgICB0aGlzLmZvbnRzLnB1c2goZm9udEFycltpXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoX3BlbmRpbmdGb250cyA9PT0gMCkge1xyXG4gICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE9uIHNvbWUgY2FzZXMgZXZlbiBpZiB0aGUgZm9udCBpcyBsb2FkZWQsIGl0IHdvbid0IGxvYWQgY29ycmVjdGx5IHdoZW4gbWVhc3VyaW5nIHRleHQgb24gY2FudmFzLlxyXG4gICAgICAvLyBBZGRpbmcgdGhpcyB0aW1lb3V0IHNlZW1zIHRvIGZpeCBpdFxyXG4gICAgICBzZXRUaW1lb3V0KHRoaXMuY2hlY2tMb2FkZWRGb250cy5iaW5kKHRoaXMpLCAxMDApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWRkQ2hhcnMoY2hhcnMpIHtcclxuICAgIGlmICghY2hhcnMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLmNoYXJzKSB7XHJcbiAgICAgIHRoaXMuY2hhcnMgPSBbXTtcclxuICAgIH1cclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IGNoYXJzLmxlbmd0aDtcclxuICAgIHZhciBqO1xyXG4gICAgdmFyIGpMZW4gPSB0aGlzLmNoYXJzLmxlbmd0aDtcclxuICAgIHZhciBmb3VuZDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBqID0gMDtcclxuICAgICAgZm91bmQgPSBmYWxzZTtcclxuICAgICAgd2hpbGUgKGogPCBqTGVuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhcnNbal0uc3R5bGUgPT09IGNoYXJzW2ldLnN0eWxlICYmIHRoaXMuY2hhcnNbal0uZkZhbWlseSA9PT0gY2hhcnNbaV0uZkZhbWlseSAmJiB0aGlzLmNoYXJzW2pdLmNoID09PSBjaGFyc1tpXS5jaCkge1xyXG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBqICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgIHRoaXMuY2hhcnMucHVzaChjaGFyc1tpXSk7XHJcbiAgICAgICAgakxlbiArPSAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRDaGFyRGF0YShjaGFyLCBzdHlsZSwgZm9udCkge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIGxlbiA9IHRoaXMuY2hhcnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgaWYgKHRoaXMuY2hhcnNbaV0uY2ggPT09IGNoYXIgJiYgdGhpcy5jaGFyc1tpXS5zdHlsZSA9PT0gc3R5bGUgJiYgdGhpcy5jaGFyc1tpXS5mRmFtaWx5ID09PSBmb250KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnNbaV07XHJcbiAgICAgIH1cclxuICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG4gICAgaWYgKCgodHlwZW9mIGNoYXIgPT09ICdzdHJpbmcnICYmIGNoYXIuY2hhckNvZGVBdCgwKSAhPT0gMTMpIHx8ICFjaGFyKVxyXG4gICAgICAgICAgICAmJiBjb25zb2xlXHJcbiAgICAgICAgICAgICYmIGNvbnNvbGUud2FybiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICAgICAgJiYgIXRoaXMuX3dhcm5lZFxyXG4gICAgKSB7XHJcbiAgICAgIHRoaXMuX3dhcm5lZCA9IHRydWU7XHJcbiAgICAgIGNvbnNvbGUud2FybignTWlzc2luZyBjaGFyYWN0ZXIgZnJvbSBleHBvcnRlZCBjaGFyYWN0ZXJzIGxpc3Q6ICcsIGNoYXIsIHN0eWxlLCBmb250KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW1wdHlDaGFyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWVhc3VyZVRleHQoY2hhciwgZm9udE5hbWUsIHNpemUpIHtcclxuICAgIHZhciBmb250RGF0YSA9IHRoaXMuZ2V0Rm9udEJ5TmFtZShmb250TmFtZSk7XHJcbiAgICB2YXIgaW5kZXggPSBjaGFyLmNoYXJDb2RlQXQoMCk7XHJcbiAgICBpZiAoIWZvbnREYXRhLmNhY2hlW2luZGV4ICsgMV0pIHtcclxuICAgICAgdmFyIHRIZWxwZXIgPSBmb250RGF0YS5oZWxwZXI7XHJcbiAgICAgIC8vIENhbnZhcyB2ZXJzaW9uXHJcbiAgICAgIC8vIGZvbnREYXRhLmNhY2hlW2luZGV4XSA9IHRIZWxwZXIubWVhc3VyZVRleHQoY2hhcikud2lkdGggLyAxMDA7XHJcbiAgICAgIC8vIFNWRyB2ZXJzaW9uXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRIZWxwZXIuZ2V0QkJveCgpLndpZHRoKVxyXG4gICAgICBpZiAoY2hhciA9PT0gJyAnKSB7XHJcbiAgICAgICAgdEhlbHBlci50ZXh0Q29udGVudCA9ICd8JyArIGNoYXIgKyAnfCc7XHJcbiAgICAgICAgdmFyIGRvdWJsZVNpemUgPSB0SGVscGVyLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xyXG4gICAgICAgIHRIZWxwZXIudGV4dENvbnRlbnQgPSAnfHwnO1xyXG4gICAgICAgIHZhciBzaW5nbGVTaXplID0gdEhlbHBlci5nZXRDb21wdXRlZFRleHRMZW5ndGgoKTtcclxuICAgICAgICBmb250RGF0YS5jYWNoZVtpbmRleCArIDFdID0gKGRvdWJsZVNpemUgLSBzaW5nbGVTaXplKSAvIDEwMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0SGVscGVyLnRleHRDb250ZW50ID0gY2hhcjtcclxuICAgICAgICBmb250RGF0YS5jYWNoZVtpbmRleCArIDFdID0gKHRIZWxwZXIuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkpIC8gMTAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZm9udERhdGEuY2FjaGVbaW5kZXggKyAxXSAqIHNpemU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRGb250QnlOYW1lKG5hbWUpIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBsZW4gPSB0aGlzLmZvbnRzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgIGlmICh0aGlzLmZvbnRzW2ldLmZOYW1lID09PSBuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udHNbaV07XHJcbiAgICAgIH1cclxuICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZm9udHNbMF07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRDb21iaW5lZENoYXJhY3RlckNvZGVzKCkge1xyXG4gICAgcmV0dXJuIGNvbWJpbmVkQ2hhcmFjdGVycztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldElzTG9hZGVkKCkge1xyXG4gICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICB2YXIgRm9udCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZm9udHMgPSBbXTtcclxuICAgIHRoaXMuY2hhcnMgPSBudWxsO1xyXG4gICAgdGhpcy50eXBla2l0TG9hZGVkID0gMDtcclxuICAgIHRoaXMuaXNMb2FkZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3dhcm5lZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5pbml0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICB0aGlzLnNldElzTG9hZGVkQmluZGVkID0gdGhpcy5zZXRJc0xvYWRlZC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5jaGVja0xvYWRlZEZvbnRzQmluZGVkID0gdGhpcy5jaGVja0xvYWRlZEZvbnRzLmJpbmQodGhpcyk7XHJcbiAgfTtcclxuICAgIC8vIFRPRE86IGZvciBub3cgSSdtIGFkZGluZyB0aGVzZSBtZXRob2RzIHRvIHRoZSBDbGFzcyBhbmQgbm90IHRoZSBwcm90b3R5cGUuIFRoaW5rIG9mIGEgYmV0dGVyIHdheSB0byBpbXBsZW1lbnQgaXQuXHJcbiAgRm9udC5nZXRDb21iaW5lZENoYXJhY3RlckNvZGVzID0gZ2V0Q29tYmluZWRDaGFyYWN0ZXJDb2RlcztcclxuXHJcbiAgdmFyIGZvbnRQcm90b3R5cGUgPSB7XHJcbiAgICBhZGRDaGFyczogYWRkQ2hhcnMsXHJcbiAgICBhZGRGb250czogYWRkRm9udHMsXHJcbiAgICBnZXRDaGFyRGF0YTogZ2V0Q2hhckRhdGEsXHJcbiAgICBnZXRGb250QnlOYW1lOiBnZXRGb250QnlOYW1lLFxyXG4gICAgbWVhc3VyZVRleHQ6IG1lYXN1cmVUZXh0LFxyXG4gICAgY2hlY2tMb2FkZWRGb250czogY2hlY2tMb2FkZWRGb250cyxcclxuICAgIHNldElzTG9hZGVkOiBzZXRJc0xvYWRlZCxcclxuICB9O1xyXG5cclxuICBGb250LnByb3RvdHlwZSA9IGZvbnRQcm90b3R5cGU7XHJcblxyXG4gIHJldHVybiBGb250O1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIGluaXRpYWxEZWZhdWx0RnJhbWUsIEJlemllckZhY3RvcnksIGRlZ1RvUmFkcywgYmV6LCBjcmVhdGVUeXBlZEFycmF5ICovXHJcbi8qIGV4cG9ydGVkIFByb3BlcnR5RmFjdG9yeSAqL1xyXG5cclxudmFyIFByb3BlcnR5RmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGluaXRGcmFtZSA9IGluaXRpYWxEZWZhdWx0RnJhbWU7XHJcbiAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcclxuXHJcbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVWYWx1ZShmcmFtZU51bSwgY2FjaGluZykge1xyXG4gICAgdmFyIG9mZnNldFRpbWUgPSB0aGlzLm9mZnNldFRpbWU7XHJcbiAgICB2YXIgbmV3VmFsdWU7XHJcbiAgICBpZiAodGhpcy5wcm9wVHlwZSA9PT0gJ211bHRpZGltZW5zaW9uYWwnKSB7XHJcbiAgICAgIG5ld1ZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIHRoaXMucHYubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHZhciBpdGVyYXRpb25JbmRleCA9IGNhY2hpbmcubGFzdEluZGV4O1xyXG4gICAgdmFyIGkgPSBpdGVyYXRpb25JbmRleDtcclxuICAgIHZhciBsZW4gPSB0aGlzLmtleWZyYW1lcy5sZW5ndGggLSAxO1xyXG4gICAgdmFyIGZsYWcgPSB0cnVlO1xyXG4gICAgdmFyIGtleURhdGE7XHJcbiAgICB2YXIgbmV4dEtleURhdGE7XHJcblxyXG4gICAgd2hpbGUgKGZsYWcpIHtcclxuICAgICAga2V5RGF0YSA9IHRoaXMua2V5ZnJhbWVzW2ldO1xyXG4gICAgICBuZXh0S2V5RGF0YSA9IHRoaXMua2V5ZnJhbWVzW2kgKyAxXTtcclxuICAgICAgaWYgKGkgPT09IGxlbiAtIDEgJiYgZnJhbWVOdW0gPj0gbmV4dEtleURhdGEudCAtIG9mZnNldFRpbWUpIHtcclxuICAgICAgICBpZiAoa2V5RGF0YS5oKSB7XHJcbiAgICAgICAgICBrZXlEYXRhID0gbmV4dEtleURhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGl0ZXJhdGlvbkluZGV4ID0gMDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZiAoKG5leHRLZXlEYXRhLnQgLSBvZmZzZXRUaW1lKSA+IGZyYW1lTnVtKSB7XHJcbiAgICAgICAgaXRlcmF0aW9uSW5kZXggPSBpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpIDwgbGVuIC0gMSkge1xyXG4gICAgICAgIGkgKz0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpdGVyYXRpb25JbmRleCA9IDA7XHJcbiAgICAgICAgZmxhZyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGs7XHJcbiAgICB2YXIga0xlbjtcclxuICAgIHZhciBwZXJjO1xyXG4gICAgdmFyIGpMZW47XHJcbiAgICB2YXIgajtcclxuICAgIHZhciBmbmM7XHJcbiAgICB2YXIgbmV4dEtleVRpbWUgPSBuZXh0S2V5RGF0YS50IC0gb2Zmc2V0VGltZTtcclxuICAgIHZhciBrZXlUaW1lID0ga2V5RGF0YS50IC0gb2Zmc2V0VGltZTtcclxuICAgIHZhciBlbmRWYWx1ZTtcclxuICAgIGlmIChrZXlEYXRhLnRvKSB7XHJcbiAgICAgIGlmICgha2V5RGF0YS5iZXppZXJEYXRhKSB7XHJcbiAgICAgICAga2V5RGF0YS5iZXppZXJEYXRhID0gYmV6LmJ1aWxkQmV6aWVyRGF0YShrZXlEYXRhLnMsIG5leHRLZXlEYXRhLnMgfHwga2V5RGF0YS5lLCBrZXlEYXRhLnRvLCBrZXlEYXRhLnRpKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgYmV6aWVyRGF0YSA9IGtleURhdGEuYmV6aWVyRGF0YTtcclxuICAgICAgaWYgKGZyYW1lTnVtID49IG5leHRLZXlUaW1lIHx8IGZyYW1lTnVtIDwga2V5VGltZSkge1xyXG4gICAgICAgIHZhciBpbmQgPSBmcmFtZU51bSA+PSBuZXh0S2V5VGltZSA/IGJlemllckRhdGEucG9pbnRzLmxlbmd0aCAtIDEgOiAwO1xyXG4gICAgICAgIGtMZW4gPSBiZXppZXJEYXRhLnBvaW50c1tpbmRdLnBvaW50Lmxlbmd0aDtcclxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XHJcbiAgICAgICAgICBuZXdWYWx1ZVtrXSA9IGJlemllckRhdGEucG9pbnRzW2luZF0ucG9pbnRba107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhY2hpbmcuX2xhc3RLZXlmcmFtZUluZGV4ID0gLTE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGtleURhdGEuX19mbmN0KSB7XHJcbiAgICAgICAgICBmbmMgPSBrZXlEYXRhLl9fZm5jdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm5jID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoa2V5RGF0YS5vLngsIGtleURhdGEuby55LCBrZXlEYXRhLmkueCwga2V5RGF0YS5pLnksIGtleURhdGEubikuZ2V0O1xyXG4gICAgICAgICAga2V5RGF0YS5fX2ZuY3QgPSBmbmM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBlcmMgPSBmbmMoKGZyYW1lTnVtIC0ga2V5VGltZSkgLyAobmV4dEtleVRpbWUgLSBrZXlUaW1lKSk7XHJcbiAgICAgICAgdmFyIGRpc3RhbmNlSW5MaW5lID0gYmV6aWVyRGF0YS5zZWdtZW50TGVuZ3RoICogcGVyYztcclxuXHJcbiAgICAgICAgdmFyIHNlZ21lbnRQZXJjO1xyXG4gICAgICAgIHZhciBhZGRlZExlbmd0aCA9IChjYWNoaW5nLmxhc3RGcmFtZSA8IGZyYW1lTnVtICYmIGNhY2hpbmcuX2xhc3RLZXlmcmFtZUluZGV4ID09PSBpKSA/IGNhY2hpbmcuX2xhc3RBZGRlZExlbmd0aCA6IDA7XHJcbiAgICAgICAgaiA9IChjYWNoaW5nLmxhc3RGcmFtZSA8IGZyYW1lTnVtICYmIGNhY2hpbmcuX2xhc3RLZXlmcmFtZUluZGV4ID09PSBpKSA/IGNhY2hpbmcuX2xhc3RQb2ludCA6IDA7XHJcbiAgICAgICAgZmxhZyA9IHRydWU7XHJcbiAgICAgICAgakxlbiA9IGJlemllckRhdGEucG9pbnRzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoZmxhZykge1xyXG4gICAgICAgICAgYWRkZWRMZW5ndGggKz0gYmV6aWVyRGF0YS5wb2ludHNbal0ucGFydGlhbExlbmd0aDtcclxuICAgICAgICAgIGlmIChkaXN0YW5jZUluTGluZSA9PT0gMCB8fCBwZXJjID09PSAwIHx8IGogPT09IGJlemllckRhdGEucG9pbnRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAga0xlbiA9IGJlemllckRhdGEucG9pbnRzW2pdLnBvaW50Lmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xyXG4gICAgICAgICAgICAgIG5ld1ZhbHVlW2tdID0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnRba107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpc3RhbmNlSW5MaW5lID49IGFkZGVkTGVuZ3RoICYmIGRpc3RhbmNlSW5MaW5lIDwgYWRkZWRMZW5ndGggKyBiZXppZXJEYXRhLnBvaW50c1tqICsgMV0ucGFydGlhbExlbmd0aCkge1xyXG4gICAgICAgICAgICBzZWdtZW50UGVyYyA9IChkaXN0YW5jZUluTGluZSAtIGFkZGVkTGVuZ3RoKSAvIGJlemllckRhdGEucG9pbnRzW2ogKyAxXS5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgICAgICBrTGVuID0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnQubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XHJcbiAgICAgICAgICAgICAgbmV3VmFsdWVba10gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludFtrXSArIChiZXppZXJEYXRhLnBvaW50c1tqICsgMV0ucG9pbnRba10gLSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludFtrXSkgKiBzZWdtZW50UGVyYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChqIDwgakxlbiAtIDEpIHtcclxuICAgICAgICAgICAgaiArPSAxO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYWNoaW5nLl9sYXN0UG9pbnQgPSBqO1xyXG4gICAgICAgIGNhY2hpbmcuX2xhc3RBZGRlZExlbmd0aCA9IGFkZGVkTGVuZ3RoIC0gYmV6aWVyRGF0YS5wb2ludHNbal0ucGFydGlhbExlbmd0aDtcclxuICAgICAgICBjYWNoaW5nLl9sYXN0S2V5ZnJhbWVJbmRleCA9IGk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBvdXRYO1xyXG4gICAgICB2YXIgb3V0WTtcclxuICAgICAgdmFyIGluWDtcclxuICAgICAgdmFyIGluWTtcclxuICAgICAgdmFyIGtleVZhbHVlO1xyXG4gICAgICBsZW4gPSBrZXlEYXRhLnMubGVuZ3RoO1xyXG4gICAgICBlbmRWYWx1ZSA9IG5leHRLZXlEYXRhLnMgfHwga2V5RGF0YS5lO1xyXG4gICAgICBpZiAodGhpcy5zaCAmJiBrZXlEYXRhLmggIT09IDEpIHtcclxuICAgICAgICBpZiAoZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUpIHtcclxuICAgICAgICAgIG5ld1ZhbHVlWzBdID0gZW5kVmFsdWVbMF07XHJcbiAgICAgICAgICBuZXdWYWx1ZVsxXSA9IGVuZFZhbHVlWzFdO1xyXG4gICAgICAgICAgbmV3VmFsdWVbMl0gPSBlbmRWYWx1ZVsyXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGZyYW1lTnVtIDw9IGtleVRpbWUpIHtcclxuICAgICAgICAgIG5ld1ZhbHVlWzBdID0ga2V5RGF0YS5zWzBdO1xyXG4gICAgICAgICAgbmV3VmFsdWVbMV0gPSBrZXlEYXRhLnNbMV07XHJcbiAgICAgICAgICBuZXdWYWx1ZVsyXSA9IGtleURhdGEuc1syXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIHF1YXRTdGFydCA9IGNyZWF0ZVF1YXRlcm5pb24oa2V5RGF0YS5zKTtcclxuICAgICAgICAgIHZhciBxdWF0RW5kID0gY3JlYXRlUXVhdGVybmlvbihlbmRWYWx1ZSk7XHJcbiAgICAgICAgICB2YXIgdGltZSA9IChmcmFtZU51bSAtIGtleVRpbWUpIC8gKG5leHRLZXlUaW1lIC0ga2V5VGltZSk7XHJcbiAgICAgICAgICBxdWF0ZXJuaW9uVG9FdWxlcihuZXdWYWx1ZSwgc2xlcnAocXVhdFN0YXJ0LCBxdWF0RW5kLCB0aW1lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgaWYgKGtleURhdGEuaCAhPT0gMSkge1xyXG4gICAgICAgICAgICBpZiAoZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUpIHtcclxuICAgICAgICAgICAgICBwZXJjID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChmcmFtZU51bSA8IGtleVRpbWUpIHtcclxuICAgICAgICAgICAgICBwZXJjID0gMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpZiAoa2V5RGF0YS5vLnguY29uc3RydWN0b3IgPT09IEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWtleURhdGEuX19mbmN0KSB7XHJcbiAgICAgICAgICAgICAgICAgIGtleURhdGEuX19mbmN0ID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWtleURhdGEuX19mbmN0W2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgIG91dFggPSAodHlwZW9mIGtleURhdGEuby54W2ldID09PSAndW5kZWZpbmVkJykgPyBrZXlEYXRhLm8ueFswXSA6IGtleURhdGEuby54W2ldO1xyXG4gICAgICAgICAgICAgICAgICBvdXRZID0gKHR5cGVvZiBrZXlEYXRhLm8ueVtpXSA9PT0gJ3VuZGVmaW5lZCcpID8ga2V5RGF0YS5vLnlbMF0gOiBrZXlEYXRhLm8ueVtpXTtcclxuICAgICAgICAgICAgICAgICAgaW5YID0gKHR5cGVvZiBrZXlEYXRhLmkueFtpXSA9PT0gJ3VuZGVmaW5lZCcpID8ga2V5RGF0YS5pLnhbMF0gOiBrZXlEYXRhLmkueFtpXTtcclxuICAgICAgICAgICAgICAgICAgaW5ZID0gKHR5cGVvZiBrZXlEYXRhLmkueVtpXSA9PT0gJ3VuZGVmaW5lZCcpID8ga2V5RGF0YS5pLnlbMF0gOiBrZXlEYXRhLmkueVtpXTtcclxuICAgICAgICAgICAgICAgICAgZm5jID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcob3V0WCwgb3V0WSwgaW5YLCBpblkpLmdldDtcclxuICAgICAgICAgICAgICAgICAga2V5RGF0YS5fX2ZuY3RbaV0gPSBmbmM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBmbmMgPSBrZXlEYXRhLl9fZm5jdFtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFrZXlEYXRhLl9fZm5jdCkge1xyXG4gICAgICAgICAgICAgICAgb3V0WCA9IGtleURhdGEuby54O1xyXG4gICAgICAgICAgICAgICAgb3V0WSA9IGtleURhdGEuby55O1xyXG4gICAgICAgICAgICAgICAgaW5YID0ga2V5RGF0YS5pLng7XHJcbiAgICAgICAgICAgICAgICBpblkgPSBrZXlEYXRhLmkueTtcclxuICAgICAgICAgICAgICAgIGZuYyA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKG91dFgsIG91dFksIGluWCwgaW5ZKS5nZXQ7XHJcbiAgICAgICAgICAgICAgICBrZXlEYXRhLl9fZm5jdCA9IGZuYztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm5jID0ga2V5RGF0YS5fX2ZuY3Q7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHBlcmMgPSBmbmMoKGZyYW1lTnVtIC0ga2V5VGltZSkgLyAobmV4dEtleVRpbWUgLSBrZXlUaW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBlbmRWYWx1ZSA9IG5leHRLZXlEYXRhLnMgfHwga2V5RGF0YS5lO1xyXG4gICAgICAgICAga2V5VmFsdWUgPSBrZXlEYXRhLmggPT09IDEgPyBrZXlEYXRhLnNbaV0gOiBrZXlEYXRhLnNbaV0gKyAoZW5kVmFsdWVbaV0gLSBrZXlEYXRhLnNbaV0pICogcGVyYztcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5wcm9wVHlwZSA9PT0gJ211bHRpZGltZW5zaW9uYWwnKSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlW2ldID0ga2V5VmFsdWU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGtleVZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2FjaGluZy5sYXN0SW5kZXggPSBpdGVyYXRpb25JbmRleDtcclxuICAgIHJldHVybiBuZXdWYWx1ZTtcclxuICB9XHJcblxyXG4gIC8vIGJhc2VkIG9uIEBUb2ppJ3MgaHR0cHM6Ly9naXRodWIuY29tL3RvamkvZ2wtbWF0cml4L1xyXG4gIGZ1bmN0aW9uIHNsZXJwKGEsIGIsIHQpIHtcclxuICAgIHZhciBvdXQgPSBbXTtcclxuICAgIHZhciBheCA9IGFbMF07XHJcbiAgICB2YXIgYXkgPSBhWzFdO1xyXG4gICAgdmFyIGF6ID0gYVsyXTtcclxuICAgIHZhciBhdyA9IGFbM107XHJcbiAgICB2YXIgYnggPSBiWzBdO1xyXG4gICAgdmFyIGJ5ID0gYlsxXTtcclxuICAgIHZhciBieiA9IGJbMl07XHJcbiAgICB2YXIgYncgPSBiWzNdO1xyXG5cclxuICAgIHZhciBvbWVnYTtcclxuICAgIHZhciBjb3NvbTtcclxuICAgIHZhciBzaW5vbTtcclxuICAgIHZhciBzY2FsZTA7XHJcbiAgICB2YXIgc2NhbGUxO1xyXG5cclxuICAgIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcclxuICAgIGlmIChjb3NvbSA8IDAuMCkge1xyXG4gICAgICBjb3NvbSA9IC1jb3NvbTtcclxuICAgICAgYnggPSAtYng7XHJcbiAgICAgIGJ5ID0gLWJ5O1xyXG4gICAgICBieiA9IC1iejtcclxuICAgICAgYncgPSAtYnc7XHJcbiAgICB9XHJcbiAgICBpZiAoKDEuMCAtIGNvc29tKSA+IDAuMDAwMDAxKSB7XHJcbiAgICAgIG9tZWdhID0gTWF0aC5hY29zKGNvc29tKTtcclxuICAgICAgc2lub20gPSBNYXRoLnNpbihvbWVnYSk7XHJcbiAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xyXG4gICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzY2FsZTAgPSAxLjAgLSB0O1xyXG4gICAgICBzY2FsZTEgPSB0O1xyXG4gICAgfVxyXG4gICAgb3V0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcclxuICAgIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XHJcbiAgICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xyXG4gICAgb3V0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcXVhdGVybmlvblRvRXVsZXIob3V0LCBxdWF0KSB7XHJcbiAgICB2YXIgcXggPSBxdWF0WzBdO1xyXG4gICAgdmFyIHF5ID0gcXVhdFsxXTtcclxuICAgIHZhciBxeiA9IHF1YXRbMl07XHJcbiAgICB2YXIgcXcgPSBxdWF0WzNdO1xyXG4gICAgdmFyIGhlYWRpbmcgPSBNYXRoLmF0YW4yKDIgKiBxeSAqIHF3IC0gMiAqIHF4ICogcXosIDEgLSAyICogcXkgKiBxeSAtIDIgKiBxeiAqIHF6KTtcclxuICAgIHZhciBhdHRpdHVkZSA9IE1hdGguYXNpbigyICogcXggKiBxeSArIDIgKiBxeiAqIHF3KTtcclxuICAgIHZhciBiYW5rID0gTWF0aC5hdGFuMigyICogcXggKiBxdyAtIDIgKiBxeSAqIHF6LCAxIC0gMiAqIHF4ICogcXggLSAyICogcXogKiBxeik7XHJcbiAgICBvdXRbMF0gPSBoZWFkaW5nIC8gZGVnVG9SYWRzO1xyXG4gICAgb3V0WzFdID0gYXR0aXR1ZGUgLyBkZWdUb1JhZHM7XHJcbiAgICBvdXRbMl0gPSBiYW5rIC8gZGVnVG9SYWRzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlUXVhdGVybmlvbih2YWx1ZXMpIHtcclxuICAgIHZhciBoZWFkaW5nID0gdmFsdWVzWzBdICogZGVnVG9SYWRzO1xyXG4gICAgdmFyIGF0dGl0dWRlID0gdmFsdWVzWzFdICogZGVnVG9SYWRzO1xyXG4gICAgdmFyIGJhbmsgPSB2YWx1ZXNbMl0gKiBkZWdUb1JhZHM7XHJcbiAgICB2YXIgYzEgPSBNYXRoLmNvcyhoZWFkaW5nIC8gMik7XHJcbiAgICB2YXIgYzIgPSBNYXRoLmNvcyhhdHRpdHVkZSAvIDIpO1xyXG4gICAgdmFyIGMzID0gTWF0aC5jb3MoYmFuayAvIDIpO1xyXG4gICAgdmFyIHMxID0gTWF0aC5zaW4oaGVhZGluZyAvIDIpO1xyXG4gICAgdmFyIHMyID0gTWF0aC5zaW4oYXR0aXR1ZGUgLyAyKTtcclxuICAgIHZhciBzMyA9IE1hdGguc2luKGJhbmsgLyAyKTtcclxuICAgIHZhciB3ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG4gICAgdmFyIHggPSBzMSAqIHMyICogYzMgKyBjMSAqIGMyICogczM7XHJcbiAgICB2YXIgeSA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuICAgIHZhciB6ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cclxuICAgIHJldHVybiBbeCwgeSwgeiwgd107XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRWYWx1ZUF0Q3VycmVudFRpbWUoKSB7XHJcbiAgICB2YXIgZnJhbWVOdW0gPSB0aGlzLmNvbXAucmVuZGVyZWRGcmFtZSAtIHRoaXMub2Zmc2V0VGltZTtcclxuICAgIHZhciBpbml0VGltZSA9IHRoaXMua2V5ZnJhbWVzWzBdLnQgLSB0aGlzLm9mZnNldFRpbWU7XHJcbiAgICB2YXIgZW5kVGltZSA9IHRoaXMua2V5ZnJhbWVzW3RoaXMua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLSB0aGlzLm9mZnNldFRpbWU7XHJcbiAgICBpZiAoIShmcmFtZU51bSA9PT0gdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgfHwgKHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lICE9PSBpbml0RnJhbWUgJiYgKCh0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSA+PSBlbmRUaW1lICYmIGZyYW1lTnVtID49IGVuZFRpbWUpIHx8ICh0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSA8IGluaXRUaW1lICYmIGZyYW1lTnVtIDwgaW5pdFRpbWUpKSkpKSB7XHJcbiAgICAgIGlmICh0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSA+PSBmcmFtZU51bSkge1xyXG4gICAgICAgIHRoaXMuX2NhY2hpbmcuX2xhc3RLZXlmcmFtZUluZGV4ID0gLTE7XHJcbiAgICAgICAgdGhpcy5fY2FjaGluZy5sYXN0SW5kZXggPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcmVuZGVyUmVzdWx0ID0gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCB0aGlzLl9jYWNoaW5nKTtcclxuICAgICAgdGhpcy5wdiA9IHJlbmRlclJlc3VsdDtcclxuICAgIH1cclxuICAgIHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lID0gZnJhbWVOdW07XHJcbiAgICByZXR1cm4gdGhpcy5wdjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldFZWYWx1ZSh2YWwpIHtcclxuICAgIHZhciBtdWx0aXBsaWVkVmFsdWU7XHJcbiAgICBpZiAodGhpcy5wcm9wVHlwZSA9PT0gJ3VuaWRpbWVuc2lvbmFsJykge1xyXG4gICAgICBtdWx0aXBsaWVkVmFsdWUgPSB2YWwgKiB0aGlzLm11bHQ7XHJcbiAgICAgIGlmIChtYXRoQWJzKHRoaXMudiAtIG11bHRpcGxpZWRWYWx1ZSkgPiAwLjAwMDAxKSB7XHJcbiAgICAgICAgdGhpcy52ID0gbXVsdGlwbGllZFZhbHVlO1xyXG4gICAgICAgIHRoaXMuX21kZiA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBpID0gMDtcclxuICAgICAgdmFyIGxlbiA9IHRoaXMudi5sZW5ndGg7XHJcbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgICAgbXVsdGlwbGllZFZhbHVlID0gdmFsW2ldICogdGhpcy5tdWx0O1xyXG4gICAgICAgIGlmIChtYXRoQWJzKHRoaXMudltpXSAtIG11bHRpcGxpZWRWYWx1ZSkgPiAwLjAwMDAxKSB7XHJcbiAgICAgICAgICB0aGlzLnZbaV0gPSBtdWx0aXBsaWVkVmFsdWU7XHJcbiAgICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHByb2Nlc3NFZmZlY3RzU2VxdWVuY2UoKSB7XHJcbiAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkIHx8ICF0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubG9jaykge1xyXG4gICAgICB0aGlzLnNldFZWYWx1ZSh0aGlzLnB2KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sb2NrID0gdHJ1ZTtcclxuICAgIHRoaXMuX21kZiA9IHRoaXMuX2lzRmlyc3RGcmFtZTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcclxuICAgIHZhciBmaW5hbFZhbHVlID0gdGhpcy5rZiA/IHRoaXMucHYgOiB0aGlzLmRhdGEuaztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0oZmluYWxWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnNldFZWYWx1ZShmaW5hbFZhbHVlKTtcclxuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5sb2NrID0gZmFsc2U7XHJcbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWRkRWZmZWN0KGVmZmVjdEZ1bmN0aW9uKSB7XHJcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZS5wdXNoKGVmZmVjdEZ1bmN0aW9uKTtcclxuICAgIHRoaXMuY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIFZhbHVlUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKSB7XHJcbiAgICB0aGlzLnByb3BUeXBlID0gJ3VuaWRpbWVuc2lvbmFsJztcclxuICAgIHRoaXMubXVsdCA9IG11bHQgfHwgMTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLnYgPSBtdWx0ID8gZGF0YS5rICogbXVsdCA6IGRhdGEuaztcclxuICAgIHRoaXMucHYgPSBkYXRhLms7XHJcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcclxuICAgIHRoaXMuayA9IGZhbHNlO1xyXG4gICAgdGhpcy5rZiA9IGZhbHNlO1xyXG4gICAgdGhpcy52ZWwgPSAwO1xyXG4gICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbXTtcclxuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XHJcbiAgICB0aGlzLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcclxuICAgIHRoaXMuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xyXG4gICAgdGhpcy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBNdWx0aURpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKSB7XHJcbiAgICB0aGlzLnByb3BUeXBlID0gJ211bHRpZGltZW5zaW9uYWwnO1xyXG4gICAgdGhpcy5tdWx0ID0gbXVsdCB8fCAxO1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xyXG4gICAgdGhpcy5rID0gZmFsc2U7XHJcbiAgICB0aGlzLmtmID0gZmFsc2U7XHJcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IGRhdGEuay5sZW5ndGg7XHJcbiAgICB0aGlzLnYgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgIHRoaXMucHYgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgIHRoaXMudmVsID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgdGhpcy52W2ldID0gZGF0YS5rW2ldICogdGhpcy5tdWx0O1xyXG4gICAgICB0aGlzLnB2W2ldID0gZGF0YS5rW2ldO1xyXG4gICAgfVxyXG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcclxuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW107XHJcbiAgICB0aGlzLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcclxuICAgIHRoaXMuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xyXG4gICAgdGhpcy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBLZXlmcmFtZWRWYWx1ZVByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcikge1xyXG4gICAgdGhpcy5wcm9wVHlwZSA9ICd1bmlkaW1lbnNpb25hbCc7XHJcbiAgICB0aGlzLmtleWZyYW1lcyA9IGRhdGEuaztcclxuICAgIHRoaXMub2Zmc2V0VGltZSA9IGVsZW0uZGF0YS5zdDtcclxuICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xyXG4gICAgdGhpcy5fY2FjaGluZyA9IHtcclxuICAgICAgbGFzdEZyYW1lOiBpbml0RnJhbWUsIGxhc3RJbmRleDogMCwgdmFsdWU6IDAsIF9sYXN0S2V5ZnJhbWVJbmRleDogLTEsXHJcbiAgICB9O1xyXG4gICAgdGhpcy5rID0gdHJ1ZTtcclxuICAgIHRoaXMua2YgPSB0cnVlO1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIHRoaXMubXVsdCA9IG11bHQgfHwgMTtcclxuICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcclxuICAgIHRoaXMudiA9IGluaXRGcmFtZTtcclxuICAgIHRoaXMucHYgPSBpbml0RnJhbWU7XHJcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gICAgdGhpcy5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XHJcbiAgICB0aGlzLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcclxuICAgIHRoaXMuaW50ZXJwb2xhdGVWYWx1ZSA9IGludGVycG9sYXRlVmFsdWU7XHJcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtnZXRWYWx1ZUF0Q3VycmVudFRpbWUuYmluZCh0aGlzKV07XHJcbiAgICB0aGlzLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIEtleWZyYW1lZE11bHRpZGltZW5zaW9uYWxQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpIHtcclxuICAgIHRoaXMucHJvcFR5cGUgPSAnbXVsdGlkaW1lbnNpb25hbCc7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBkYXRhLmsubGVuZ3RoO1xyXG4gICAgdmFyIHM7XHJcbiAgICB2YXIgZTtcclxuICAgIHZhciB0bztcclxuICAgIHZhciB0aTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpICs9IDEpIHtcclxuICAgICAgaWYgKGRhdGEua1tpXS50byAmJiBkYXRhLmtbaV0ucyAmJiBkYXRhLmtbaSArIDFdICYmIGRhdGEua1tpICsgMV0ucykge1xyXG4gICAgICAgIHMgPSBkYXRhLmtbaV0ucztcclxuICAgICAgICBlID0gZGF0YS5rW2kgKyAxXS5zO1xyXG4gICAgICAgIHRvID0gZGF0YS5rW2ldLnRvO1xyXG4gICAgICAgIHRpID0gZGF0YS5rW2ldLnRpO1xyXG4gICAgICAgIGlmICgocy5sZW5ndGggPT09IDIgJiYgIShzWzBdID09PSBlWzBdICYmIHNbMV0gPT09IGVbMV0pICYmIGJlei5wb2ludE9uTGluZTJEKHNbMF0sIHNbMV0sIGVbMF0sIGVbMV0sIHNbMF0gKyB0b1swXSwgc1sxXSArIHRvWzFdKSAmJiBiZXoucG9pbnRPbkxpbmUyRChzWzBdLCBzWzFdLCBlWzBdLCBlWzFdLCBlWzBdICsgdGlbMF0sIGVbMV0gKyB0aVsxXSkpIHx8IChzLmxlbmd0aCA9PT0gMyAmJiAhKHNbMF0gPT09IGVbMF0gJiYgc1sxXSA9PT0gZVsxXSAmJiBzWzJdID09PSBlWzJdKSAmJiBiZXoucG9pbnRPbkxpbmUzRChzWzBdLCBzWzFdLCBzWzJdLCBlWzBdLCBlWzFdLCBlWzJdLCBzWzBdICsgdG9bMF0sIHNbMV0gKyB0b1sxXSwgc1syXSArIHRvWzJdKSAmJiBiZXoucG9pbnRPbkxpbmUzRChzWzBdLCBzWzFdLCBzWzJdLCBlWzBdLCBlWzFdLCBlWzJdLCBlWzBdICsgdGlbMF0sIGVbMV0gKyB0aVsxXSwgZVsyXSArIHRpWzJdKSkpIHtcclxuICAgICAgICAgIGRhdGEua1tpXS50byA9IG51bGw7XHJcbiAgICAgICAgICBkYXRhLmtbaV0udGkgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc1swXSA9PT0gZVswXSAmJiBzWzFdID09PSBlWzFdICYmIHRvWzBdID09PSAwICYmIHRvWzFdID09PSAwICYmIHRpWzBdID09PSAwICYmIHRpWzFdID09PSAwKSB7XHJcbiAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDIgfHwgKHNbMl0gPT09IGVbMl0gJiYgdG9bMl0gPT09IDAgJiYgdGlbMl0gPT09IDApKSB7XHJcbiAgICAgICAgICAgIGRhdGEua1tpXS50byA9IG51bGw7XHJcbiAgICAgICAgICAgIGRhdGEua1tpXS50aSA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtnZXRWYWx1ZUF0Q3VycmVudFRpbWUuYmluZCh0aGlzKV07XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy5rZXlmcmFtZXMgPSBkYXRhLms7XHJcbiAgICB0aGlzLm9mZnNldFRpbWUgPSBlbGVtLmRhdGEuc3Q7XHJcbiAgICB0aGlzLmsgPSB0cnVlO1xyXG4gICAgdGhpcy5rZiA9IHRydWU7XHJcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gICAgdGhpcy5tdWx0ID0gbXVsdCB8fCAxO1xyXG4gICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xyXG4gICAgdGhpcy5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XHJcbiAgICB0aGlzLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcclxuICAgIHRoaXMuaW50ZXJwb2xhdGVWYWx1ZSA9IGludGVycG9sYXRlVmFsdWU7XHJcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcclxuICAgIHZhciBhcnJMZW4gPSBkYXRhLmtbMF0ucy5sZW5ndGg7XHJcbiAgICB0aGlzLnYgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgYXJyTGVuKTtcclxuICAgIHRoaXMucHYgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgYXJyTGVuKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnJMZW47IGkgKz0gMSkge1xyXG4gICAgICB0aGlzLnZbaV0gPSBpbml0RnJhbWU7XHJcbiAgICAgIHRoaXMucHZbaV0gPSBpbml0RnJhbWU7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9jYWNoaW5nID0geyBsYXN0RnJhbWU6IGluaXRGcmFtZSwgbGFzdEluZGV4OiAwLCB2YWx1ZTogY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGFyckxlbikgfTtcclxuICAgIHRoaXMuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UHJvcChlbGVtLCBkYXRhLCB0eXBlLCBtdWx0LCBjb250YWluZXIpIHtcclxuICAgIHZhciBwO1xyXG4gICAgaWYgKCFkYXRhLmsubGVuZ3RoKSB7XHJcbiAgICAgIHAgPSBuZXcgVmFsdWVQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgKGRhdGEua1swXSkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIHAgPSBuZXcgTXVsdGlEaW1lbnNpb25hbFByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICBwID0gbmV3IEtleWZyYW1lZFZhbHVlUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIHAgPSBuZXcgS2V5ZnJhbWVkTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcclxuICAgICAgY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eShwKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwO1xyXG4gIH1cclxuXHJcbiAgdmFyIG9iID0ge1xyXG4gICAgZ2V0UHJvcDogZ2V0UHJvcCxcclxuICB9O1xyXG4gIHJldHVybiBvYjtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBNYXRyaXgsIGRlZ1RvUmFkcywgUHJvcGVydHlGYWN0b3J5LCBleHRlbmRQcm90b3R5cGUsIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lciAqL1xyXG4vKiBleHBvcnRlZCBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkgKi9cclxuXHJcbnZhciBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBkZWZhdWx0VmVjdG9yID0gWzAsIDBdO1xyXG5cclxuICBmdW5jdGlvbiBhcHBseVRvTWF0cml4KG1hdCkge1xyXG4gICAgdmFyIF9tZGYgPSB0aGlzLl9tZGY7XHJcbiAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xyXG4gICAgdGhpcy5fbWRmID0gdGhpcy5fbWRmIHx8IF9tZGY7XHJcbiAgICBpZiAodGhpcy5hKSB7XHJcbiAgICAgIG1hdC50cmFuc2xhdGUoLXRoaXMuYS52WzBdLCAtdGhpcy5hLnZbMV0sIHRoaXMuYS52WzJdKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnMpIHtcclxuICAgICAgbWF0LnNjYWxlKHRoaXMucy52WzBdLCB0aGlzLnMudlsxXSwgdGhpcy5zLnZbMl0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuc2spIHtcclxuICAgICAgbWF0LnNrZXdGcm9tQXhpcygtdGhpcy5zay52LCB0aGlzLnNhLnYpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMucikge1xyXG4gICAgICBtYXQucm90YXRlKC10aGlzLnIudik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtYXQucm90YXRlWigtdGhpcy5yei52KS5yb3RhdGVZKHRoaXMucnkudikucm90YXRlWCh0aGlzLnJ4LnYpLnJvdGF0ZVooLXRoaXMub3IudlsyXSlcclxuICAgICAgICAucm90YXRlWSh0aGlzLm9yLnZbMV0pXHJcbiAgICAgICAgLnJvdGF0ZVgodGhpcy5vci52WzBdKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmRhdGEucC5zKSB7XHJcbiAgICAgIGlmICh0aGlzLmRhdGEucC56KSB7XHJcbiAgICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgLXRoaXMucHoudik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgMCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1hdC50cmFuc2xhdGUodGhpcy5wLnZbMF0sIHRoaXMucC52WzFdLCAtdGhpcy5wLnZbMl0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBwcm9jZXNzS2V5cyhmb3JjZVJlbmRlcikge1xyXG4gICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5faXNEaXJ0eSkge1xyXG4gICAgICB0aGlzLnByZWNhbGN1bGF0ZU1hdHJpeCgpO1xyXG4gICAgICB0aGlzLl9pc0RpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcclxuXHJcbiAgICBpZiAodGhpcy5fbWRmIHx8IGZvcmNlUmVuZGVyKSB7XHJcbiAgICAgIHZhciBmcmFtZVJhdGU7XHJcbiAgICAgIHRoaXMudi5jbG9uZUZyb21Qcm9wcyh0aGlzLnByZS5wcm9wcyk7XHJcbiAgICAgIGlmICh0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAxKSB7XHJcbiAgICAgICAgdGhpcy52LnRyYW5zbGF0ZSgtdGhpcy5hLnZbMF0sIC10aGlzLmEudlsxXSwgdGhpcy5hLnZbMl0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAyKSB7XHJcbiAgICAgICAgdGhpcy52LnNjYWxlKHRoaXMucy52WzBdLCB0aGlzLnMudlsxXSwgdGhpcy5zLnZbMl0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnNrICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDMpIHtcclxuICAgICAgICB0aGlzLnYuc2tld0Zyb21BeGlzKC10aGlzLnNrLnYsIHRoaXMuc2Eudik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuciAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCA0KSB7XHJcbiAgICAgICAgdGhpcy52LnJvdGF0ZSgtdGhpcy5yLnYpO1xyXG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLnIgJiYgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgNCkge1xyXG4gICAgICAgIHRoaXMudi5yb3RhdGVaKC10aGlzLnJ6LnYpLnJvdGF0ZVkodGhpcy5yeS52KS5yb3RhdGVYKHRoaXMucngudikucm90YXRlWigtdGhpcy5vci52WzJdKVxyXG4gICAgICAgICAgLnJvdGF0ZVkodGhpcy5vci52WzFdKVxyXG4gICAgICAgICAgLnJvdGF0ZVgodGhpcy5vci52WzBdKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5hdXRvT3JpZW50ZWQpIHtcclxuICAgICAgICB2YXIgdjE7XHJcbiAgICAgICAgdmFyIHYyO1xyXG4gICAgICAgIGZyYW1lUmF0ZSA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgICAgICBpZiAodGhpcy5wICYmIHRoaXMucC5rZXlmcmFtZXMgJiYgdGhpcy5wLmdldFZhbHVlQXRUaW1lKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5wLl9jYWNoaW5nLmxhc3RGcmFtZSArIHRoaXMucC5vZmZzZXRUaW1lIDw9IHRoaXMucC5rZXlmcmFtZXNbMF0udCkge1xyXG4gICAgICAgICAgICB2MSA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSgodGhpcy5wLmtleWZyYW1lc1swXS50ICsgMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgICB2MiA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSh0aGlzLnAua2V5ZnJhbWVzWzBdLnQgLyBmcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnAuX2NhY2hpbmcubGFzdEZyYW1lICsgdGhpcy5wLm9mZnNldFRpbWUgPj0gdGhpcy5wLmtleWZyYW1lc1t0aGlzLnAua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQpIHtcclxuICAgICAgICAgICAgdjEgPSB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUoKHRoaXMucC5rZXlmcmFtZXNbdGhpcy5wLmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC8gZnJhbWVSYXRlKSwgMCk7XHJcbiAgICAgICAgICAgIHYyID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKCh0aGlzLnAua2V5ZnJhbWVzW3RoaXMucC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAtIDAuMDUpIC8gZnJhbWVSYXRlLCAwKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHYxID0gdGhpcy5wLnB2O1xyXG4gICAgICAgICAgICB2MiA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSgodGhpcy5wLl9jYWNoaW5nLmxhc3RGcmFtZSArIHRoaXMucC5vZmZzZXRUaW1lIC0gMC4wMSkgLyBmcmFtZVJhdGUsIHRoaXMucC5vZmZzZXRUaW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHggJiYgdGhpcy5weC5rZXlmcmFtZXMgJiYgdGhpcy5weS5rZXlmcmFtZXMgJiYgdGhpcy5weC5nZXRWYWx1ZUF0VGltZSAmJiB0aGlzLnB5LmdldFZhbHVlQXRUaW1lKSB7XHJcbiAgICAgICAgICB2MSA9IFtdO1xyXG4gICAgICAgICAgdjIgPSBbXTtcclxuICAgICAgICAgIHZhciBweCA9IHRoaXMucHg7XHJcbiAgICAgICAgICB2YXIgcHkgPSB0aGlzLnB5O1xyXG4gICAgICAgICAgaWYgKHB4Ll9jYWNoaW5nLmxhc3RGcmFtZSArIHB4Lm9mZnNldFRpbWUgPD0gcHgua2V5ZnJhbWVzWzBdLnQpIHtcclxuICAgICAgICAgICAgdjFbMF0gPSBweC5nZXRWYWx1ZUF0VGltZSgocHgua2V5ZnJhbWVzWzBdLnQgKyAwLjAxKSAvIGZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgICAgICAgIHYxWzFdID0gcHkuZ2V0VmFsdWVBdFRpbWUoKHB5LmtleWZyYW1lc1swXS50ICsgMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgICB2MlswXSA9IHB4LmdldFZhbHVlQXRUaW1lKChweC5rZXlmcmFtZXNbMF0udCkgLyBmcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgICB2MlsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5rZXlmcmFtZXNbMF0udCkgLyBmcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChweC5fY2FjaGluZy5sYXN0RnJhbWUgKyBweC5vZmZzZXRUaW1lID49IHB4LmtleWZyYW1lc1tweC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCkge1xyXG4gICAgICAgICAgICB2MVswXSA9IHB4LmdldFZhbHVlQXRUaW1lKChweC5rZXlmcmFtZXNbcHgua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLyBmcmFtZVJhdGUpLCAwKTtcclxuICAgICAgICAgICAgdjFbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkua2V5ZnJhbWVzW3B5LmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC8gZnJhbWVSYXRlKSwgMCk7XHJcbiAgICAgICAgICAgIHYyWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUoKHB4LmtleWZyYW1lc1tweC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAtIDAuMDEpIC8gZnJhbWVSYXRlLCAwKTtcclxuICAgICAgICAgICAgdjJbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkua2V5ZnJhbWVzW3B5LmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdjEgPSBbcHgucHYsIHB5LnB2XTtcclxuICAgICAgICAgICAgdjJbMF0gPSBweC5nZXRWYWx1ZUF0VGltZSgocHguX2NhY2hpbmcubGFzdEZyYW1lICsgcHgub2Zmc2V0VGltZSAtIDAuMDEpIC8gZnJhbWVSYXRlLCBweC5vZmZzZXRUaW1lKTtcclxuICAgICAgICAgICAgdjJbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkuX2NhY2hpbmcubGFzdEZyYW1lICsgcHkub2Zmc2V0VGltZSAtIDAuMDEpIC8gZnJhbWVSYXRlLCBweS5vZmZzZXRUaW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdjIgPSBkZWZhdWx0VmVjdG9yO1xyXG4gICAgICAgICAgdjEgPSB2MjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52LnJvdGF0ZSgtTWF0aC5hdGFuMih2MVsxXSAtIHYyWzFdLCB2MVswXSAtIHYyWzBdKSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuZGF0YS5wICYmIHRoaXMuZGF0YS5wLnMpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLnAueikge1xyXG4gICAgICAgICAgdGhpcy52LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgLXRoaXMucHoudik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMudi50cmFuc2xhdGUodGhpcy5weC52LCB0aGlzLnB5LnYsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnYudHJhbnNsYXRlKHRoaXMucC52WzBdLCB0aGlzLnAudlsxXSwgLXRoaXMucC52WzJdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHByZWNhbGN1bGF0ZU1hdHJpeCgpIHtcclxuICAgIGlmICghdGhpcy5hLmspIHtcclxuICAgICAgdGhpcy5wcmUudHJhbnNsYXRlKC10aGlzLmEudlswXSwgLXRoaXMuYS52WzFdLCB0aGlzLmEudlsyXSk7XHJcbiAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIXRoaXMucy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMucHJlLnNjYWxlKHRoaXMucy52WzBdLCB0aGlzLnMudlsxXSwgdGhpcy5zLnZbMl0pO1xyXG4gICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuc2spIHtcclxuICAgICAgaWYgKCF0aGlzLnNrLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMuc2EuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMucHJlLnNrZXdGcm9tQXhpcygtdGhpcy5zay52LCB0aGlzLnNhLnYpO1xyXG4gICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5yKSB7XHJcbiAgICAgIGlmICghdGhpcy5yLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLnByZS5yb3RhdGUoLXRoaXMuci52KTtcclxuICAgICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSA0O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnJ6LmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMucnkuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAmJiAhdGhpcy5yeC5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICYmICF0aGlzLm9yLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5wcmUucm90YXRlWigtdGhpcy5yei52KS5yb3RhdGVZKHRoaXMucnkudikucm90YXRlWCh0aGlzLnJ4LnYpLnJvdGF0ZVooLXRoaXMub3IudlsyXSlcclxuICAgICAgICAucm90YXRlWSh0aGlzLm9yLnZbMV0pXHJcbiAgICAgICAgLnJvdGF0ZVgodGhpcy5vci52WzBdKTtcclxuICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gNDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGF1dG9PcmllbnQoKSB7XHJcbiAgICAvL1xyXG4gICAgLy8gdmFyIHByZXZQID0gdGhpcy5nZXRWYWx1ZUF0VGltZSgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApIHtcclxuICAgIHRoaXMuX2FkZER5bmFtaWNQcm9wZXJ0eShwcm9wKTtcclxuICAgIHRoaXMuZWxlbS5hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XHJcbiAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcikge1xyXG4gICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xyXG4gICAgdGhpcy5wcm9wVHlwZSA9ICd0cmFuc2Zvcm0nO1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIHRoaXMudiA9IG5ldyBNYXRyaXgoKTtcclxuICAgIC8vIFByZWNhbGN1bGF0ZWQgbWF0cml4IHdpdGggbm9uIGFuaW1hdGVkIHByb3BlcnRpZXNcclxuICAgIHRoaXMucHJlID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMDtcclxuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihjb250YWluZXIgfHwgZWxlbSk7XHJcbiAgICBpZiAoZGF0YS5wICYmIGRhdGEucC5zKSB7XHJcbiAgICAgIHRoaXMucHggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAueCwgMCwgMCwgdGhpcyk7XHJcbiAgICAgIHRoaXMucHkgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAueSwgMCwgMCwgdGhpcyk7XHJcbiAgICAgIGlmIChkYXRhLnAueikge1xyXG4gICAgICAgIHRoaXMucHogPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAueiwgMCwgMCwgdGhpcyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucCB8fCB7IGs6IFswLCAwLCAwXSB9LCAxLCAwLCB0aGlzKTtcclxuICAgIH1cclxuICAgIGlmIChkYXRhLnJ4KSB7XHJcbiAgICAgIHRoaXMucnggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnJ4LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gICAgICB0aGlzLnJ5ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yeSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcclxuICAgICAgdGhpcy5yeiA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucnosIDAsIGRlZ1RvUmFkcywgdGhpcyk7XHJcbiAgICAgIGlmIChkYXRhLm9yLmtbMF0udGkpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgbGVuID0gZGF0YS5vci5rLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgIGRhdGEub3Iua1tpXS50byA9IG51bGw7XHJcbiAgICAgICAgICBkYXRhLm9yLmtbaV0udGkgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLm9yID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vciwgMSwgZGVnVG9SYWRzLCB0aGlzKTtcclxuICAgICAgLy8gc2ggSW5kaWNhdGVzIGl0IG5lZWRzIHRvIGJlIGNhcHBlZCBiZXR3ZWVuIC0xODAgYW5kIDE4MFxyXG4gICAgICB0aGlzLm9yLnNoID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuciA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuciB8fCB7IGs6IDAgfSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcclxuICAgIH1cclxuICAgIGlmIChkYXRhLnNrKSB7XHJcbiAgICAgIHRoaXMuc2sgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnNrLCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gICAgICB0aGlzLnNhID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zYSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcclxuICAgIH1cclxuICAgIHRoaXMuYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSB8fCB7IGs6IFswLCAwLCAwXSB9LCAxLCAwLCB0aGlzKTtcclxuICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucyB8fCB7IGs6IFsxMDAsIDEwMCwgMTAwXSB9LCAxLCAwLjAxLCB0aGlzKTtcclxuICAgIC8vIE9wYWNpdHkgaXMgbm90IHBhcnQgb2YgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzLCB0aGF0J3Mgd2h5IGl0IHdvbid0IHVzZSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLiBUaGF0IHdheSB0cmFuc2Zvcm1zIHdvbid0IGdldCB1cGRhdGVkIGlmIG9wYWNpdHkgY2hhbmdlcy5cclxuICAgIGlmIChkYXRhLm8pIHtcclxuICAgICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vLCAwLCAwLjAxLCBlbGVtKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubyA9IHsgX21kZjogZmFsc2UsIHY6IDEgfTtcclxuICAgIH1cclxuICAgIHRoaXMuX2lzRGlydHkgPSB0cnVlO1xyXG4gICAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgVHJhbnNmb3JtUHJvcGVydHkucHJvdG90eXBlID0ge1xyXG4gICAgYXBwbHlUb01hdHJpeDogYXBwbHlUb01hdHJpeCxcclxuICAgIGdldFZhbHVlOiBwcm9jZXNzS2V5cyxcclxuICAgIHByZWNhbGN1bGF0ZU1hdHJpeDogcHJlY2FsY3VsYXRlTWF0cml4LFxyXG4gICAgYXV0b09yaWVudDogYXV0b09yaWVudCxcclxuICB9O1xyXG5cclxuICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFRyYW5zZm9ybVByb3BlcnR5KTtcclxuICBUcmFuc2Zvcm1Qcm9wZXJ0eS5wcm90b3R5cGUuYWRkRHluYW1pY1Byb3BlcnR5ID0gYWRkRHluYW1pY1Byb3BlcnR5O1xyXG4gIFRyYW5zZm9ybVByb3BlcnR5LnByb3RvdHlwZS5fYWRkRHluYW1pY1Byb3BlcnR5ID0gRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyLnByb3RvdHlwZS5hZGREeW5hbWljUHJvcGVydHk7XHJcblxyXG4gIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcikge1xyXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1Qcm9wZXJ0eShlbGVtLCBkYXRhLCBjb250YWluZXIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGdldFRyYW5zZm9ybVByb3BlcnR5OiBnZXRUcmFuc2Zvcm1Qcm9wZXJ0eSxcclxuICB9O1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZVNpemVkQXJyYXksIGNyZWF0ZVNpemVkQXJyYXksIHBvaW50UG9vbCAqL1xyXG5cclxuZnVuY3Rpb24gU2hhcGVQYXRoKCkge1xyXG4gIHRoaXMuYyA9IGZhbHNlO1xyXG4gIHRoaXMuX2xlbmd0aCA9IDA7XHJcbiAgdGhpcy5fbWF4TGVuZ3RoID0gODtcclxuICB0aGlzLnYgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCk7XHJcbiAgdGhpcy5vID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpO1xyXG4gIHRoaXMuaSA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKTtcclxufVxyXG5cclxuU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRQYXRoRGF0YSA9IGZ1bmN0aW9uIChjbG9zZWQsIGxlbikge1xyXG4gIHRoaXMuYyA9IGNsb3NlZDtcclxuICB0aGlzLnNldExlbmd0aChsZW4pO1xyXG4gIHZhciBpID0gMDtcclxuICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgdGhpcy52W2ldID0gcG9pbnRQb29sLm5ld0VsZW1lbnQoKTtcclxuICAgIHRoaXMub1tpXSA9IHBvaW50UG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgICB0aGlzLmlbaV0gPSBwb2ludFBvb2wubmV3RWxlbWVudCgpO1xyXG4gICAgaSArPSAxO1xyXG4gIH1cclxufTtcclxuXHJcblNoYXBlUGF0aC5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xyXG4gIHdoaWxlICh0aGlzLl9tYXhMZW5ndGggPCBsZW4pIHtcclxuICAgIHRoaXMuZG91YmxlQXJyYXlMZW5ndGgoKTtcclxuICB9XHJcbiAgdGhpcy5fbGVuZ3RoID0gbGVuO1xyXG59O1xyXG5cclxuU2hhcGVQYXRoLnByb3RvdHlwZS5kb3VibGVBcnJheUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnYgPSB0aGlzLnYuY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKSk7XHJcbiAgdGhpcy5pID0gdGhpcy5pLmNvbmNhdChjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCkpO1xyXG4gIHRoaXMubyA9IHRoaXMuby5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpKTtcclxuICB0aGlzLl9tYXhMZW5ndGggKj0gMjtcclxufTtcclxuXHJcblNoYXBlUGF0aC5wcm90b3R5cGUuc2V0WFlBdCA9IGZ1bmN0aW9uICh4LCB5LCB0eXBlLCBwb3MsIHJlcGxhY2UpIHtcclxuICB2YXIgYXJyO1xyXG4gIHRoaXMuX2xlbmd0aCA9IE1hdGgubWF4KHRoaXMuX2xlbmd0aCwgcG9zICsgMSk7XHJcbiAgaWYgKHRoaXMuX2xlbmd0aCA+PSB0aGlzLl9tYXhMZW5ndGgpIHtcclxuICAgIHRoaXMuZG91YmxlQXJyYXlMZW5ndGgoKTtcclxuICB9XHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlICd2JzpcclxuICAgICAgYXJyID0gdGhpcy52O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2knOlxyXG4gICAgICBhcnIgPSB0aGlzLmk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnbyc6XHJcbiAgICAgIGFyciA9IHRoaXMubztcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBhcnIgPSBbXTtcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIGlmICghYXJyW3Bvc10gfHwgKGFycltwb3NdICYmICFyZXBsYWNlKSkge1xyXG4gICAgYXJyW3Bvc10gPSBwb2ludFBvb2wubmV3RWxlbWVudCgpO1xyXG4gIH1cclxuICBhcnJbcG9zXVswXSA9IHg7XHJcbiAgYXJyW3Bvc11bMV0gPSB5O1xyXG59O1xyXG5cclxuU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRUcmlwbGVBdCA9IGZ1bmN0aW9uICh2WCwgdlksIG9YLCBvWSwgaVgsIGlZLCBwb3MsIHJlcGxhY2UpIHtcclxuICB0aGlzLnNldFhZQXQodlgsIHZZLCAndicsIHBvcywgcmVwbGFjZSk7XHJcbiAgdGhpcy5zZXRYWUF0KG9YLCBvWSwgJ28nLCBwb3MsIHJlcGxhY2UpO1xyXG4gIHRoaXMuc2V0WFlBdChpWCwgaVksICdpJywgcG9zLCByZXBsYWNlKTtcclxufTtcclxuXHJcblNoYXBlUGF0aC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbmV3UGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcclxuICBuZXdQYXRoLnNldFBhdGhEYXRhKHRoaXMuYywgdGhpcy5fbGVuZ3RoKTtcclxuICB2YXIgdmVydGljZXMgPSB0aGlzLnY7XHJcbiAgdmFyIG91dFBvaW50cyA9IHRoaXMubztcclxuICB2YXIgaW5Qb2ludHMgPSB0aGlzLmk7XHJcbiAgdmFyIGluaXQgPSAwO1xyXG4gIGlmICh0aGlzLmMpIHtcclxuICAgIG5ld1BhdGguc2V0VHJpcGxlQXQodmVydGljZXNbMF1bMF0sIHZlcnRpY2VzWzBdWzFdLCBpblBvaW50c1swXVswXSwgaW5Qb2ludHNbMF1bMV0sIG91dFBvaW50c1swXVswXSwgb3V0UG9pbnRzWzBdWzFdLCAwLCBmYWxzZSk7XHJcbiAgICBpbml0ID0gMTtcclxuICB9XHJcbiAgdmFyIGNudCA9IHRoaXMuX2xlbmd0aCAtIDE7XHJcbiAgdmFyIGxlbiA9IHRoaXMuX2xlbmd0aDtcclxuXHJcbiAgdmFyIGk7XHJcbiAgZm9yIChpID0gaW5pdDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBuZXdQYXRoLnNldFRyaXBsZUF0KHZlcnRpY2VzW2NudF1bMF0sIHZlcnRpY2VzW2NudF1bMV0sIGluUG9pbnRzW2NudF1bMF0sIGluUG9pbnRzW2NudF1bMV0sIG91dFBvaW50c1tjbnRdWzBdLCBvdXRQb2ludHNbY250XVsxXSwgaSwgZmFsc2UpO1xyXG4gICAgY250IC09IDE7XHJcbiAgfVxyXG4gIHJldHVybiBuZXdQYXRoO1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgcm91bmRDb3JuZXIsIEJlemllckZhY3RvcnksIHNoYXBlUG9vbCwgZGVnVG9SYWRzLFxyXG4gIHNoYXBlQ29sbGVjdGlvblBvb2wsIFByb3BlcnR5RmFjdG9yeSwgYm1NaW4sIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lciAqL1xyXG4vKiBleHBvcnRlZCBTaGFwZVByb3BlcnR5RmFjdG9yeSAqL1xyXG5cclxudmFyIFNoYXBlUHJvcGVydHlGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaW5pdEZyYW1lID0gLTk5OTk5OTtcclxuXHJcbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVTaGFwZShmcmFtZU51bSwgcHJldmlvdXNWYWx1ZSwgY2FjaGluZykge1xyXG4gICAgdmFyIGl0ZXJhdGlvbkluZGV4ID0gY2FjaGluZy5sYXN0SW5kZXg7XHJcbiAgICB2YXIga2V5UHJvcFM7XHJcbiAgICB2YXIga2V5UHJvcEU7XHJcbiAgICB2YXIgaXNIb2xkO1xyXG4gICAgdmFyIGo7XHJcbiAgICB2YXIgaztcclxuICAgIHZhciBqTGVuO1xyXG4gICAgdmFyIGtMZW47XHJcbiAgICB2YXIgcGVyYztcclxuICAgIHZhciB2ZXJ0ZXhWYWx1ZTtcclxuICAgIHZhciBrZiA9IHRoaXMua2V5ZnJhbWVzO1xyXG4gICAgaWYgKGZyYW1lTnVtIDwga2ZbMF0udCAtIHRoaXMub2Zmc2V0VGltZSkge1xyXG4gICAgICBrZXlQcm9wUyA9IGtmWzBdLnNbMF07XHJcbiAgICAgIGlzSG9sZCA9IHRydWU7XHJcbiAgICAgIGl0ZXJhdGlvbkluZGV4ID0gMDtcclxuICAgIH0gZWxzZSBpZiAoZnJhbWVOdW0gPj0ga2Zba2YubGVuZ3RoIC0gMV0udCAtIHRoaXMub2Zmc2V0VGltZSkge1xyXG4gICAgICBrZXlQcm9wUyA9IGtmW2tmLmxlbmd0aCAtIDFdLnMgPyBrZltrZi5sZW5ndGggLSAxXS5zWzBdIDoga2Zba2YubGVuZ3RoIC0gMl0uZVswXTtcclxuICAgICAgLyogaWYoa2Zba2YubGVuZ3RoIC0gMV0ucyl7XHJcbiAgICAgICAgICAgICAgICBrZXlQcm9wUyA9IGtmW2tmLmxlbmd0aCAtIDFdLnNbMF07XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAga2V5UHJvcFMgPSBrZltrZi5sZW5ndGggLSAyXS5lWzBdO1xyXG4gICAgICAgICAgICB9ICovXHJcbiAgICAgIGlzSG9sZCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgaSA9IGl0ZXJhdGlvbkluZGV4O1xyXG4gICAgICB2YXIgbGVuID0ga2YubGVuZ3RoIC0gMTtcclxuICAgICAgdmFyIGZsYWcgPSB0cnVlO1xyXG4gICAgICB2YXIga2V5RGF0YTtcclxuICAgICAgdmFyIG5leHRLZXlEYXRhO1xyXG4gICAgICB3aGlsZSAoZmxhZykge1xyXG4gICAgICAgIGtleURhdGEgPSBrZltpXTtcclxuICAgICAgICBuZXh0S2V5RGF0YSA9IGtmW2kgKyAxXTtcclxuICAgICAgICBpZiAoKG5leHRLZXlEYXRhLnQgLSB0aGlzLm9mZnNldFRpbWUpID4gZnJhbWVOdW0pIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcclxuICAgICAgICAgIGkgKz0gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpc0hvbGQgPSBrZXlEYXRhLmggPT09IDE7XHJcbiAgICAgIGl0ZXJhdGlvbkluZGV4ID0gaTtcclxuICAgICAgaWYgKCFpc0hvbGQpIHtcclxuICAgICAgICBpZiAoZnJhbWVOdW0gPj0gbmV4dEtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSkge1xyXG4gICAgICAgICAgcGVyYyA9IDE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmcmFtZU51bSA8IGtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSkge1xyXG4gICAgICAgICAgcGVyYyA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciBmbmM7XHJcbiAgICAgICAgICBpZiAoa2V5RGF0YS5fX2ZuY3QpIHtcclxuICAgICAgICAgICAgZm5jID0ga2V5RGF0YS5fX2ZuY3Q7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhrZXlEYXRhLm8ueCwga2V5RGF0YS5vLnksIGtleURhdGEuaS54LCBrZXlEYXRhLmkueSkuZ2V0O1xyXG4gICAgICAgICAgICBrZXlEYXRhLl9fZm5jdCA9IGZuYztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBlcmMgPSBmbmMoKGZyYW1lTnVtIC0gKGtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSkpIC8gKChuZXh0S2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSAtIChrZXlEYXRhLnQgLSB0aGlzLm9mZnNldFRpbWUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleVByb3BFID0gbmV4dEtleURhdGEucyA/IG5leHRLZXlEYXRhLnNbMF0gOiBrZXlEYXRhLmVbMF07XHJcbiAgICAgIH1cclxuICAgICAga2V5UHJvcFMgPSBrZXlEYXRhLnNbMF07XHJcbiAgICB9XHJcbiAgICBqTGVuID0gcHJldmlvdXNWYWx1ZS5fbGVuZ3RoO1xyXG4gICAga0xlbiA9IGtleVByb3BTLmlbMF0ubGVuZ3RoO1xyXG4gICAgY2FjaGluZy5sYXN0SW5kZXggPSBpdGVyYXRpb25JbmRleDtcclxuXHJcbiAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcclxuICAgICAgICB2ZXJ0ZXhWYWx1ZSA9IGlzSG9sZCA/IGtleVByb3BTLmlbal1ba10gOiBrZXlQcm9wUy5pW2pdW2tdICsgKGtleVByb3BFLmlbal1ba10gLSBrZXlQcm9wUy5pW2pdW2tdKSAqIHBlcmM7XHJcbiAgICAgICAgcHJldmlvdXNWYWx1ZS5pW2pdW2tdID0gdmVydGV4VmFsdWU7XHJcbiAgICAgICAgdmVydGV4VmFsdWUgPSBpc0hvbGQgPyBrZXlQcm9wUy5vW2pdW2tdIDoga2V5UHJvcFMub1tqXVtrXSArIChrZXlQcm9wRS5vW2pdW2tdIC0ga2V5UHJvcFMub1tqXVtrXSkgKiBwZXJjO1xyXG4gICAgICAgIHByZXZpb3VzVmFsdWUub1tqXVtrXSA9IHZlcnRleFZhbHVlO1xyXG4gICAgICAgIHZlcnRleFZhbHVlID0gaXNIb2xkID8ga2V5UHJvcFMudltqXVtrXSA6IGtleVByb3BTLnZbal1ba10gKyAoa2V5UHJvcEUudltqXVtrXSAtIGtleVByb3BTLnZbal1ba10pICogcGVyYztcclxuICAgICAgICBwcmV2aW91c1ZhbHVlLnZbal1ba10gPSB2ZXJ0ZXhWYWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVTaGFwZUN1cnJlbnRUaW1lKCkge1xyXG4gICAgdmFyIGZyYW1lTnVtID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLm9mZnNldFRpbWU7XHJcbiAgICB2YXIgaW5pdFRpbWUgPSB0aGlzLmtleWZyYW1lc1swXS50IC0gdGhpcy5vZmZzZXRUaW1lO1xyXG4gICAgdmFyIGVuZFRpbWUgPSB0aGlzLmtleWZyYW1lc1t0aGlzLmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gdGhpcy5vZmZzZXRUaW1lO1xyXG4gICAgdmFyIGxhc3RGcmFtZSA9IHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lO1xyXG4gICAgaWYgKCEobGFzdEZyYW1lICE9PSBpbml0RnJhbWUgJiYgKChsYXN0RnJhbWUgPCBpbml0VGltZSAmJiBmcmFtZU51bSA8IGluaXRUaW1lKSB8fCAobGFzdEZyYW1lID4gZW5kVGltZSAmJiBmcmFtZU51bSA+IGVuZFRpbWUpKSkpIHtcclxuICAgICAgLy8vIC9cclxuICAgICAgdGhpcy5fY2FjaGluZy5sYXN0SW5kZXggPSBsYXN0RnJhbWUgPCBmcmFtZU51bSA/IHRoaXMuX2NhY2hpbmcubGFzdEluZGV4IDogMDtcclxuICAgICAgdGhpcy5pbnRlcnBvbGF0ZVNoYXBlKGZyYW1lTnVtLCB0aGlzLnB2LCB0aGlzLl9jYWNoaW5nKTtcclxuICAgICAgLy8vIC9cclxuICAgIH1cclxuICAgIHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lID0gZnJhbWVOdW07XHJcbiAgICByZXR1cm4gdGhpcy5wdjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2V0U2hhcGUoKSB7XHJcbiAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNoYXBlc0VxdWFsKHNoYXBlMSwgc2hhcGUyKSB7XHJcbiAgICBpZiAoc2hhcGUxLl9sZW5ndGggIT09IHNoYXBlMi5fbGVuZ3RoIHx8IHNoYXBlMS5jICE9PSBzaGFwZTIuYykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBzaGFwZTEuX2xlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBpZiAoc2hhcGUxLnZbaV1bMF0gIT09IHNoYXBlMi52W2ldWzBdXHJcbiAgICAgICAgICAgIHx8IHNoYXBlMS52W2ldWzFdICE9PSBzaGFwZTIudltpXVsxXVxyXG4gICAgICAgICAgICB8fCBzaGFwZTEub1tpXVswXSAhPT0gc2hhcGUyLm9baV1bMF1cclxuICAgICAgICAgICAgfHwgc2hhcGUxLm9baV1bMV0gIT09IHNoYXBlMi5vW2ldWzFdXHJcbiAgICAgICAgICAgIHx8IHNoYXBlMS5pW2ldWzBdICE9PSBzaGFwZTIuaVtpXVswXVxyXG4gICAgICAgICAgICB8fCBzaGFwZTEuaVtpXVsxXSAhPT0gc2hhcGUyLmlbaV1bMV0pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0VlZhbHVlKG5ld1BhdGgpIHtcclxuICAgIGlmICghc2hhcGVzRXF1YWwodGhpcy52LCBuZXdQYXRoKSkge1xyXG4gICAgICB0aGlzLnYgPSBzaGFwZVBvb2wuY2xvbmUobmV3UGF0aCk7XHJcbiAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xyXG4gICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMudik7XHJcbiAgICAgIHRoaXMuX21kZiA9IHRydWU7XHJcbiAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZSgpIHtcclxuICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSBpZiAoIXRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubG9jaykge1xyXG4gICAgICB0aGlzLnNldFZWYWx1ZSh0aGlzLnB2KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sb2NrID0gdHJ1ZTtcclxuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gICAgdmFyIGZpbmFsVmFsdWU7XHJcbiAgICBpZiAodGhpcy5rZikge1xyXG4gICAgICBmaW5hbFZhbHVlID0gdGhpcy5wdjtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmtzKSB7XHJcbiAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmRhdGEua3MuaztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmRhdGEucHQuaztcclxuICAgIH1cclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0oZmluYWxWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnNldFZWYWx1ZShmaW5hbFZhbHVlKTtcclxuICAgIHRoaXMubG9jayA9IGZhbHNlO1xyXG4gICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIFNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSwgdHlwZSkge1xyXG4gICAgdGhpcy5wcm9wVHlwZSA9ICdzaGFwZSc7XHJcbiAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XHJcbiAgICB0aGlzLmNvbnRhaW5lciA9IGVsZW07XHJcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIHRoaXMuayA9IGZhbHNlO1xyXG4gICAgdGhpcy5rZiA9IGZhbHNlO1xyXG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgICB2YXIgcGF0aERhdGEgPSB0eXBlID09PSAzID8gZGF0YS5wdC5rIDogZGF0YS5rcy5rO1xyXG4gICAgdGhpcy52ID0gc2hhcGVQb29sLmNsb25lKHBhdGhEYXRhKTtcclxuICAgIHRoaXMucHYgPSBzaGFwZVBvb2wuY2xvbmUodGhpcy52KTtcclxuICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZUNvbGxlY3Rpb25Qb29sLm5ld1NoYXBlQ29sbGVjdGlvbigpO1xyXG4gICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICB0aGlzLnBhdGhzLmFkZFNoYXBlKHRoaXMudik7XHJcbiAgICB0aGlzLnJlc2V0ID0gcmVzZXRTaGFwZTtcclxuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW107XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGRFZmZlY3QoZWZmZWN0RnVuY3Rpb24pIHtcclxuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlLnB1c2goZWZmZWN0RnVuY3Rpb24pO1xyXG4gICAgdGhpcy5jb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuaW50ZXJwb2xhdGVTaGFwZSA9IGludGVycG9sYXRlU2hhcGU7XHJcbiAgU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xyXG4gIFNoYXBlUHJvcGVydHkucHJvdG90eXBlLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcclxuICBTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XHJcblxyXG4gIGZ1bmN0aW9uIEtleWZyYW1lZFNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSwgdHlwZSkge1xyXG4gICAgdGhpcy5wcm9wVHlwZSA9ICdzaGFwZSc7XHJcbiAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XHJcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgdGhpcy5jb250YWluZXIgPSBlbGVtO1xyXG4gICAgdGhpcy5vZmZzZXRUaW1lID0gZWxlbS5kYXRhLnN0O1xyXG4gICAgdGhpcy5rZXlmcmFtZXMgPSB0eXBlID09PSAzID8gZGF0YS5wdC5rIDogZGF0YS5rcy5rO1xyXG4gICAgdGhpcy5rID0gdHJ1ZTtcclxuICAgIHRoaXMua2YgPSB0cnVlO1xyXG4gICAgdmFyIGxlbiA9IHRoaXMua2V5ZnJhbWVzWzBdLnNbMF0uaS5sZW5ndGg7XHJcbiAgICB0aGlzLnYgPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xyXG4gICAgdGhpcy52LnNldFBhdGhEYXRhKHRoaXMua2V5ZnJhbWVzWzBdLnNbMF0uYywgbGVuKTtcclxuICAgIHRoaXMucHYgPSBzaGFwZVBvb2wuY2xvbmUodGhpcy52KTtcclxuICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZUNvbGxlY3Rpb25Qb29sLm5ld1NoYXBlQ29sbGVjdGlvbigpO1xyXG4gICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICB0aGlzLnBhdGhzLmFkZFNoYXBlKHRoaXMudik7XHJcbiAgICB0aGlzLmxhc3RGcmFtZSA9IGluaXRGcmFtZTtcclxuICAgIHRoaXMucmVzZXQgPSByZXNldFNoYXBlO1xyXG4gICAgdGhpcy5fY2FjaGluZyA9IHsgbGFzdEZyYW1lOiBpbml0RnJhbWUsIGxhc3RJbmRleDogMCB9O1xyXG4gICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbaW50ZXJwb2xhdGVTaGFwZUN1cnJlbnRUaW1lLmJpbmQodGhpcyldO1xyXG4gIH1cclxuICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XHJcbiAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuaW50ZXJwb2xhdGVTaGFwZSA9IGludGVycG9sYXRlU2hhcGU7XHJcbiAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xyXG4gIEtleWZyYW1lZFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcclxuXHJcbiAgdmFyIEVsbFNoYXBlUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGNQb2ludCA9IHJvdW5kQ29ybmVyO1xyXG5cclxuICAgIGZ1bmN0aW9uIEVsbFNoYXBlUHJvcGVydHlGYWN0b3J5KGVsZW0sIGRhdGEpIHtcclxuICAgICAgLyogdGhpcy52ID0ge1xyXG4gICAgICAgICAgICAgICAgdjogY3JlYXRlU2l6ZWRBcnJheSg0KSxcclxuICAgICAgICAgICAgICAgIGk6IGNyZWF0ZVNpemVkQXJyYXkoNCksXHJcbiAgICAgICAgICAgICAgICBvOiBjcmVhdGVTaXplZEFycmF5KDQpLFxyXG4gICAgICAgICAgICAgICAgYzogdHJ1ZVxyXG4gICAgICAgICAgICB9OyAqL1xyXG4gICAgICB0aGlzLnYgPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xyXG4gICAgICB0aGlzLnYuc2V0UGF0aERhdGEodHJ1ZSwgNCk7XHJcbiAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZUNvbGxlY3Rpb25Qb29sLm5ld1NoYXBlQ29sbGVjdGlvbigpO1xyXG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnYpO1xyXG4gICAgICB0aGlzLmQgPSBkYXRhLmQ7XHJcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcclxuICAgICAgdGhpcy5mcmFtZUlkID0gLTE7XHJcbiAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcclxuICAgICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5wLCAxLCAwLCB0aGlzKTtcclxuICAgICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zLCAxLCAwLCB0aGlzKTtcclxuICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5rID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmsgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbnZlcnRFbGxUb1BhdGgoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEVsbFNoYXBlUHJvcGVydHlGYWN0b3J5LnByb3RvdHlwZSA9IHtcclxuICAgICAgcmVzZXQ6IHJlc2V0U2hhcGUsXHJcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xyXG4gICAgICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9tZGYpIHtcclxuICAgICAgICAgIHRoaXMuY29udmVydEVsbFRvUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgY29udmVydEVsbFRvUGF0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwMCA9IHRoaXMucC52WzBdO1xyXG4gICAgICAgIHZhciBwMSA9IHRoaXMucC52WzFdO1xyXG4gICAgICAgIHZhciBzMCA9IHRoaXMucy52WzBdIC8gMjtcclxuICAgICAgICB2YXIgczEgPSB0aGlzLnMudlsxXSAvIDI7XHJcbiAgICAgICAgdmFyIF9jdyA9IHRoaXMuZCAhPT0gMztcclxuICAgICAgICB2YXIgX3YgPSB0aGlzLnY7XHJcbiAgICAgICAgX3YudlswXVswXSA9IHAwO1xyXG4gICAgICAgIF92LnZbMF1bMV0gPSBwMSAtIHMxO1xyXG4gICAgICAgIF92LnZbMV1bMF0gPSBfY3cgPyBwMCArIHMwIDogcDAgLSBzMDtcclxuICAgICAgICBfdi52WzFdWzFdID0gcDE7XHJcbiAgICAgICAgX3YudlsyXVswXSA9IHAwO1xyXG4gICAgICAgIF92LnZbMl1bMV0gPSBwMSArIHMxO1xyXG4gICAgICAgIF92LnZbM11bMF0gPSBfY3cgPyBwMCAtIHMwIDogcDAgKyBzMDtcclxuICAgICAgICBfdi52WzNdWzFdID0gcDE7XHJcbiAgICAgICAgX3YuaVswXVswXSA9IF9jdyA/IHAwIC0gczAgKiBjUG9pbnQgOiBwMCArIHMwICogY1BvaW50O1xyXG4gICAgICAgIF92LmlbMF1bMV0gPSBwMSAtIHMxO1xyXG4gICAgICAgIF92LmlbMV1bMF0gPSBfY3cgPyBwMCArIHMwIDogcDAgLSBzMDtcclxuICAgICAgICBfdi5pWzFdWzFdID0gcDEgLSBzMSAqIGNQb2ludDtcclxuICAgICAgICBfdi5pWzJdWzBdID0gX2N3ID8gcDAgKyBzMCAqIGNQb2ludCA6IHAwIC0gczAgKiBjUG9pbnQ7XHJcbiAgICAgICAgX3YuaVsyXVsxXSA9IHAxICsgczE7XHJcbiAgICAgICAgX3YuaVszXVswXSA9IF9jdyA/IHAwIC0gczAgOiBwMCArIHMwO1xyXG4gICAgICAgIF92LmlbM11bMV0gPSBwMSArIHMxICogY1BvaW50O1xyXG4gICAgICAgIF92Lm9bMF1bMF0gPSBfY3cgPyBwMCArIHMwICogY1BvaW50IDogcDAgLSBzMCAqIGNQb2ludDtcclxuICAgICAgICBfdi5vWzBdWzFdID0gcDEgLSBzMTtcclxuICAgICAgICBfdi5vWzFdWzBdID0gX2N3ID8gcDAgKyBzMCA6IHAwIC0gczA7XHJcbiAgICAgICAgX3Yub1sxXVsxXSA9IHAxICsgczEgKiBjUG9pbnQ7XHJcbiAgICAgICAgX3Yub1syXVswXSA9IF9jdyA/IHAwIC0gczAgKiBjUG9pbnQgOiBwMCArIHMwICogY1BvaW50O1xyXG4gICAgICAgIF92Lm9bMl1bMV0gPSBwMSArIHMxO1xyXG4gICAgICAgIF92Lm9bM11bMF0gPSBfY3cgPyBwMCAtIHMwIDogcDAgKyBzMDtcclxuICAgICAgICBfdi5vWzNdWzFdID0gcDEgLSBzMSAqIGNQb2ludDtcclxuICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBFbGxTaGFwZVByb3BlcnR5RmFjdG9yeSk7XHJcblxyXG4gICAgcmV0dXJuIEVsbFNoYXBlUHJvcGVydHlGYWN0b3J5O1xyXG4gIH0oKSk7XHJcblxyXG4gIHZhciBTdGFyU2hhcGVQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdGFyU2hhcGVQcm9wZXJ0eUZhY3RvcnkoZWxlbSwgZGF0YSkge1xyXG4gICAgICB0aGlzLnYgPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xyXG4gICAgICB0aGlzLnYuc2V0UGF0aERhdGEodHJ1ZSwgMCk7XHJcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcclxuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgdGhpcy5mcmFtZUlkID0gLTE7XHJcbiAgICAgIHRoaXMuZCA9IGRhdGEuZDtcclxuICAgICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xyXG4gICAgICBpZiAoZGF0YS5zeSA9PT0gMSkge1xyXG4gICAgICAgIHRoaXMuaXIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmlyLCAwLCAwLCB0aGlzKTtcclxuICAgICAgICB0aGlzLmlzID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5pcywgMCwgMC4wMSwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb252ZXJ0VG9QYXRoID0gdGhpcy5jb252ZXJ0U3RhclRvUGF0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmNvbnZlcnRUb1BhdGggPSB0aGlzLmNvbnZlcnRQb2x5Z29uVG9QYXRoO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucHQgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnB0LCAwLCAwLCB0aGlzKTtcclxuICAgICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5wLCAxLCAwLCB0aGlzKTtcclxuICAgICAgdGhpcy5yID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yLCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gICAgICB0aGlzLm9yID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vciwgMCwgMCwgdGhpcyk7XHJcbiAgICAgIHRoaXMub3MgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm9zLCAwLCAwLjAxLCB0aGlzKTtcclxuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XHJcbiAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy52KTtcclxuICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuayA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5rID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb252ZXJ0VG9QYXRoKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBTdGFyU2hhcGVQcm9wZXJ0eUZhY3RvcnkucHJvdG90eXBlID0ge1xyXG4gICAgICByZXNldDogcmVzZXRTaGFwZSxcclxuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XHJcbiAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcclxuICAgICAgICBpZiAodGhpcy5fbWRmKSB7XHJcbiAgICAgICAgICB0aGlzLmNvbnZlcnRUb1BhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbnZlcnRTdGFyVG9QYXRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG51bVB0cyA9IE1hdGguZmxvb3IodGhpcy5wdC52KSAqIDI7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gKE1hdGguUEkgKiAyKSAvIG51bVB0cztcclxuICAgICAgICAvKiB0aGlzLnYudi5sZW5ndGggPSBudW1QdHM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnYuaS5sZW5ndGggPSBudW1QdHM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnYuby5sZW5ndGggPSBudW1QdHM7ICovXHJcbiAgICAgICAgdmFyIGxvbmdGbGFnID0gdHJ1ZTtcclxuICAgICAgICB2YXIgbG9uZ1JhZCA9IHRoaXMub3IudjtcclxuICAgICAgICB2YXIgc2hvcnRSYWQgPSB0aGlzLmlyLnY7XHJcbiAgICAgICAgdmFyIGxvbmdSb3VuZCA9IHRoaXMub3MudjtcclxuICAgICAgICB2YXIgc2hvcnRSb3VuZCA9IHRoaXMuaXMudjtcclxuICAgICAgICB2YXIgbG9uZ1BlcmltU2VnbWVudCA9ICgyICogTWF0aC5QSSAqIGxvbmdSYWQpIC8gKG51bVB0cyAqIDIpO1xyXG4gICAgICAgIHZhciBzaG9ydFBlcmltU2VnbWVudCA9ICgyICogTWF0aC5QSSAqIHNob3J0UmFkKSAvIChudW1QdHMgKiAyKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgcmFkO1xyXG4gICAgICAgIHZhciByb3VuZG5lc3M7XHJcbiAgICAgICAgdmFyIHBlcmltU2VnbWVudDtcclxuICAgICAgICB2YXIgY3VycmVudEFuZyA9IC1NYXRoLlBJIC8gMjtcclxuICAgICAgICBjdXJyZW50QW5nICs9IHRoaXMuci52O1xyXG4gICAgICAgIHZhciBkaXIgPSB0aGlzLmRhdGEuZCA9PT0gMyA/IC0xIDogMTtcclxuICAgICAgICB0aGlzLnYuX2xlbmd0aCA9IDA7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVB0czsgaSArPSAxKSB7XHJcbiAgICAgICAgICByYWQgPSBsb25nRmxhZyA/IGxvbmdSYWQgOiBzaG9ydFJhZDtcclxuICAgICAgICAgIHJvdW5kbmVzcyA9IGxvbmdGbGFnID8gbG9uZ1JvdW5kIDogc2hvcnRSb3VuZDtcclxuICAgICAgICAgIHBlcmltU2VnbWVudCA9IGxvbmdGbGFnID8gbG9uZ1BlcmltU2VnbWVudCA6IHNob3J0UGVyaW1TZWdtZW50O1xyXG4gICAgICAgICAgdmFyIHggPSByYWQgKiBNYXRoLmNvcyhjdXJyZW50QW5nKTtcclxuICAgICAgICAgIHZhciB5ID0gcmFkICogTWF0aC5zaW4oY3VycmVudEFuZyk7XHJcbiAgICAgICAgICB2YXIgb3ggPSB4ID09PSAwICYmIHkgPT09IDAgPyAwIDogeSAvIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICAgICAgICAgIHZhciBveSA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiAteCAvIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICAgICAgICAgIHggKz0gK3RoaXMucC52WzBdO1xyXG4gICAgICAgICAgeSArPSArdGhpcy5wLnZbMV07XHJcbiAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQoeCwgeSwgeCAtIG94ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB5IC0gb3kgKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHggKyBveCAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeSArIG95ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCBpLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAvKiB0aGlzLnYudltpXSA9IFt4LHldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudi5pW2ldID0gW3grb3gqcGVyaW1TZWdtZW50KnJvdW5kbmVzcypkaXIseStveSpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpcl07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52Lm9baV0gPSBbeC1veCpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpcix5LW95KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnYuX2xlbmd0aCA9IG51bVB0czsgKi9cclxuICAgICAgICAgIGxvbmdGbGFnID0gIWxvbmdGbGFnO1xyXG4gICAgICAgICAgY3VycmVudEFuZyArPSBhbmdsZSAqIGRpcjtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbnZlcnRQb2x5Z29uVG9QYXRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG51bVB0cyA9IE1hdGguZmxvb3IodGhpcy5wdC52KTtcclxuICAgICAgICB2YXIgYW5nbGUgPSAoTWF0aC5QSSAqIDIpIC8gbnVtUHRzO1xyXG4gICAgICAgIHZhciByYWQgPSB0aGlzLm9yLnY7XHJcbiAgICAgICAgdmFyIHJvdW5kbmVzcyA9IHRoaXMub3MudjtcclxuICAgICAgICB2YXIgcGVyaW1TZWdtZW50ID0gKDIgKiBNYXRoLlBJICogcmFkKSAvIChudW1QdHMgKiA0KTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgY3VycmVudEFuZyA9IC1NYXRoLlBJICogMC41O1xyXG4gICAgICAgIHZhciBkaXIgPSB0aGlzLmRhdGEuZCA9PT0gMyA/IC0xIDogMTtcclxuICAgICAgICBjdXJyZW50QW5nICs9IHRoaXMuci52O1xyXG4gICAgICAgIHRoaXMudi5fbGVuZ3RoID0gMDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUHRzOyBpICs9IDEpIHtcclxuICAgICAgICAgIHZhciB4ID0gcmFkICogTWF0aC5jb3MoY3VycmVudEFuZyk7XHJcbiAgICAgICAgICB2YXIgeSA9IHJhZCAqIE1hdGguc2luKGN1cnJlbnRBbmcpO1xyXG4gICAgICAgICAgdmFyIG94ID0geCA9PT0gMCAmJiB5ID09PSAwID8gMCA6IHkgLyBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcbiAgICAgICAgICB2YXIgb3kgPSB4ID09PSAwICYmIHkgPT09IDAgPyAwIDogLXggLyBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcbiAgICAgICAgICB4ICs9ICt0aGlzLnAudlswXTtcclxuICAgICAgICAgIHkgKz0gK3RoaXMucC52WzFdO1xyXG4gICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHgsIHksIHggLSBveCAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeSAtIG95ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB4ICsgb3ggKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHkgKyBveSAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgaSwgdHJ1ZSk7XHJcbiAgICAgICAgICBjdXJyZW50QW5nICs9IGFuZ2xlICogZGlyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhdGhzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5wYXRoc1swXSA9IHRoaXMudjtcclxuICAgICAgfSxcclxuXHJcbiAgICB9O1xyXG4gICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTdGFyU2hhcGVQcm9wZXJ0eUZhY3RvcnkpO1xyXG5cclxuICAgIHJldHVybiBTdGFyU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XHJcbiAgfSgpKTtcclxuXHJcbiAgdmFyIFJlY3RTaGFwZVByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlY3RTaGFwZVByb3BlcnR5RmFjdG9yeShlbGVtLCBkYXRhKSB7XHJcbiAgICAgIHRoaXMudiA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgICAgIHRoaXMudi5jID0gdHJ1ZTtcclxuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XHJcbiAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy52KTtcclxuICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcclxuICAgICAgdGhpcy5mcmFtZUlkID0gLTE7XHJcbiAgICAgIHRoaXMuZCA9IGRhdGEuZDtcclxuICAgICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xyXG4gICAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAsIDEsIDAsIHRoaXMpO1xyXG4gICAgICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDEsIDAsIHRoaXMpO1xyXG4gICAgICB0aGlzLnIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIsIDAsIDAsIHRoaXMpO1xyXG4gICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmsgPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuayA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29udmVydFJlY3RUb1BhdGgoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFJlY3RTaGFwZVByb3BlcnR5RmFjdG9yeS5wcm90b3R5cGUgPSB7XHJcbiAgICAgIGNvbnZlcnRSZWN0VG9QYXRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHAwID0gdGhpcy5wLnZbMF07XHJcbiAgICAgICAgdmFyIHAxID0gdGhpcy5wLnZbMV07XHJcbiAgICAgICAgdmFyIHYwID0gdGhpcy5zLnZbMF0gLyAyO1xyXG4gICAgICAgIHZhciB2MSA9IHRoaXMucy52WzFdIC8gMjtcclxuICAgICAgICB2YXIgcm91bmQgPSBibU1pbih2MCwgdjEsIHRoaXMuci52KTtcclxuICAgICAgICB2YXIgY1BvaW50ID0gcm91bmQgKiAoMSAtIHJvdW5kQ29ybmVyKTtcclxuICAgICAgICB0aGlzLnYuX2xlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmQgPT09IDIgfHwgdGhpcy5kID09PSAxKSB7XHJcbiAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCArIHYwLCBwMSAtIHYxICsgcm91bmQsIHAwICsgdjAsIHAxIC0gdjEgKyBjUG9pbnQsIDAsIHRydWUpO1xyXG4gICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgKyB2MCwgcDEgKyB2MSAtIGNQb2ludCwgcDAgKyB2MCwgcDEgKyB2MSAtIHJvdW5kLCAxLCB0cnVlKTtcclxuICAgICAgICAgIGlmIChyb3VuZCAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCAtIHJvdW5kLCBwMSArIHYxLCBwMCArIHYwIC0gcm91bmQsIHAxICsgdjEsIHAwICsgdjAgLSBjUG9pbnQsIHAxICsgdjEsIDIsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCArIHJvdW5kLCBwMSArIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSArIHYxLCBwMCAtIHYwICsgcm91bmQsIHAxICsgdjEsIDMsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCAtIHYwLCBwMSArIHYxIC0gcm91bmQsIHAwIC0gdjAsIHAxICsgdjEgLSBjUG9pbnQsIDQsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCAtIHYwLCBwMSAtIHYxICsgY1BvaW50LCBwMCAtIHYwLCBwMSAtIHYxICsgcm91bmQsIDUsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCArIHJvdW5kLCBwMSAtIHYxLCBwMCAtIHYwICsgcm91bmQsIHAxIC0gdjEsIHAwIC0gdjAgKyBjUG9pbnQsIHAxIC0gdjEsIDYsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCAtIHJvdW5kLCBwMSAtIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSAtIHYxLCBwMCArIHYwIC0gcm91bmQsIHAxIC0gdjEsIDcsIHRydWUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEsIHAwIC0gdjAgKyBjUG9pbnQsIHAxICsgdjEsIHAwIC0gdjAsIHAxICsgdjEsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgLSB2MSwgcDAgLSB2MCwgcDEgLSB2MSArIGNQb2ludCwgcDAgLSB2MCwgcDEgLSB2MSwgMyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwLCBwMSAtIHYxICsgcm91bmQsIHAwICsgdjAsIHAxIC0gdjEgKyBjUG9pbnQsIHAwICsgdjAsIHAxIC0gdjEgKyByb3VuZCwgMCwgdHJ1ZSk7XHJcbiAgICAgICAgICBpZiAocm91bmQgIT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgLSB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSAtIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSAtIHYxLCAxLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgLSB2MSwgcDAgLSB2MCArIGNQb2ludCwgcDEgLSB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSAtIHYxLCAyLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgLSB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCAtIHYwLCBwMSAtIHYxICsgY1BvaW50LCAzLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgLSB2MCwgcDEgKyB2MSAtIGNQb2ludCwgcDAgLSB2MCwgcDEgKyB2MSAtIHJvdW5kLCA0LCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgKyB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSArIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSArIHYxLCA1LCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgKyB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgKyB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSArIHYxLCA2LCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgKyB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCArIHYwLCBwMSArIHYxIC0gY1BvaW50LCA3LCB0cnVlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSAtIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSAtIHYxLCBwMCAtIHYwLCBwMSAtIHYxLCAxLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEsIHAwIC0gdjAsIHAxICsgdjEgLSBjUG9pbnQsIHAwIC0gdjAsIHAxICsgdjEsIDIsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgKyB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgKyB2MSwgcDAgKyB2MCwgcDEgKyB2MSwgMywgdHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcclxuICAgICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xyXG4gICAgICAgIGlmICh0aGlzLl9tZGYpIHtcclxuICAgICAgICAgIHRoaXMuY29udmVydFJlY3RUb1BhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHJlc2V0OiByZXNldFNoYXBlLFxyXG4gICAgfTtcclxuICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5KTtcclxuXHJcbiAgICByZXR1cm4gUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5O1xyXG4gIH0oKSk7XHJcblxyXG4gIGZ1bmN0aW9uIGdldFNoYXBlUHJvcChlbGVtLCBkYXRhLCB0eXBlKSB7XHJcbiAgICB2YXIgcHJvcDtcclxuICAgIGlmICh0eXBlID09PSAzIHx8IHR5cGUgPT09IDQpIHtcclxuICAgICAgdmFyIGRhdGFQcm9wID0gdHlwZSA9PT0gMyA/IGRhdGEucHQgOiBkYXRhLmtzO1xyXG4gICAgICB2YXIga2V5cyA9IGRhdGFQcm9wLms7XHJcbiAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIHByb3AgPSBuZXcgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwcm9wID0gbmV3IFNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSwgdHlwZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNSkge1xyXG4gICAgICBwcm9wID0gbmV3IFJlY3RTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSA2KSB7XHJcbiAgICAgIHByb3AgPSBuZXcgRWxsU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNykge1xyXG4gICAgICBwcm9wID0gbmV3IFN0YXJTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgaWYgKHByb3Auaykge1xyXG4gICAgICBlbGVtLmFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3JGdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBTaGFwZVByb3BlcnR5O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0S2V5ZnJhbWVkQ29uc3RydWN0b3JGdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBLZXlmcmFtZWRTaGFwZVByb3BlcnR5O1xyXG4gIH1cclxuXHJcbiAgdmFyIG9iID0ge307XHJcbiAgb2IuZ2V0U2hhcGVQcm9wID0gZ2V0U2hhcGVQcm9wO1xyXG4gIG9iLmdldENvbnN0cnVjdG9yRnVuY3Rpb24gPSBnZXRDb25zdHJ1Y3RvckZ1bmN0aW9uO1xyXG4gIG9iLmdldEtleWZyYW1lZENvbnN0cnVjdG9yRnVuY3Rpb24gPSBnZXRLZXlmcmFtZWRDb25zdHJ1Y3RvckZ1bmN0aW9uO1xyXG4gIHJldHVybiBvYjtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBzaGFwZUNvbGxlY3Rpb25Qb29sLCBpbml0aWFsRGVmYXVsdEZyYW1lLCBleHRlbmRQcm90b3R5cGUsIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lciAqL1xyXG4vKiBleHBvcnRlZCBTaGFwZU1vZGlmaWVycyAqL1xyXG5cclxudmFyIFNoYXBlTW9kaWZpZXJzID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgb2IgPSB7fTtcclxuICB2YXIgbW9kaWZpZXJzID0ge307XHJcbiAgb2IucmVnaXN0ZXJNb2RpZmllciA9IHJlZ2lzdGVyTW9kaWZpZXI7XHJcbiAgb2IuZ2V0TW9kaWZpZXIgPSBnZXRNb2RpZmllcjtcclxuXHJcbiAgZnVuY3Rpb24gcmVnaXN0ZXJNb2RpZmllcihubSwgZmFjdG9yeSkge1xyXG4gICAgaWYgKCFtb2RpZmllcnNbbm1dKSB7XHJcbiAgICAgIG1vZGlmaWVyc1tubV0gPSBmYWN0b3J5O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0TW9kaWZpZXIobm0sIGVsZW0sIGRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgbW9kaWZpZXJzW25tXShlbGVtLCBkYXRhKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBvYjtcclxufSgpKTtcclxuXHJcbmZ1bmN0aW9uIFNoYXBlTW9kaWZpZXIoKSB7fVxyXG5TaGFwZU1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge307XHJcblNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlVG9Nb2RpZmllciA9IGZ1bmN0aW9uICgpIHt9O1xyXG5TaGFwZU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgaWYgKCF0aGlzLmNsb3NlZCkge1xyXG4gICAgLy8gQWRkaW5nIHNoYXBlIHRvIGR5bmFtaWMgcHJvcGVydGllcy4gSXQgY292ZXJzIHRoZSBjYXNlIHdoZXJlIGEgc2hhcGUgaGFzIG5vIGVmZmVjdHMgYXBwbGllZCwgdG8gcmVzZXQgaXQncyBfbWRmIHN0YXRlIG9uIGV2ZXJ5IHRpY2suXHJcbiAgICBkYXRhLnNoLmNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkoZGF0YS5zaCk7XHJcbiAgICB2YXIgc2hhcGVEYXRhID0geyBzaGFwZTogZGF0YS5zaCwgZGF0YTogZGF0YSwgbG9jYWxTaGFwZUNvbGxlY3Rpb246IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCkgfTtcclxuICAgIHRoaXMuc2hhcGVzLnB1c2goc2hhcGVEYXRhKTtcclxuICAgIHRoaXMuYWRkU2hhcGVUb01vZGlmaWVyKHNoYXBlRGF0YSk7XHJcbiAgICBpZiAodGhpcy5faXNBbmltYXRlZCkge1xyXG4gICAgICBkYXRhLnNldEFzQW5pbWF0ZWQoKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xyXG4gIHRoaXMuc2hhcGVzID0gW107XHJcbiAgdGhpcy5lbGVtID0gZWxlbTtcclxuICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XHJcbiAgdGhpcy5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzKGVsZW0sIGRhdGEpO1xyXG4gIHRoaXMuZnJhbWVJZCA9IGluaXRpYWxEZWZhdWx0RnJhbWU7XHJcbiAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcclxuICB0aGlzLmsgPSBmYWxzZTtcclxuICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgIHRoaXMuayA9IHRydWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XHJcbiAgfVxyXG59O1xyXG5TaGFwZU1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzS2V5cyA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XHJcbiAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcclxufTtcclxuXHJcbmV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU2hhcGVNb2RpZmllcik7XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCBTaGFwZU1vZGlmaWVyLCBQcm9wZXJ0eUZhY3RvcnksIHNlZ21lbnRzTGVuZ3RoUG9vbCwgYmV6LCBzaGFwZVBvb2wsIFNoYXBlTW9kaWZpZXJzICovXHJcblxyXG5mdW5jdGlvbiBUcmltTW9kaWZpZXIoKSB7XHJcbn1cclxuZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgVHJpbU1vZGlmaWVyKTtcclxuVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcclxuICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDAsIDAuMDEsIHRoaXMpO1xyXG4gIHRoaXMuZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuZSwgMCwgMC4wMSwgdGhpcyk7XHJcbiAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vLCAwLCAwLCB0aGlzKTtcclxuICB0aGlzLnNWYWx1ZSA9IDA7XHJcbiAgdGhpcy5lVmFsdWUgPSAwO1xyXG4gIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xyXG4gIHRoaXMubSA9IGRhdGEubTtcclxuICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLnMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCB8fCAhIXRoaXMuZS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoIHx8ICEhdGhpcy5vLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XHJcbn07XHJcblxyXG5UcmltTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlVG9Nb2RpZmllciA9IGZ1bmN0aW9uIChzaGFwZURhdGEpIHtcclxuICBzaGFwZURhdGEucGF0aHNEYXRhID0gW107XHJcbn07XHJcblxyXG5UcmltTW9kaWZpZXIucHJvdG90eXBlLmNhbGN1bGF0ZVNoYXBlRWRnZXMgPSBmdW5jdGlvbiAocywgZSwgc2hhcGVMZW5ndGgsIGFkZGVkTGVuZ3RoLCB0b3RhbE1vZGlmaWVyTGVuZ3RoKSB7XHJcbiAgdmFyIHNlZ21lbnRzID0gW107XHJcbiAgaWYgKGUgPD0gMSkge1xyXG4gICAgc2VnbWVudHMucHVzaCh7XHJcbiAgICAgIHM6IHMsXHJcbiAgICAgIGU6IGUsXHJcbiAgICB9KTtcclxuICB9IGVsc2UgaWYgKHMgPj0gMSkge1xyXG4gICAgc2VnbWVudHMucHVzaCh7XHJcbiAgICAgIHM6IHMgLSAxLFxyXG4gICAgICBlOiBlIC0gMSxcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzZWdtZW50cy5wdXNoKHtcclxuICAgICAgczogcyxcclxuICAgICAgZTogMSxcclxuICAgIH0pO1xyXG4gICAgc2VnbWVudHMucHVzaCh7XHJcbiAgICAgIHM6IDAsXHJcbiAgICAgIGU6IGUgLSAxLFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHZhciBzaGFwZVNlZ21lbnRzID0gW107XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDtcclxuICB2YXIgc2VnbWVudE9iO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgc2VnbWVudE9iID0gc2VnbWVudHNbaV07XHJcbiAgICBpZiAoIShzZWdtZW50T2IuZSAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPCBhZGRlZExlbmd0aCB8fCBzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPiBhZGRlZExlbmd0aCArIHNoYXBlTGVuZ3RoKSkge1xyXG4gICAgICB2YXIgc2hhcGVTO1xyXG4gICAgICB2YXIgc2hhcGVFO1xyXG4gICAgICBpZiAoc2VnbWVudE9iLnMgKiB0b3RhbE1vZGlmaWVyTGVuZ3RoIDw9IGFkZGVkTGVuZ3RoKSB7XHJcbiAgICAgICAgc2hhcGVTID0gMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzaGFwZVMgPSAoc2VnbWVudE9iLnMgKiB0b3RhbE1vZGlmaWVyTGVuZ3RoIC0gYWRkZWRMZW5ndGgpIC8gc2hhcGVMZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNlZ21lbnRPYi5lICogdG90YWxNb2RpZmllckxlbmd0aCA+PSBhZGRlZExlbmd0aCArIHNoYXBlTGVuZ3RoKSB7XHJcbiAgICAgICAgc2hhcGVFID0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzaGFwZUUgPSAoKHNlZ21lbnRPYi5lICogdG90YWxNb2RpZmllckxlbmd0aCAtIGFkZGVkTGVuZ3RoKSAvIHNoYXBlTGVuZ3RoKTtcclxuICAgICAgfVxyXG4gICAgICBzaGFwZVNlZ21lbnRzLnB1c2goW3NoYXBlUywgc2hhcGVFXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghc2hhcGVTZWdtZW50cy5sZW5ndGgpIHtcclxuICAgIHNoYXBlU2VnbWVudHMucHVzaChbMCwgMF0pO1xyXG4gIH1cclxuICByZXR1cm4gc2hhcGVTZWdtZW50cztcclxufTtcclxuXHJcblRyaW1Nb2RpZmllci5wcm90b3R5cGUucmVsZWFzZVBhdGhzRGF0YSA9IGZ1bmN0aW9uIChwYXRoc0RhdGEpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gcGF0aHNEYXRhLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIHNlZ21lbnRzTGVuZ3RoUG9vbC5yZWxlYXNlKHBhdGhzRGF0YVtpXSk7XHJcbiAgfVxyXG4gIHBhdGhzRGF0YS5sZW5ndGggPSAwO1xyXG4gIHJldHVybiBwYXRoc0RhdGE7XHJcbn07XHJcblxyXG5UcmltTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NTaGFwZXMgPSBmdW5jdGlvbiAoX2lzRmlyc3RGcmFtZSkge1xyXG4gIHZhciBzO1xyXG4gIHZhciBlO1xyXG4gIGlmICh0aGlzLl9tZGYgfHwgX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgdmFyIG8gPSAodGhpcy5vLnYgJSAzNjApIC8gMzYwO1xyXG4gICAgaWYgKG8gPCAwKSB7XHJcbiAgICAgIG8gKz0gMTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnMudiA+IDEpIHtcclxuICAgICAgcyA9IDEgKyBvO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLnMudiA8IDApIHtcclxuICAgICAgcyA9IDAgKyBvO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcyA9IHRoaXMucy52ICsgbztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmUudiA+IDEpIHtcclxuICAgICAgZSA9IDEgKyBvO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmUudiA8IDApIHtcclxuICAgICAgZSA9IDAgKyBvO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZSA9IHRoaXMuZS52ICsgbztcclxuICAgIH1cclxuXHJcbiAgICBpZiAocyA+IGUpIHtcclxuICAgICAgdmFyIF9zID0gcztcclxuICAgICAgcyA9IGU7XHJcbiAgICAgIGUgPSBfcztcclxuICAgIH1cclxuICAgIHMgPSBNYXRoLnJvdW5kKHMgKiAxMDAwMCkgKiAwLjAwMDE7XHJcbiAgICBlID0gTWF0aC5yb3VuZChlICogMTAwMDApICogMC4wMDAxO1xyXG4gICAgdGhpcy5zVmFsdWUgPSBzO1xyXG4gICAgdGhpcy5lVmFsdWUgPSBlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzID0gdGhpcy5zVmFsdWU7XHJcbiAgICBlID0gdGhpcy5lVmFsdWU7XHJcbiAgfVxyXG4gIHZhciBzaGFwZVBhdGhzO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW47XHJcbiAgdmFyIHBhdGhzRGF0YTtcclxuICB2YXIgcGF0aERhdGE7XHJcbiAgdmFyIHRvdGFsU2hhcGVMZW5ndGg7XHJcbiAgdmFyIHRvdGFsTW9kaWZpZXJMZW5ndGggPSAwO1xyXG5cclxuICBpZiAoZSA9PT0gcykge1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHRoaXMuc2hhcGVzW2ldLmxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcclxuICAgICAgdGhpcy5zaGFwZXNbaV0uc2hhcGUuX21kZiA9IHRydWU7XHJcbiAgICAgIHRoaXMuc2hhcGVzW2ldLnNoYXBlLnBhdGhzID0gdGhpcy5zaGFwZXNbaV0ubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICAgIGlmICh0aGlzLl9tZGYpIHtcclxuICAgICAgICB0aGlzLnNoYXBlc1tpXS5wYXRoc0RhdGEubGVuZ3RoID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoISgoZSA9PT0gMSAmJiBzID09PSAwKSB8fCAoZSA9PT0gMCAmJiBzID09PSAxKSkpIHtcclxuICAgIHZhciBzZWdtZW50cyA9IFtdO1xyXG4gICAgdmFyIHNoYXBlRGF0YTtcclxuICAgIHZhciBsb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBzaGFwZURhdGEgPSB0aGlzLnNoYXBlc1tpXTtcclxuICAgICAgLy8gaWYgc2hhcGUgaGFzbid0IGNoYW5nZWQgYW5kIHRyaW0gcHJvcGVydGllcyBoYXZlbid0IGNoYW5nZWQsIGNhY2hlZCBwcmV2aW91cyBwYXRoIGNhbiBiZSB1c2VkXHJcbiAgICAgIGlmICghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgIXRoaXMuX21kZiAmJiAhX2lzRmlyc3RGcmFtZSAmJiB0aGlzLm0gIT09IDIpIHtcclxuICAgICAgICBzaGFwZURhdGEuc2hhcGUucGF0aHMgPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocztcclxuICAgICAgICBqTGVuID0gc2hhcGVQYXRocy5fbGVuZ3RoO1xyXG4gICAgICAgIHRvdGFsU2hhcGVMZW5ndGggPSAwO1xyXG4gICAgICAgIGlmICghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgc2hhcGVEYXRhLnBhdGhzRGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgIHRvdGFsU2hhcGVMZW5ndGggPSBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcGF0aHNEYXRhID0gdGhpcy5yZWxlYXNlUGF0aHNEYXRhKHNoYXBlRGF0YS5wYXRoc0RhdGEpO1xyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgICBwYXRoRGF0YSA9IGJlei5nZXRTZWdtZW50c0xlbmd0aChzaGFwZVBhdGhzLnNoYXBlc1tqXSk7XHJcbiAgICAgICAgICAgIHBhdGhzRGF0YS5wdXNoKHBhdGhEYXRhKTtcclxuICAgICAgICAgICAgdG90YWxTaGFwZUxlbmd0aCArPSBwYXRoRGF0YS50b3RhbExlbmd0aDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoID0gdG90YWxTaGFwZUxlbmd0aDtcclxuICAgICAgICAgIHNoYXBlRGF0YS5wYXRoc0RhdGEgPSBwYXRoc0RhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0b3RhbE1vZGlmaWVyTGVuZ3RoICs9IHRvdGFsU2hhcGVMZW5ndGg7XHJcbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLl9tZGYgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgc2hhcGVTID0gcztcclxuICAgIHZhciBzaGFwZUUgPSBlO1xyXG4gICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcclxuICAgIHZhciBlZGdlcztcclxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldO1xyXG4gICAgICBpZiAoc2hhcGVEYXRhLnNoYXBlLl9tZGYpIHtcclxuICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5yZWxlYXNlU2hhcGVzKCk7XHJcbiAgICAgICAgLy8gaWYgbSA9PT0gMiBtZWFucyBwYXRocyBhcmUgdHJpbW1lZCBpbmRpdmlkdWFsbHkgc28gZWRnZXMgbmVlZCB0byBiZSBmb3VuZCBmb3IgdGhpcyBzcGVjaWZpYyBzaGFwZSByZWxhdGl2ZSB0byB3aG9lbCBncm91cFxyXG4gICAgICAgIGlmICh0aGlzLm0gPT09IDIgJiYgbGVuID4gMSkge1xyXG4gICAgICAgICAgZWRnZXMgPSB0aGlzLmNhbGN1bGF0ZVNoYXBlRWRnZXMocywgZSwgc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGgsIGFkZGVkTGVuZ3RoLCB0b3RhbE1vZGlmaWVyTGVuZ3RoKTtcclxuICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlZGdlcyA9IFtbc2hhcGVTLCBzaGFwZUVdXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgakxlbiA9IGVkZ2VzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICBzaGFwZVMgPSBlZGdlc1tqXVswXTtcclxuICAgICAgICAgIHNoYXBlRSA9IGVkZ2VzW2pdWzFdO1xyXG4gICAgICAgICAgc2VnbWVudHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgIGlmIChzaGFwZUUgPD0gMSkge1xyXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICBzOiBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCAqIHNoYXBlUyxcclxuICAgICAgICAgICAgICBlOiBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCAqIHNoYXBlRSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlUyA+PSAxKSB7XHJcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgIHM6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogKHNoYXBlUyAtIDEpLFxyXG4gICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogKHNoYXBlRSAtIDEpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgIHM6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVTLFxyXG4gICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgczogMCxcclxuICAgICAgICAgICAgICBlOiBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCAqIChzaGFwZUUgLSAxKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgbmV3U2hhcGVzRGF0YSA9IHRoaXMuYWRkU2hhcGVzKHNoYXBlRGF0YSwgc2VnbWVudHNbMF0pO1xyXG4gICAgICAgICAgaWYgKHNlZ21lbnRzWzBdLnMgIT09IHNlZ21lbnRzWzBdLmUpIHtcclxuICAgICAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICB2YXIgbGFzdFNoYXBlSW5Db2xsZWN0aW9uID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlc1tzaGFwZURhdGEuc2hhcGUucGF0aHMuX2xlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgIGlmIChsYXN0U2hhcGVJbkNvbGxlY3Rpb24uYykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RTaGFwZSA9IG5ld1NoYXBlc0RhdGEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBhdGhzKG5ld1NoYXBlc0RhdGEsIGxvY2FsU2hhcGVDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIG5ld1NoYXBlc0RhdGEgPSB0aGlzLmFkZFNoYXBlcyhzaGFwZURhdGEsIHNlZ21lbnRzWzFdLCBsYXN0U2hhcGUpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBhdGhzKG5ld1NoYXBlc0RhdGEsIGxvY2FsU2hhcGVDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIG5ld1NoYXBlc0RhdGEgPSB0aGlzLmFkZFNoYXBlcyhzaGFwZURhdGEsIHNlZ21lbnRzWzFdKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hZGRQYXRocyhuZXdTaGFwZXNEYXRhLCBsb2NhbFNoYXBlQ29sbGVjdGlvbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNoYXBlRGF0YS5zaGFwZS5wYXRocyA9IGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh0aGlzLl9tZGYpIHtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAvLyBSZWxlYXNpZ24gVHJpbSBDYWNoZWQgcGF0aHMgZGF0YSB3aGVuIG5vIHRyaW0gYXBwbGllZCBpbiBjYXNlIHNoYXBlcyBhcmUgbW9kaWZpZWQgaW5iZXR3ZWVuLlxyXG4gICAgICAvLyBEb24ndCByZW1vdmUgdGhpcyBldmVuIGlmIGl0J3MgbG9zaW5nIGNhY2hlZCBpbmZvLlxyXG4gICAgICB0aGlzLnNoYXBlc1tpXS5wYXRoc0RhdGEubGVuZ3RoID0gMDtcclxuICAgICAgdGhpcy5zaGFwZXNbaV0uc2hhcGUuX21kZiA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRQYXRocyA9IGZ1bmN0aW9uIChuZXdQYXRocywgbG9jYWxTaGFwZUNvbGxlY3Rpb24pIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gbmV3UGF0aHMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUobmV3UGF0aHNbaV0pO1xyXG4gIH1cclxufTtcclxuXHJcblRyaW1Nb2RpZmllci5wcm90b3R5cGUuYWRkU2VnbWVudCA9IGZ1bmN0aW9uIChwdDEsIHB0MiwgcHQzLCBwdDQsIHNoYXBlUGF0aCwgcG9zLCBuZXdTaGFwZSkge1xyXG4gIHNoYXBlUGF0aC5zZXRYWUF0KHB0MlswXSwgcHQyWzFdLCAnbycsIHBvcyk7XHJcbiAgc2hhcGVQYXRoLnNldFhZQXQocHQzWzBdLCBwdDNbMV0sICdpJywgcG9zICsgMSk7XHJcbiAgaWYgKG5ld1NoYXBlKSB7XHJcbiAgICBzaGFwZVBhdGguc2V0WFlBdChwdDFbMF0sIHB0MVsxXSwgJ3YnLCBwb3MpO1xyXG4gIH1cclxuICBzaGFwZVBhdGguc2V0WFlBdChwdDRbMF0sIHB0NFsxXSwgJ3YnLCBwb3MgKyAxKTtcclxufTtcclxuXHJcblRyaW1Nb2RpZmllci5wcm90b3R5cGUuYWRkU2VnbWVudEZyb21BcnJheSA9IGZ1bmN0aW9uIChwb2ludHMsIHNoYXBlUGF0aCwgcG9zLCBuZXdTaGFwZSkge1xyXG4gIHNoYXBlUGF0aC5zZXRYWUF0KHBvaW50c1sxXSwgcG9pbnRzWzVdLCAnbycsIHBvcyk7XHJcbiAgc2hhcGVQYXRoLnNldFhZQXQocG9pbnRzWzJdLCBwb2ludHNbNl0sICdpJywgcG9zICsgMSk7XHJcbiAgaWYgKG5ld1NoYXBlKSB7XHJcbiAgICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbMF0sIHBvaW50c1s0XSwgJ3YnLCBwb3MpO1xyXG4gIH1cclxuICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbM10sIHBvaW50c1s3XSwgJ3YnLCBwb3MgKyAxKTtcclxufTtcclxuXHJcblRyaW1Nb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGVzID0gZnVuY3Rpb24gKHNoYXBlRGF0YSwgc2hhcGVTZWdtZW50LCBzaGFwZVBhdGgpIHtcclxuICB2YXIgcGF0aHNEYXRhID0gc2hhcGVEYXRhLnBhdGhzRGF0YTtcclxuICB2YXIgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoO1xyXG4gIHZhciBqO1xyXG4gIHZhciBqTGVuO1xyXG4gIHZhciBhZGRlZExlbmd0aCA9IDA7XHJcbiAgdmFyIGN1cnJlbnRMZW5ndGhEYXRhO1xyXG4gIHZhciBzZWdtZW50Q291bnQ7XHJcbiAgdmFyIGxlbmd0aHM7XHJcbiAgdmFyIHNlZ21lbnQ7XHJcbiAgdmFyIHNoYXBlcyA9IFtdO1xyXG4gIHZhciBpbml0UG9zO1xyXG4gIHZhciBuZXdTaGFwZSA9IHRydWU7XHJcbiAgaWYgKCFzaGFwZVBhdGgpIHtcclxuICAgIHNoYXBlUGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgICBzZWdtZW50Q291bnQgPSAwO1xyXG4gICAgaW5pdFBvcyA9IDA7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNlZ21lbnRDb3VudCA9IHNoYXBlUGF0aC5fbGVuZ3RoO1xyXG4gICAgaW5pdFBvcyA9IHNoYXBlUGF0aC5fbGVuZ3RoO1xyXG4gIH1cclxuICBzaGFwZXMucHVzaChzaGFwZVBhdGgpO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgbGVuZ3RocyA9IHBhdGhzRGF0YVtpXS5sZW5ndGhzO1xyXG4gICAgc2hhcGVQYXRoLmMgPSBzaGFwZVBhdGhzW2ldLmM7XHJcbiAgICBqTGVuID0gc2hhcGVQYXRoc1tpXS5jID8gbGVuZ3Rocy5sZW5ndGggOiBsZW5ndGhzLmxlbmd0aCArIDE7XHJcbiAgICBmb3IgKGogPSAxOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgIGN1cnJlbnRMZW5ndGhEYXRhID0gbGVuZ3Roc1tqIC0gMV07XHJcbiAgICAgIGlmIChhZGRlZExlbmd0aCArIGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoIDwgc2hhcGVTZWdtZW50LnMpIHtcclxuICAgICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcclxuICAgICAgICBzaGFwZVBhdGguYyA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2UgaWYgKGFkZGVkTGVuZ3RoID4gc2hhcGVTZWdtZW50LmUpIHtcclxuICAgICAgICBzaGFwZVBhdGguYyA9IGZhbHNlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChzaGFwZVNlZ21lbnQucyA8PSBhZGRlZExlbmd0aCAmJiBzaGFwZVNlZ21lbnQuZSA+PSBhZGRlZExlbmd0aCArIGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aGlzLmFkZFNlZ21lbnQoc2hhcGVQYXRoc1tpXS52W2ogLSAxXSwgc2hhcGVQYXRoc1tpXS5vW2ogLSAxXSwgc2hhcGVQYXRoc1tpXS5pW2pdLCBzaGFwZVBhdGhzW2ldLnZbal0sIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7XHJcbiAgICAgICAgICBuZXdTaGFwZSA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZWdtZW50ID0gYmV6LmdldE5ld1NlZ21lbnQoc2hhcGVQYXRoc1tpXS52W2ogLSAxXSwgc2hhcGVQYXRoc1tpXS52W2pdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbal0sIChzaGFwZVNlZ21lbnQucyAtIGFkZGVkTGVuZ3RoKSAvIGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoLCAoc2hhcGVTZWdtZW50LmUgLSBhZGRlZExlbmd0aCkgLyBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aCwgbGVuZ3Roc1tqIC0gMV0pO1xyXG4gICAgICAgICAgdGhpcy5hZGRTZWdtZW50RnJvbUFycmF5KHNlZ21lbnQsIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7XHJcbiAgICAgICAgICAvLyB0aGlzLmFkZFNlZ21lbnQoc2VnbWVudC5wdDEsIHNlZ21lbnQucHQzLCBzZWdtZW50LnB0NCwgc2VnbWVudC5wdDIsIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7XHJcbiAgICAgICAgICBuZXdTaGFwZSA9IGZhbHNlO1xyXG4gICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkZWRMZW5ndGggKz0gY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGg7XHJcbiAgICAgICAgc2VnbWVudENvdW50ICs9IDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzaGFwZVBhdGhzW2ldLmMgJiYgbGVuZ3Rocy5sZW5ndGgpIHtcclxuICAgICAgY3VycmVudExlbmd0aERhdGEgPSBsZW5ndGhzW2ogLSAxXTtcclxuICAgICAgaWYgKGFkZGVkTGVuZ3RoIDw9IHNoYXBlU2VnbWVudC5lKSB7XHJcbiAgICAgICAgdmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhzW2ogLSAxXS5hZGRlZExlbmd0aDtcclxuICAgICAgICBpZiAoc2hhcGVTZWdtZW50LnMgPD0gYWRkZWRMZW5ndGggJiYgc2hhcGVTZWdtZW50LmUgPj0gYWRkZWRMZW5ndGggKyBzZWdtZW50TGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aGlzLmFkZFNlZ21lbnQoc2hhcGVQYXRoc1tpXS52W2ogLSAxXSwgc2hhcGVQYXRoc1tpXS5vW2ogLSAxXSwgc2hhcGVQYXRoc1tpXS5pWzBdLCBzaGFwZVBhdGhzW2ldLnZbMF0sIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7XHJcbiAgICAgICAgICBuZXdTaGFwZSA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZWdtZW50ID0gYmV6LmdldE5ld1NlZ21lbnQoc2hhcGVQYXRoc1tpXS52W2ogLSAxXSwgc2hhcGVQYXRoc1tpXS52WzBdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbMF0sIChzaGFwZVNlZ21lbnQucyAtIGFkZGVkTGVuZ3RoKSAvIHNlZ21lbnRMZW5ndGgsIChzaGFwZVNlZ21lbnQuZSAtIGFkZGVkTGVuZ3RoKSAvIHNlZ21lbnRMZW5ndGgsIGxlbmd0aHNbaiAtIDFdKTtcclxuICAgICAgICAgIHRoaXMuYWRkU2VnbWVudEZyb21BcnJheShzZWdtZW50LCBzaGFwZVBhdGgsIHNlZ21lbnRDb3VudCwgbmV3U2hhcGUpO1xyXG4gICAgICAgICAgLy8gdGhpcy5hZGRTZWdtZW50KHNlZ21lbnQucHQxLCBzZWdtZW50LnB0Mywgc2VnbWVudC5wdDQsIHNlZ21lbnQucHQyLCBzaGFwZVBhdGgsIHNlZ21lbnRDb3VudCwgbmV3U2hhcGUpO1xyXG4gICAgICAgICAgbmV3U2hhcGUgPSBmYWxzZTtcclxuICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgYWRkZWRMZW5ndGggKz0gY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGg7XHJcbiAgICAgIHNlZ21lbnRDb3VudCArPSAxO1xyXG4gICAgfVxyXG4gICAgaWYgKHNoYXBlUGF0aC5fbGVuZ3RoKSB7XHJcbiAgICAgIHNoYXBlUGF0aC5zZXRYWUF0KHNoYXBlUGF0aC52W2luaXRQb3NdWzBdLCBzaGFwZVBhdGgudltpbml0UG9zXVsxXSwgJ2knLCBpbml0UG9zKTtcclxuICAgICAgc2hhcGVQYXRoLnNldFhZQXQoc2hhcGVQYXRoLnZbc2hhcGVQYXRoLl9sZW5ndGggLSAxXVswXSwgc2hhcGVQYXRoLnZbc2hhcGVQYXRoLl9sZW5ndGggLSAxXVsxXSwgJ28nLCBzaGFwZVBhdGguX2xlbmd0aCAtIDEpO1xyXG4gICAgfVxyXG4gICAgaWYgKGFkZGVkTGVuZ3RoID4gc2hhcGVTZWdtZW50LmUpIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpZiAoaSA8IGxlbiAtIDEpIHtcclxuICAgICAgc2hhcGVQYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcclxuICAgICAgbmV3U2hhcGUgPSB0cnVlO1xyXG4gICAgICBzaGFwZXMucHVzaChzaGFwZVBhdGgpO1xyXG4gICAgICBzZWdtZW50Q291bnQgPSAwO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc2hhcGVzO1xyXG59O1xyXG5cclxuU2hhcGVNb2RpZmllcnMucmVnaXN0ZXJNb2RpZmllcigndG0nLCBUcmltTW9kaWZpZXIpO1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgU2hhcGVNb2RpZmllciwgUHJvcGVydHlGYWN0b3J5LCBzaGFwZVBvb2wsIHJvdW5kQ29ybmVyLCBTaGFwZU1vZGlmaWVycyAqL1xyXG5cclxuZnVuY3Rpb24gUm91bmRDb3JuZXJzTW9kaWZpZXIoKSB7fVxyXG5leHRlbmRQcm90b3R5cGUoW1NoYXBlTW9kaWZpZXJdLCBSb3VuZENvcm5lcnNNb2RpZmllcik7XHJcblJvdW5kQ29ybmVyc01vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcclxuICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcclxuICB0aGlzLnJkID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yLCAwLCBudWxsLCB0aGlzKTtcclxuICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLnJkLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XHJcbn07XHJcblxyXG5Sb3VuZENvcm5lcnNNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1BhdGggPSBmdW5jdGlvbiAocGF0aCwgcm91bmQpIHtcclxuICB2YXIgY2xvbmVkUGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgY2xvbmVkUGF0aC5jID0gcGF0aC5jO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBwYXRoLl9sZW5ndGg7XHJcbiAgdmFyIGN1cnJlbnRWO1xyXG4gIHZhciBjdXJyZW50STtcclxuICB2YXIgY3VycmVudE87XHJcbiAgdmFyIGNsb3NlclY7XHJcbiAgdmFyIGRpc3RhbmNlO1xyXG4gIHZhciBuZXdQb3NQZXJjO1xyXG4gIHZhciBpbmRleCA9IDA7XHJcbiAgdmFyIHZYO1xyXG4gIHZhciB2WTtcclxuICB2YXIgb1g7XHJcbiAgdmFyIG9ZO1xyXG4gIHZhciBpWDtcclxuICB2YXIgaVk7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBjdXJyZW50ViA9IHBhdGgudltpXTtcclxuICAgIGN1cnJlbnRPID0gcGF0aC5vW2ldO1xyXG4gICAgY3VycmVudEkgPSBwYXRoLmlbaV07XHJcbiAgICBpZiAoY3VycmVudFZbMF0gPT09IGN1cnJlbnRPWzBdICYmIGN1cnJlbnRWWzFdID09PSBjdXJyZW50T1sxXSAmJiBjdXJyZW50VlswXSA9PT0gY3VycmVudElbMF0gJiYgY3VycmVudFZbMV0gPT09IGN1cnJlbnRJWzFdKSB7XHJcbiAgICAgIGlmICgoaSA9PT0gMCB8fCBpID09PSBsZW4gLSAxKSAmJiAhcGF0aC5jKSB7XHJcbiAgICAgICAgY2xvbmVkUGF0aC5zZXRUcmlwbGVBdChjdXJyZW50VlswXSwgY3VycmVudFZbMV0sIGN1cnJlbnRPWzBdLCBjdXJyZW50T1sxXSwgY3VycmVudElbMF0sIGN1cnJlbnRJWzFdLCBpbmRleCk7XHJcbiAgICAgICAgLyogY2xvbmVkUGF0aC52W2luZGV4XSA9IGN1cnJlbnRWO1xyXG4gICAgICAgICAgICAgICAgY2xvbmVkUGF0aC5vW2luZGV4XSA9IGN1cnJlbnRPO1xyXG4gICAgICAgICAgICAgICAgY2xvbmVkUGF0aC5pW2luZGV4XSA9IGN1cnJlbnRJOyAqL1xyXG4gICAgICAgIGluZGV4ICs9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgIGNsb3NlclYgPSBwYXRoLnZbbGVuIC0gMV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNsb3NlclYgPSBwYXRoLnZbaSAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyhjdXJyZW50VlswXSAtIGNsb3NlclZbMF0sIDIpICsgTWF0aC5wb3coY3VycmVudFZbMV0gLSBjbG9zZXJWWzFdLCAyKSk7XHJcbiAgICAgICAgbmV3UG9zUGVyYyA9IGRpc3RhbmNlID8gTWF0aC5taW4oZGlzdGFuY2UgLyAyLCByb3VuZCkgLyBkaXN0YW5jZSA6IDA7XHJcbiAgICAgICAgaVggPSBjdXJyZW50VlswXSArIChjbG9zZXJWWzBdIC0gY3VycmVudFZbMF0pICogbmV3UG9zUGVyYztcclxuICAgICAgICB2WCA9IGlYO1xyXG4gICAgICAgIGlZID0gY3VycmVudFZbMV0gLSAoY3VycmVudFZbMV0gLSBjbG9zZXJWWzFdKSAqIG5ld1Bvc1BlcmM7XHJcbiAgICAgICAgdlkgPSBpWTtcclxuICAgICAgICBvWCA9IHZYIC0gKHZYIC0gY3VycmVudFZbMF0pICogcm91bmRDb3JuZXI7XHJcbiAgICAgICAgb1kgPSB2WSAtICh2WSAtIGN1cnJlbnRWWzFdKSAqIHJvdW5kQ29ybmVyO1xyXG4gICAgICAgIGNsb25lZFBhdGguc2V0VHJpcGxlQXQodlgsIHZZLCBvWCwgb1ksIGlYLCBpWSwgaW5kZXgpO1xyXG4gICAgICAgIGluZGV4ICs9IDE7XHJcblxyXG4gICAgICAgIGlmIChpID09PSBsZW4gLSAxKSB7XHJcbiAgICAgICAgICBjbG9zZXJWID0gcGF0aC52WzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjbG9zZXJWID0gcGF0aC52W2kgKyAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudFZbMF0gLSBjbG9zZXJWWzBdLCAyKSArIE1hdGgucG93KGN1cnJlbnRWWzFdIC0gY2xvc2VyVlsxXSwgMikpO1xyXG4gICAgICAgIG5ld1Bvc1BlcmMgPSBkaXN0YW5jZSA/IE1hdGgubWluKGRpc3RhbmNlIC8gMiwgcm91bmQpIC8gZGlzdGFuY2UgOiAwO1xyXG4gICAgICAgIG9YID0gY3VycmVudFZbMF0gKyAoY2xvc2VyVlswXSAtIGN1cnJlbnRWWzBdKSAqIG5ld1Bvc1BlcmM7XHJcbiAgICAgICAgdlggPSBvWDtcclxuICAgICAgICBvWSA9IGN1cnJlbnRWWzFdICsgKGNsb3NlclZbMV0gLSBjdXJyZW50VlsxXSkgKiBuZXdQb3NQZXJjO1xyXG4gICAgICAgIHZZID0gb1k7XHJcbiAgICAgICAgaVggPSB2WCAtICh2WCAtIGN1cnJlbnRWWzBdKSAqIHJvdW5kQ29ybmVyO1xyXG4gICAgICAgIGlZID0gdlkgLSAodlkgLSBjdXJyZW50VlsxXSkgKiByb3VuZENvcm5lcjtcclxuICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KHZYLCB2WSwgb1gsIG9ZLCBpWCwgaVksIGluZGV4KTtcclxuICAgICAgICBpbmRleCArPSAxO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KHBhdGgudltpXVswXSwgcGF0aC52W2ldWzFdLCBwYXRoLm9baV1bMF0sIHBhdGgub1tpXVsxXSwgcGF0aC5pW2ldWzBdLCBwYXRoLmlbaV1bMV0sIGluZGV4KTtcclxuICAgICAgaW5kZXggKz0gMTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGNsb25lZFBhdGg7XHJcbn07XHJcblxyXG5Sb3VuZENvcm5lcnNNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XHJcbiAgdmFyIHNoYXBlUGF0aHM7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcclxuICB2YXIgajtcclxuICB2YXIgakxlbjtcclxuICB2YXIgcmQgPSB0aGlzLnJkLnY7XHJcblxyXG4gIGlmIChyZCAhPT0gMCkge1xyXG4gICAgdmFyIHNoYXBlRGF0YTtcclxuICAgIHZhciBsb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBzaGFwZURhdGEgPSB0aGlzLnNoYXBlc1tpXTtcclxuICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICAgIGlmICghKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lKSkge1xyXG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcclxuICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XHJcbiAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XHJcbiAgICAgICAgakxlbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMucHJvY2Vzc1BhdGgoc2hhcGVQYXRoc1tqXSwgcmQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG5TaGFwZU1vZGlmaWVycy5yZWdpc3Rlck1vZGlmaWVyKCdyZCcsIFJvdW5kQ29ybmVyc01vZGlmaWVyKTtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIFNoYXBlTW9kaWZpZXIsIFByb3BlcnR5RmFjdG9yeSwgc2hhcGVQb29sLCBTaGFwZU1vZGlmaWVycyAqL1xyXG5cclxuZnVuY3Rpb24gUHVja2VyQW5kQmxvYXRNb2RpZmllcigpIHt9XHJcbmV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIFB1Y2tlckFuZEJsb2F0TW9kaWZpZXIpO1xyXG5QdWNrZXJBbmRCbG9hdE1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcclxuICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcclxuICB0aGlzLmFtb3VudCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSwgMCwgbnVsbCwgdGhpcyk7XHJcbiAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5hbW91bnQuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcclxufTtcclxuXHJcblB1Y2tlckFuZEJsb2F0TW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKHBhdGgsIGFtb3VudCkge1xyXG4gIHZhciBwZXJjZW50ID0gYW1vdW50IC8gMTAwO1xyXG4gIHZhciBjZW50ZXJQb2ludCA9IFswLCAwXTtcclxuICB2YXIgcGF0aExlbmd0aCA9IHBhdGguX2xlbmd0aDtcclxuICB2YXIgaSA9IDA7XHJcbiAgZm9yIChpID0gMDsgaSA8IHBhdGhMZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgY2VudGVyUG9pbnRbMF0gKz0gcGF0aC52W2ldWzBdO1xyXG4gICAgY2VudGVyUG9pbnRbMV0gKz0gcGF0aC52W2ldWzFdO1xyXG4gIH1cclxuICBjZW50ZXJQb2ludFswXSAvPSBwYXRoTGVuZ3RoO1xyXG4gIGNlbnRlclBvaW50WzFdIC89IHBhdGhMZW5ndGg7XHJcbiAgdmFyIGNsb25lZFBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xyXG4gIGNsb25lZFBhdGguYyA9IHBhdGguYztcclxuICB2YXIgdlg7XHJcbiAgdmFyIHZZO1xyXG4gIHZhciBvWDtcclxuICB2YXIgb1k7XHJcbiAgdmFyIGlYO1xyXG4gIHZhciBpWTtcclxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aExlbmd0aDsgaSArPSAxKSB7XHJcbiAgICB2WCA9IHBhdGgudltpXVswXSArIChjZW50ZXJQb2ludFswXSAtIHBhdGgudltpXVswXSkgKiBwZXJjZW50O1xyXG4gICAgdlkgPSBwYXRoLnZbaV1bMV0gKyAoY2VudGVyUG9pbnRbMV0gLSBwYXRoLnZbaV1bMV0pICogcGVyY2VudDtcclxuICAgIG9YID0gcGF0aC5vW2ldWzBdICsgKGNlbnRlclBvaW50WzBdIC0gcGF0aC5vW2ldWzBdKSAqIC1wZXJjZW50O1xyXG4gICAgb1kgPSBwYXRoLm9baV1bMV0gKyAoY2VudGVyUG9pbnRbMV0gLSBwYXRoLm9baV1bMV0pICogLXBlcmNlbnQ7XHJcbiAgICBpWCA9IHBhdGguaVtpXVswXSArIChjZW50ZXJQb2ludFswXSAtIHBhdGguaVtpXVswXSkgKiAtcGVyY2VudDtcclxuICAgIGlZID0gcGF0aC5pW2ldWzFdICsgKGNlbnRlclBvaW50WzFdIC0gcGF0aC5pW2ldWzFdKSAqIC1wZXJjZW50O1xyXG4gICAgY2xvbmVkUGF0aC5zZXRUcmlwbGVBdCh2WCwgdlksIG9YLCBvWSwgaVgsIGlZLCBpKTtcclxuICB9XHJcbiAgcmV0dXJuIGNsb25lZFBhdGg7XHJcbn07XHJcblxyXG5QdWNrZXJBbmRCbG9hdE1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcclxuICB2YXIgc2hhcGVQYXRocztcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xyXG4gIHZhciBqO1xyXG4gIHZhciBqTGVuO1xyXG4gIHZhciBhbW91bnQgPSB0aGlzLmFtb3VudC52O1xyXG5cclxuICBpZiAoYW1vdW50ICE9PSAwKSB7XHJcbiAgICB2YXIgc2hhcGVEYXRhO1xyXG4gICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldO1xyXG4gICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgICAgaWYgKCEoIXNoYXBlRGF0YS5zaGFwZS5fbWRmICYmICF0aGlzLl9tZGYgJiYgIV9pc0ZpcnN0RnJhbWUpKSB7XHJcbiAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xyXG4gICAgICAgIHNoYXBlRGF0YS5zaGFwZS5fbWRmID0gdHJ1ZTtcclxuICAgICAgICBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlcztcclxuICAgICAgICBqTGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGg7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy5wcm9jZXNzUGF0aChzaGFwZVBhdGhzW2pdLCBhbW91bnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICB9XHJcbn07XHJcblNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3BiJywgUHVja2VyQW5kQmxvYXRNb2RpZmllcik7XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCBTaGFwZU1vZGlmaWVyLCBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnksIFByb3BlcnR5RmFjdG9yeSwgTWF0cml4LCBTaGFwZU1vZGlmaWVycyAqL1xyXG5cclxuZnVuY3Rpb24gUmVwZWF0ZXJNb2RpZmllcigpIHt9XHJcbmV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIFJlcGVhdGVyTW9kaWZpZXIpO1xyXG5cclxuUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhKSB7XHJcbiAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XHJcbiAgdGhpcy5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5jLCAwLCBudWxsLCB0aGlzKTtcclxuICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIG51bGwsIHRoaXMpO1xyXG4gIHRoaXMudHIgPSBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YS50ciwgdGhpcyk7XHJcbiAgdGhpcy5zbyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudHIuc28sIDAsIDAuMDEsIHRoaXMpO1xyXG4gIHRoaXMuZW8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnRyLmVvLCAwLCAwLjAxLCB0aGlzKTtcclxuICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XHJcbiAgfVxyXG4gIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xyXG4gIHRoaXMucE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcclxuICB0aGlzLnJNYXRyaXggPSBuZXcgTWF0cml4KCk7XHJcbiAgdGhpcy5zTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG4gIHRoaXMudE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcclxuICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcclxufTtcclxuXHJcblJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtcyA9IGZ1bmN0aW9uIChwTWF0cml4LCByTWF0cml4LCBzTWF0cml4LCB0cmFuc2Zvcm0sIHBlcmMsIGludikge1xyXG4gIHZhciBkaXIgPSBpbnYgPyAtMSA6IDE7XHJcbiAgdmFyIHNjYWxlWCA9IHRyYW5zZm9ybS5zLnZbMF0gKyAoMSAtIHRyYW5zZm9ybS5zLnZbMF0pICogKDEgLSBwZXJjKTtcclxuICB2YXIgc2NhbGVZID0gdHJhbnNmb3JtLnMudlsxXSArICgxIC0gdHJhbnNmb3JtLnMudlsxXSkgKiAoMSAtIHBlcmMpO1xyXG4gIHBNYXRyaXgudHJhbnNsYXRlKHRyYW5zZm9ybS5wLnZbMF0gKiBkaXIgKiBwZXJjLCB0cmFuc2Zvcm0ucC52WzFdICogZGlyICogcGVyYywgdHJhbnNmb3JtLnAudlsyXSk7XHJcbiAgck1hdHJpeC50cmFuc2xhdGUoLXRyYW5zZm9ybS5hLnZbMF0sIC10cmFuc2Zvcm0uYS52WzFdLCB0cmFuc2Zvcm0uYS52WzJdKTtcclxuICByTWF0cml4LnJvdGF0ZSgtdHJhbnNmb3JtLnIudiAqIGRpciAqIHBlcmMpO1xyXG4gIHJNYXRyaXgudHJhbnNsYXRlKHRyYW5zZm9ybS5hLnZbMF0sIHRyYW5zZm9ybS5hLnZbMV0sIHRyYW5zZm9ybS5hLnZbMl0pO1xyXG4gIHNNYXRyaXgudHJhbnNsYXRlKC10cmFuc2Zvcm0uYS52WzBdLCAtdHJhbnNmb3JtLmEudlsxXSwgdHJhbnNmb3JtLmEudlsyXSk7XHJcbiAgc01hdHJpeC5zY2FsZShpbnYgPyAxIC8gc2NhbGVYIDogc2NhbGVYLCBpbnYgPyAxIC8gc2NhbGVZIDogc2NhbGVZKTtcclxuICBzTWF0cml4LnRyYW5zbGF0ZSh0cmFuc2Zvcm0uYS52WzBdLCB0cmFuc2Zvcm0uYS52WzFdLCB0cmFuc2Zvcm0uYS52WzJdKTtcclxufTtcclxuXHJcblJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWxlbSwgYXJyLCBwb3MsIGVsZW1zRGF0YSkge1xyXG4gIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgdGhpcy5hcnIgPSBhcnI7XHJcbiAgdGhpcy5wb3MgPSBwb3M7XHJcbiAgdGhpcy5lbGVtc0RhdGEgPSBlbGVtc0RhdGE7XHJcbiAgdGhpcy5fY3VycmVudENvcGllcyA9IDA7XHJcbiAgdGhpcy5fZWxlbWVudHMgPSBbXTtcclxuICB0aGlzLl9ncm91cHMgPSBbXTtcclxuICB0aGlzLmZyYW1lSWQgPSAtMTtcclxuICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XHJcbiAgdGhpcy5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzKGVsZW0sIGFycltwb3NdKTtcclxuICB3aGlsZSAocG9zID4gMCkge1xyXG4gICAgcG9zIC09IDE7XHJcbiAgICAvLyB0aGlzLl9lbGVtZW50cy51bnNoaWZ0KGFyci5zcGxpY2UocG9zLDEpWzBdKTtcclxuICAgIHRoaXMuX2VsZW1lbnRzLnVuc2hpZnQoYXJyW3Bvc10pO1xyXG4gIH1cclxuICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgIHRoaXMuayA9IHRydWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUucmVzZXRFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBlbGVtZW50c1tpXS5fcHJvY2Vzc2VkID0gZmFsc2U7XHJcbiAgICBpZiAoZWxlbWVudHNbaV0udHkgPT09ICdncicpIHtcclxuICAgICAgdGhpcy5yZXNldEVsZW1lbnRzKGVsZW1lbnRzW2ldLml0KTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5SZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5jbG9uZUVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZW1lbnRzKSB7XHJcbiAgdmFyIG5ld0VsZW1lbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbGVtZW50cykpO1xyXG4gIHRoaXMucmVzZXRFbGVtZW50cyhuZXdFbGVtZW50cyk7XHJcbiAgcmV0dXJuIG5ld0VsZW1lbnRzO1xyXG59O1xyXG5cclxuUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuY2hhbmdlR3JvdXBSZW5kZXIgPSBmdW5jdGlvbiAoZWxlbWVudHMsIHJlbmRlckZsYWcpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgZWxlbWVudHNbaV0uX3JlbmRlciA9IHJlbmRlckZsYWc7XHJcbiAgICBpZiAoZWxlbWVudHNbaV0udHkgPT09ICdncicpIHtcclxuICAgICAgdGhpcy5jaGFuZ2VHcm91cFJlbmRlcihlbGVtZW50c1tpXS5pdCwgcmVuZGVyRmxhZyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XHJcbiAgdmFyIGl0ZW1zO1xyXG4gIHZhciBpdGVtc1RyYW5zZm9ybTtcclxuICB2YXIgaTtcclxuICB2YXIgZGlyO1xyXG4gIHZhciBjb250O1xyXG4gIHZhciBoYXNSZWxvYWRlZCA9IGZhbHNlO1xyXG4gIGlmICh0aGlzLl9tZGYgfHwgX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgdmFyIGNvcGllcyA9IE1hdGguY2VpbCh0aGlzLmMudik7XHJcbiAgICBpZiAodGhpcy5fZ3JvdXBzLmxlbmd0aCA8IGNvcGllcykge1xyXG4gICAgICB3aGlsZSAodGhpcy5fZ3JvdXBzLmxlbmd0aCA8IGNvcGllcykge1xyXG4gICAgICAgIHZhciBncm91cCA9IHtcclxuICAgICAgICAgIGl0OiB0aGlzLmNsb25lRWxlbWVudHModGhpcy5fZWxlbWVudHMpLFxyXG4gICAgICAgICAgdHk6ICdncicsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBncm91cC5pdC5wdXNoKHtcclxuICAgICAgICAgIGE6IHsgYTogMCwgaXg6IDEsIGs6IFswLCAwXSB9LCBubTogJ1RyYW5zZm9ybScsIG86IHsgYTogMCwgaXg6IDcsIGs6IDEwMCB9LCBwOiB7IGE6IDAsIGl4OiAyLCBrOiBbMCwgMF0gfSwgcjogeyBhOiAxLCBpeDogNiwgazogW3sgczogMCwgZTogMCwgdDogMCB9LCB7IHM6IDAsIGU6IDAsIHQ6IDEgfV0gfSwgczogeyBhOiAwLCBpeDogMywgazogWzEwMCwgMTAwXSB9LCBzYTogeyBhOiAwLCBpeDogNSwgazogMCB9LCBzazogeyBhOiAwLCBpeDogNCwgazogMCB9LCB0eTogJ3RyJyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5hcnIuc3BsaWNlKDAsIDAsIGdyb3VwKTtcclxuICAgICAgICB0aGlzLl9ncm91cHMuc3BsaWNlKDAsIDAsIGdyb3VwKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Q29waWVzICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5lbGVtLnJlbG9hZFNoYXBlcygpO1xyXG4gICAgICBoYXNSZWxvYWRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBjb250ID0gMDtcclxuICAgIHZhciByZW5kZXJGbGFnO1xyXG4gICAgZm9yIChpID0gMDsgaSA8PSB0aGlzLl9ncm91cHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XHJcbiAgICAgIHJlbmRlckZsYWcgPSBjb250IDwgY29waWVzO1xyXG4gICAgICB0aGlzLl9ncm91cHNbaV0uX3JlbmRlciA9IHJlbmRlckZsYWc7XHJcbiAgICAgIHRoaXMuY2hhbmdlR3JvdXBSZW5kZXIodGhpcy5fZ3JvdXBzW2ldLml0LCByZW5kZXJGbGFnKTtcclxuICAgICAgaWYgKCFyZW5kZXJGbGFnKSB7XHJcbiAgICAgICAgdmFyIGVsZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybURhdGEgPSBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAodHJhbnNmb3JtRGF0YS50cmFuc2Zvcm0ub3AudiAhPT0gMCkge1xyXG4gICAgICAgICAgdHJhbnNmb3JtRGF0YS50cmFuc2Zvcm0ub3AuX21kZiA9IHRydWU7XHJcbiAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC52ID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdHJhbnNmb3JtRGF0YS50cmFuc2Zvcm0ub3AuX21kZiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb250ICs9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fY3VycmVudENvcGllcyA9IGNvcGllcztcclxuICAgIC8vLyAvXHJcblxyXG4gICAgdmFyIG9mZnNldCA9IHRoaXMuby52O1xyXG4gICAgdmFyIG9mZnNldE1vZHVsbyA9IG9mZnNldCAlIDE7XHJcbiAgICB2YXIgcm91bmRPZmZzZXQgPSBvZmZzZXQgPiAwID8gTWF0aC5mbG9vcihvZmZzZXQpIDogTWF0aC5jZWlsKG9mZnNldCk7XHJcbiAgICB2YXIgcFByb3BzID0gdGhpcy5wTWF0cml4LnByb3BzO1xyXG4gICAgdmFyIHJQcm9wcyA9IHRoaXMuck1hdHJpeC5wcm9wcztcclxuICAgIHZhciBzUHJvcHMgPSB0aGlzLnNNYXRyaXgucHJvcHM7XHJcbiAgICB0aGlzLnBNYXRyaXgucmVzZXQoKTtcclxuICAgIHRoaXMuck1hdHJpeC5yZXNldCgpO1xyXG4gICAgdGhpcy5zTWF0cml4LnJlc2V0KCk7XHJcbiAgICB0aGlzLnRNYXRyaXgucmVzZXQoKTtcclxuICAgIHRoaXMubWF0cml4LnJlc2V0KCk7XHJcbiAgICB2YXIgaXRlcmF0aW9uID0gMDtcclxuXHJcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xyXG4gICAgICB3aGlsZSAoaXRlcmF0aW9uIDwgcm91bmRPZmZzZXQpIHtcclxuICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh0aGlzLnBNYXRyaXgsIHRoaXMuck1hdHJpeCwgdGhpcy5zTWF0cml4LCB0aGlzLnRyLCAxLCBmYWxzZSk7XHJcbiAgICAgICAgaXRlcmF0aW9uICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9mZnNldE1vZHVsbykge1xyXG4gICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIG9mZnNldE1vZHVsbywgZmFsc2UpO1xyXG4gICAgICAgIGl0ZXJhdGlvbiArPSBvZmZzZXRNb2R1bG87XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAob2Zmc2V0IDwgMCkge1xyXG4gICAgICB3aGlsZSAoaXRlcmF0aW9uID4gcm91bmRPZmZzZXQpIHtcclxuICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh0aGlzLnBNYXRyaXgsIHRoaXMuck1hdHJpeCwgdGhpcy5zTWF0cml4LCB0aGlzLnRyLCAxLCB0cnVlKTtcclxuICAgICAgICBpdGVyYXRpb24gLT0gMTtcclxuICAgICAgfVxyXG4gICAgICBpZiAob2Zmc2V0TW9kdWxvKSB7XHJcbiAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXModGhpcy5wTWF0cml4LCB0aGlzLnJNYXRyaXgsIHRoaXMuc01hdHJpeCwgdGhpcy50ciwgLW9mZnNldE1vZHVsbywgdHJ1ZSk7XHJcbiAgICAgICAgaXRlcmF0aW9uIC09IG9mZnNldE1vZHVsbztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaSA9IHRoaXMuZGF0YS5tID09PSAxID8gMCA6IHRoaXMuX2N1cnJlbnRDb3BpZXMgLSAxO1xyXG4gICAgZGlyID0gdGhpcy5kYXRhLm0gPT09IDEgPyAxIDogLTE7XHJcbiAgICBjb250ID0gdGhpcy5fY3VycmVudENvcGllcztcclxuICAgIHZhciBqO1xyXG4gICAgdmFyIGpMZW47XHJcbiAgICB3aGlsZSAoY29udCkge1xyXG4gICAgICBpdGVtcyA9IHRoaXMuZWxlbXNEYXRhW2ldLml0O1xyXG4gICAgICBpdGVtc1RyYW5zZm9ybSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5tUHJvcHMudi5wcm9wcztcclxuICAgICAgakxlbiA9IGl0ZW1zVHJhbnNmb3JtLmxlbmd0aDtcclxuICAgICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy5fbWRmID0gdHJ1ZTtcclxuICAgICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm9wLl9tZGYgPSB0cnVlO1xyXG4gICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ub3AudiA9IHRoaXMuX2N1cnJlbnRDb3BpZXMgPT09IDFcclxuICAgICAgICA/IHRoaXMuc28udlxyXG4gICAgICAgIDogdGhpcy5zby52ICsgKHRoaXMuZW8udiAtIHRoaXMuc28udikgKiAoaSAvICh0aGlzLl9jdXJyZW50Q29waWVzIC0gMSkpO1xyXG5cclxuICAgICAgaWYgKGl0ZXJhdGlvbiAhPT0gMCkge1xyXG4gICAgICAgIGlmICgoaSAhPT0gMCAmJiBkaXIgPT09IDEpIHx8IChpICE9PSB0aGlzLl9jdXJyZW50Q29waWVzIC0gMSAmJiBkaXIgPT09IC0xKSkge1xyXG4gICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXModGhpcy5wTWF0cml4LCB0aGlzLnJNYXRyaXgsIHRoaXMuc01hdHJpeCwgdGhpcy50ciwgMSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0oclByb3BzWzBdLCByUHJvcHNbMV0sIHJQcm9wc1syXSwgclByb3BzWzNdLCByUHJvcHNbNF0sIHJQcm9wc1s1XSwgclByb3BzWzZdLCByUHJvcHNbN10sIHJQcm9wc1s4XSwgclByb3BzWzldLCByUHJvcHNbMTBdLCByUHJvcHNbMTFdLCByUHJvcHNbMTJdLCByUHJvcHNbMTNdLCByUHJvcHNbMTRdLCByUHJvcHNbMTVdKTtcclxuICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0oc1Byb3BzWzBdLCBzUHJvcHNbMV0sIHNQcm9wc1syXSwgc1Byb3BzWzNdLCBzUHJvcHNbNF0sIHNQcm9wc1s1XSwgc1Byb3BzWzZdLCBzUHJvcHNbN10sIHNQcm9wc1s4XSwgc1Byb3BzWzldLCBzUHJvcHNbMTBdLCBzUHJvcHNbMTFdLCBzUHJvcHNbMTJdLCBzUHJvcHNbMTNdLCBzUHJvcHNbMTRdLCBzUHJvcHNbMTVdKTtcclxuICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0ocFByb3BzWzBdLCBwUHJvcHNbMV0sIHBQcm9wc1syXSwgcFByb3BzWzNdLCBwUHJvcHNbNF0sIHBQcm9wc1s1XSwgcFByb3BzWzZdLCBwUHJvcHNbN10sIHBQcm9wc1s4XSwgcFByb3BzWzldLCBwUHJvcHNbMTBdLCBwUHJvcHNbMTFdLCBwUHJvcHNbMTJdLCBwUHJvcHNbMTNdLCBwUHJvcHNbMTRdLCBwUHJvcHNbMTVdKTtcclxuXHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgaXRlbXNUcmFuc2Zvcm1bal0gPSB0aGlzLm1hdHJpeC5wcm9wc1tqXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm1hdHJpeC5yZXNldCgpO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgIGl0ZW1zVHJhbnNmb3JtW2pdID0gdGhpcy5tYXRyaXgucHJvcHNbal07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGl0ZXJhdGlvbiArPSAxO1xyXG4gICAgICBjb250IC09IDE7XHJcbiAgICAgIGkgKz0gZGlyO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBjb250ID0gdGhpcy5fY3VycmVudENvcGllcztcclxuICAgIGkgPSAwO1xyXG4gICAgZGlyID0gMTtcclxuICAgIHdoaWxlIChjb250KSB7XHJcbiAgICAgIGl0ZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XHJcbiAgICAgIGl0ZW1zVHJhbnNmb3JtID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy52LnByb3BzO1xyXG4gICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLl9tZGYgPSBmYWxzZTtcclxuICAgICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm9wLl9tZGYgPSBmYWxzZTtcclxuICAgICAgY29udCAtPSAxO1xyXG4gICAgICBpICs9IGRpcjtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGhhc1JlbG9hZGVkO1xyXG59O1xyXG5cclxuUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcblNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3JwJywgUmVwZWF0ZXJNb2RpZmllcik7XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlU2l6ZWRBcnJheSwgc2hhcGVQb29sICovXHJcblxyXG5mdW5jdGlvbiBTaGFwZUNvbGxlY3Rpb24oKSB7XHJcbiAgdGhpcy5fbGVuZ3RoID0gMDtcclxuICB0aGlzLl9tYXhMZW5ndGggPSA0O1xyXG4gIHRoaXMuc2hhcGVzID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpO1xyXG59XHJcblxyXG5TaGFwZUNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKHNoYXBlRGF0YSkge1xyXG4gIGlmICh0aGlzLl9sZW5ndGggPT09IHRoaXMuX21heExlbmd0aCkge1xyXG4gICAgdGhpcy5zaGFwZXMgPSB0aGlzLnNoYXBlcy5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpKTtcclxuICAgIHRoaXMuX21heExlbmd0aCAqPSAyO1xyXG4gIH1cclxuICB0aGlzLnNoYXBlc1t0aGlzLl9sZW5ndGhdID0gc2hhcGVEYXRhO1xyXG4gIHRoaXMuX2xlbmd0aCArPSAxO1xyXG59O1xyXG5cclxuU2hhcGVDb2xsZWN0aW9uLnByb3RvdHlwZS5yZWxlYXNlU2hhcGVzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBpO1xyXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgc2hhcGVQb29sLnJlbGVhc2UodGhpcy5zaGFwZXNbaV0pO1xyXG4gIH1cclxuICB0aGlzLl9sZW5ndGggPSAwO1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZVNpemVkQXJyYXksIGNyZWF0ZVR5cGVkQXJyYXksIFByb3BlcnR5RmFjdG9yeSwgZXh0ZW5kUHJvdG90eXBlLCBEeW5hbWljUHJvcGVydHlDb250YWluZXIgKi9cclxuXHJcbmZ1bmN0aW9uIERhc2hQcm9wZXJ0eShlbGVtLCBkYXRhLCByZW5kZXJlciwgY29udGFpbmVyKSB7XHJcbiAgdGhpcy5lbGVtID0gZWxlbTtcclxuICB0aGlzLmZyYW1lSWQgPSAtMTtcclxuICB0aGlzLmRhdGFQcm9wcyA9IGNyZWF0ZVNpemVkQXJyYXkoZGF0YS5sZW5ndGgpO1xyXG4gIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuICB0aGlzLmsgPSBmYWxzZTtcclxuICB0aGlzLmRhc2hTdHIgPSAnJztcclxuICB0aGlzLmRhc2hBcnJheSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBkYXRhLmxlbmd0aCA/IGRhdGEubGVuZ3RoIC0gMSA6IDApO1xyXG4gIHRoaXMuZGFzaG9mZnNldCA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAxKTtcclxuICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoY29udGFpbmVyKTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gZGF0YS5sZW5ndGggfHwgMDtcclxuICB2YXIgcHJvcDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIHByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhW2ldLnYsIDAsIDAsIHRoaXMpO1xyXG4gICAgdGhpcy5rID0gcHJvcC5rIHx8IHRoaXMuaztcclxuICAgIHRoaXMuZGF0YVByb3BzW2ldID0geyBuOiBkYXRhW2ldLm4sIHA6IHByb3AgfTtcclxuICB9XHJcbiAgaWYgKCF0aGlzLmspIHtcclxuICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XHJcbiAgfVxyXG4gIHRoaXMuX2lzQW5pbWF0ZWQgPSB0aGlzLms7XHJcbn1cclxuXHJcbkRhc2hQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcclxuICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkICYmICFmb3JjZVJlbmRlcikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xyXG4gIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XHJcbiAgdGhpcy5fbWRmID0gdGhpcy5fbWRmIHx8IGZvcmNlUmVuZGVyO1xyXG4gIGlmICh0aGlzLl9tZGYpIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBsZW4gPSB0aGlzLmRhdGFQcm9wcy5sZW5ndGg7XHJcbiAgICBpZiAodGhpcy5yZW5kZXJlciA9PT0gJ3N2ZycpIHtcclxuICAgICAgdGhpcy5kYXNoU3RyID0gJyc7XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgaWYgKHRoaXMuZGF0YVByb3BzW2ldLm4gIT09ICdvJykge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyID09PSAnc3ZnJykge1xyXG4gICAgICAgICAgdGhpcy5kYXNoU3RyICs9ICcgJyArIHRoaXMuZGF0YVByb3BzW2ldLnAudjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5kYXNoQXJyYXlbaV0gPSB0aGlzLmRhdGFQcm9wc1tpXS5wLnY7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZGFzaG9mZnNldFswXSA9IHRoaXMuZGF0YVByb3BzW2ldLnAudjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBEYXNoUHJvcGVydHkpO1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZVR5cGVkQXJyYXksIFByb3BlcnR5RmFjdG9yeSwgZXh0ZW5kUHJvdG90eXBlLCBEeW5hbWljUHJvcGVydHlDb250YWluZXIgKi9cclxuZnVuY3Rpb24gR3JhZGllbnRQcm9wZXJ0eShlbGVtLCBkYXRhLCBjb250YWluZXIpIHtcclxuICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gIHRoaXMuYyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ3VpbnQ4YycsIGRhdGEucCAqIDQpO1xyXG4gIHZhciBjTGVuZ3RoID0gZGF0YS5rLmtbMF0ucyA/IChkYXRhLmsua1swXS5zLmxlbmd0aCAtIGRhdGEucCAqIDQpIDogZGF0YS5rLmsubGVuZ3RoIC0gZGF0YS5wICogNDtcclxuICB0aGlzLm8gPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgY0xlbmd0aCk7XHJcbiAgdGhpcy5fY21kZiA9IGZhbHNlO1xyXG4gIHRoaXMuX29tZGYgPSBmYWxzZTtcclxuICB0aGlzLl9jb2xsYXBzYWJsZSA9IHRoaXMuY2hlY2tDb2xsYXBzYWJsZSgpO1xyXG4gIHRoaXMuX2hhc09wYWNpdHkgPSBjTGVuZ3RoO1xyXG4gIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihjb250YWluZXIpO1xyXG4gIHRoaXMucHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuaywgMSwgbnVsbCwgdGhpcyk7XHJcbiAgdGhpcy5rID0gdGhpcy5wcm9wLms7XHJcbiAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcclxufVxyXG5cclxuR3JhZGllbnRQcm9wZXJ0eS5wcm90b3R5cGUuY29tcGFyZVBvaW50cyA9IGZ1bmN0aW9uICh2YWx1ZXMsIHBvaW50cykge1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgbGVuID0gdGhpcy5vLmxlbmd0aCAvIDI7XHJcbiAgdmFyIGRpZmY7XHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIGRpZmYgPSBNYXRoLmFicyh2YWx1ZXNbaSAqIDRdIC0gdmFsdWVzW3BvaW50cyAqIDQgKyBpICogMl0pO1xyXG4gICAgaWYgKGRpZmYgPiAwLjAxKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGkgKz0gMTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5HcmFkaWVudFByb3BlcnR5LnByb3RvdHlwZS5jaGVja0NvbGxhcHNhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICh0aGlzLm8ubGVuZ3RoIC8gMiAhPT0gdGhpcy5jLmxlbmd0aCAvIDQpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKHRoaXMuZGF0YS5rLmtbMF0ucykge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5rLmsubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgaWYgKCF0aGlzLmNvbXBhcmVQb2ludHModGhpcy5kYXRhLmsua1tpXS5zLCB0aGlzLmRhdGEucCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoIXRoaXMuY29tcGFyZVBvaW50cyh0aGlzLmRhdGEuay5rLCB0aGlzLmRhdGEucCkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5HcmFkaWVudFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xyXG4gIHRoaXMucHJvcC5nZXRWYWx1ZSgpO1xyXG4gIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gIHRoaXMuX2NtZGYgPSBmYWxzZTtcclxuICB0aGlzLl9vbWRmID0gZmFsc2U7XHJcbiAgaWYgKHRoaXMucHJvcC5fbWRmIHx8IGZvcmNlUmVuZGVyKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSB0aGlzLmRhdGEucCAqIDQ7XHJcbiAgICB2YXIgbXVsdDtcclxuICAgIHZhciB2YWw7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgbXVsdCA9IGkgJSA0ID09PSAwID8gMTAwIDogMjU1O1xyXG4gICAgICB2YWwgPSBNYXRoLnJvdW5kKHRoaXMucHJvcC52W2ldICogbXVsdCk7XHJcbiAgICAgIGlmICh0aGlzLmNbaV0gIT09IHZhbCkge1xyXG4gICAgICAgIHRoaXMuY1tpXSA9IHZhbDtcclxuICAgICAgICB0aGlzLl9jbWRmID0gIWZvcmNlUmVuZGVyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5vLmxlbmd0aCkge1xyXG4gICAgICBsZW4gPSB0aGlzLnByb3Audi5sZW5ndGg7XHJcbiAgICAgIGZvciAoaSA9IHRoaXMuZGF0YS5wICogNDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgbXVsdCA9IGkgJSAyID09PSAwID8gMTAwIDogMTtcclxuICAgICAgICB2YWwgPSBpICUgMiA9PT0gMCA/IE1hdGgucm91bmQodGhpcy5wcm9wLnZbaV0gKiAxMDApIDogdGhpcy5wcm9wLnZbaV07XHJcbiAgICAgICAgaWYgKHRoaXMub1tpIC0gdGhpcy5kYXRhLnAgKiA0XSAhPT0gdmFsKSB7XHJcbiAgICAgICAgICB0aGlzLm9baSAtIHRoaXMuZGF0YS5wICogNF0gPSB2YWw7XHJcbiAgICAgICAgICB0aGlzLl9vbWRmID0gIWZvcmNlUmVuZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5fbWRmID0gIWZvcmNlUmVuZGVyO1xyXG4gIH1cclxufTtcclxuXHJcbmV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgR3JhZGllbnRQcm9wZXJ0eSk7XHJcblxyXG4vKiBleHBvcnRlZCBidWlsZFNoYXBlU3RyaW5nICovXHJcblxyXG52YXIgYnVpbGRTaGFwZVN0cmluZyA9IGZ1bmN0aW9uIChwYXRoTm9kZXMsIGxlbmd0aCwgY2xvc2VkLCBtYXQpIHtcclxuICBpZiAobGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG4gIHZhciBfbyA9IHBhdGhOb2Rlcy5vO1xyXG4gIHZhciBfaSA9IHBhdGhOb2Rlcy5pO1xyXG4gIHZhciBfdiA9IHBhdGhOb2Rlcy52O1xyXG4gIHZhciBpO1xyXG4gIHZhciBzaGFwZVN0cmluZyA9ICcgTScgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX3ZbMF1bMF0sIF92WzBdWzFdKTtcclxuICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcclxuICAgIHNoYXBlU3RyaW5nICs9ICcgQycgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX29baSAtIDFdWzBdLCBfb1tpIC0gMV1bMV0pICsgJyAnICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF9pW2ldWzBdLCBfaVtpXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX3ZbaV1bMF0sIF92W2ldWzFdKTtcclxuICB9XHJcbiAgaWYgKGNsb3NlZCAmJiBsZW5ndGgpIHtcclxuICAgIHNoYXBlU3RyaW5nICs9ICcgQycgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX29baSAtIDFdWzBdLCBfb1tpIC0gMV1bMV0pICsgJyAnICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF9pWzBdWzBdLCBfaVswXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX3ZbMF1bMF0sIF92WzBdWzFdKTtcclxuICAgIHNoYXBlU3RyaW5nICs9ICd6JztcclxuICB9XHJcbiAgcmV0dXJuIHNoYXBlU3RyaW5nO1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIEhvd2wgKi9cclxuLyogZXhwb3J0ZWQgYXVkaW9Db250cm9sbGVyRmFjdG9yeSAqL1xyXG5cclxudmFyIGF1ZGlvQ29udHJvbGxlckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIEF1ZGlvQ29udHJvbGxlcihhdWRpb0ZhY3RvcnkpIHtcclxuICAgIHRoaXMuYXVkaW9zID0gW107XHJcbiAgICB0aGlzLmF1ZGlvRmFjdG9yeSA9IGF1ZGlvRmFjdG9yeTtcclxuICAgIHRoaXMuX3ZvbHVtZSA9IDE7XHJcbiAgICB0aGlzLl9pc011dGVkID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBBdWRpb0NvbnRyb2xsZXIucHJvdG90eXBlID0ge1xyXG4gICAgYWRkQXVkaW86IGZ1bmN0aW9uIChhdWRpbykge1xyXG4gICAgICB0aGlzLmF1ZGlvcy5wdXNoKGF1ZGlvKTtcclxuICAgIH0sXHJcbiAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbiA9IHRoaXMuYXVkaW9zLmxlbmd0aDtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb3NbaV0ucGF1c2UoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbiA9IHRoaXMuYXVkaW9zLmxlbmd0aDtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb3NbaV0ucmVzdW1lKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzZXRSYXRlOiBmdW5jdGlvbiAocmF0ZVZhbHVlKSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuID0gdGhpcy5hdWRpb3MubGVuZ3RoO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvc1tpXS5zZXRSYXRlKHJhdGVWYWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjcmVhdGVBdWRpbzogZnVuY3Rpb24gKGFzc2V0UGF0aCkge1xyXG4gICAgICBpZiAodGhpcy5hdWRpb0ZhY3RvcnkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdWRpb0ZhY3RvcnkoYXNzZXRQYXRoKTtcclxuICAgICAgfSBpZiAoSG93bCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSG93bCh7XHJcbiAgICAgICAgICBzcmM6IFthc3NldFBhdGhdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaXNQbGF5aW5nOiBmYWxzZSxcclxuICAgICAgICBwbGF5OiBmdW5jdGlvbiAoKSB7IHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTsgfSxcclxuICAgICAgICBzZWVrOiBmdW5jdGlvbiAoKSB7IHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7IH0sXHJcbiAgICAgICAgcGxheWluZzogZnVuY3Rpb24gKCkge30sXHJcbiAgICAgICAgcmF0ZTogZnVuY3Rpb24gKCkge30sXHJcbiAgICAgICAgc2V0Vm9sdW1lOiBmdW5jdGlvbiAoKSB7fSxcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBzZXRBdWRpb0ZhY3Rvcnk6IGZ1bmN0aW9uIChhdWRpb0ZhY3RvcnkpIHtcclxuICAgICAgdGhpcy5hdWRpb0ZhY3RvcnkgPSBhdWRpb0ZhY3Rvcnk7XHJcbiAgICB9LFxyXG4gICAgc2V0Vm9sdW1lOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgdGhpcy5fdm9sdW1lID0gdmFsdWU7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xyXG4gICAgfSxcclxuICAgIG11dGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5faXNNdXRlZCA9IHRydWU7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xyXG4gICAgfSxcclxuICAgIHVubXV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLl9pc011dGVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xyXG4gICAgfSxcclxuICAgIGdldFZvbHVtZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdm9sdW1lO1xyXG4gICAgfSxcclxuICAgIF91cGRhdGVWb2x1bWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsZW4gPSB0aGlzLmF1ZGlvcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9zW2ldLnZvbHVtZSh0aGlzLl92b2x1bWUgKiAodGhpcy5faXNNdXRlZCA/IDAgOiAxKSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuZXcgQXVkaW9Db250cm9sbGVyKCk7XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVUYWcsIGNyZWF0ZU5TLCBpc1NhZmFyaSwgYXNzZXRMb2FkZXIgKi9cclxuLyogZXhwb3J0ZWQgSW1hZ2VQcmVsb2FkZXIgKi9cclxuXHJcbnZhciBJbWFnZVByZWxvYWRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHByb3h5SW1hZ2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGNhbnZhcyA9IGNyZWF0ZVRhZygnY2FudmFzJyk7XHJcbiAgICBjYW52YXMud2lkdGggPSAxO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IDE7XHJcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xyXG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xyXG4gICAgcmV0dXJuIGNhbnZhcztcclxuICB9KCkpO1xyXG5cclxuICBmdW5jdGlvbiBpbWFnZUxvYWRlZCgpIHtcclxuICAgIHRoaXMubG9hZGVkQXNzZXRzICs9IDE7XHJcbiAgICBpZiAodGhpcy5sb2FkZWRBc3NldHMgPT09IHRoaXMudG90YWxJbWFnZXMgJiYgdGhpcy5sb2FkZWRGb290YWdlc0NvdW50ID09PSB0aGlzLnRvdGFsRm9vdGFnZXMpIHtcclxuICAgICAgaWYgKHRoaXMuaW1hZ2VzTG9hZGVkQ2IpIHtcclxuICAgICAgICB0aGlzLmltYWdlc0xvYWRlZENiKG51bGwpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGZvb3RhZ2VMb2FkZWQoKSB7XHJcbiAgICB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgKz0gMTtcclxuICAgIGlmICh0aGlzLmxvYWRlZEFzc2V0cyA9PT0gdGhpcy50b3RhbEltYWdlcyAmJiB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPT09IHRoaXMudG90YWxGb290YWdlcykge1xyXG4gICAgICBpZiAodGhpcy5pbWFnZXNMb2FkZWRDYikge1xyXG4gICAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IobnVsbCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldEFzc2V0c1BhdGgoYXNzZXREYXRhLCBhc3NldHNQYXRoLCBvcmlnaW5hbFBhdGgpIHtcclxuICAgIHZhciBwYXRoID0gJyc7XHJcbiAgICBpZiAoYXNzZXREYXRhLmUpIHtcclxuICAgICAgcGF0aCA9IGFzc2V0RGF0YS5wO1xyXG4gICAgfSBlbHNlIGlmIChhc3NldHNQYXRoKSB7XHJcbiAgICAgIHZhciBpbWFnZVBhdGggPSBhc3NldERhdGEucDtcclxuICAgICAgaWYgKGltYWdlUGF0aC5pbmRleE9mKCdpbWFnZXMvJykgIT09IC0xKSB7XHJcbiAgICAgICAgaW1hZ2VQYXRoID0gaW1hZ2VQYXRoLnNwbGl0KCcvJylbMV07XHJcbiAgICAgIH1cclxuICAgICAgcGF0aCA9IGFzc2V0c1BhdGggKyBpbWFnZVBhdGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYXRoID0gb3JpZ2luYWxQYXRoO1xyXG4gICAgICBwYXRoICs9IGFzc2V0RGF0YS51ID8gYXNzZXREYXRhLnUgOiAnJztcclxuICAgICAgcGF0aCArPSBhc3NldERhdGEucDtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdGVzdEltYWdlTG9hZGVkKGltZykge1xyXG4gICAgdmFyIF9jb3VudCA9IDA7XHJcbiAgICB2YXIgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJveCA9IGltZy5nZXRCQm94KCk7XHJcbiAgICAgIGlmIChib3gud2lkdGggfHwgX2NvdW50ID4gNTAwKSB7XHJcbiAgICAgICAgdGhpcy5faW1hZ2VMb2FkZWQoKTtcclxuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xyXG4gICAgICB9XHJcbiAgICAgIF9jb3VudCArPSAxO1xyXG4gICAgfS5iaW5kKHRoaXMpLCA1MCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVJbWFnZURhdGEoYXNzZXREYXRhKSB7XHJcbiAgICB2YXIgcGF0aCA9IGdldEFzc2V0c1BhdGgoYXNzZXREYXRhLCB0aGlzLmFzc2V0c1BhdGgsIHRoaXMucGF0aCk7XHJcbiAgICB2YXIgaW1nID0gY3JlYXRlTlMoJ2ltYWdlJyk7XHJcbiAgICBpZiAoaXNTYWZhcmkpIHtcclxuICAgICAgdGhpcy50ZXN0SW1hZ2VMb2FkZWQoaW1nKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5faW1hZ2VMb2FkZWQsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgb2IuaW1nID0gcHJveHlJbWFnZTtcclxuICAgICAgdGhpcy5faW1hZ2VMb2FkZWQoKTtcclxuICAgIH0uYmluZCh0aGlzKSwgZmFsc2UpO1xyXG4gICAgaW1nLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ2hyZWYnLCBwYXRoKTtcclxuICAgIGlmICh0aGlzLl9lbGVtZW50SGVscGVyLmFwcGVuZCkge1xyXG4gICAgICB0aGlzLl9lbGVtZW50SGVscGVyLmFwcGVuZChpbWcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fZWxlbWVudEhlbHBlci5hcHBlbmRDaGlsZChpbWcpO1xyXG4gICAgfVxyXG4gICAgdmFyIG9iID0ge1xyXG4gICAgICBpbWc6IGltZyxcclxuICAgICAgYXNzZXREYXRhOiBhc3NldERhdGEsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG9iO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlSW1nRGF0YShhc3NldERhdGEpIHtcclxuICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcclxuICAgIHZhciBpbWcgPSBjcmVhdGVUYWcoJ2ltZycpO1xyXG4gICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2ltYWdlTG9hZGVkLCBmYWxzZSk7XHJcbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIG9iLmltZyA9IHByb3h5SW1hZ2U7XHJcbiAgICAgIHRoaXMuX2ltYWdlTG9hZGVkKCk7XHJcbiAgICB9LmJpbmQodGhpcyksIGZhbHNlKTtcclxuICAgIGltZy5zcmMgPSBwYXRoO1xyXG4gICAgdmFyIG9iID0ge1xyXG4gICAgICBpbWc6IGltZyxcclxuICAgICAgYXNzZXREYXRhOiBhc3NldERhdGEsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG9iO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlRm9vdGFnZURhdGEoZGF0YSkge1xyXG4gICAgdmFyIG9iID0ge1xyXG4gICAgICBhc3NldERhdGE6IGRhdGEsXHJcbiAgICB9O1xyXG4gICAgdmFyIHBhdGggPSBnZXRBc3NldHNQYXRoKGRhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcclxuICAgIGFzc2V0TG9hZGVyLmxvYWQocGF0aCwgZnVuY3Rpb24gKGZvb3RhZ2VEYXRhKSB7XHJcbiAgICAgIG9iLmltZyA9IGZvb3RhZ2VEYXRhO1xyXG4gICAgICB0aGlzLl9mb290YWdlTG9hZGVkKCk7XHJcbiAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgb2IuaW1nID0ge307XHJcbiAgICAgIHRoaXMuX2Zvb3RhZ2VMb2FkZWQoKTtcclxuICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICByZXR1cm4gb2I7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2FkQXNzZXRzKGFzc2V0cywgY2IpIHtcclxuICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IgPSBjYjtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IGFzc2V0cy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgaWYgKCFhc3NldHNbaV0ubGF5ZXJzKSB7XHJcbiAgICAgICAgaWYgKCFhc3NldHNbaV0udCB8fCBhc3NldHNbaV0udCA9PT0gJ3NlcScpIHtcclxuICAgICAgICAgIHRoaXMudG90YWxJbWFnZXMgKz0gMTtcclxuICAgICAgICAgIHRoaXMuaW1hZ2VzLnB1c2godGhpcy5fY3JlYXRlSW1hZ2VEYXRhKGFzc2V0c1tpXSkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXNzZXRzW2ldLnQgPT09IDMpIHtcclxuICAgICAgICAgIHRoaXMudG90YWxGb290YWdlcyArPSAxO1xyXG4gICAgICAgICAgdGhpcy5pbWFnZXMucHVzaCh0aGlzLmNyZWF0ZUZvb3RhZ2VEYXRhKGFzc2V0c1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0UGF0aChwYXRoKSB7XHJcbiAgICB0aGlzLnBhdGggPSBwYXRoIHx8ICcnO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0QXNzZXRzUGF0aChwYXRoKSB7XHJcbiAgICB0aGlzLmFzc2V0c1BhdGggPSBwYXRoIHx8ICcnO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0QXNzZXQoYXNzZXREYXRhKSB7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5pbWFnZXMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgaWYgKHRoaXMuaW1hZ2VzW2ldLmFzc2V0RGF0YSA9PT0gYXNzZXREYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VzW2ldLmltZztcclxuICAgICAgfVxyXG4gICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmltYWdlc0xvYWRlZENiID0gbnVsbDtcclxuICAgIHRoaXMuaW1hZ2VzLmxlbmd0aCA9IDA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2FkZWRJbWFnZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b3RhbEltYWdlcyA9PT0gdGhpcy5sb2FkZWRBc3NldHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2FkZWRGb290YWdlcygpIHtcclxuICAgIHJldHVybiB0aGlzLnRvdGFsRm9vdGFnZXMgPT09IHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldENhY2hlVHlwZSh0eXBlLCBlbGVtZW50SGVscGVyKSB7XHJcbiAgICBpZiAodHlwZSA9PT0gJ3N2ZycpIHtcclxuICAgICAgdGhpcy5fZWxlbWVudEhlbHBlciA9IGVsZW1lbnRIZWxwZXI7XHJcbiAgICAgIHRoaXMuX2NyZWF0ZUltYWdlRGF0YSA9IHRoaXMuY3JlYXRlSW1hZ2VEYXRhLmJpbmQodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9jcmVhdGVJbWFnZURhdGEgPSB0aGlzLmNyZWF0ZUltZ0RhdGEuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIEltYWdlUHJlbG9hZGVyRmFjdG9yeSgpIHtcclxuICAgIHRoaXMuX2ltYWdlTG9hZGVkID0gaW1hZ2VMb2FkZWQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX2Zvb3RhZ2VMb2FkZWQgPSBmb290YWdlTG9hZGVkLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLnRlc3RJbWFnZUxvYWRlZCA9IHRlc3RJbWFnZUxvYWRlZC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5jcmVhdGVGb290YWdlRGF0YSA9IGNyZWF0ZUZvb3RhZ2VEYXRhLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmFzc2V0c1BhdGggPSAnJztcclxuICAgIHRoaXMucGF0aCA9ICcnO1xyXG4gICAgdGhpcy50b3RhbEltYWdlcyA9IDA7XHJcbiAgICB0aGlzLnRvdGFsRm9vdGFnZXMgPSAwO1xyXG4gICAgdGhpcy5sb2FkZWRBc3NldHMgPSAwO1xyXG4gICAgdGhpcy5sb2FkZWRGb290YWdlc0NvdW50ID0gMDtcclxuICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IgPSBudWxsO1xyXG4gICAgdGhpcy5pbWFnZXMgPSBbXTtcclxuICB9XHJcblxyXG4gIEltYWdlUHJlbG9hZGVyRmFjdG9yeS5wcm90b3R5cGUgPSB7XHJcbiAgICBsb2FkQXNzZXRzOiBsb2FkQXNzZXRzLFxyXG4gICAgc2V0QXNzZXRzUGF0aDogc2V0QXNzZXRzUGF0aCxcclxuICAgIHNldFBhdGg6IHNldFBhdGgsXHJcbiAgICBsb2FkZWRJbWFnZXM6IGxvYWRlZEltYWdlcyxcclxuICAgIGxvYWRlZEZvb3RhZ2VzOiBsb2FkZWRGb290YWdlcyxcclxuICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXHJcbiAgICBnZXRBc3NldDogZ2V0QXNzZXQsXHJcbiAgICBjcmVhdGVJbWdEYXRhOiBjcmVhdGVJbWdEYXRhLFxyXG4gICAgY3JlYXRlSW1hZ2VEYXRhOiBjcmVhdGVJbWFnZURhdGEsXHJcbiAgICBpbWFnZUxvYWRlZDogaW1hZ2VMb2FkZWQsXHJcbiAgICBmb290YWdlTG9hZGVkOiBmb290YWdlTG9hZGVkLFxyXG4gICAgc2V0Q2FjaGVUeXBlOiBzZXRDYWNoZVR5cGUsXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIEltYWdlUHJlbG9hZGVyRmFjdG9yeTtcclxufSgpKTtcclxuXHJcbi8qIGV4cG9ydGVkIGZlYXR1cmVTdXBwb3J0ICovXHJcblxyXG52YXIgZmVhdHVyZVN1cHBvcnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBvYiA9IHtcclxuICAgIG1hc2tUeXBlOiB0cnVlLFxyXG4gIH07XHJcbiAgaWYgKC9NU0lFIDEwL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fCAvTVNJRSA5L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fCAvcnY6MTEuMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL0VkZ2VcXC9cXGQuL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xyXG4gICAgb2IubWFza1R5cGUgPSBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIG9iO1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZU5TICovXHJcbi8qIGV4cG9ydGVkIGZpbHRlcnNGYWN0b3J5ICovXHJcblxyXG52YXIgZmlsdGVyc0ZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBvYiA9IHt9O1xyXG4gIG9iLmNyZWF0ZUZpbHRlciA9IGNyZWF0ZUZpbHRlcjtcclxuICBvYi5jcmVhdGVBbHBoYVRvTHVtaW5hbmNlRmlsdGVyID0gY3JlYXRlQWxwaGFUb0x1bWluYW5jZUZpbHRlcjtcclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlRmlsdGVyKGZpbElkLCBza2lwQ29vcmRpbmF0ZXMpIHtcclxuICAgIHZhciBmaWwgPSBjcmVhdGVOUygnZmlsdGVyJyk7XHJcbiAgICBmaWwuc2V0QXR0cmlidXRlKCdpZCcsIGZpbElkKTtcclxuICAgIGlmIChza2lwQ29vcmRpbmF0ZXMgIT09IHRydWUpIHtcclxuICAgICAgZmlsLnNldEF0dHJpYnV0ZSgnZmlsdGVyVW5pdHMnLCAnb2JqZWN0Qm91bmRpbmdCb3gnKTtcclxuICAgICAgZmlsLnNldEF0dHJpYnV0ZSgneCcsICcwJScpO1xyXG4gICAgICBmaWwuc2V0QXR0cmlidXRlKCd5JywgJzAlJyk7XHJcbiAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzEwMCUnKTtcclxuICAgICAgZmlsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzEwMCUnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmaWw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVBbHBoYVRvTHVtaW5hbmNlRmlsdGVyKCkge1xyXG4gICAgdmFyIGZlQ29sb3JNYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xyXG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XHJcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcclxuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMCAwIDAgMSAwICAwIDAgMCAxIDAgIDAgMCAwIDEgMCAgMCAwIDAgMSAxJyk7XHJcbiAgICByZXR1cm4gZmVDb2xvck1hdHJpeDtcclxuICB9XHJcblxyXG4gIHJldHVybiBvYjtcclxufSgpKTtcclxuXHJcbi8qIGV4cG9ydGVkIGFzc2V0TG9hZGVyICovXHJcblxyXG52YXIgYXNzZXRMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIGZvcm1hdFJlc3BvbnNlKHhocikge1xyXG4gICAgaWYgKHhoci5yZXNwb25zZSAmJiB0eXBlb2YgeGhyLnJlc3BvbnNlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm4geGhyLnJlc3BvbnNlO1xyXG4gICAgfSBpZiAoeGhyLnJlc3BvbnNlICYmIHR5cGVvZiB4aHIucmVzcG9uc2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHhoci5yZXNwb25zZSk7XHJcbiAgICB9IGlmICh4aHIucmVzcG9uc2VUZXh0KSB7XHJcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2FkQXNzZXQocGF0aCwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcclxuICAgIHZhciByZXNwb25zZTtcclxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgIC8vIHNldCByZXNwb25zZVR5cGUgYWZ0ZXIgY2FsbGluZyBvcGVuIG9yIElFIHdpbGwgYnJlYWsuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBUaGlzIGNyYXNoZXMgb24gQW5kcm9pZCBXZWJWaWV3IHByaW9yIHRvIEtpdEthdFxyXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XHJcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcclxuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICByZXNwb25zZSA9IGZvcm1hdFJlc3BvbnNlKHhocik7XHJcbiAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlID0gZm9ybWF0UmVzcG9uc2UoeGhyKTtcclxuICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgeGhyLm9wZW4oJ0dFVCcsIHBhdGgsIHRydWUpO1xyXG4gICAgeGhyLnNlbmQoKTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIGxvYWQ6IGxvYWRBc3NldCxcclxuICB9O1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZVNpemVkQXJyYXksIFByb3BlcnR5RmFjdG9yeSwgVGV4dEFuaW1hdG9yRGF0YVByb3BlcnR5LCBiZXosIGFkZEh1ZVRvUkdCLFxyXG4gIGFkZFNhdHVyYXRpb25Ub1JHQiwgYWRkQnJpZ2h0bmVzc1RvUkdCLCBMZXR0ZXJQcm9wcywgTWF0cml4LCBleHRlbmRQcm90b3R5cGUsIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lciAqL1xyXG5cclxuZnVuY3Rpb24gVGV4dEFuaW1hdG9yUHJvcGVydHkodGV4dERhdGEsIHJlbmRlclR5cGUsIGVsZW0pIHtcclxuICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gIHRoaXMuX2hhc01hc2tlZFBhdGggPSBmYWxzZTtcclxuICB0aGlzLl9mcmFtZUlkID0gLTE7XHJcbiAgdGhpcy5fdGV4dERhdGEgPSB0ZXh0RGF0YTtcclxuICB0aGlzLl9yZW5kZXJUeXBlID0gcmVuZGVyVHlwZTtcclxuICB0aGlzLl9lbGVtID0gZWxlbTtcclxuICB0aGlzLl9hbmltYXRvcnNEYXRhID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl90ZXh0RGF0YS5hLmxlbmd0aCk7XHJcbiAgdGhpcy5fcGF0aERhdGEgPSB7fTtcclxuICB0aGlzLl9tb3JlT3B0aW9ucyA9IHtcclxuICAgIGFsaWdubWVudDoge30sXHJcbiAgfTtcclxuICB0aGlzLnJlbmRlcmVkTGV0dGVycyA9IFtdO1xyXG4gIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gZmFsc2U7XHJcbiAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xyXG59XHJcblxyXG5UZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5fdGV4dERhdGEuYS5sZW5ndGg7XHJcbiAgdmFyIGFuaW1hdG9yUHJvcHM7XHJcbiAgdmFyIGdldFByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGFuaW1hdG9yUHJvcHMgPSB0aGlzLl90ZXh0RGF0YS5hW2ldO1xyXG4gICAgdGhpcy5fYW5pbWF0b3JzRGF0YVtpXSA9IG5ldyBUZXh0QW5pbWF0b3JEYXRhUHJvcGVydHkodGhpcy5fZWxlbSwgYW5pbWF0b3JQcm9wcywgdGhpcyk7XHJcbiAgfVxyXG4gIGlmICh0aGlzLl90ZXh0RGF0YS5wICYmICdtJyBpbiB0aGlzLl90ZXh0RGF0YS5wKSB7XHJcbiAgICB0aGlzLl9wYXRoRGF0YSA9IHtcclxuICAgICAgZjogZ2V0UHJvcCh0aGlzLl9lbGVtLCB0aGlzLl90ZXh0RGF0YS5wLmYsIDAsIDAsIHRoaXMpLFxyXG4gICAgICBsOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAubCwgMCwgMCwgdGhpcyksXHJcbiAgICAgIHI6IHRoaXMuX3RleHREYXRhLnAucixcclxuICAgICAgbTogdGhpcy5fZWxlbS5tYXNrTWFuYWdlci5nZXRNYXNrUHJvcGVydHkodGhpcy5fdGV4dERhdGEucC5tKSxcclxuICAgIH07XHJcbiAgICB0aGlzLl9oYXNNYXNrZWRQYXRoID0gdHJ1ZTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5faGFzTWFza2VkUGF0aCA9IGZhbHNlO1xyXG4gIH1cclxuICB0aGlzLl9tb3JlT3B0aW9ucy5hbGlnbm1lbnQgPSBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLm0uYSwgMSwgMCwgdGhpcyk7XHJcbn07XHJcblxyXG5UZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0TWVhc3VyZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhLCBsZXR0ZXJzQ2hhbmdlZEZsYWcpIHtcclxuICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IGxldHRlcnNDaGFuZ2VkRmxhZztcclxuICBpZiAoIXRoaXMuX21kZiAmJiAhdGhpcy5faXNGaXJzdEZyYW1lICYmICFsZXR0ZXJzQ2hhbmdlZEZsYWcgJiYgKCF0aGlzLl9oYXNNYXNrZWRQYXRoIHx8ICF0aGlzLl9wYXRoRGF0YS5tLl9tZGYpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xyXG4gIHZhciBhbGlnbm1lbnQgPSB0aGlzLl9tb3JlT3B0aW9ucy5hbGlnbm1lbnQudjtcclxuICB2YXIgYW5pbWF0b3JzID0gdGhpcy5fYW5pbWF0b3JzRGF0YTtcclxuICB2YXIgdGV4dERhdGEgPSB0aGlzLl90ZXh0RGF0YTtcclxuICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xyXG4gIHZhciByZW5kZXJUeXBlID0gdGhpcy5fcmVuZGVyVHlwZTtcclxuICB2YXIgcmVuZGVyZWRMZXR0ZXJzQ291bnQgPSB0aGlzLnJlbmRlcmVkTGV0dGVycy5sZW5ndGg7XHJcbiAgdmFyIHhQb3M7XHJcbiAgdmFyIHlQb3M7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbjtcclxuICB2YXIgbGV0dGVycyA9IGRvY3VtZW50RGF0YS5sO1xyXG4gIHZhciBwYXRoSW5mbztcclxuICB2YXIgY3VycmVudExlbmd0aDtcclxuICB2YXIgY3VycmVudFBvaW50O1xyXG4gIHZhciBzZWdtZW50TGVuZ3RoO1xyXG4gIHZhciBmbGFnO1xyXG4gIHZhciBwb2ludEluZDtcclxuICB2YXIgc2VnbWVudEluZDtcclxuICB2YXIgcHJldlBvaW50O1xyXG4gIHZhciBwb2ludHM7XHJcbiAgdmFyIHNlZ21lbnRzO1xyXG4gIHZhciBwYXJ0aWFsTGVuZ3RoO1xyXG4gIHZhciB0b3RhbExlbmd0aDtcclxuICB2YXIgcGVyYztcclxuICB2YXIgdGFuQW5nbGU7XHJcbiAgdmFyIG1hc2s7XHJcbiAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcclxuICAgIG1hc2sgPSB0aGlzLl9wYXRoRGF0YS5tO1xyXG4gICAgaWYgKCF0aGlzLl9wYXRoRGF0YS5uIHx8IHRoaXMuX3BhdGhEYXRhLl9tZGYpIHtcclxuICAgICAgdmFyIHBhdGhzID0gbWFzay52O1xyXG4gICAgICBpZiAodGhpcy5fcGF0aERhdGEucikge1xyXG4gICAgICAgIHBhdGhzID0gcGF0aHMucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFRPRE86IHJlbGVhc2UgYmV6aWVyIGRhdGEgY2FjaGVkIGZyb20gcHJldmlvdXMgcGF0aEluZm86IHRoaXMuX3BhdGhEYXRhLnBpXHJcbiAgICAgIHBhdGhJbmZvID0ge1xyXG4gICAgICAgIHRMZW5ndGg6IDAsXHJcbiAgICAgICAgc2VnbWVudHM6IFtdLFxyXG4gICAgICB9O1xyXG4gICAgICBsZW4gPSBwYXRocy5fbGVuZ3RoIC0gMTtcclxuICAgICAgdmFyIGJlemllckRhdGE7XHJcbiAgICAgIHRvdGFsTGVuZ3RoID0gMDtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgYmV6aWVyRGF0YSA9IGJlei5idWlsZEJlemllckRhdGEocGF0aHMudltpXSxcclxuICAgICAgICAgIHBhdGhzLnZbaSArIDFdLFxyXG4gICAgICAgICAgW3BhdGhzLm9baV1bMF0gLSBwYXRocy52W2ldWzBdLCBwYXRocy5vW2ldWzFdIC0gcGF0aHMudltpXVsxXV0sXHJcbiAgICAgICAgICBbcGF0aHMuaVtpICsgMV1bMF0gLSBwYXRocy52W2kgKyAxXVswXSwgcGF0aHMuaVtpICsgMV1bMV0gLSBwYXRocy52W2kgKyAxXVsxXV0pO1xyXG4gICAgICAgIHBhdGhJbmZvLnRMZW5ndGggKz0gYmV6aWVyRGF0YS5zZWdtZW50TGVuZ3RoO1xyXG4gICAgICAgIHBhdGhJbmZvLnNlZ21lbnRzLnB1c2goYmV6aWVyRGF0YSk7XHJcbiAgICAgICAgdG90YWxMZW5ndGggKz0gYmV6aWVyRGF0YS5zZWdtZW50TGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIGkgPSBsZW47XHJcbiAgICAgIGlmIChtYXNrLnYuYykge1xyXG4gICAgICAgIGJlemllckRhdGEgPSBiZXouYnVpbGRCZXppZXJEYXRhKHBhdGhzLnZbaV0sXHJcbiAgICAgICAgICBwYXRocy52WzBdLFxyXG4gICAgICAgICAgW3BhdGhzLm9baV1bMF0gLSBwYXRocy52W2ldWzBdLCBwYXRocy5vW2ldWzFdIC0gcGF0aHMudltpXVsxXV0sXHJcbiAgICAgICAgICBbcGF0aHMuaVswXVswXSAtIHBhdGhzLnZbMF1bMF0sIHBhdGhzLmlbMF1bMV0gLSBwYXRocy52WzBdWzFdXSk7XHJcbiAgICAgICAgcGF0aEluZm8udExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XHJcbiAgICAgICAgcGF0aEluZm8uc2VnbWVudHMucHVzaChiZXppZXJEYXRhKTtcclxuICAgICAgICB0b3RhbExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fcGF0aERhdGEucGkgPSBwYXRoSW5mbztcclxuICAgIH1cclxuICAgIHBhdGhJbmZvID0gdGhpcy5fcGF0aERhdGEucGk7XHJcblxyXG4gICAgY3VycmVudExlbmd0aCA9IHRoaXMuX3BhdGhEYXRhLmYudjtcclxuICAgIHNlZ21lbnRJbmQgPSAwO1xyXG4gICAgcG9pbnRJbmQgPSAxO1xyXG4gICAgc2VnbWVudExlbmd0aCA9IDA7XHJcbiAgICBmbGFnID0gdHJ1ZTtcclxuICAgIHNlZ21lbnRzID0gcGF0aEluZm8uc2VnbWVudHM7XHJcbiAgICBpZiAoY3VycmVudExlbmd0aCA8IDAgJiYgbWFzay52LmMpIHtcclxuICAgICAgaWYgKHBhdGhJbmZvLnRMZW5ndGggPCBNYXRoLmFicyhjdXJyZW50TGVuZ3RoKSkge1xyXG4gICAgICAgIGN1cnJlbnRMZW5ndGggPSAtTWF0aC5hYnMoY3VycmVudExlbmd0aCkgJSBwYXRoSW5mby50TGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIHNlZ21lbnRJbmQgPSBzZWdtZW50cy5sZW5ndGggLSAxO1xyXG4gICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5wb2ludHM7XHJcbiAgICAgIHBvaW50SW5kID0gcG9pbnRzLmxlbmd0aCAtIDE7XHJcbiAgICAgIHdoaWxlIChjdXJyZW50TGVuZ3RoIDwgMCkge1xyXG4gICAgICAgIGN1cnJlbnRMZW5ndGggKz0gcG9pbnRzW3BvaW50SW5kXS5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgIHBvaW50SW5kIC09IDE7XHJcbiAgICAgICAgaWYgKHBvaW50SW5kIDwgMCkge1xyXG4gICAgICAgICAgc2VnbWVudEluZCAtPSAxO1xyXG4gICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xyXG4gICAgICAgICAgcG9pbnRJbmQgPSBwb2ludHMubGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLnBvaW50cztcclxuICAgIHByZXZQb2ludCA9IHBvaW50c1twb2ludEluZCAtIDFdO1xyXG4gICAgY3VycmVudFBvaW50ID0gcG9pbnRzW3BvaW50SW5kXTtcclxuICAgIHBhcnRpYWxMZW5ndGggPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcclxuICB9XHJcblxyXG4gIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xyXG4gIHhQb3MgPSAwO1xyXG4gIHlQb3MgPSAwO1xyXG4gIHZhciB5T2ZmID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIDEuMiAqIDAuNzE0O1xyXG4gIHZhciBmaXJzdExpbmUgPSB0cnVlO1xyXG4gIHZhciBhbmltYXRvclByb3BzO1xyXG4gIHZhciBhbmltYXRvclNlbGVjdG9yO1xyXG4gIHZhciBqO1xyXG4gIHZhciBqTGVuO1xyXG4gIHZhciBsZXR0ZXJWYWx1ZTtcclxuXHJcbiAgakxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XHJcblxyXG4gIHZhciBtdWx0O1xyXG4gIHZhciBpbmQgPSAtMTtcclxuICB2YXIgb2ZmZjtcclxuICB2YXIgeFBhdGhQb3M7XHJcbiAgdmFyIHlQYXRoUG9zO1xyXG4gIHZhciBpbml0UGF0aFBvcyA9IGN1cnJlbnRMZW5ndGg7XHJcbiAgdmFyIGluaXRTZWdtZW50SW5kID0gc2VnbWVudEluZDtcclxuICB2YXIgaW5pdFBvaW50SW5kID0gcG9pbnRJbmQ7XHJcbiAgdmFyIGN1cnJlbnRMaW5lID0gLTE7XHJcbiAgdmFyIGVsZW1PcGFjaXR5O1xyXG4gIHZhciBzYztcclxuICB2YXIgc3c7XHJcbiAgdmFyIGZjO1xyXG4gIHZhciBrO1xyXG4gIHZhciBsZXR0ZXJTdztcclxuICB2YXIgbGV0dGVyU2M7XHJcbiAgdmFyIGxldHRlckZjO1xyXG4gIHZhciBsZXR0ZXJNID0gJyc7XHJcbiAgdmFyIGxldHRlclAgPSB0aGlzLmRlZmF1bHRQcm9wc0FycmF5O1xyXG4gIHZhciBsZXR0ZXJPO1xyXG5cclxuICAvL1xyXG4gIGlmIChkb2N1bWVudERhdGEuaiA9PT0gMiB8fCBkb2N1bWVudERhdGEuaiA9PT0gMSkge1xyXG4gICAgdmFyIGFuaW1hdG9ySnVzdGlmeU9mZnNldCA9IDA7XHJcbiAgICB2YXIgYW5pbWF0b3JGaXJzdENoYXJPZmZzZXQgPSAwO1xyXG4gICAgdmFyIGp1c3RpZnlPZmZzZXRNdWx0ID0gZG9jdW1lbnREYXRhLmogPT09IDIgPyAtMC41IDogLTE7XHJcbiAgICB2YXIgbGFzdEluZGV4ID0gMDtcclxuICAgIHZhciBpc05ld0xpbmUgPSB0cnVlO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBpZiAobGV0dGVyc1tpXS5uKSB7XHJcbiAgICAgICAgaWYgKGFuaW1hdG9ySnVzdGlmeU9mZnNldCkge1xyXG4gICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICs9IGFuaW1hdG9yRmlyc3RDaGFyT2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAobGFzdEluZGV4IDwgaSkge1xyXG4gICAgICAgICAgbGV0dGVyc1tsYXN0SW5kZXhdLmFuaW1hdG9ySnVzdGlmeU9mZnNldCA9IGFuaW1hdG9ySnVzdGlmeU9mZnNldDtcclxuICAgICAgICAgIGxhc3RJbmRleCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQgPSAwO1xyXG4gICAgICAgIGlzTmV3TGluZSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xyXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMudC5wcm9wVHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNOZXdMaW5lICYmIGRvY3VtZW50RGF0YS5qID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgYW5pbWF0b3JGaXJzdENoYXJPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBqdXN0aWZ5T2Zmc2V0TXVsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XHJcbiAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcclxuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdFswXSAqIGp1c3RpZnlPZmZzZXRNdWx0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldCArPSBhbmltYXRvclByb3BzLnQudiAqIG11bHQgKiBqdXN0aWZ5T2Zmc2V0TXVsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpc05ld0xpbmUgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFuaW1hdG9ySnVzdGlmeU9mZnNldCkge1xyXG4gICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQgKz0gYW5pbWF0b3JGaXJzdENoYXJPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAobGFzdEluZGV4IDwgaSkge1xyXG4gICAgICBsZXR0ZXJzW2xhc3RJbmRleF0uYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0O1xyXG4gICAgICBsYXN0SW5kZXggKz0gMTtcclxuICAgIH1cclxuICB9XHJcbiAgLy9cclxuXHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcclxuICAgIGVsZW1PcGFjaXR5ID0gMTtcclxuICAgIGlmIChsZXR0ZXJzW2ldLm4pIHtcclxuICAgICAgeFBvcyA9IDA7XHJcbiAgICAgIHlQb3MgKz0gZG9jdW1lbnREYXRhLnlPZmZzZXQ7XHJcbiAgICAgIHlQb3MgKz0gZmlyc3RMaW5lID8gMSA6IDA7XHJcbiAgICAgIGN1cnJlbnRMZW5ndGggPSBpbml0UGF0aFBvcztcclxuICAgICAgZmlyc3RMaW5lID0gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XHJcbiAgICAgICAgc2VnbWVudEluZCA9IGluaXRTZWdtZW50SW5kO1xyXG4gICAgICAgIHBvaW50SW5kID0gaW5pdFBvaW50SW5kO1xyXG4gICAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLnBvaW50cztcclxuICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbcG9pbnRJbmQgLSAxXTtcclxuICAgICAgICBjdXJyZW50UG9pbnQgPSBwb2ludHNbcG9pbnRJbmRdO1xyXG4gICAgICAgIHBhcnRpYWxMZW5ndGggPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcclxuICAgICAgICBzZWdtZW50TGVuZ3RoID0gMDtcclxuICAgICAgfVxyXG4gICAgICBsZXR0ZXJNID0gJyc7XHJcbiAgICAgIGxldHRlckZjID0gJyc7XHJcbiAgICAgIGxldHRlclN3ID0gJyc7XHJcbiAgICAgIGxldHRlck8gPSAnJztcclxuICAgICAgbGV0dGVyUCA9IHRoaXMuZGVmYXVsdFByb3BzQXJyYXk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodGhpcy5faGFzTWFza2VkUGF0aCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50TGluZSAhPT0gbGV0dGVyc1tpXS5saW5lKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IHRvdGFsTGVuZ3RoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGV0dGVyc1tpXS5saW5lXTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gKHRvdGFsTGVuZ3RoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGV0dGVyc1tpXS5saW5lXSkgLyAyO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY3VycmVudExpbmUgPSBsZXR0ZXJzW2ldLmxpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmQgIT09IGxldHRlcnNbaV0uaW5kKSB7XHJcbiAgICAgICAgICBpZiAobGV0dGVyc1tpbmRdKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gbGV0dGVyc1tpbmRdLmV4dHJhO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY3VycmVudExlbmd0aCArPSBsZXR0ZXJzW2ldLmFuIC8gMjtcclxuICAgICAgICAgIGluZCA9IGxldHRlcnNbaV0uaW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50TGVuZ3RoICs9IChhbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuKSAqIDAuMDA1O1xyXG4gICAgICAgIHZhciBhbmltYXRvck9mZnNldCA9IDA7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xyXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucC5wcm9wVHlwZSkge1xyXG4gICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XHJcbiAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcclxuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0WzBdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMucC52WzBdICogbXVsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuYS5wcm9wVHlwZSkge1xyXG4gICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XHJcbiAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcclxuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5hLnZbMF0gKiBtdWx0WzBdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmbGFnID0gdHJ1ZTtcclxuICAgICAgICB3aGlsZSAoZmxhZykge1xyXG4gICAgICAgICAgaWYgKHNlZ21lbnRMZW5ndGggKyBwYXJ0aWFsTGVuZ3RoID49IGN1cnJlbnRMZW5ndGggKyBhbmltYXRvck9mZnNldCB8fCAhcG9pbnRzKSB7XHJcbiAgICAgICAgICAgIHBlcmMgPSAoY3VycmVudExlbmd0aCArIGFuaW1hdG9yT2Zmc2V0IC0gc2VnbWVudExlbmd0aCkgLyBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcclxuICAgICAgICAgICAgeFBhdGhQb3MgPSBwcmV2UG9pbnQucG9pbnRbMF0gKyAoY3VycmVudFBvaW50LnBvaW50WzBdIC0gcHJldlBvaW50LnBvaW50WzBdKSAqIHBlcmM7XHJcbiAgICAgICAgICAgIHlQYXRoUG9zID0gcHJldlBvaW50LnBvaW50WzFdICsgKGN1cnJlbnRQb2ludC5wb2ludFsxXSAtIHByZXZQb2ludC5wb2ludFsxXSkgKiBwZXJjO1xyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKCgtYWxpZ25tZW50WzBdICogbGV0dGVyc1tpXS5hbikgKiAwLjAwNSwgLShhbGlnbm1lbnRbMV0gKiB5T2ZmKSAqIDAuMDEpO1xyXG4gICAgICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50cykge1xyXG4gICAgICAgICAgICBzZWdtZW50TGVuZ3RoICs9IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgICAgICBwb2ludEluZCArPSAxO1xyXG4gICAgICAgICAgICBpZiAocG9pbnRJbmQgPj0gcG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIHBvaW50SW5kID0gMDtcclxuICAgICAgICAgICAgICBzZWdtZW50SW5kICs9IDE7XHJcbiAgICAgICAgICAgICAgaWYgKCFzZWdtZW50c1tzZWdtZW50SW5kXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hc2sudi5jKSB7XHJcbiAgICAgICAgICAgICAgICAgIHBvaW50SW5kID0gMDtcclxuICAgICAgICAgICAgICAgICAgc2VnbWVudEluZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLnBvaW50cztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnRMZW5ndGggLT0gY3VycmVudFBvaW50LnBhcnRpYWxMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIHBvaW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLnBvaW50cztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvaW50cykge1xyXG4gICAgICAgICAgICAgIHByZXZQb2ludCA9IGN1cnJlbnRQb2ludDtcclxuICAgICAgICAgICAgICBjdXJyZW50UG9pbnQgPSBwb2ludHNbcG9pbnRJbmRdO1xyXG4gICAgICAgICAgICAgIHBhcnRpYWxMZW5ndGggPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBvZmZmID0gbGV0dGVyc1tpXS5hbiAvIDIgLSBsZXR0ZXJzW2ldLmFkZDtcclxuICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1vZmZmLCAwLCAwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvZmZmID0gbGV0dGVyc1tpXS5hbiAvIDIgLSBsZXR0ZXJzW2ldLmFkZDtcclxuICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1vZmZmLCAwLCAwKTtcclxuXHJcbiAgICAgICAgLy8gR3JvdXBpbmcgYWxpZ25tZW50XHJcbiAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgoLWFsaWdubWVudFswXSAqIGxldHRlcnNbaV0uYW4pICogMC4wMDUsICgtYWxpZ25tZW50WzFdICogeU9mZikgKiAwLjAxLCAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcclxuICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy50LnByb3BUeXBlKSB7XHJcbiAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XHJcbiAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XHJcbiAgICAgICAgICAvLyBUaGlzIGNvbmRpdGlvbiBpcyB0byBwcmV2ZW50IGFwcGx5aW5nIHRyYWNraW5nIHRvIGZpcnN0IGNoYXJhY3RlciBpbiBlYWNoIGxpbmUuIE1pZ2h0IGJlIGJldHRlciB0byB1c2UgYSBib29sZWFuIFwiaXNOZXdMaW5lXCJcclxuICAgICAgICAgIGlmICh4UG9zICE9PSAwIHx8IGRvY3VtZW50RGF0YS5qICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XHJcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdFswXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBhbmltYXRvclByb3BzLnQudiAqIG11bHQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgeFBvcyArPSBhbmltYXRvclByb3BzLnQudiAqIG11bHRbMF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeFBvcyArPSBhbmltYXRvclByb3BzLnQudiAqIG11bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGRvY3VtZW50RGF0YS5zdHJva2VXaWR0aEFuaW0pIHtcclxuICAgICAgICBzdyA9IGRvY3VtZW50RGF0YS5zdyB8fCAwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlQ29sb3JBbmltKSB7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5zYykge1xyXG4gICAgICAgICAgc2MgPSBbZG9jdW1lbnREYXRhLnNjWzBdLCBkb2N1bWVudERhdGEuc2NbMV0sIGRvY3VtZW50RGF0YS5zY1syXV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNjID0gWzAsIDAsIDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoZG9jdW1lbnREYXRhLmZpbGxDb2xvckFuaW0gJiYgZG9jdW1lbnREYXRhLmZjKSB7XHJcbiAgICAgICAgZmMgPSBbZG9jdW1lbnREYXRhLmZjWzBdLCBkb2N1bWVudERhdGEuZmNbMV0sIGRvY3VtZW50RGF0YS5mY1syXV07XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcclxuICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5hLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XHJcbiAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XHJcblxyXG4gICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLWFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdFswXSwgLWFuaW1hdG9yUHJvcHMuYS52WzFdICogbXVsdFsxXSwgYW5pbWF0b3JQcm9wcy5hLnZbMl0gKiBtdWx0WzJdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLWFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdCwgLWFuaW1hdG9yUHJvcHMuYS52WzFdICogbXVsdCwgYW5pbWF0b3JQcm9wcy5hLnZbMl0gKiBtdWx0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcclxuICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5zLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XHJcbiAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XHJcbiAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnNjYWxlKDEgKyAoKGFuaW1hdG9yUHJvcHMucy52WzBdIC0gMSkgKiBtdWx0WzBdKSwgMSArICgoYW5pbWF0b3JQcm9wcy5zLnZbMV0gLSAxKSAqIG11bHRbMV0pLCAxKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci5zY2FsZSgxICsgKChhbmltYXRvclByb3BzLnMudlswXSAtIDEpICogbXVsdCksIDEgKyAoKGFuaW1hdG9yUHJvcHMucy52WzFdIC0gMSkgKiBtdWx0KSwgMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XHJcbiAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xyXG4gICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcclxuICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5zay5wcm9wVHlwZSkge1xyXG4gICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci5za2V3RnJvbUF4aXMoLWFuaW1hdG9yUHJvcHMuc2sudiAqIG11bHRbMF0sIGFuaW1hdG9yUHJvcHMuc2EudiAqIG11bHRbMV0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnNrZXdGcm9tQXhpcygtYW5pbWF0b3JQcm9wcy5zay52ICogbXVsdCwgYW5pbWF0b3JQcm9wcy5zYS52ICogbXVsdCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbmltYXRvclByb3BzLnIucHJvcFR5cGUpIHtcclxuICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWigtYW5pbWF0b3JQcm9wcy5yLnYgKiBtdWx0WzJdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVaKC1hbmltYXRvclByb3BzLnIudiAqIG11bHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5yeS5wcm9wVHlwZSkge1xyXG4gICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVZKGFuaW1hdG9yUHJvcHMucnkudiAqIG11bHRbMV0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVkoYW5pbWF0b3JQcm9wcy5yeS52ICogbXVsdCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbmltYXRvclByb3BzLnJ4LnByb3BUeXBlKSB7XHJcbiAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVgoYW5pbWF0b3JQcm9wcy5yeC52ICogbXVsdFswXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWChhbmltYXRvclByb3BzLnJ4LnYgKiBtdWx0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuby5wcm9wVHlwZSkge1xyXG4gICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGVsZW1PcGFjaXR5ICs9ICgoYW5pbWF0b3JQcm9wcy5vLnYpICogbXVsdFswXSAtIGVsZW1PcGFjaXR5KSAqIG11bHRbMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbGVtT3BhY2l0eSArPSAoKGFuaW1hdG9yUHJvcHMuby52KSAqIG11bHQgLSBlbGVtT3BhY2l0eSkgKiBtdWx0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZVdpZHRoQW5pbSAmJiBhbmltYXRvclByb3BzLnN3LnByb3BUeXBlKSB7XHJcbiAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgc3cgKz0gYW5pbWF0b3JQcm9wcy5zdy52ICogbXVsdFswXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN3ICs9IGFuaW1hdG9yUHJvcHMuc3cudiAqIG11bHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlQ29sb3JBbmltICYmIGFuaW1hdG9yUHJvcHMuc2MucHJvcFR5cGUpIHtcclxuICAgICAgICAgIGZvciAoayA9IDA7IGsgPCAzOyBrICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgc2Nba10gKz0gKGFuaW1hdG9yUHJvcHMuc2MudltrXSAtIHNjW2tdKSAqIG11bHRbMF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgc2Nba10gKz0gKGFuaW1hdG9yUHJvcHMuc2MudltrXSAtIHNjW2tdKSAqIG11bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltICYmIGRvY3VtZW50RGF0YS5mYykge1xyXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZmMucHJvcFR5cGUpIHtcclxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDM7IGsgKz0gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZmNba10gKz0gKGFuaW1hdG9yUHJvcHMuZmMudltrXSAtIGZjW2tdKSAqIG11bHRbMF07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZjW2tdICs9IChhbmltYXRvclByb3BzLmZjLnZba10gLSBmY1trXSkgKiBtdWx0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZmgucHJvcFR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgZmMgPSBhZGRIdWVUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5maC52ICogbXVsdFswXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZmMgPSBhZGRIdWVUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5maC52ICogbXVsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLmZzLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIGZjID0gYWRkU2F0dXJhdGlvblRvUkdCKGZjLCBhbmltYXRvclByb3BzLmZzLnYgKiBtdWx0WzBdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBmYyA9IGFkZFNhdHVyYXRpb25Ub1JHQihmYywgYW5pbWF0b3JQcm9wcy5mcy52ICogbXVsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLmZiLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIGZjID0gYWRkQnJpZ2h0bmVzc1RvUkdCKGZjLCBhbmltYXRvclByb3BzLmZiLnYgKiBtdWx0WzBdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBmYyA9IGFkZEJyaWdodG5lc3NUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5mYi52ICogbXVsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XHJcblxyXG4gICAgICAgIGlmIChhbmltYXRvclByb3BzLnAucHJvcFR5cGUpIHtcclxuICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcclxuICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcclxuICAgICAgICAgIGlmICh0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0WzBdLCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0WzFdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKDAsIGFuaW1hdG9yUHJvcHMucC52WzFdICogbXVsdCwgLWFuaW1hdG9yUHJvcHMucC52WzJdICogbXVsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShhbmltYXRvclByb3BzLnAudlswXSAqIG11bHRbMF0sIGFuaW1hdG9yUHJvcHMucC52WzFdICogbXVsdFsxXSwgLWFuaW1hdG9yUHJvcHMucC52WzJdICogbXVsdFsyXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGFuaW1hdG9yUHJvcHMucC52WzBdICogbXVsdCwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0LCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGRvY3VtZW50RGF0YS5zdHJva2VXaWR0aEFuaW0pIHtcclxuICAgICAgICBsZXR0ZXJTdyA9IHN3IDwgMCA/IDAgOiBzdztcclxuICAgICAgfVxyXG4gICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZUNvbG9yQW5pbSkge1xyXG4gICAgICAgIGxldHRlclNjID0gJ3JnYignICsgTWF0aC5yb3VuZChzY1swXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKHNjWzFdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoc2NbMl0gKiAyNTUpICsgJyknO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkb2N1bWVudERhdGEuZmlsbENvbG9yQW5pbSAmJiBkb2N1bWVudERhdGEuZmMpIHtcclxuICAgICAgICBsZXR0ZXJGYyA9ICdyZ2IoJyArIE1hdGgucm91bmQoZmNbMF0gKiAyNTUpICsgJywnICsgTWF0aC5yb3VuZChmY1sxXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGZjWzJdICogMjU1KSArICcpJztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcclxuICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKDAsIC1kb2N1bWVudERhdGEubHMpO1xyXG5cclxuICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKDAsIChhbGlnbm1lbnRbMV0gKiB5T2ZmKSAqIDAuMDEgKyB5UG9zLCAwKTtcclxuICAgICAgICBpZiAodGV4dERhdGEucC5wKSB7XHJcbiAgICAgICAgICB0YW5BbmdsZSA9IChjdXJyZW50UG9pbnQucG9pbnRbMV0gLSBwcmV2UG9pbnQucG9pbnRbMV0pIC8gKGN1cnJlbnRQb2ludC5wb2ludFswXSAtIHByZXZQb2ludC5wb2ludFswXSk7XHJcbiAgICAgICAgICB2YXIgcm90ID0gKE1hdGguYXRhbih0YW5BbmdsZSkgKiAxODApIC8gTWF0aC5QSTtcclxuICAgICAgICAgIGlmIChjdXJyZW50UG9pbnQucG9pbnRbMF0gPCBwcmV2UG9pbnQucG9pbnRbMF0pIHtcclxuICAgICAgICAgICAgcm90ICs9IDE4MDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGUoKC1yb3QgKiBNYXRoLlBJKSAvIDE4MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoeFBhdGhQb3MsIHlQYXRoUG9zLCAwKTtcclxuICAgICAgICBjdXJyZW50TGVuZ3RoIC09IChhbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuKSAqIDAuMDA1O1xyXG4gICAgICAgIGlmIChsZXR0ZXJzW2kgKyAxXSAmJiBpbmQgIT09IGxldHRlcnNbaSArIDFdLmluZCkge1xyXG4gICAgICAgICAgY3VycmVudExlbmd0aCArPSBsZXR0ZXJzW2ldLmFuIC8gMjtcclxuICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gKGRvY3VtZW50RGF0YS50ciAqIDAuMDAxKSAqIGRvY3VtZW50RGF0YS5maW5hbFNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoeFBvcywgeVBvcywgMCk7XHJcblxyXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEucHMpIHtcclxuICAgICAgICAgIC8vIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLGRvY3VtZW50RGF0YS5wc1sxXSwwKTtcclxuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLCBkb2N1bWVudERhdGEucHNbMV0gKyBkb2N1bWVudERhdGEuYXNjZW50LCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChkb2N1bWVudERhdGEuaikge1xyXG4gICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGxldHRlcnNbaV0uYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICsgZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgKyAoZG9jdW1lbnREYXRhLmJveFdpZHRoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGV0dGVyc1tpXS5saW5lXSksIDAsIDApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShsZXR0ZXJzW2ldLmFuaW1hdG9ySnVzdGlmeU9mZnNldCArIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ICsgKGRvY3VtZW50RGF0YS5ib3hXaWR0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xldHRlcnNbaV0ubGluZV0pIC8gMiwgMCwgMCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgLWRvY3VtZW50RGF0YS5scyk7XHJcbiAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShvZmZmLCAwLCAwKTtcclxuICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKChhbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuKSAqIDAuMDA1LCAoYWxpZ25tZW50WzFdICogeU9mZikgKiAwLjAxLCAwKTtcclxuICAgICAgICB4UG9zICs9IGxldHRlcnNbaV0ubCArIChkb2N1bWVudERhdGEudHIgKiAwLjAwMSkgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZW5kZXJUeXBlID09PSAnaHRtbCcpIHtcclxuICAgICAgICBsZXR0ZXJNID0gbWF0cml4SGVscGVyLnRvQ1NTKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVuZGVyVHlwZSA9PT0gJ3N2ZycpIHtcclxuICAgICAgICBsZXR0ZXJNID0gbWF0cml4SGVscGVyLnRvMmRDU1MoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXR0ZXJQID0gW21hdHJpeEhlbHBlci5wcm9wc1swXSwgbWF0cml4SGVscGVyLnByb3BzWzFdLCBtYXRyaXhIZWxwZXIucHJvcHNbMl0sIG1hdHJpeEhlbHBlci5wcm9wc1szXSwgbWF0cml4SGVscGVyLnByb3BzWzRdLCBtYXRyaXhIZWxwZXIucHJvcHNbNV0sIG1hdHJpeEhlbHBlci5wcm9wc1s2XSwgbWF0cml4SGVscGVyLnByb3BzWzddLCBtYXRyaXhIZWxwZXIucHJvcHNbOF0sIG1hdHJpeEhlbHBlci5wcm9wc1s5XSwgbWF0cml4SGVscGVyLnByb3BzWzEwXSwgbWF0cml4SGVscGVyLnByb3BzWzExXSwgbWF0cml4SGVscGVyLnByb3BzWzEyXSwgbWF0cml4SGVscGVyLnByb3BzWzEzXSwgbWF0cml4SGVscGVyLnByb3BzWzE0XSwgbWF0cml4SGVscGVyLnByb3BzWzE1XV07XHJcbiAgICAgIH1cclxuICAgICAgbGV0dGVyTyA9IGVsZW1PcGFjaXR5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZW5kZXJlZExldHRlcnNDb3VudCA8PSBpKSB7XHJcbiAgICAgIGxldHRlclZhbHVlID0gbmV3IExldHRlclByb3BzKGxldHRlck8sIGxldHRlclN3LCBsZXR0ZXJTYywgbGV0dGVyRmMsIGxldHRlck0sIGxldHRlclApO1xyXG4gICAgICB0aGlzLnJlbmRlcmVkTGV0dGVycy5wdXNoKGxldHRlclZhbHVlKTtcclxuICAgICAgcmVuZGVyZWRMZXR0ZXJzQ291bnQgKz0gMTtcclxuICAgICAgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0dGVyVmFsdWUgPSB0aGlzLnJlbmRlcmVkTGV0dGVyc1tpXTtcclxuICAgICAgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgPSBsZXR0ZXJWYWx1ZS51cGRhdGUobGV0dGVyTywgbGV0dGVyU3csIGxldHRlclNjLCBsZXR0ZXJGYywgbGV0dGVyTSwgbGV0dGVyUCkgfHwgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWc7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuVGV4dEFuaW1hdG9yUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICh0aGlzLl9lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5fZnJhbWVJZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLl9mcmFtZUlkID0gdGhpcy5fZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XHJcbiAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcclxufTtcclxuXHJcblRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5tSGVscGVyID0gbmV3IE1hdHJpeCgpO1xyXG5UZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZGVmYXVsdFByb3BzQXJyYXkgPSBbXTtcclxuZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBUZXh0QW5pbWF0b3JQcm9wZXJ0eSk7XHJcblxyXG4vKiBnbG9iYWwgUHJvcGVydHlGYWN0b3J5LCBkZWdUb1JhZHMsIFRleHRTZWxlY3RvclByb3AgKi9cclxuLyogZXhwb3J0ZWQgVGV4dEFuaW1hdG9yRGF0YVByb3BlcnR5ICovXHJcblxyXG5mdW5jdGlvbiBUZXh0QW5pbWF0b3JEYXRhUHJvcGVydHkoZWxlbSwgYW5pbWF0b3JQcm9wcywgY29udGFpbmVyKSB7XHJcbiAgdmFyIGRlZmF1bHREYXRhID0geyBwcm9wVHlwZTogZmFsc2UgfTtcclxuICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xyXG4gIHZhciB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcyA9IGFuaW1hdG9yUHJvcHMuYTtcclxuICB0aGlzLmEgPSB7XHJcbiAgICByOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yLCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcclxuICAgIHJ4OiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yeCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucngsIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgcnk6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnJ5ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yeSwgMCwgZGVnVG9SYWRzLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICBzazogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2sgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNrLCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcclxuICAgIHNhOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zYSA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2EsIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgczogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucyA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucywgMSwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgYTogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuYSA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuYSwgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgbzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMubyA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMubywgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgcDogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucCwgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgc3c6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnN3ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zdywgMCwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgc2M6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNjID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zYywgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgZmM6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZjID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5mYywgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgZmg6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZoID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5maCwgMCwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgZnM6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZzID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5mcywgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgZmI6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZiID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5mYiwgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgdDogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMudCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMudCwgMCwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gIH07XHJcblxyXG4gIHRoaXMucyA9IFRleHRTZWxlY3RvclByb3AuZ2V0VGV4dFNlbGVjdG9yUHJvcChlbGVtLCBhbmltYXRvclByb3BzLnMsIGNvbnRhaW5lcik7XHJcbiAgdGhpcy5zLnQgPSBhbmltYXRvclByb3BzLnMudDtcclxufVxyXG5cclxuZnVuY3Rpb24gTGV0dGVyUHJvcHMobywgc3csIHNjLCBmYywgbSwgcCkge1xyXG4gIHRoaXMubyA9IG87XHJcbiAgdGhpcy5zdyA9IHN3O1xyXG4gIHRoaXMuc2MgPSBzYztcclxuICB0aGlzLmZjID0gZmM7XHJcbiAgdGhpcy5tID0gbTtcclxuICB0aGlzLnAgPSBwO1xyXG4gIHRoaXMuX21kZiA9IHtcclxuICAgIG86IHRydWUsXHJcbiAgICBzdzogISFzdyxcclxuICAgIHNjOiAhIXNjLFxyXG4gICAgZmM6ICEhZmMsXHJcbiAgICBtOiB0cnVlLFxyXG4gICAgcDogdHJ1ZSxcclxuICB9O1xyXG59XHJcblxyXG5MZXR0ZXJQcm9wcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG8sIHN3LCBzYywgZmMsIG0sIHApIHtcclxuICB0aGlzLl9tZGYubyA9IGZhbHNlO1xyXG4gIHRoaXMuX21kZi5zdyA9IGZhbHNlO1xyXG4gIHRoaXMuX21kZi5zYyA9IGZhbHNlO1xyXG4gIHRoaXMuX21kZi5mYyA9IGZhbHNlO1xyXG4gIHRoaXMuX21kZi5tID0gZmFsc2U7XHJcbiAgdGhpcy5fbWRmLnAgPSBmYWxzZTtcclxuICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xyXG5cclxuICBpZiAodGhpcy5vICE9PSBvKSB7XHJcbiAgICB0aGlzLm8gPSBvO1xyXG4gICAgdGhpcy5fbWRmLm8gPSB0cnVlO1xyXG4gICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgfVxyXG4gIGlmICh0aGlzLnN3ICE9PSBzdykge1xyXG4gICAgdGhpcy5zdyA9IHN3O1xyXG4gICAgdGhpcy5fbWRmLnN3ID0gdHJ1ZTtcclxuICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gIH1cclxuICBpZiAodGhpcy5zYyAhPT0gc2MpIHtcclxuICAgIHRoaXMuc2MgPSBzYztcclxuICAgIHRoaXMuX21kZi5zYyA9IHRydWU7XHJcbiAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKHRoaXMuZmMgIT09IGZjKSB7XHJcbiAgICB0aGlzLmZjID0gZmM7XHJcbiAgICB0aGlzLl9tZGYuZmMgPSB0cnVlO1xyXG4gICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgfVxyXG4gIGlmICh0aGlzLm0gIT09IG0pIHtcclxuICAgIHRoaXMubSA9IG07XHJcbiAgICB0aGlzLl9tZGYubSA9IHRydWU7XHJcbiAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKHAubGVuZ3RoICYmICh0aGlzLnBbMF0gIT09IHBbMF0gfHwgdGhpcy5wWzFdICE9PSBwWzFdIHx8IHRoaXMucFs0XSAhPT0gcFs0XSB8fCB0aGlzLnBbNV0gIT09IHBbNV0gfHwgdGhpcy5wWzEyXSAhPT0gcFsxMl0gfHwgdGhpcy5wWzEzXSAhPT0gcFsxM10pKSB7XHJcbiAgICB0aGlzLnAgPSBwO1xyXG4gICAgdGhpcy5fbWRmLnAgPSB0cnVlO1xyXG4gICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgfVxyXG4gIHJldHVybiB1cGRhdGVkO1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIEZvbnRNYW5hZ2VyLCBpbml0aWFsRGVmYXVsdEZyYW1lLCBnZXRGb250UHJvcGVydGllcyAqL1xyXG4vKiBleHBvcnRlZCBUZXh0UHJvcGVydHkgKi9cclxuXHJcbmZ1bmN0aW9uIFRleHRQcm9wZXJ0eShlbGVtLCBkYXRhKSB7XHJcbiAgdGhpcy5fZnJhbWVJZCA9IGluaXRpYWxEZWZhdWx0RnJhbWU7XHJcbiAgdGhpcy5wdiA9ICcnO1xyXG4gIHRoaXMudiA9ICcnO1xyXG4gIHRoaXMua2YgPSBmYWxzZTtcclxuICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgdGhpcy5lbGVtID0gZWxlbTtcclxuICB0aGlzLmNvbXAgPSB0aGlzLmVsZW0uY29tcDtcclxuICB0aGlzLmtleXNJbmRleCA9IDA7XHJcbiAgdGhpcy5jYW5SZXNpemUgPSBmYWxzZTtcclxuICB0aGlzLm1pbmltdW1Gb250U2l6ZSA9IDE7XHJcbiAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbXTtcclxuICB0aGlzLmN1cnJlbnREYXRhID0ge1xyXG4gICAgYXNjZW50OiAwLFxyXG4gICAgYm94V2lkdGg6IHRoaXMuZGVmYXVsdEJveFdpZHRoLFxyXG4gICAgZjogJycsXHJcbiAgICBmU3R5bGU6ICcnLFxyXG4gICAgZldlaWdodDogJycsXHJcbiAgICBmYzogJycsXHJcbiAgICBqOiAnJyxcclxuICAgIGp1c3RpZnlPZmZzZXQ6ICcnLFxyXG4gICAgbDogW10sXHJcbiAgICBsaDogMCxcclxuICAgIGxpbmVXaWR0aHM6IFtdLFxyXG4gICAgbHM6ICcnLFxyXG4gICAgb2Y6ICcnLFxyXG4gICAgczogJycsXHJcbiAgICBzYzogJycsXHJcbiAgICBzdzogMCxcclxuICAgIHQ6IDAsXHJcbiAgICB0cjogMCxcclxuICAgIHN6OiAwLFxyXG4gICAgcHM6IG51bGwsXHJcbiAgICBmaWxsQ29sb3JBbmltOiBmYWxzZSxcclxuICAgIHN0cm9rZUNvbG9yQW5pbTogZmFsc2UsXHJcbiAgICBzdHJva2VXaWR0aEFuaW06IGZhbHNlLFxyXG4gICAgeU9mZnNldDogMCxcclxuICAgIGZpbmFsU2l6ZTogMCxcclxuICAgIGZpbmFsVGV4dDogW10sXHJcbiAgICBmaW5hbExpbmVIZWlnaHQ6IDAsXHJcbiAgICBfX2NvbXBsZXRlOiBmYWxzZSxcclxuXHJcbiAgfTtcclxuICB0aGlzLmNvcHlEYXRhKHRoaXMuY3VycmVudERhdGEsIHRoaXMuZGF0YS5kLmtbMF0ucyk7XHJcblxyXG4gIGlmICghdGhpcy5zZWFyY2hQcm9wZXJ0eSgpKSB7XHJcbiAgICB0aGlzLmNvbXBsZXRlVGV4dERhdGEodGhpcy5jdXJyZW50RGF0YSk7XHJcbiAgfVxyXG59XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLmRlZmF1bHRCb3hXaWR0aCA9IFswLCAwXTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuY29weURhdGEgPSBmdW5jdGlvbiAob2JqLCBkYXRhKSB7XHJcbiAgZm9yICh2YXIgcyBpbiBkYXRhKSB7XHJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIHMpKSB7XHJcbiAgICAgIG9ialtzXSA9IGRhdGFbc107XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLnNldEN1cnJlbnREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICBpZiAoIWRhdGEuX19jb21wbGV0ZSkge1xyXG4gICAgdGhpcy5jb21wbGV0ZVRleHREYXRhKGRhdGEpO1xyXG4gIH1cclxuICB0aGlzLmN1cnJlbnREYXRhID0gZGF0YTtcclxuICB0aGlzLmN1cnJlbnREYXRhLmJveFdpZHRoID0gdGhpcy5jdXJyZW50RGF0YS5ib3hXaWR0aCB8fCB0aGlzLmRlZmF1bHRCb3hXaWR0aDtcclxuICB0aGlzLl9tZGYgPSB0cnVlO1xyXG59O1xyXG5cclxuVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5zZWFyY2hLZXlmcmFtZXMoKTtcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoS2V5ZnJhbWVzID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMua2YgPSB0aGlzLmRhdGEuZC5rLmxlbmd0aCA+IDE7XHJcbiAgaWYgKHRoaXMua2YpIHtcclxuICAgIHRoaXMuYWRkRWZmZWN0KHRoaXMuZ2V0S2V5ZnJhbWVWYWx1ZS5iaW5kKHRoaXMpKTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXMua2Y7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLmFkZEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3RGdW5jdGlvbikge1xyXG4gIHRoaXMuZWZmZWN0c1NlcXVlbmNlLnB1c2goZWZmZWN0RnVuY3Rpb24pO1xyXG4gIHRoaXMuZWxlbS5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKF9maW5hbFZhbHVlKSB7XHJcbiAgaWYgKCh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQgfHwgIXRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkgJiYgIV9maW5hbFZhbHVlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMuY3VycmVudERhdGEudCA9IHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnMudDtcclxuICB2YXIgY3VycmVudFZhbHVlID0gdGhpcy5jdXJyZW50RGF0YTtcclxuICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5rZXlzSW5kZXg7XHJcbiAgaWYgKHRoaXMubG9jaykge1xyXG4gICAgdGhpcy5zZXRDdXJyZW50RGF0YSh0aGlzLmN1cnJlbnREYXRhKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdGhpcy5sb2NrID0gdHJ1ZTtcclxuICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICB2YXIgaTsgdmFyXHJcbiAgICBsZW4gPSB0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XHJcbiAgdmFyIGZpbmFsVmFsdWUgPSBfZmluYWxWYWx1ZSB8fCB0aGlzLmRhdGEuZC5rW3RoaXMua2V5c0luZGV4XS5zO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgLy8gQ2hlY2tpbmcgaWYgaW5kZXggY2hhbmdlZCB0byBwcmV2ZW50IGNyZWF0aW5nIGEgbmV3IG9iamVjdCBldmVyeSB0aW1lIHRoZSBleHByZXNzaW9uIHVwZGF0ZXMuXHJcbiAgICBpZiAoY3VycmVudEluZGV4ICE9PSB0aGlzLmtleXNJbmRleCkge1xyXG4gICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0oZmluYWxWYWx1ZSwgZmluYWxWYWx1ZS50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmVmZmVjdHNTZXF1ZW5jZVtpXSh0aGlzLmN1cnJlbnREYXRhLCBmaW5hbFZhbHVlLnQpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoY3VycmVudFZhbHVlICE9PSBmaW5hbFZhbHVlKSB7XHJcbiAgICB0aGlzLnNldEN1cnJlbnREYXRhKGZpbmFsVmFsdWUpO1xyXG4gIH1cclxuICB0aGlzLnYgPSB0aGlzLmN1cnJlbnREYXRhO1xyXG4gIHRoaXMucHYgPSB0aGlzLnY7XHJcbiAgdGhpcy5sb2NrID0gZmFsc2U7XHJcbiAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0S2V5ZnJhbWVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgdGV4dEtleXMgPSB0aGlzLmRhdGEuZC5rO1xyXG4gIHZhciBmcmFtZU51bSA9IHRoaXMuZWxlbS5jb21wLnJlbmRlcmVkRnJhbWU7XHJcbiAgdmFyIGkgPSAwOyB2YXJcclxuICAgIGxlbiA9IHRleHRLZXlzLmxlbmd0aDtcclxuICB3aGlsZSAoaSA8PSBsZW4gLSAxKSB7XHJcbiAgICBpZiAoaSA9PT0gbGVuIC0gMSB8fCB0ZXh0S2V5c1tpICsgMV0udCA+IGZyYW1lTnVtKSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgaSArPSAxO1xyXG4gIH1cclxuICBpZiAodGhpcy5rZXlzSW5kZXggIT09IGkpIHtcclxuICAgIHRoaXMua2V5c0luZGV4ID0gaTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnM7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLmJ1aWxkRmluYWxUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICB2YXIgY29tYmluZWRDaGFyYWN0ZXJzID0gRm9udE1hbmFnZXIuZ2V0Q29tYmluZWRDaGFyYWN0ZXJDb2RlcygpO1xyXG4gIHZhciBjaGFyYWN0ZXJzQXJyYXkgPSBbXTtcclxuICB2YXIgaSA9IDA7IHZhclxyXG4gICAgbGVuID0gdGV4dC5sZW5ndGg7XHJcbiAgdmFyIGNoYXJDb2RlO1xyXG4gIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcclxuICAgIGlmIChjb21iaW5lZENoYXJhY3RlcnMuaW5kZXhPZihjaGFyQ29kZSkgIT09IC0xKSB7XHJcbiAgICAgIGNoYXJhY3RlcnNBcnJheVtjaGFyYWN0ZXJzQXJyYXkubGVuZ3RoIC0gMV0gKz0gdGV4dC5jaGFyQXQoaSk7XHJcbiAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcclxuICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpO1xyXG4gICAgICBpZiAoY2hhckNvZGUgPj0gMHhEQzAwICYmIGNoYXJDb2RlIDw9IDB4REZGRikge1xyXG4gICAgICAgIGNoYXJhY3RlcnNBcnJheS5wdXNoKHRleHQuc3Vic3RyKGksIDIpKTtcclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hhcmFjdGVyc0FycmF5LnB1c2godGV4dC5jaGFyQXQoaSkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjaGFyYWN0ZXJzQXJyYXkucHVzaCh0ZXh0LmNoYXJBdChpKSk7XHJcbiAgICB9XHJcbiAgICBpICs9IDE7XHJcbiAgfVxyXG4gIHJldHVybiBjaGFyYWN0ZXJzQXJyYXk7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLmNvbXBsZXRlVGV4dERhdGEgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhKSB7XHJcbiAgZG9jdW1lbnREYXRhLl9fY29tcGxldGUgPSB0cnVlO1xyXG4gIHZhciBmb250TWFuYWdlciA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyO1xyXG4gIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gIHZhciBsZXR0ZXJzID0gW107XHJcbiAgdmFyIGk7IHZhclxyXG4gICAgbGVuO1xyXG4gIHZhciBuZXdMaW5lRmxhZzsgdmFyIGluZGV4ID0gMDsgdmFyXHJcbiAgICB2YWw7XHJcbiAgdmFyIGFuY2hvckdyb3VwaW5nID0gZGF0YS5tLmc7XHJcbiAgdmFyIGN1cnJlbnRTaXplID0gMDsgdmFyIGN1cnJlbnRQb3MgPSAwOyB2YXIgY3VycmVudExpbmUgPSAwOyB2YXJcclxuICAgIGxpbmVXaWR0aHMgPSBbXTtcclxuICB2YXIgbGluZVdpZHRoID0gMDtcclxuICB2YXIgbWF4TGluZVdpZHRoID0gMDtcclxuICB2YXIgajsgdmFyXHJcbiAgICBqTGVuO1xyXG4gIHZhciBmb250RGF0YSA9IGZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpO1xyXG4gIHZhciBjaGFyRGF0YTsgdmFyXHJcbiAgICBjTGVuZ3RoID0gMDtcclxuXHJcbiAgdmFyIGZvbnRQcm9wcyA9IGdldEZvbnRQcm9wZXJ0aWVzKGZvbnREYXRhKTtcclxuICBkb2N1bWVudERhdGEuZldlaWdodCA9IGZvbnRQcm9wcy53ZWlnaHQ7XHJcbiAgZG9jdW1lbnREYXRhLmZTdHlsZSA9IGZvbnRQcm9wcy5zdHlsZTtcclxuICBkb2N1bWVudERhdGEuZmluYWxTaXplID0gZG9jdW1lbnREYXRhLnM7XHJcbiAgZG9jdW1lbnREYXRhLmZpbmFsVGV4dCA9IHRoaXMuYnVpbGRGaW5hbFRleHQoZG9jdW1lbnREYXRhLnQpO1xyXG4gIGxlbiA9IGRvY3VtZW50RGF0YS5maW5hbFRleHQubGVuZ3RoO1xyXG4gIGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgPSBkb2N1bWVudERhdGEubGg7XHJcbiAgdmFyIHRyYWNraW5nT2Zmc2V0ID0gKGRvY3VtZW50RGF0YS50ciAvIDEwMDApICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcclxuICB2YXIgY2hhckNvZGU7XHJcbiAgaWYgKGRvY3VtZW50RGF0YS5zeikge1xyXG4gICAgdmFyIGZsYWcgPSB0cnVlO1xyXG4gICAgdmFyIGJveFdpZHRoID0gZG9jdW1lbnREYXRhLnN6WzBdO1xyXG4gICAgdmFyIGJveEhlaWdodCA9IGRvY3VtZW50RGF0YS5zelsxXTtcclxuICAgIHZhciBjdXJyZW50SGVpZ2h0OyB2YXJcclxuICAgICAgZmluYWxUZXh0O1xyXG4gICAgd2hpbGUgKGZsYWcpIHtcclxuICAgICAgZmluYWxUZXh0ID0gdGhpcy5idWlsZEZpbmFsVGV4dChkb2N1bWVudERhdGEudCk7XHJcbiAgICAgIGN1cnJlbnRIZWlnaHQgPSAwO1xyXG4gICAgICBsaW5lV2lkdGggPSAwO1xyXG4gICAgICBsZW4gPSBmaW5hbFRleHQubGVuZ3RoO1xyXG4gICAgICB0cmFja2luZ09mZnNldCA9IChkb2N1bWVudERhdGEudHIgLyAxMDAwKSAqIGRvY3VtZW50RGF0YS5maW5hbFNpemU7XHJcbiAgICAgIHZhciBsYXN0U3BhY2VJbmRleCA9IC0xO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBjaGFyQ29kZSA9IGZpbmFsVGV4dFtpXS5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgIG5ld0xpbmVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGZpbmFsVGV4dFtpXSA9PT0gJyAnKSB7XHJcbiAgICAgICAgICBsYXN0U3BhY2VJbmRleCA9IGk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PT0gMTMgfHwgY2hhckNvZGUgPT09IDMpIHtcclxuICAgICAgICAgIGxpbmVXaWR0aCA9IDA7XHJcbiAgICAgICAgICBuZXdMaW5lRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICBjdXJyZW50SGVpZ2h0ICs9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgfHwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIDEuMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvbnRNYW5hZ2VyLmNoYXJzKSB7XHJcbiAgICAgICAgICBjaGFyRGF0YSA9IGZvbnRNYW5hZ2VyLmdldENoYXJEYXRhKGZpbmFsVGV4dFtpXSwgZm9udERhdGEuZlN0eWxlLCBmb250RGF0YS5mRmFtaWx5KTtcclxuICAgICAgICAgIGNMZW5ndGggPSBuZXdMaW5lRmxhZyA/IDAgOiAoY2hhckRhdGEudyAqIGRvY3VtZW50RGF0YS5maW5hbFNpemUpIC8gMTAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyB0Q2FudmFzSGVscGVyLmZvbnQgPSBkb2N1bWVudERhdGEucyArICdweCAnKyBmb250RGF0YS5mRmFtaWx5O1xyXG4gICAgICAgICAgY0xlbmd0aCA9IGZvbnRNYW5hZ2VyLm1lYXN1cmVUZXh0KGZpbmFsVGV4dFtpXSwgZG9jdW1lbnREYXRhLmYsIGRvY3VtZW50RGF0YS5maW5hbFNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGluZVdpZHRoICsgY0xlbmd0aCA+IGJveFdpZHRoICYmIGZpbmFsVGV4dFtpXSAhPT0gJyAnKSB7XHJcbiAgICAgICAgICBpZiAobGFzdFNwYWNlSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGxlbiArPSAxO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9IGxhc3RTcGFjZUluZGV4O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY3VycmVudEhlaWdodCArPSBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0IHx8IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKiAxLjI7XHJcbiAgICAgICAgICBmaW5hbFRleHQuc3BsaWNlKGksIGxhc3RTcGFjZUluZGV4ID09PSBpID8gMSA6IDAsICdcXHInKTtcclxuICAgICAgICAgIC8vIGZpbmFsVGV4dCA9IGZpbmFsVGV4dC5zdWJzdHIoMCxpKSArIFwiXFxyXCIgKyBmaW5hbFRleHQuc3Vic3RyKGkgPT09IGxhc3RTcGFjZUluZGV4ID8gaSArIDEgOiBpKTtcclxuICAgICAgICAgIGxhc3RTcGFjZUluZGV4ID0gLTE7XHJcbiAgICAgICAgICBsaW5lV2lkdGggPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsaW5lV2lkdGggKz0gY0xlbmd0aDtcclxuICAgICAgICAgIGxpbmVXaWR0aCArPSB0cmFja2luZ09mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY3VycmVudEhlaWdodCArPSAoZm9udERhdGEuYXNjZW50ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSkgLyAxMDA7XHJcbiAgICAgIGlmICh0aGlzLmNhblJlc2l6ZSAmJiBkb2N1bWVudERhdGEuZmluYWxTaXplID4gdGhpcy5taW5pbXVtRm9udFNpemUgJiYgYm94SGVpZ2h0IDwgY3VycmVudEhlaWdodCkge1xyXG4gICAgICAgIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLT0gMTtcclxuICAgICAgICBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0ID0gKGRvY3VtZW50RGF0YS5maW5hbFNpemUgKiBkb2N1bWVudERhdGEubGgpIC8gZG9jdW1lbnREYXRhLnM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG9jdW1lbnREYXRhLmZpbmFsVGV4dCA9IGZpbmFsVGV4dDtcclxuICAgICAgICBsZW4gPSBkb2N1bWVudERhdGEuZmluYWxUZXh0Lmxlbmd0aDtcclxuICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgbGluZVdpZHRoID0gLXRyYWNraW5nT2Zmc2V0O1xyXG4gIGNMZW5ndGggPSAwO1xyXG4gIHZhciB1bmNvbGxhcHNlZFNwYWNlcyA9IDA7XHJcbiAgdmFyIGN1cnJlbnRDaGFyO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgbmV3TGluZUZsYWcgPSBmYWxzZTtcclxuICAgIGN1cnJlbnRDaGFyID0gZG9jdW1lbnREYXRhLmZpbmFsVGV4dFtpXTtcclxuICAgIGNoYXJDb2RlID0gY3VycmVudENoYXIuY2hhckNvZGVBdCgwKTtcclxuICAgIGlmIChjaGFyQ29kZSA9PT0gMTMgfHwgY2hhckNvZGUgPT09IDMpIHtcclxuICAgICAgdW5jb2xsYXBzZWRTcGFjZXMgPSAwO1xyXG4gICAgICBsaW5lV2lkdGhzLnB1c2gobGluZVdpZHRoKTtcclxuICAgICAgbWF4TGluZVdpZHRoID0gbGluZVdpZHRoID4gbWF4TGluZVdpZHRoID8gbGluZVdpZHRoIDogbWF4TGluZVdpZHRoO1xyXG4gICAgICBsaW5lV2lkdGggPSAtMiAqIHRyYWNraW5nT2Zmc2V0O1xyXG4gICAgICB2YWwgPSAnJztcclxuICAgICAgbmV3TGluZUZsYWcgPSB0cnVlO1xyXG4gICAgICBjdXJyZW50TGluZSArPSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFsID0gY3VycmVudENoYXI7XHJcbiAgICB9XHJcbiAgICBpZiAoZm9udE1hbmFnZXIuY2hhcnMpIHtcclxuICAgICAgY2hhckRhdGEgPSBmb250TWFuYWdlci5nZXRDaGFyRGF0YShjdXJyZW50Q2hhciwgZm9udERhdGEuZlN0eWxlLCBmb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcclxuICAgICAgY0xlbmd0aCA9IG5ld0xpbmVGbGFnID8gMCA6IChjaGFyRGF0YS53ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSkgLyAxMDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB2YXIgY2hhcldpZHRoID0gZm9udE1hbmFnZXIubWVhc3VyZVRleHQodmFsLCBkb2N1bWVudERhdGEuZiwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSk7XHJcbiAgICAgIC8vIHRDYW52YXNIZWxwZXIuZm9udCA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKyAncHggJysgZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseTtcclxuICAgICAgY0xlbmd0aCA9IGZvbnRNYW5hZ2VyLm1lYXN1cmVUZXh0KHZhbCwgZG9jdW1lbnREYXRhLmYsIGRvY3VtZW50RGF0YS5maW5hbFNpemUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcbiAgICBpZiAoY3VycmVudENoYXIgPT09ICcgJykge1xyXG4gICAgICB1bmNvbGxhcHNlZFNwYWNlcyArPSBjTGVuZ3RoICsgdHJhY2tpbmdPZmZzZXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsaW5lV2lkdGggKz0gY0xlbmd0aCArIHRyYWNraW5nT2Zmc2V0ICsgdW5jb2xsYXBzZWRTcGFjZXM7XHJcbiAgICAgIHVuY29sbGFwc2VkU3BhY2VzID0gMDtcclxuICAgIH1cclxuICAgIGxldHRlcnMucHVzaCh7XHJcbiAgICAgIGw6IGNMZW5ndGgsIGFuOiBjTGVuZ3RoLCBhZGQ6IGN1cnJlbnRTaXplLCBuOiBuZXdMaW5lRmxhZywgYW5JbmRleGVzOiBbXSwgdmFsOiB2YWwsIGxpbmU6IGN1cnJlbnRMaW5lLCBhbmltYXRvckp1c3RpZnlPZmZzZXQ6IDAsXHJcbiAgICB9KTtcclxuICAgIGlmIChhbmNob3JHcm91cGluZyA9PSAyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcbiAgICAgIGN1cnJlbnRTaXplICs9IGNMZW5ndGg7XHJcbiAgICAgIGlmICh2YWwgPT09ICcnIHx8IHZhbCA9PT0gJyAnIHx8IGkgPT09IGxlbiAtIDEpIHtcclxuICAgICAgICBpZiAodmFsID09PSAnJyB8fCB2YWwgPT09ICcgJykge1xyXG4gICAgICAgICAgY3VycmVudFNpemUgLT0gY0xlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRQb3MgPD0gaSkge1xyXG4gICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5hbiA9IGN1cnJlbnRTaXplO1xyXG4gICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5pbmQgPSBpbmRleDtcclxuICAgICAgICAgIGxldHRlcnNbY3VycmVudFBvc10uZXh0cmEgPSBjTGVuZ3RoO1xyXG4gICAgICAgICAgY3VycmVudFBvcyArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmRleCArPSAxO1xyXG4gICAgICAgIGN1cnJlbnRTaXplID0gMDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChhbmNob3JHcm91cGluZyA9PSAzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcbiAgICAgIGN1cnJlbnRTaXplICs9IGNMZW5ndGg7XHJcbiAgICAgIGlmICh2YWwgPT09ICcnIHx8IGkgPT09IGxlbiAtIDEpIHtcclxuICAgICAgICBpZiAodmFsID09PSAnJykge1xyXG4gICAgICAgICAgY3VycmVudFNpemUgLT0gY0xlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRQb3MgPD0gaSkge1xyXG4gICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5hbiA9IGN1cnJlbnRTaXplO1xyXG4gICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5pbmQgPSBpbmRleDtcclxuICAgICAgICAgIGxldHRlcnNbY3VycmVudFBvc10uZXh0cmEgPSBjTGVuZ3RoO1xyXG4gICAgICAgICAgY3VycmVudFBvcyArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50U2l6ZSA9IDA7XHJcbiAgICAgICAgaW5kZXggKz0gMTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0dGVyc1tpbmRleF0uaW5kID0gaW5kZXg7XHJcbiAgICAgIGxldHRlcnNbaW5kZXhdLmV4dHJhID0gMDtcclxuICAgICAgaW5kZXggKz0gMTtcclxuICAgIH1cclxuICB9XHJcbiAgZG9jdW1lbnREYXRhLmwgPSBsZXR0ZXJzO1xyXG4gIG1heExpbmVXaWR0aCA9IGxpbmVXaWR0aCA+IG1heExpbmVXaWR0aCA/IGxpbmVXaWR0aCA6IG1heExpbmVXaWR0aDtcclxuICBsaW5lV2lkdGhzLnB1c2gobGluZVdpZHRoKTtcclxuICBpZiAoZG9jdW1lbnREYXRhLnN6KSB7XHJcbiAgICBkb2N1bWVudERhdGEuYm94V2lkdGggPSBkb2N1bWVudERhdGEuc3pbMF07XHJcbiAgICBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCA9IDA7XHJcbiAgfSBlbHNlIHtcclxuICAgIGRvY3VtZW50RGF0YS5ib3hXaWR0aCA9IG1heExpbmVXaWR0aDtcclxuICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gLWRvY3VtZW50RGF0YS5ib3hXaWR0aDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gLWRvY3VtZW50RGF0YS5ib3hXaWR0aCAvIDI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgPSAwO1xyXG4gICAgfVxyXG4gIH1cclxuICBkb2N1bWVudERhdGEubGluZVdpZHRocyA9IGxpbmVXaWR0aHM7XHJcblxyXG4gIHZhciBhbmltYXRvcnMgPSBkYXRhLmE7IHZhciBhbmltYXRvckRhdGE7IHZhclxyXG4gICAgbGV0dGVyRGF0YTtcclxuICBqTGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcclxuICB2YXIgYmFzZWQ7IHZhciBpbmQ7IHZhclxyXG4gICAgaW5kZXhlcyA9IFtdO1xyXG4gIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgIGFuaW1hdG9yRGF0YSA9IGFuaW1hdG9yc1tqXTtcclxuICAgIGlmIChhbmltYXRvckRhdGEuYS5zYykge1xyXG4gICAgICBkb2N1bWVudERhdGEuc3Ryb2tlQ29sb3JBbmltID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChhbmltYXRvckRhdGEuYS5zdykge1xyXG4gICAgICBkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChhbmltYXRvckRhdGEuYS5mYyB8fCBhbmltYXRvckRhdGEuYS5maCB8fCBhbmltYXRvckRhdGEuYS5mcyB8fCBhbmltYXRvckRhdGEuYS5mYikge1xyXG4gICAgICBkb2N1bWVudERhdGEuZmlsbENvbG9yQW5pbSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpbmQgPSAwO1xyXG4gICAgYmFzZWQgPSBhbmltYXRvckRhdGEucy5iO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGxldHRlckRhdGEgPSBsZXR0ZXJzW2ldO1xyXG4gICAgICBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXSA9IGluZDtcclxuICAgICAgaWYgKChiYXNlZCA9PSAxICYmIGxldHRlckRhdGEudmFsICE9PSAnJykgfHwgKGJhc2VkID09IDIgJiYgbGV0dGVyRGF0YS52YWwgIT09ICcnICYmIGxldHRlckRhdGEudmFsICE9PSAnICcpIHx8IChiYXNlZCA9PSAzICYmIChsZXR0ZXJEYXRhLm4gfHwgbGV0dGVyRGF0YS52YWwgPT0gJyAnIHx8IGkgPT0gbGVuIC0gMSkpIHx8IChiYXNlZCA9PSA0ICYmIChsZXR0ZXJEYXRhLm4gfHwgaSA9PSBsZW4gLSAxKSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgICAgICBpZiAoYW5pbWF0b3JEYXRhLnMucm4gPT09IDEpIHtcclxuICAgICAgICAgIGluZGV4ZXMucHVzaChpbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmQgKz0gMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGF0YS5hW2pdLnMudG90YWxDaGFycyA9IGluZDtcclxuICAgIHZhciBjdXJyZW50SW5kID0gLTE7IHZhclxyXG4gICAgICBuZXdJbmQ7XHJcbiAgICBpZiAoYW5pbWF0b3JEYXRhLnMucm4gPT09IDEpIHtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgbGV0dGVyRGF0YSA9IGxldHRlcnNbaV07XHJcbiAgICAgICAgaWYgKGN1cnJlbnRJbmQgIT0gbGV0dGVyRGF0YS5hbkluZGV4ZXNbal0pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgICAgICAgIGN1cnJlbnRJbmQgPSBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXTtcclxuICAgICAgICAgIG5ld0luZCA9IGluZGV4ZXMuc3BsaWNlKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGluZGV4ZXMubGVuZ3RoKSwgMSlbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldHRlckRhdGEuYW5JbmRleGVzW2pdID0gbmV3SW5kO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGRvY3VtZW50RGF0YS55T2Zmc2V0ID0gZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodCB8fCBkb2N1bWVudERhdGEuZmluYWxTaXplICogMS4yO1xyXG4gIGRvY3VtZW50RGF0YS5scyA9IGRvY3VtZW50RGF0YS5scyB8fCAwO1xyXG4gIGRvY3VtZW50RGF0YS5hc2NlbnQgPSAoZm9udERhdGEuYXNjZW50ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSkgLyAxMDA7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhLCBpbmRleCkge1xyXG4gIGluZGV4ID0gaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMua2V5c0luZGV4IDogaW5kZXg7XHJcbiAgdmFyIGREYXRhID0gdGhpcy5jb3B5RGF0YSh7fSwgdGhpcy5kYXRhLmQua1tpbmRleF0ucyk7XHJcbiAgZERhdGEgPSB0aGlzLmNvcHlEYXRhKGREYXRhLCBuZXdEYXRhKTtcclxuICB0aGlzLmRhdGEuZC5rW2luZGV4XS5zID0gZERhdGE7XHJcbiAgdGhpcy5yZWNhbGN1bGF0ZShpbmRleCk7XHJcbiAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICB2YXIgZERhdGEgPSB0aGlzLmRhdGEuZC5rW2luZGV4XS5zO1xyXG4gIGREYXRhLl9fY29tcGxldGUgPSBmYWxzZTtcclxuICB0aGlzLmtleXNJbmRleCA9IDA7XHJcbiAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcclxuICB0aGlzLmdldFZhbHVlKGREYXRhKTtcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuY2FuUmVzaXplRm9udCA9IGZ1bmN0aW9uIChfY2FuUmVzaXplKSB7XHJcbiAgdGhpcy5jYW5SZXNpemUgPSBfY2FuUmVzaXplO1xyXG4gIHRoaXMucmVjYWxjdWxhdGUodGhpcy5rZXlzSW5kZXgpO1xyXG4gIHRoaXMuZWxlbS5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLnNldE1pbmltdW1Gb250U2l6ZSA9IGZ1bmN0aW9uIChfZm9udFZhbHVlKSB7XHJcbiAgdGhpcy5taW5pbXVtRm9udFNpemUgPSBNYXRoLmZsb29yKF9mb250VmFsdWUpIHx8IDE7XHJcbiAgdGhpcy5yZWNhbGN1bGF0ZSh0aGlzLmtleXNJbmRleCk7XHJcbiAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcclxufTtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIEJlemllckZhY3RvcnksIFByb3BlcnR5RmFjdG9yeSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyICovXHJcbi8qIGV4cG9ydGVkIFRleHRTZWxlY3RvclByb3AgKi9cclxuXHJcbnZhciBUZXh0U2VsZWN0b3JQcm9wID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWF4ID0gTWF0aC5tYXg7XHJcbiAgdmFyIG1pbiA9IE1hdGgubWluO1xyXG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XHJcblxyXG4gIGZ1bmN0aW9uIFRleHRTZWxlY3RvclByb3BGYWN0b3J5KGVsZW0sIGRhdGEpIHtcclxuICAgIHRoaXMuX2N1cnJlbnRUZXh0TGVuZ3RoID0gLTE7XHJcbiAgICB0aGlzLmsgPSBmYWxzZTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xyXG4gICAgdGhpcy5maW5hbFMgPSAwO1xyXG4gICAgdGhpcy5maW5hbEUgPSAwO1xyXG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xyXG4gICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zIHx8IHsgazogMCB9LCAwLCAwLCB0aGlzKTtcclxuICAgIGlmICgnZScgaW4gZGF0YSkge1xyXG4gICAgICB0aGlzLmUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmUsIDAsIDAsIHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5lID0geyB2OiAxMDAgfTtcclxuICAgIH1cclxuICAgIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubyB8fCB7IGs6IDAgfSwgMCwgMCwgdGhpcyk7XHJcbiAgICB0aGlzLnhlID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS54ZSB8fCB7IGs6IDAgfSwgMCwgMCwgdGhpcyk7XHJcbiAgICB0aGlzLm5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5uZSB8fCB7IGs6IDAgfSwgMCwgMCwgdGhpcyk7XHJcbiAgICB0aGlzLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmEsIDAsIDAuMDEsIHRoaXMpO1xyXG4gICAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBUZXh0U2VsZWN0b3JQcm9wRmFjdG9yeS5wcm90b3R5cGUgPSB7XHJcbiAgICBnZXRNdWx0OiBmdW5jdGlvbiAoaW5kKSB7XHJcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VGV4dExlbmd0aCAhPT0gdGhpcy5lbGVtLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS5sLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuZ2V0VmFsdWUoKTtcclxuICAgICAgfVxyXG4gICAgICAvLyB2YXIgZWFzZXIgPSBiZXouZ2V0RWFzaW5nQ3VydmUodGhpcy5uZS52LzEwMCwwLDEtdGhpcy54ZS52LzEwMCwxKTtcclxuICAgICAgdmFyIHgxID0gMDtcclxuICAgICAgdmFyIHkxID0gMDtcclxuICAgICAgdmFyIHgyID0gMTtcclxuICAgICAgdmFyIHkyID0gMTtcclxuICAgICAgaWYgKHRoaXMubmUudiA+IDApIHtcclxuICAgICAgICB4MSA9IHRoaXMubmUudiAvIDEwMC4wO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHkxID0gLXRoaXMubmUudiAvIDEwMC4wO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnhlLnYgPiAwKSB7XHJcbiAgICAgICAgeDIgPSAxLjAgLSB0aGlzLnhlLnYgLyAxMDAuMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB5MiA9IDEuMCArIHRoaXMueGUudiAvIDEwMC4wO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBlYXNlciA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKHgxLCB5MSwgeDIsIHkyKS5nZXQ7XHJcblxyXG4gICAgICB2YXIgbXVsdCA9IDA7XHJcbiAgICAgIHZhciBzID0gdGhpcy5maW5hbFM7XHJcbiAgICAgIHZhciBlID0gdGhpcy5maW5hbEU7XHJcbiAgICAgIHZhciB0eXBlID0gdGhpcy5kYXRhLnNoO1xyXG4gICAgICBpZiAodHlwZSA9PT0gMikge1xyXG4gICAgICAgIGlmIChlID09PSBzKSB7XHJcbiAgICAgICAgICBtdWx0ID0gaW5kID49IGUgPyAxIDogMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbXVsdCA9IG1heCgwLCBtaW4oMC41IC8gKGUgLSBzKSArIChpbmQgLSBzKSAvIChlIC0gcyksIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDMpIHtcclxuICAgICAgICBpZiAoZSA9PT0gcykge1xyXG4gICAgICAgICAgbXVsdCA9IGluZCA+PSBlID8gMCA6IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG11bHQgPSAxIC0gbWF4KDAsIG1pbigwLjUgLyAoZSAtIHMpICsgKGluZCAtIHMpIC8gKGUgLSBzKSwgMSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDQpIHtcclxuICAgICAgICBpZiAoZSA9PT0gcykge1xyXG4gICAgICAgICAgbXVsdCA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG11bHQgPSBtYXgoMCwgbWluKDAuNSAvIChlIC0gcykgKyAoaW5kIC0gcykgLyAoZSAtIHMpLCAxKSk7XHJcbiAgICAgICAgICBpZiAobXVsdCA8IDAuNSkge1xyXG4gICAgICAgICAgICBtdWx0ICo9IDI7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtdWx0ID0gMSAtIDIgKiAobXVsdCAtIDAuNSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA1KSB7XHJcbiAgICAgICAgaWYgKGUgPT09IHMpIHtcclxuICAgICAgICAgIG11bHQgPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgdG90ID0gZSAtIHM7XHJcbiAgICAgICAgICAvKiBpbmQgKz0gMC41O1xyXG4gICAgICAgICAgICAgICAgICAgIG11bHQgPSAtNC8odG90KnRvdCkqKGluZCppbmQpKyg0L3RvdCkqaW5kOyAqL1xyXG4gICAgICAgICAgaW5kID0gbWluKG1heCgwLCBpbmQgKyAwLjUgLSBzKSwgZSAtIHMpO1xyXG4gICAgICAgICAgdmFyIHggPSAtdG90IC8gMiArIGluZDtcclxuICAgICAgICAgIHZhciBhID0gdG90IC8gMjtcclxuICAgICAgICAgIG11bHQgPSBNYXRoLnNxcnQoMSAtICh4ICogeCkgLyAoYSAqIGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHtcclxuICAgICAgICBpZiAoZSA9PT0gcykge1xyXG4gICAgICAgICAgbXVsdCA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGluZCA9IG1pbihtYXgoMCwgaW5kICsgMC41IC0gcyksIGUgLSBzKTtcclxuICAgICAgICAgIG11bHQgPSAoMSArIChNYXRoLmNvcygoTWF0aC5QSSArIE1hdGguUEkgKiAyICogKGluZCkgLyAoZSAtIHMpKSkpKSAvIDI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChpbmQgPj0gZmxvb3IocykpIHtcclxuICAgICAgICAgIGlmIChpbmQgLSBzIDwgMCkge1xyXG4gICAgICAgICAgICBtdWx0ID0gbWF4KDAsIG1pbihtaW4oZSwgMSkgLSAocyAtIGluZCksIDEpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG11bHQgPSBtYXgoMCwgbWluKGUgLSBpbmQsIDEpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBtdWx0ICogdGhpcy5hLnY7XHJcbiAgICB9LFxyXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChuZXdDaGFyc0ZsYWcpIHtcclxuICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcclxuICAgICAgdGhpcy5fbWRmID0gbmV3Q2hhcnNGbGFnIHx8IHRoaXMuX21kZjtcclxuICAgICAgdGhpcy5fY3VycmVudFRleHRMZW5ndGggPSB0aGlzLmVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmwubGVuZ3RoIHx8IDA7XHJcbiAgICAgIGlmIChuZXdDaGFyc0ZsYWcgJiYgdGhpcy5kYXRhLnIgPT09IDIpIHtcclxuICAgICAgICB0aGlzLmUudiA9IHRoaXMuX2N1cnJlbnRUZXh0TGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBkaXZpc29yID0gdGhpcy5kYXRhLnIgPT09IDIgPyAxIDogMTAwIC8gdGhpcy5kYXRhLnRvdGFsQ2hhcnM7XHJcbiAgICAgIHZhciBvID0gdGhpcy5vLnYgLyBkaXZpc29yO1xyXG4gICAgICB2YXIgcyA9IHRoaXMucy52IC8gZGl2aXNvciArIG87XHJcbiAgICAgIHZhciBlID0gKHRoaXMuZS52IC8gZGl2aXNvcikgKyBvO1xyXG4gICAgICBpZiAocyA+IGUpIHtcclxuICAgICAgICB2YXIgX3MgPSBzO1xyXG4gICAgICAgIHMgPSBlO1xyXG4gICAgICAgIGUgPSBfcztcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmZpbmFsUyA9IHM7XHJcbiAgICAgIHRoaXMuZmluYWxFID0gZTtcclxuICAgIH0sXHJcbiAgfTtcclxuICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFRleHRTZWxlY3RvclByb3BGYWN0b3J5KTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0VGV4dFNlbGVjdG9yUHJvcChlbGVtLCBkYXRhLCBhcnIpIHtcclxuICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkoZWxlbSwgZGF0YSwgYXJyKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBnZXRUZXh0U2VsZWN0b3JQcm9wOiBnZXRUZXh0U2VsZWN0b3JQcm9wLFxyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlU2l6ZWRBcnJheSwgcG9vbGluZyAqL1xyXG4vKiBleHBvcnRlZCBwb29sRmFjdG9yeSAqL1xyXG5cclxudmFyIHBvb2xGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGluaXRpYWxMZW5ndGgsIF9jcmVhdGUsIF9yZWxlYXNlKSB7XHJcbiAgICB2YXIgX2xlbmd0aCA9IDA7XHJcbiAgICB2YXIgX21heExlbmd0aCA9IGluaXRpYWxMZW5ndGg7XHJcbiAgICB2YXIgcG9vbCA9IGNyZWF0ZVNpemVkQXJyYXkoX21heExlbmd0aCk7XHJcblxyXG4gICAgdmFyIG9iID0ge1xyXG4gICAgICBuZXdFbGVtZW50OiBuZXdFbGVtZW50LFxyXG4gICAgICByZWxlYXNlOiByZWxlYXNlLFxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBuZXdFbGVtZW50KCkge1xyXG4gICAgICB2YXIgZWxlbWVudDtcclxuICAgICAgaWYgKF9sZW5ndGgpIHtcclxuICAgICAgICBfbGVuZ3RoIC09IDE7XHJcbiAgICAgICAgZWxlbWVudCA9IHBvb2xbX2xlbmd0aF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlbWVudCA9IF9jcmVhdGUoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWxlYXNlKGVsZW1lbnQpIHtcclxuICAgICAgaWYgKF9sZW5ndGggPT09IF9tYXhMZW5ndGgpIHtcclxuICAgICAgICBwb29sID0gcG9vbGluZy5kb3VibGUocG9vbCk7XHJcbiAgICAgICAgX21heExlbmd0aCAqPSAyO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfcmVsZWFzZSkge1xyXG4gICAgICAgIF9yZWxlYXNlKGVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHBvb2xbX2xlbmd0aF0gPSBlbGVtZW50O1xyXG4gICAgICBfbGVuZ3RoICs9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9iO1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlU2l6ZWRBcnJheSAqL1xyXG4vKiBleHBvcnRlZCBwb29saW5nICovXHJcblxyXG52YXIgcG9vbGluZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gZG91YmxlKGFycikge1xyXG4gICAgcmV0dXJuIGFyci5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheShhcnIubGVuZ3RoKSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZG91YmxlOiBkb3VibGUsXHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVUeXBlZEFycmF5LCBwb29sRmFjdG9yeSAqL1xyXG4vKiBleHBvcnRlZCBwb2ludFBvb2wgKi9cclxuXHJcbnZhciBwb2ludFBvb2wgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcclxuICAgIHJldHVybiBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgMik7XHJcbiAgfVxyXG4gIHJldHVybiBwb29sRmFjdG9yeSg4LCBjcmVhdGUpO1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIFNoYXBlUGF0aCwgcG9pbnRQb29sLCBwb29sRmFjdG9yeSAqL1xyXG4vKiBleHBvcnRlZCBzaGFwZVBvb2wgKi9cclxuXHJcbnZhciBzaGFwZVBvb2wgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcclxuICAgIHJldHVybiBuZXcgU2hhcGVQYXRoKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWxlYXNlKHNoYXBlUGF0aCkge1xyXG4gICAgdmFyIGxlbiA9IHNoYXBlUGF0aC5fbGVuZ3RoO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgcG9pbnRQb29sLnJlbGVhc2Uoc2hhcGVQYXRoLnZbaV0pO1xyXG4gICAgICBwb2ludFBvb2wucmVsZWFzZShzaGFwZVBhdGguaVtpXSk7XHJcbiAgICAgIHBvaW50UG9vbC5yZWxlYXNlKHNoYXBlUGF0aC5vW2ldKTtcclxuICAgICAgc2hhcGVQYXRoLnZbaV0gPSBudWxsO1xyXG4gICAgICBzaGFwZVBhdGguaVtpXSA9IG51bGw7XHJcbiAgICAgIHNoYXBlUGF0aC5vW2ldID0gbnVsbDtcclxuICAgIH1cclxuICAgIHNoYXBlUGF0aC5fbGVuZ3RoID0gMDtcclxuICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjbG9uZShzaGFwZSkge1xyXG4gICAgdmFyIGNsb25lZCA9IGZhY3RvcnkubmV3RWxlbWVudCgpO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gc2hhcGUuX2xlbmd0aCA9PT0gdW5kZWZpbmVkID8gc2hhcGUudi5sZW5ndGggOiBzaGFwZS5fbGVuZ3RoO1xyXG4gICAgY2xvbmVkLnNldExlbmd0aChsZW4pO1xyXG4gICAgY2xvbmVkLmMgPSBzaGFwZS5jO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBjbG9uZWQuc2V0VHJpcGxlQXQoc2hhcGUudltpXVswXSwgc2hhcGUudltpXVsxXSwgc2hhcGUub1tpXVswXSwgc2hhcGUub1tpXVsxXSwgc2hhcGUuaVtpXVswXSwgc2hhcGUuaVtpXVsxXSwgaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG4gIH1cclxuXHJcbiAgdmFyIGZhY3RvcnkgPSBwb29sRmFjdG9yeSg0LCBjcmVhdGUsIHJlbGVhc2UpO1xyXG4gIGZhY3RvcnkuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgcmV0dXJuIGZhY3Rvcnk7XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlU2l6ZWRBcnJheSwgU2hhcGVDb2xsZWN0aW9uLCBzaGFwZVBvb2wsIHBvb2xpbmcgKi9cclxuLyogZXhwb3J0ZWQgc2hhcGVDb2xsZWN0aW9uUG9vbCAqL1xyXG5cclxudmFyIHNoYXBlQ29sbGVjdGlvblBvb2wgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBvYiA9IHtcclxuICAgIG5ld1NoYXBlQ29sbGVjdGlvbjogbmV3U2hhcGVDb2xsZWN0aW9uLFxyXG4gICAgcmVsZWFzZTogcmVsZWFzZSxcclxuICB9O1xyXG5cclxuICB2YXIgX2xlbmd0aCA9IDA7XHJcbiAgdmFyIF9tYXhMZW5ndGggPSA0O1xyXG4gIHZhciBwb29sID0gY3JlYXRlU2l6ZWRBcnJheShfbWF4TGVuZ3RoKTtcclxuXHJcbiAgZnVuY3Rpb24gbmV3U2hhcGVDb2xsZWN0aW9uKCkge1xyXG4gICAgdmFyIHNoYXBlQ29sbGVjdGlvbjtcclxuICAgIGlmIChfbGVuZ3RoKSB7XHJcbiAgICAgIF9sZW5ndGggLT0gMTtcclxuICAgICAgc2hhcGVDb2xsZWN0aW9uID0gcG9vbFtfbGVuZ3RoXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNoYXBlQ29sbGVjdGlvbiA9IG5ldyBTaGFwZUNvbGxlY3Rpb24oKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzaGFwZUNvbGxlY3Rpb247XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWxlYXNlKHNoYXBlQ29sbGVjdGlvbikge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gc2hhcGVDb2xsZWN0aW9uLl9sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgc2hhcGVQb29sLnJlbGVhc2Uoc2hhcGVDb2xsZWN0aW9uLnNoYXBlc1tpXSk7XHJcbiAgICB9XHJcbiAgICBzaGFwZUNvbGxlY3Rpb24uX2xlbmd0aCA9IDA7XHJcblxyXG4gICAgaWYgKF9sZW5ndGggPT09IF9tYXhMZW5ndGgpIHtcclxuICAgICAgcG9vbCA9IHBvb2xpbmcuZG91YmxlKHBvb2wpO1xyXG4gICAgICBfbWF4TGVuZ3RoICo9IDI7XHJcbiAgICB9XHJcbiAgICBwb29sW19sZW5ndGhdID0gc2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgX2xlbmd0aCArPSAxO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iO1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIHBvb2xGYWN0b3J5LCBiZXppZXJMZW5ndGhQb29sICovXHJcbi8qIGV4cG9ydGVkIHNlZ21lbnRzTGVuZ3RoUG9vbCAqL1xyXG5cclxudmFyIHNlZ21lbnRzTGVuZ3RoUG9vbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGVuZ3RoczogW10sXHJcbiAgICAgIHRvdGFsTGVuZ3RoOiAwLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbGVhc2UoZWxlbWVudCkge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gZWxlbWVudC5sZW5ndGhzLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBiZXppZXJMZW5ndGhQb29sLnJlbGVhc2UoZWxlbWVudC5sZW5ndGhzW2ldKTtcclxuICAgIH1cclxuICAgIGVsZW1lbnQubGVuZ3Rocy5sZW5ndGggPSAwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBvb2xGYWN0b3J5KDgsIGNyZWF0ZSwgcmVsZWFzZSk7XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlVHlwZWRBcnJheSwgZGVmYXVsdEN1cnZlU2VnbWVudHMsIHBvb2xGYWN0b3J5ICovXHJcbi8qIGV4cG9ydGVkIGJlemllckxlbmd0aFBvb2wgKi9cclxuXHJcbnZhciBiZXppZXJMZW5ndGhQb29sID0gKGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhZGRlZExlbmd0aDogMCxcclxuICAgICAgcGVyY2VudHM6IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBkZWZhdWx0Q3VydmVTZWdtZW50cyksXHJcbiAgICAgIGxlbmd0aHM6IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBkZWZhdWx0Q3VydmVTZWdtZW50cyksXHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gcG9vbEZhY3RvcnkoOCwgY3JlYXRlKTtcclxufSgpKTtcclxuXHJcbi8qIGV4cG9ydGVkIG1hcmtlclBhcnNlciAqL1xyXG5cclxudmFyIG1hcmtlclBhcnNlciA9IChcclxuXHJcbiAgZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gcGFyc2VQYXlsb2FkTGluZXMocGF5bG9hZCkge1xyXG4gICAgICB2YXIgbGluZXMgPSBwYXlsb2FkLnNwbGl0KCdcXHJcXG4nKTtcclxuICAgICAgdmFyIGtleXMgPSB7fTtcclxuICAgICAgdmFyIGxpbmU7XHJcbiAgICAgIHZhciBrZXlzQ291bnQgPSAwO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgbGluZSA9IGxpbmVzW2ldLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICBrZXlzW2xpbmVbMF1dID0gbGluZVsxXS50cmltKCk7XHJcbiAgICAgICAgICBrZXlzQ291bnQgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGtleXNDb3VudCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoX21hcmtlcnMpIHtcclxuICAgICAgdmFyIG1hcmtlcnMgPSBbXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfbWFya2Vycy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgIHZhciBfbWFya2VyID0gX21hcmtlcnNbaV07XHJcbiAgICAgICAgdmFyIG1hcmtlckRhdGEgPSB7XHJcbiAgICAgICAgICB0aW1lOiBfbWFya2VyLnRtLFxyXG4gICAgICAgICAgZHVyYXRpb246IF9tYXJrZXIuZHIsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgbWFya2VyRGF0YS5wYXlsb2FkID0gSlNPTi5wYXJzZShfbWFya2Vyc1tpXS5jbSk7XHJcbiAgICAgICAgfSBjYXRjaCAoXykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbWFya2VyRGF0YS5wYXlsb2FkID0gcGFyc2VQYXlsb2FkTGluZXMoX21hcmtlcnNbaV0uY20pO1xyXG4gICAgICAgICAgfSBjYXRjaCAoX18pIHtcclxuICAgICAgICAgICAgbWFya2VyRGF0YS5wYXlsb2FkID0ge1xyXG4gICAgICAgICAgICAgIG5hbWU6IF9tYXJrZXJzW2ldLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrZXJzLnB1c2gobWFya2VyRGF0YSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1hcmtlcnM7XHJcbiAgICB9O1xyXG4gIH0oKSk7XHJcblxyXG4vKiBnbG9iYWwgQXVkaW9FbGVtZW50LCBGb290YWdlRWxlbWVudCwgRm9udE1hbmFnZXIgKi9cclxuXHJcbmZ1bmN0aW9uIEJhc2VSZW5kZXJlcigpIHt9XHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuY2hlY2tMYXllcnMgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcclxuICB2YXIgZGF0YTtcclxuICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gdHJ1ZTtcclxuICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgaWYgKCF0aGlzLmVsZW1lbnRzW2ldKSB7XHJcbiAgICAgIGRhdGEgPSB0aGlzLmxheWVyc1tpXTtcclxuICAgICAgaWYgKGRhdGEuaXAgLSBkYXRhLnN0IDw9IChudW0gLSB0aGlzLmxheWVyc1tpXS5zdCkgJiYgZGF0YS5vcCAtIGRhdGEuc3QgPiAobnVtIC0gdGhpcy5sYXllcnNbaV0uc3QpKSB7XHJcbiAgICAgICAgdGhpcy5idWlsZEl0ZW0oaSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSB0aGlzLmVsZW1lbnRzW2ldID8gdGhpcy5jb21wbGV0ZUxheWVycyA6IGZhbHNlO1xyXG4gIH1cclxuICB0aGlzLmNoZWNrUGVuZGluZ0VsZW1lbnRzKCk7XHJcbn07XHJcblxyXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUl0ZW0gPSBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBzd2l0Y2ggKGxheWVyLnR5KSB7XHJcbiAgICBjYXNlIDI6XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUltYWdlKGxheWVyKTtcclxuICAgIGNhc2UgMDpcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29tcChsYXllcik7XHJcbiAgICBjYXNlIDE6XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNvbGlkKGxheWVyKTtcclxuICAgIGNhc2UgMzpcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTnVsbChsYXllcik7XHJcbiAgICBjYXNlIDQ6XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNoYXBlKGxheWVyKTtcclxuICAgIGNhc2UgNTpcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGV4dChsYXllcik7XHJcbiAgICBjYXNlIDY6XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUF1ZGlvKGxheWVyKTtcclxuICAgIGNhc2UgMTM6XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNhbWVyYShsYXllcik7XHJcbiAgICBjYXNlIDE1OlxyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVGb290YWdlKGxheWVyKTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU51bGwobGF5ZXIpO1xyXG4gIH1cclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xyXG4gIHRocm93IG5ldyBFcnJvcignWW91XFwncmUgdXNpbmcgYSAzZCBjYW1lcmEuIFRyeSB0aGUgaHRtbCByZW5kZXJlci4nKTtcclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQXVkaW8gPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHJldHVybiBuZXcgQXVkaW9FbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUZvb3RhZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHJldHVybiBuZXcgRm9vdGFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRBbGxJdGVtcyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgdGhpcy5idWlsZEl0ZW0oaSk7XHJcbiAgfVxyXG4gIHRoaXMuY2hlY2tQZW5kaW5nRWxlbWVudHMoKTtcclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuaW5jbHVkZUxheWVycyA9IGZ1bmN0aW9uIChuZXdMYXllcnMpIHtcclxuICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IG5ld0xheWVycy5sZW5ndGg7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBqID0gMDtcclxuICAgIHdoaWxlIChqIDwgakxlbikge1xyXG4gICAgICBpZiAodGhpcy5sYXllcnNbal0uaWQgPT09IG5ld0xheWVyc1tpXS5pZCkge1xyXG4gICAgICAgIHRoaXMubGF5ZXJzW2pdID0gbmV3TGF5ZXJzW2ldO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGogKz0gMTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLnNldFByb2plY3RJbnRlcmZhY2UgPSBmdW5jdGlvbiAocEludGVyZmFjZSkge1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlID0gcEludGVyZmFjZTtcclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuaW5pdEl0ZW1zID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICghdGhpcy5nbG9iYWxEYXRhLnByb2dyZXNzaXZlTG9hZCkge1xyXG4gICAgdGhpcy5idWlsZEFsbEl0ZW1zKCk7XHJcbiAgfVxyXG59O1xyXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkRWxlbWVudFBhcmVudGluZyA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnROYW1lLCBoaWVyYXJjaHkpIHtcclxuICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xyXG4gIHZhciBsYXllcnMgPSB0aGlzLmxheWVycztcclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIGlmIChsYXllcnNbaV0uaW5kID09IHBhcmVudE5hbWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgICAgaWYgKCFlbGVtZW50c1tpXSB8fCBlbGVtZW50c1tpXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuYnVpbGRJdGVtKGkpO1xyXG4gICAgICAgIHRoaXMuYWRkUGVuZGluZ0VsZW1lbnQoZWxlbWVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaGllcmFyY2h5LnB1c2goZWxlbWVudHNbaV0pO1xyXG4gICAgICAgIGVsZW1lbnRzW2ldLnNldEFzUGFyZW50KCk7XHJcbiAgICAgICAgaWYgKGxheWVyc1tpXS5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGhpcy5idWlsZEVsZW1lbnRQYXJlbnRpbmcoZWxlbWVudCwgbGF5ZXJzW2ldLnBhcmVudCwgaGllcmFyY2h5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZWxlbWVudC5zZXRIaWVyYXJjaHkoaGllcmFyY2h5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGkgKz0gMTtcclxuICB9XHJcbn07XHJcblxyXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmFkZFBlbmRpbmdFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICB0aGlzLnBlbmRpbmdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xyXG59O1xyXG5cclxuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5zZWFyY2hFeHRyYUNvbXBvc2l0aW9ucyA9IGZ1bmN0aW9uIChhc3NldHMpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gYXNzZXRzLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmIChhc3NldHNbaV0ueHQpIHtcclxuICAgICAgdmFyIGNvbXAgPSB0aGlzLmNyZWF0ZUNvbXAoYXNzZXRzW2ldKTtcclxuICAgICAgY29tcC5pbml0RXhwcmVzc2lvbnMoKTtcclxuICAgICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UucmVnaXN0ZXJDb21wb3NpdGlvbihjb21wKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLnNldHVwR2xvYmFsRGF0YSA9IGZ1bmN0aW9uIChhbmltRGF0YSwgZm9udHNDb250YWluZXIpIHtcclxuICB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIgPSBuZXcgRm9udE1hbmFnZXIoKTtcclxuICB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkQ2hhcnMoYW5pbURhdGEuY2hhcnMpO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRGb250cyhhbmltRGF0YS5mb250cywgZm9udHNDb250YWluZXIpO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uZ2V0QXNzZXREYXRhLmJpbmQodGhpcy5hbmltYXRpb25JdGVtKTtcclxuICB0aGlzLmdsb2JhbERhdGEuZ2V0QXNzZXRzUGF0aCA9IHRoaXMuYW5pbWF0aW9uSXRlbS5nZXRBc3NldHNQYXRoLmJpbmQodGhpcy5hbmltYXRpb25JdGVtKTtcclxuICB0aGlzLmdsb2JhbERhdGEuaW1hZ2VMb2FkZXIgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uaW1hZ2VQcmVsb2FkZXI7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLmF1ZGlvQ29udHJvbGxlciA9IHRoaXMuYW5pbWF0aW9uSXRlbS5hdWRpb0NvbnRyb2xsZXI7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lSWQgPSAwO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgPSBhbmltRGF0YS5mcjtcclxuICB0aGlzLmdsb2JhbERhdGEubm0gPSBhbmltRGF0YS5ubTtcclxuICB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUgPSB7XHJcbiAgICB3OiBhbmltRGF0YS53LFxyXG4gICAgaDogYW5pbURhdGEuaCxcclxuICB9O1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZUVsZW1lbnRJRCwgZXh0ZW5kUHJvdG90eXBlLCBCYXNlUmVuZGVyZXIsIE51bGxFbGVtZW50LCBTVkdTaGFwZUVsZW1lbnQsIFNWR1RleHRMb3R0aWVFbGVtZW50LFxyXG5JSW1hZ2VFbGVtZW50LCBTVkdDb21wRWxlbWVudCwgSVNvbGlkRWxlbWVudCwgY3JlYXRlTlMsIGxvY2F0aW9uSHJlZiwgY3JlYXRlU2l6ZWRBcnJheSwgZXhwcmVzc2lvbnNQbHVnaW4gKi9cclxuXHJcbmZ1bmN0aW9uIFNWR1JlbmRlcmVyKGFuaW1hdGlvbkl0ZW0sIGNvbmZpZykge1xyXG4gIHRoaXMuYW5pbWF0aW9uSXRlbSA9IGFuaW1hdGlvbkl0ZW07XHJcbiAgdGhpcy5sYXllcnMgPSBudWxsO1xyXG4gIHRoaXMucmVuZGVyZWRGcmFtZSA9IC0xO1xyXG4gIHRoaXMuc3ZnRWxlbWVudCA9IGNyZWF0ZU5TKCdzdmcnKTtcclxuICB2YXIgYXJpYUxhYmVsID0gJyc7XHJcbiAgaWYgKGNvbmZpZyAmJiBjb25maWcudGl0bGUpIHtcclxuICAgIHZhciB0aXRsZUVsZW1lbnQgPSBjcmVhdGVOUygndGl0bGUnKTtcclxuICAgIHZhciB0aXRsZUlkID0gY3JlYXRlRWxlbWVudElEKCk7XHJcbiAgICB0aXRsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRpdGxlSWQpO1xyXG4gICAgdGl0bGVFbGVtZW50LnRleHRDb250ZW50ID0gY29uZmlnLnRpdGxlO1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LmFwcGVuZENoaWxkKHRpdGxlRWxlbWVudCk7XHJcbiAgICBhcmlhTGFiZWwgKz0gdGl0bGVJZDtcclxuICB9XHJcbiAgaWYgKGNvbmZpZyAmJiBjb25maWcuZGVzY3JpcHRpb24pIHtcclxuICAgIHZhciBkZXNjRWxlbWVudCA9IGNyZWF0ZU5TKCdkZXNjJyk7XHJcbiAgICB2YXIgZGVzY0lkID0gY3JlYXRlRWxlbWVudElEKCk7XHJcbiAgICBkZXNjRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgZGVzY0lkKTtcclxuICAgIGRlc2NFbGVtZW50LnRleHRDb250ZW50ID0gY29uZmlnLmRlc2NyaXB0aW9uO1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LmFwcGVuZENoaWxkKGRlc2NFbGVtZW50KTtcclxuICAgIGFyaWFMYWJlbCArPSAnICcgKyBkZXNjSWQ7XHJcbiAgfVxyXG4gIGlmIChhcmlhTGFiZWwpIHtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScsIGFyaWFMYWJlbCk7XHJcbiAgfVxyXG4gIHZhciBkZWZzID0gY3JlYXRlTlMoJ2RlZnMnKTtcclxuICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQoZGVmcyk7XHJcbiAgdmFyIG1hc2tFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcclxuICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQobWFza0VsZW1lbnQpO1xyXG4gIHRoaXMubGF5ZXJFbGVtZW50ID0gbWFza0VsZW1lbnQ7XHJcbiAgdGhpcy5yZW5kZXJDb25maWcgPSB7XHJcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAoY29uZmlnICYmIGNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvKSB8fCAneE1pZFlNaWQgbWVldCcsXHJcbiAgICBpbWFnZVByZXNlcnZlQXNwZWN0UmF0aW86IChjb25maWcgJiYgY29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbykgfHwgJ3hNaWRZTWlkIHNsaWNlJyxcclxuICAgIHByb2dyZXNzaXZlTG9hZDogKGNvbmZpZyAmJiBjb25maWcucHJvZ3Jlc3NpdmVMb2FkKSB8fCBmYWxzZSxcclxuICAgIGhpZGVPblRyYW5zcGFyZW50OiAhKChjb25maWcgJiYgY29uZmlnLmhpZGVPblRyYW5zcGFyZW50ID09PSBmYWxzZSkpLFxyXG4gICAgdmlld0JveE9ubHk6IChjb25maWcgJiYgY29uZmlnLnZpZXdCb3hPbmx5KSB8fCBmYWxzZSxcclxuICAgIHZpZXdCb3hTaXplOiAoY29uZmlnICYmIGNvbmZpZy52aWV3Qm94U2l6ZSkgfHwgZmFsc2UsXHJcbiAgICBjbGFzc05hbWU6IChjb25maWcgJiYgY29uZmlnLmNsYXNzTmFtZSkgfHwgJycsXHJcbiAgICBpZDogKGNvbmZpZyAmJiBjb25maWcuaWQpIHx8ICcnLFxyXG4gICAgZm9jdXNhYmxlOiBjb25maWcgJiYgY29uZmlnLmZvY3VzYWJsZSxcclxuICAgIGZpbHRlclNpemU6IHtcclxuICAgICAgd2lkdGg6IChjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUud2lkdGgpIHx8ICcxMDAlJyxcclxuICAgICAgaGVpZ2h0OiAoY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLmhlaWdodCkgfHwgJzEwMCUnLFxyXG4gICAgICB4OiAoY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLngpIHx8ICcwJScsXHJcbiAgICAgIHk6IChjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueSkgfHwgJzAlJyxcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgdGhpcy5nbG9iYWxEYXRhID0ge1xyXG4gICAgX21kZjogZmFsc2UsXHJcbiAgICBmcmFtZU51bTogLTEsXHJcbiAgICBkZWZzOiBkZWZzLFxyXG4gICAgcmVuZGVyQ29uZmlnOiB0aGlzLnJlbmRlckNvbmZpZyxcclxuICB9O1xyXG4gIHRoaXMuZWxlbWVudHMgPSBbXTtcclxuICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xyXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XHJcbiAgdGhpcy5yZW5kZXJlclR5cGUgPSAnc3ZnJztcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlUmVuZGVyZXJdLCBTVkdSZW5kZXJlcik7XHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTnVsbCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgcmV0dXJuIG5ldyBOdWxsRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVNoYXBlID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICByZXR1cm4gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHJldHVybiBuZXcgU1ZHVGV4dExvdHRpZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgcmV0dXJuIG5ldyBJSW1hZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29tcCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgcmV0dXJuIG5ldyBTVkdDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVNvbGlkID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICByZXR1cm4gbmV3IElTb2xpZEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5jb25maWdBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbURhdGEpIHtcclxuICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpO1xyXG4gIGlmICh0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94U2l6ZSkge1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHRoaXMucmVuZGVyQ29uZmlnLnZpZXdCb3hTaXplKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsICcwIDAgJyArIGFuaW1EYXRhLncgKyAnICcgKyBhbmltRGF0YS5oKTtcclxuICB9XHJcblxyXG4gIGlmICghdGhpcy5yZW5kZXJDb25maWcudmlld0JveE9ubHkpIHtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgYW5pbURhdGEudyk7XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBhbmltRGF0YS5oKTtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKDAsMCwwKSc7XHJcbiAgfVxyXG4gIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpIHtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcclxuICB9XHJcbiAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmlkKSB7XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMucmVuZGVyQ29uZmlnLmlkKTtcclxuICB9XHJcbiAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmZvY3VzYWJsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdmb2N1c2FibGUnLCB0aGlzLnJlbmRlckNvbmZpZy5mb2N1c2FibGUpO1xyXG4gIH1cclxuICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgdGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpbyk7XHJcbiAgLy8gdGhpcy5sYXllckVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKDAsMCwwKSc7XHJcbiAgLy8gdGhpcy5sYXllckVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gdGhpcy5sYXllckVsZW1lbnQuc3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gdGhpcy5sYXllckVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gdGhpcy5sYXllckVsZW1lbnQuc3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSBcIjBweCAwcHggMHB4XCI7XHJcbiAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5zdmdFbGVtZW50KTtcclxuICAvLyBNYXNrIGFuaW1hdGlvblxyXG4gIHZhciBkZWZzID0gdGhpcy5nbG9iYWxEYXRhLmRlZnM7XHJcblxyXG4gIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBkZWZzKTtcclxuICB0aGlzLmdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkID0gdGhpcy5yZW5kZXJDb25maWcucHJvZ3Jlc3NpdmVMb2FkO1xyXG4gIHRoaXMuZGF0YSA9IGFuaW1EYXRhO1xyXG5cclxuICB2YXIgbWFza0VsZW1lbnQgPSBjcmVhdGVOUygnY2xpcFBhdGgnKTtcclxuICB2YXIgcmVjdCA9IGNyZWF0ZU5TKCdyZWN0Jyk7XHJcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgYW5pbURhdGEudyk7XHJcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGFuaW1EYXRhLmgpO1xyXG4gIHJlY3Quc2V0QXR0cmlidXRlKCd4JywgMCk7XHJcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3knLCAwKTtcclxuICB2YXIgbWFza0lkID0gY3JlYXRlRWxlbWVudElEKCk7XHJcbiAgbWFza0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIG1hc2tJZCk7XHJcbiAgbWFza0VsZW1lbnQuYXBwZW5kQ2hpbGQocmVjdCk7XHJcbiAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCAndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBtYXNrSWQgKyAnKScpO1xyXG5cclxuICBkZWZzLmFwcGVuZENoaWxkKG1hc2tFbGVtZW50KTtcclxuICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcclxuICB0aGlzLmVsZW1lbnRzID0gY3JlYXRlU2l6ZWRBcnJheShhbmltRGF0YS5sYXllcnMubGVuZ3RoKTtcclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcikge1xyXG4gICAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuaW5uZXJUZXh0ID0gJyc7XHJcbiAgfVxyXG4gIHRoaXMubGF5ZXJFbGVtZW50ID0gbnVsbDtcclxuICB0aGlzLmdsb2JhbERhdGEuZGVmcyA9IG51bGw7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzID8gdGhpcy5sYXllcnMubGVuZ3RoIDogMDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldKSB7XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gIH1cclxuICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XHJcbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xyXG4gIHRoaXMuYW5pbWF0aW9uSXRlbSA9IG51bGw7XHJcbn07XHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZEl0ZW0gPSBmdW5jdGlvbiAocG9zKSB7XHJcbiAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuICBpZiAoZWxlbWVudHNbcG9zXSB8fCB0aGlzLmxheWVyc1twb3NdLnR5ID09PSA5OSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBlbGVtZW50c1twb3NdID0gdHJ1ZTtcclxuICB2YXIgZWxlbWVudCA9IHRoaXMuY3JlYXRlSXRlbSh0aGlzLmxheWVyc1twb3NdKTtcclxuXHJcbiAgZWxlbWVudHNbcG9zXSA9IGVsZW1lbnQ7XHJcbiAgaWYgKGV4cHJlc3Npb25zUGx1Z2luKSB7XHJcbiAgICBpZiAodGhpcy5sYXllcnNbcG9zXS50eSA9PT0gMCkge1xyXG4gICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxlbWVudC5pbml0RXhwcmVzc2lvbnMoKTtcclxuICB9XHJcbiAgdGhpcy5hcHBlbmRFbGVtZW50SW5Qb3MoZWxlbWVudCwgcG9zKTtcclxuICBpZiAodGhpcy5sYXllcnNbcG9zXS50dCkge1xyXG4gICAgaWYgKCF0aGlzLmVsZW1lbnRzW3BvcyAtIDFdIHx8IHRoaXMuZWxlbWVudHNbcG9zIC0gMV0gPT09IHRydWUpIHtcclxuICAgICAgdGhpcy5idWlsZEl0ZW0ocG9zIC0gMSk7XHJcbiAgICAgIHRoaXMuYWRkUGVuZGluZ0VsZW1lbnQoZWxlbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbGVtZW50LnNldE1hdHRlKGVsZW1lbnRzW3BvcyAtIDFdLmxheWVySWQpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5jaGVja1BlbmRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICB3aGlsZSAodGhpcy5wZW5kaW5nRWxlbWVudHMubGVuZ3RoKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMucGVuZGluZ0VsZW1lbnRzLnBvcCgpO1xyXG4gICAgZWxlbWVudC5jaGVja1BhcmVudGluZygpO1xyXG4gICAgaWYgKGVsZW1lbnQuZGF0YS50dCkge1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBsZW4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50c1tpXSA9PT0gZWxlbWVudCkge1xyXG4gICAgICAgICAgZWxlbWVudC5zZXRNYXR0ZSh0aGlzLmVsZW1lbnRzW2kgLSAxXS5sYXllcklkKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgaWYgKHRoaXMucmVuZGVyZWRGcmFtZSA9PT0gbnVtIHx8IHRoaXMuZGVzdHJveWVkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChudW0gPT09IG51bGwpIHtcclxuICAgIG51bSA9IHRoaXMucmVuZGVyZWRGcmFtZTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gbnVtO1xyXG4gIH1cclxuICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLScpO1xyXG4gIC8vIGNvbnNvbGUubG9nKCdGUkFNRSAnLG51bSk7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lTnVtID0gbnVtO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZUlkICs9IDE7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UuY3VycmVudEZyYW1lID0gbnVtO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gZmFsc2U7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcclxuICBpZiAoIXRoaXMuY29tcGxldGVMYXllcnMpIHtcclxuICAgIHRoaXMuY2hlY2tMYXllcnMobnVtKTtcclxuICB9XHJcbiAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgIGlmICh0aGlzLmNvbXBsZXRlTGF5ZXJzIHx8IHRoaXMuZWxlbWVudHNbaV0pIHtcclxuICAgICAgdGhpcy5lbGVtZW50c1tpXS5wcmVwYXJlRnJhbWUobnVtIC0gdGhpcy5sYXllcnNbaV0uc3QpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAodGhpcy5nbG9iYWxEYXRhLl9tZGYpIHtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZW5kZXJGcmFtZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmFwcGVuZEVsZW1lbnRJblBvcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBwb3MpIHtcclxuICB2YXIgbmV3RWxlbWVudCA9IGVsZW1lbnQuZ2V0QmFzZUVsZW1lbnQoKTtcclxuICBpZiAoIW5ld0VsZW1lbnQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHZhciBuZXh0RWxlbWVudDtcclxuICB3aGlsZSAoaSA8IHBvcykge1xyXG4gICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXSAhPT0gdHJ1ZSAmJiB0aGlzLmVsZW1lbnRzW2ldLmdldEJhc2VFbGVtZW50KCkpIHtcclxuICAgICAgbmV4dEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldLmdldEJhc2VFbGVtZW50KCk7XHJcbiAgICB9XHJcbiAgICBpICs9IDE7XHJcbiAgfVxyXG4gIGlmIChuZXh0RWxlbWVudCkge1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQsIG5leHRFbGVtZW50KTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3RWxlbWVudCk7XHJcbiAgfVxyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5sYXllckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMubGF5ZXJFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIENWQ29udGV4dERhdGEsIE1hdHJpeCwgZXh0ZW5kUHJvdG90eXBlLCBCYXNlUmVuZGVyZXIsIENWU2hhcGVFbGVtZW50LCBDVlRleHRFbGVtZW50LFxyXG5DVkltYWdlRWxlbWVudCwgQ1ZDb21wRWxlbWVudCwgQ1ZTb2xpZEVsZW1lbnQsIFNWR1JlbmRlcmVyLCBjcmVhdGVUYWcsIGNyZWF0ZVNpemVkQXJyYXkgKi9cclxuXHJcbmZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKGFuaW1hdGlvbkl0ZW0sIGNvbmZpZykge1xyXG4gIHRoaXMuYW5pbWF0aW9uSXRlbSA9IGFuaW1hdGlvbkl0ZW07XHJcbiAgdGhpcy5yZW5kZXJDb25maWcgPSB7XHJcbiAgICBjbGVhckNhbnZhczogKGNvbmZpZyAmJiBjb25maWcuY2xlYXJDYW52YXMgIT09IHVuZGVmaW5lZCkgPyBjb25maWcuY2xlYXJDYW52YXMgOiB0cnVlLFxyXG4gICAgY29udGV4dDogKGNvbmZpZyAmJiBjb25maWcuY29udGV4dCkgfHwgbnVsbCxcclxuICAgIHByb2dyZXNzaXZlTG9hZDogKGNvbmZpZyAmJiBjb25maWcucHJvZ3Jlc3NpdmVMb2FkKSB8fCBmYWxzZSxcclxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IChjb25maWcgJiYgY29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8pIHx8ICd4TWlkWU1pZCBtZWV0JyxcclxuICAgIGltYWdlUHJlc2VydmVBc3BlY3RSYXRpbzogKGNvbmZpZyAmJiBjb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvKSB8fCAneE1pZFlNaWQgc2xpY2UnLFxyXG4gICAgY2xhc3NOYW1lOiAoY29uZmlnICYmIGNvbmZpZy5jbGFzc05hbWUpIHx8ICcnLFxyXG4gICAgaWQ6IChjb25maWcgJiYgY29uZmlnLmlkKSB8fCAnJyxcclxuICB9O1xyXG4gIHRoaXMucmVuZGVyQ29uZmlnLmRwciA9IChjb25maWcgJiYgY29uZmlnLmRwcikgfHwgMTtcclxuICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcclxuICAgIHRoaXMucmVuZGVyQ29uZmlnLmRwciA9IChjb25maWcgJiYgY29uZmlnLmRwcikgfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcclxuICB9XHJcbiAgdGhpcy5yZW5kZXJlZEZyYW1lID0gLTE7XHJcbiAgdGhpcy5nbG9iYWxEYXRhID0ge1xyXG4gICAgZnJhbWVOdW06IC0xLFxyXG4gICAgX21kZjogZmFsc2UsXHJcbiAgICByZW5kZXJDb25maWc6IHRoaXMucmVuZGVyQ29uZmlnLFxyXG4gICAgY3VycmVudEdsb2JhbEFscGhhOiAtMSxcclxuICB9O1xyXG4gIHRoaXMuY29udGV4dERhdGEgPSBuZXcgQ1ZDb250ZXh0RGF0YSgpO1xyXG4gIHRoaXMuZWxlbWVudHMgPSBbXTtcclxuICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xyXG4gIHRoaXMudHJhbnNmb3JtTWF0ID0gbmV3IE1hdHJpeCgpO1xyXG4gIHRoaXMuY29tcGxldGVMYXllcnMgPSBmYWxzZTtcclxuICB0aGlzLnJlbmRlcmVyVHlwZSA9ICdjYW52YXMnO1xyXG59XHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZVJlbmRlcmVyXSwgQ2FudmFzUmVuZGVyZXIpO1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVNoYXBlID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICByZXR1cm4gbmV3IENWU2hhcGVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgcmV0dXJuIG5ldyBDVlRleHRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlSW1hZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHJldHVybiBuZXcgQ1ZJbWFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICByZXR1cm4gbmV3IENWQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVTb2xpZCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgcmV0dXJuIG5ldyBDVlNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZU51bGwgPSBTVkdSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTnVsbDtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jdHhUcmFuc2Zvcm0gPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICBpZiAocHJvcHNbMF0gPT09IDEgJiYgcHJvcHNbMV0gPT09IDAgJiYgcHJvcHNbNF0gPT09IDAgJiYgcHJvcHNbNV0gPT09IDEgJiYgcHJvcHNbMTJdID09PSAwICYmIHByb3BzWzEzXSA9PT0gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoIXRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzKSB7XHJcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQudHJhbnNmb3JtKHByb3BzWzBdLCBwcm9wc1sxXSwgcHJvcHNbNF0sIHByb3BzWzVdLCBwcm9wc1sxMl0sIHByb3BzWzEzXSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMudHJhbnNmb3JtTWF0LmNsb25lRnJvbVByb3BzKHByb3BzKTtcclxuICB2YXIgY1Byb3BzID0gdGhpcy5jb250ZXh0RGF0YS5jVHIucHJvcHM7XHJcbiAgdGhpcy50cmFuc2Zvcm1NYXQudHJhbnNmb3JtKGNQcm9wc1swXSwgY1Byb3BzWzFdLCBjUHJvcHNbMl0sIGNQcm9wc1szXSwgY1Byb3BzWzRdLCBjUHJvcHNbNV0sIGNQcm9wc1s2XSwgY1Byb3BzWzddLCBjUHJvcHNbOF0sIGNQcm9wc1s5XSwgY1Byb3BzWzEwXSwgY1Byb3BzWzExXSwgY1Byb3BzWzEyXSwgY1Byb3BzWzEzXSwgY1Byb3BzWzE0XSwgY1Byb3BzWzE1XSk7XHJcbiAgLy8gdGhpcy5jb250ZXh0RGF0YS5jVHIudHJhbnNmb3JtKHByb3BzWzBdLHByb3BzWzFdLHByb3BzWzJdLHByb3BzWzNdLHByb3BzWzRdLHByb3BzWzVdLHByb3BzWzZdLHByb3BzWzddLHByb3BzWzhdLHByb3BzWzldLHByb3BzWzEwXSxwcm9wc1sxMV0scHJvcHNbMTJdLHByb3BzWzEzXSxwcm9wc1sxNF0scHJvcHNbMTVdKTtcclxuICB0aGlzLmNvbnRleHREYXRhLmNUci5jbG9uZUZyb21Qcm9wcyh0aGlzLnRyYW5zZm9ybU1hdC5wcm9wcyk7XHJcbiAgdmFyIHRyUHJvcHMgPSB0aGlzLmNvbnRleHREYXRhLmNUci5wcm9wcztcclxuICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKHRyUHJvcHNbMF0sIHRyUHJvcHNbMV0sIHRyUHJvcHNbNF0sIHRyUHJvcHNbNV0sIHRyUHJvcHNbMTJdLCB0clByb3BzWzEzXSk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY3R4T3BhY2l0eSA9IGZ1bmN0aW9uIChvcCkge1xyXG4gIC8qIGlmKG9wID09PSAxKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9ICovXHJcbiAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcykge1xyXG4gICAgdGhpcy5jYW52YXNDb250ZXh0Lmdsb2JhbEFscGhhICo9IG9wIDwgMCA/IDAgOiBvcDtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5jdXJyZW50R2xvYmFsQWxwaGEgPSB0aGlzLmNvbnRleHREYXRhLmNPO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLmNvbnRleHREYXRhLmNPICo9IG9wIDwgMCA/IDAgOiBvcDtcclxuICBpZiAodGhpcy5nbG9iYWxEYXRhLmN1cnJlbnRHbG9iYWxBbHBoYSAhPT0gdGhpcy5jb250ZXh0RGF0YS5jTykge1xyXG4gICAgdGhpcy5jYW52YXNDb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy5jb250ZXh0RGF0YS5jTztcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5jdXJyZW50R2xvYmFsQWxwaGEgPSB0aGlzLmNvbnRleHREYXRhLmNPO1xyXG4gIH1cclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAoIXRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzKSB7XHJcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLmNvbnRleHREYXRhLnJlc2V0KCk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChhY3Rpb25GbGFnKSB7XHJcbiAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcykge1xyXG4gICAgdGhpcy5jYW52YXNDb250ZXh0LnNhdmUoKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGFjdGlvbkZsYWcpIHtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dC5zYXZlKCk7XHJcbiAgfVxyXG4gIHZhciBwcm9wcyA9IHRoaXMuY29udGV4dERhdGEuY1RyLnByb3BzO1xyXG4gIGlmICh0aGlzLmNvbnRleHREYXRhLl9sZW5ndGggPD0gdGhpcy5jb250ZXh0RGF0YS5jQXJyUG9zKSB7XHJcbiAgICB0aGlzLmNvbnRleHREYXRhLmR1cGxpY2F0ZSgpO1xyXG4gIH1cclxuICB2YXIgaTtcclxuICB2YXIgYXJyID0gdGhpcy5jb250ZXh0RGF0YS5zYXZlZFt0aGlzLmNvbnRleHREYXRhLmNBcnJQb3NdO1xyXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XHJcbiAgICBhcnJbaV0gPSBwcm9wc1tpXTtcclxuICB9XHJcbiAgdGhpcy5jb250ZXh0RGF0YS5zYXZlZE9wW3RoaXMuY29udGV4dERhdGEuY0FyclBvc10gPSB0aGlzLmNvbnRleHREYXRhLmNPO1xyXG4gIHRoaXMuY29udGV4dERhdGEuY0FyclBvcyArPSAxO1xyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoYWN0aW9uRmxhZykge1xyXG4gIGlmICghdGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMpIHtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChhY3Rpb25GbGFnKSB7XHJcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLmJsZW5kTW9kZSA9ICdzb3VyY2Utb3Zlcic7XHJcbiAgfVxyXG4gIHRoaXMuY29udGV4dERhdGEuY0FyclBvcyAtPSAxO1xyXG4gIHZhciBwb3BwZWQgPSB0aGlzLmNvbnRleHREYXRhLnNhdmVkW3RoaXMuY29udGV4dERhdGEuY0FyclBvc107XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGFyciA9IHRoaXMuY29udGV4dERhdGEuY1RyLnByb3BzO1xyXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XHJcbiAgICBhcnJbaV0gPSBwb3BwZWRbaV07XHJcbiAgfVxyXG4gIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0ocG9wcGVkWzBdLCBwb3BwZWRbMV0sIHBvcHBlZFs0XSwgcG9wcGVkWzVdLCBwb3BwZWRbMTJdLCBwb3BwZWRbMTNdKTtcclxuICBwb3BwZWQgPSB0aGlzLmNvbnRleHREYXRhLnNhdmVkT3BbdGhpcy5jb250ZXh0RGF0YS5jQXJyUG9zXTtcclxuICB0aGlzLmNvbnRleHREYXRhLmNPID0gcG9wcGVkO1xyXG4gIGlmICh0aGlzLmdsb2JhbERhdGEuY3VycmVudEdsb2JhbEFscGhhICE9PSBwb3BwZWQpIHtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dC5nbG9iYWxBbHBoYSA9IHBvcHBlZDtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5jdXJyZW50R2xvYmFsQWxwaGEgPSBwb3BwZWQ7XHJcbiAgfVxyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNvbmZpZ0FuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltRGF0YSkge1xyXG4gIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcikge1xyXG4gICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lciA9IGNyZWF0ZVRhZygnY2FudmFzJyk7XHJcbiAgICB2YXIgY29udGFpbmVyU3R5bGUgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnN0eWxlO1xyXG4gICAgY29udGFpbmVyU3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgICBjb250YWluZXJTdHlsZS5oZWlnaHQgPSAnMTAwJSc7XHJcbiAgICB2YXIgb3JpZ2luID0gJzBweCAwcHggMHB4JztcclxuICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IG9yaWdpbjtcclxuICAgIGNvbnRhaW5lclN0eWxlLm1velRyYW5zZm9ybU9yaWdpbiA9IG9yaWdpbjtcclxuICAgIGNvbnRhaW5lclN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IG9yaWdpbjtcclxuICAgIGNvbnRhaW5lclN0eWxlWyctd2Via2l0LXRyYW5zZm9ybSddID0gb3JpZ2luO1xyXG4gICAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lcik7XHJcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKSB7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMucmVuZGVyQ29uZmlnLmNsYXNzTmFtZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuaWQpIHtcclxuICAgICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5yZW5kZXJDb25maWcuaWQpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQgPSB0aGlzLnJlbmRlckNvbmZpZy5jb250ZXh0O1xyXG4gIH1cclxuICB0aGlzLmRhdGEgPSBhbmltRGF0YTtcclxuICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcclxuICB0aGlzLnRyYW5zZm9ybUNhbnZhcyA9IHtcclxuICAgIHc6IGFuaW1EYXRhLncsXHJcbiAgICBoOiBhbmltRGF0YS5oLFxyXG4gICAgc3g6IDAsXHJcbiAgICBzeTogMCxcclxuICAgIHR4OiAwLFxyXG4gICAgdHk6IDAsXHJcbiAgfTtcclxuICB0aGlzLnNldHVwR2xvYmFsRGF0YShhbmltRGF0YSwgZG9jdW1lbnQuYm9keSk7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQgPSB0aGlzLmNhbnZhc0NvbnRleHQ7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyID0gdGhpcztcclxuICB0aGlzLmdsb2JhbERhdGEuaXNEYXNoZWQgPSBmYWxzZTtcclxuICB0aGlzLmdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkID0gdGhpcy5yZW5kZXJDb25maWcucHJvZ3Jlc3NpdmVMb2FkO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS50cmFuc2Zvcm1DYW52YXMgPSB0aGlzLnRyYW5zZm9ybUNhbnZhcztcclxuICB0aGlzLmVsZW1lbnRzID0gY3JlYXRlU2l6ZWRBcnJheShhbmltRGF0YS5sYXllcnMubGVuZ3RoKTtcclxuXHJcbiAgdGhpcy51cGRhdGVDb250YWluZXJTaXplKCk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnJlc2V0KCk7XHJcbiAgdmFyIGVsZW1lbnRXaWR0aDtcclxuICB2YXIgZWxlbWVudEhlaWdodDtcclxuICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIgJiYgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lcikge1xyXG4gICAgZWxlbWVudFdpZHRoID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0V2lkdGg7XHJcbiAgICBlbGVtZW50SGVpZ2h0ID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0SGVpZ2h0O1xyXG4gICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgZWxlbWVudFdpZHRoICogdGhpcy5yZW5kZXJDb25maWcuZHByKTtcclxuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBlbGVtZW50SGVpZ2h0ICogdGhpcy5yZW5kZXJDb25maWcuZHByKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZWxlbWVudFdpZHRoID0gdGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcy53aWR0aCAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcclxuICAgIGVsZW1lbnRIZWlnaHQgPSB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLmhlaWdodCAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcclxuICB9XHJcbiAgdmFyIGVsZW1lbnRSZWw7XHJcbiAgdmFyIGFuaW1hdGlvblJlbDtcclxuICBpZiAodGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpby5pbmRleE9mKCdtZWV0JykgIT09IC0xIHx8IHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8uaW5kZXhPZignc2xpY2UnKSAhPT0gLTEpIHtcclxuICAgIHZhciBwYXIgPSB0aGlzLnJlbmRlckNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvLnNwbGl0KCcgJyk7XHJcbiAgICB2YXIgZmlsbFR5cGUgPSBwYXJbMV0gfHwgJ21lZXQnO1xyXG4gICAgdmFyIHBvcyA9IHBhclswXSB8fCAneE1pZFlNaWQnO1xyXG4gICAgdmFyIHhQb3MgPSBwb3Muc3Vic3RyKDAsIDQpO1xyXG4gICAgdmFyIHlQb3MgPSBwb3Muc3Vic3RyKDQpO1xyXG4gICAgZWxlbWVudFJlbCA9IGVsZW1lbnRXaWR0aCAvIGVsZW1lbnRIZWlnaHQ7XHJcbiAgICBhbmltYXRpb25SZWwgPSB0aGlzLnRyYW5zZm9ybUNhbnZhcy53IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaDtcclxuICAgIGlmICgoYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ21lZXQnKSB8fCAoYW5pbWF0aW9uUmVsIDwgZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcclxuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ggPSBlbGVtZW50V2lkdGggLyAodGhpcy50cmFuc2Zvcm1DYW52YXMudyAvIHRoaXMucmVuZGVyQ29uZmlnLmRwcik7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5ID0gZWxlbWVudFdpZHRoIC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLncgLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ggPSBlbGVtZW50SGVpZ2h0IC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLmggLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IGVsZW1lbnRIZWlnaHQgLyAodGhpcy50cmFuc2Zvcm1DYW52YXMuaCAvIHRoaXMucmVuZGVyQ29uZmlnLmRwcik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHhQb3MgPT09ICd4TWlkJyAmJiAoKGFuaW1hdGlvblJlbCA8IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdtZWV0JykgfHwgKGFuaW1hdGlvblJlbCA+IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdzbGljZScpKSkge1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCA9ICgoZWxlbWVudFdpZHRoIC0gdGhpcy50cmFuc2Zvcm1DYW52YXMudyAqIChlbGVtZW50SGVpZ2h0IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCkpIC8gMikgKiB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XHJcbiAgICB9IGVsc2UgaWYgKHhQb3MgPT09ICd4TWF4JyAmJiAoKGFuaW1hdGlvblJlbCA8IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdtZWV0JykgfHwgKGFuaW1hdGlvblJlbCA+IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdzbGljZScpKSkge1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCA9IChlbGVtZW50V2lkdGggLSB0aGlzLnRyYW5zZm9ybUNhbnZhcy53ICogKGVsZW1lbnRIZWlnaHQgLyB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oKSkgKiB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAoeVBvcyA9PT0gJ1lNaWQnICYmICgoYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ21lZXQnKSB8fCAoYW5pbWF0aW9uUmVsIDwgZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpKSB7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gKChlbGVtZW50SGVpZ2h0IC0gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCAqIChlbGVtZW50V2lkdGggLyB0aGlzLnRyYW5zZm9ybUNhbnZhcy53KSkgLyAyKSAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcclxuICAgIH0gZWxzZSBpZiAoeVBvcyA9PT0gJ1lNYXgnICYmICgoYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ21lZXQnKSB8fCAoYW5pbWF0aW9uUmVsIDwgZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpKSB7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gKChlbGVtZW50SGVpZ2h0IC0gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCAqIChlbGVtZW50V2lkdGggLyB0aGlzLnRyYW5zZm9ybUNhbnZhcy53KSkpICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAwO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAodGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpbyA9PT0gJ25vbmUnKSB7XHJcbiAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCA9IGVsZW1lbnRXaWR0aCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy53IC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcclxuICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5ID0gZWxlbWVudEhlaWdodCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy5oIC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcclxuICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gMDtcclxuICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gMDtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ggPSB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XHJcbiAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcclxuICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gMDtcclxuICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gMDtcclxuICB9XHJcbiAgdGhpcy50cmFuc2Zvcm1DYW52YXMucHJvcHMgPSBbdGhpcy50cmFuc2Zvcm1DYW52YXMuc3gsIDAsIDAsIDAsIDAsIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5LCAwLCAwLCAwLCAwLCAxLCAwLCB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCwgdGhpcy50cmFuc2Zvcm1DYW52YXMudHksIDAsIDFdO1xyXG4gIC8qIHZhciBpLCBsZW4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcclxuICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgaWYodGhpcy5lbGVtZW50c1tpXSAmJiB0aGlzLmVsZW1lbnRzW2ldLmRhdGEudHkgPT09IDApe1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnJlc2l6ZSh0aGlzLmdsb2JhbERhdGEudHJhbnNmb3JtQ2FudmFzKTtcclxuICAgICAgICB9XHJcbiAgICB9ICovXHJcbiAgdGhpcy5jdHhUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1DYW52YXMucHJvcHMpO1xyXG4gIHRoaXMuY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcclxuICB0aGlzLmNhbnZhc0NvbnRleHQucmVjdCgwLCAwLCB0aGlzLnRyYW5zZm9ybUNhbnZhcy53LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oKTtcclxuICB0aGlzLmNhbnZhc0NvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgdGhpcy5jYW52YXNDb250ZXh0LmNsaXAoKTtcclxuXHJcbiAgdGhpcy5yZW5kZXJGcmFtZSh0aGlzLnJlbmRlcmVkRnJhbWUsIHRydWUpO1xyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzICYmIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5pbm5lclRleHQgPSAnJztcclxuICB9XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzID8gdGhpcy5sYXllcnMubGVuZ3RoIDogMDtcclxuICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgaWYgKHRoaXMuZWxlbWVudHNbaV0pIHtcclxuICAgICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRoaXMuZWxlbWVudHMubGVuZ3RoID0gMDtcclxuICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dCA9IG51bGw7XHJcbiAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lciA9IG51bGw7XHJcbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKG51bSwgZm9yY2VSZW5kZXIpIHtcclxuICBpZiAoKHRoaXMucmVuZGVyZWRGcmFtZSA9PT0gbnVtICYmIHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzID09PSB0cnVlICYmICFmb3JjZVJlbmRlcikgfHwgdGhpcy5kZXN0cm95ZWQgfHwgbnVtID09PSAtMSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLnJlbmRlcmVkRnJhbWUgPSBudW07XHJcbiAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lTnVtID0gbnVtIC0gdGhpcy5hbmltYXRpb25JdGVtLl9pc0ZpcnN0RnJhbWU7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lSWQgKz0gMTtcclxuICB0aGlzLmdsb2JhbERhdGEuX21kZiA9ICF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyB8fCBmb3JjZVJlbmRlcjtcclxuICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5jdXJyZW50RnJhbWUgPSBudW07XHJcblxyXG4gIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLScpO1xyXG4gIC8vIGNvbnNvbGUubG9nKCdORVc6ICcsbnVtKTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gIGlmICghdGhpcy5jb21wbGV0ZUxheWVycykge1xyXG4gICAgdGhpcy5jaGVja0xheWVycyhudW0pO1xyXG4gIH1cclxuXHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbaV0ucHJlcGFyZUZyYW1lKG51bSAtIHRoaXMubGF5ZXJzW2ldLnN0KTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHRoaXMuZ2xvYmFsRGF0YS5fbWRmKSB7XHJcbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMgPT09IHRydWUpIHtcclxuICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnRyYW5zZm9ybUNhbnZhcy53LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2F2ZSgpO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVuZGVyRnJhbWUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzICE9PSB0cnVlKSB7XHJcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZEl0ZW0gPSBmdW5jdGlvbiAocG9zKSB7XHJcbiAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuICBpZiAoZWxlbWVudHNbcG9zXSB8fCB0aGlzLmxheWVyc1twb3NdLnR5ID09PSA5OSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgZWxlbWVudCA9IHRoaXMuY3JlYXRlSXRlbSh0aGlzLmxheWVyc1twb3NdLCB0aGlzLCB0aGlzLmdsb2JhbERhdGEpO1xyXG4gIGVsZW1lbnRzW3Bvc10gPSBlbGVtZW50O1xyXG4gIGVsZW1lbnQuaW5pdEV4cHJlc3Npb25zKCk7XHJcbiAgLyogaWYodGhpcy5sYXllcnNbcG9zXS50eSA9PT0gMCl7XHJcbiAgICAgICAgZWxlbWVudC5yZXNpemUodGhpcy5nbG9iYWxEYXRhLnRyYW5zZm9ybUNhbnZhcyk7XHJcbiAgICB9ICovXHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY2hlY2tQZW5kaW5nRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgd2hpbGUgKHRoaXMucGVuZGluZ0VsZW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBlbmRpbmdFbGVtZW50cy5wb3AoKTtcclxuICAgIGVsZW1lbnQuY2hlY2tQYXJlbnRpbmcoKTtcclxuICB9XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgQmFzZVJlbmRlcmVyLCBTVkdSZW5kZXJlciwgU1ZHU2hhcGVFbGVtZW50LCBIU2hhcGVFbGVtZW50LCBTVkdUZXh0TG90dGllRWxlbWVudCxcclxuSFRleHRFbGVtZW50LCBIQ2FtZXJhRWxlbWVudCwgSUltYWdlRWxlbWVudCwgSEltYWdlRWxlbWVudCwgU1ZHQ29tcEVsZW1lbnQsIEhDb21wRWxlbWVudCwgSVNvbGlkRWxlbWVudCxcclxuSFNvbGlkRWxlbWVudCwgc3R5bGVEaXYsIGNyZWF0ZVRhZywgY3JlYXRlTlMgKi9cclxuXHJcbmZ1bmN0aW9uIEh5YnJpZFJlbmRlcmVyKGFuaW1hdGlvbkl0ZW0sIGNvbmZpZykge1xyXG4gIHRoaXMuYW5pbWF0aW9uSXRlbSA9IGFuaW1hdGlvbkl0ZW07XHJcbiAgdGhpcy5sYXllcnMgPSBudWxsO1xyXG4gIHRoaXMucmVuZGVyZWRGcmFtZSA9IC0xO1xyXG4gIHRoaXMucmVuZGVyQ29uZmlnID0ge1xyXG4gICAgY2xhc3NOYW1lOiAoY29uZmlnICYmIGNvbmZpZy5jbGFzc05hbWUpIHx8ICcnLFxyXG4gICAgaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvOiAoY29uZmlnICYmIGNvbmZpZy5pbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8pIHx8ICd4TWlkWU1pZCBzbGljZScsXHJcbiAgICBoaWRlT25UcmFuc3BhcmVudDogIShjb25maWcgJiYgY29uZmlnLmhpZGVPblRyYW5zcGFyZW50ID09PSBmYWxzZSksXHJcbiAgICBmaWx0ZXJTaXplOiB7XHJcbiAgICAgIHdpZHRoOiAoY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLndpZHRoKSB8fCAnNDAwJScsXHJcbiAgICAgIGhlaWdodDogKGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS5oZWlnaHQpIHx8ICc0MDAlJyxcclxuICAgICAgeDogKGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS54KSB8fCAnLTEwMCUnLFxyXG4gICAgICB5OiAoY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnkpIHx8ICctMTAwJScsXHJcbiAgICB9LFxyXG4gIH07XHJcbiAgdGhpcy5nbG9iYWxEYXRhID0ge1xyXG4gICAgX21kZjogZmFsc2UsXHJcbiAgICBmcmFtZU51bTogLTEsXHJcbiAgICByZW5kZXJDb25maWc6IHRoaXMucmVuZGVyQ29uZmlnLFxyXG4gIH07XHJcbiAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcclxuICB0aGlzLmVsZW1lbnRzID0gW107XHJcbiAgdGhpcy50aHJlZURFbGVtZW50cyA9IFtdO1xyXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XHJcbiAgdGhpcy5jYW1lcmEgPSBudWxsO1xyXG4gIHRoaXMuc3VwcG9ydHMzZCA9IHRydWU7XHJcbiAgdGhpcy5yZW5kZXJlclR5cGUgPSAnaHRtbCc7XHJcbn1cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZVJlbmRlcmVyXSwgSHlicmlkUmVuZGVyZXIpO1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkSXRlbSA9IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZEl0ZW07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuY2hlY2tQZW5kaW5nRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgd2hpbGUgKHRoaXMucGVuZGluZ0VsZW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBlbmRpbmdFbGVtZW50cy5wb3AoKTtcclxuICAgIGVsZW1lbnQuY2hlY2tQYXJlbnRpbmcoKTtcclxuICB9XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuYXBwZW5kRWxlbWVudEluUG9zID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBvcykge1xyXG4gIHZhciBuZXdET01FbGVtZW50ID0gZWxlbWVudC5nZXRCYXNlRWxlbWVudCgpO1xyXG4gIGlmICghbmV3RE9NRWxlbWVudCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgbGF5ZXIgPSB0aGlzLmxheWVyc1twb3NdO1xyXG4gIGlmICghbGF5ZXIuZGRkIHx8ICF0aGlzLnN1cHBvcnRzM2QpIHtcclxuICAgIGlmICh0aGlzLnRocmVlREVsZW1lbnRzKSB7XHJcbiAgICAgIHRoaXMuYWRkVG8zZENvbnRhaW5lcihuZXdET01FbGVtZW50LCBwb3MpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICB2YXIgbmV4dERPTUVsZW1lbnQ7XHJcbiAgICAgIHZhciBuZXh0TGF5ZXI7XHJcbiAgICAgIHZhciB0bXBET01FbGVtZW50O1xyXG4gICAgICB3aGlsZSAoaSA8IHBvcykge1xyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0gIT09IHRydWUgJiYgdGhpcy5lbGVtZW50c1tpXS5nZXRCYXNlRWxlbWVudCkge1xyXG4gICAgICAgICAgbmV4dExheWVyID0gdGhpcy5lbGVtZW50c1tpXTtcclxuICAgICAgICAgIHRtcERPTUVsZW1lbnQgPSB0aGlzLmxheWVyc1tpXS5kZGQgPyB0aGlzLmdldFRocmVlRENvbnRhaW5lckJ5UG9zKGkpIDogbmV4dExheWVyLmdldEJhc2VFbGVtZW50KCk7XHJcbiAgICAgICAgICBuZXh0RE9NRWxlbWVudCA9IHRtcERPTUVsZW1lbnQgfHwgbmV4dERPTUVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmV4dERPTUVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoIWxheWVyLmRkZCB8fCAhdGhpcy5zdXBwb3J0czNkKSB7XHJcbiAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5pbnNlcnRCZWZvcmUobmV3RE9NRWxlbWVudCwgbmV4dERPTUVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICghbGF5ZXIuZGRkIHx8ICF0aGlzLnN1cHBvcnRzM2QpIHtcclxuICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChuZXdET01FbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmFkZFRvM2RDb250YWluZXIobmV3RE9NRWxlbWVudCwgcG9zKTtcclxuICB9XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIGlmICghdGhpcy5zdXBwb3J0czNkKSB7XHJcbiAgICByZXR1cm4gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IEhTaGFwZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xyXG4gICAgcmV0dXJuIG5ldyBTVkdUZXh0TG90dGllRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IEhUZXh0RWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNhbWVyYSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgdGhpcy5jYW1lcmEgPSBuZXcgSENhbWVyYUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxuICByZXR1cm4gdGhpcy5jYW1lcmE7XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlSW1hZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIGlmICghdGhpcy5zdXBwb3J0czNkKSB7XHJcbiAgICByZXR1cm4gbmV3IElJbWFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBISW1hZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29tcCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcclxuICAgIHJldHVybiBuZXcgU1ZHQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBIQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVTb2xpZCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcclxuICAgIHJldHVybiBuZXcgSVNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IEhTb2xpZEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVOdWxsID0gU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZU51bGw7XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuZ2V0VGhyZWVEQ29udGFpbmVyQnlQb3MgPSBmdW5jdGlvbiAocG9zKSB7XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHZhciBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcclxuICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgaWYgKHRoaXMudGhyZWVERWxlbWVudHNbaV0uc3RhcnRQb3MgPD0gcG9zICYmIHRoaXMudGhyZWVERWxlbWVudHNbaV0uZW5kUG9zID49IHBvcykge1xyXG4gICAgICByZXR1cm4gdGhpcy50aHJlZURFbGVtZW50c1tpXS5wZXJzcGVjdGl2ZUVsZW07XHJcbiAgICB9XHJcbiAgICBpICs9IDE7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRocmVlRENvbnRhaW5lciA9IGZ1bmN0aW9uIChwb3MsIHR5cGUpIHtcclxuICB2YXIgcGVyc3BlY3RpdmVFbGVtID0gY3JlYXRlVGFnKCdkaXYnKTtcclxuICB2YXIgc3R5bGU7XHJcbiAgdmFyIGNvbnRhaW5lclN0eWxlO1xyXG4gIHN0eWxlRGl2KHBlcnNwZWN0aXZlRWxlbSk7XHJcbiAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZVRhZygnZGl2Jyk7XHJcbiAgc3R5bGVEaXYoY29udGFpbmVyKTtcclxuICBpZiAodHlwZSA9PT0gJzNkJykge1xyXG4gICAgc3R5bGUgPSBwZXJzcGVjdGl2ZUVsZW0uc3R5bGU7XHJcbiAgICBzdHlsZS53aWR0aCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53ICsgJ3B4JztcclxuICAgIHN0eWxlLmhlaWdodCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oICsgJ3B4JztcclxuICAgIHZhciBjZW50ZXIgPSAnNTAlIDUwJSc7XHJcbiAgICBzdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSBjZW50ZXI7XHJcbiAgICBzdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSBjZW50ZXI7XHJcbiAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBjZW50ZXI7XHJcbiAgICBjb250YWluZXJTdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuICAgIHZhciBtYXRyaXggPSAnbWF0cml4M2QoMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMSknO1xyXG4gICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtID0gbWF0cml4O1xyXG4gICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0cml4O1xyXG4gIH1cclxuXHJcbiAgcGVyc3BlY3RpdmVFbGVtLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcbiAgLy8gdGhpcy5yZXNpemVyRWxlbS5hcHBlbmRDaGlsZChwZXJzcGVjdGl2ZUVsZW0pO1xyXG4gIHZhciB0aHJlZURDb250YWluZXJEYXRhID0ge1xyXG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICBwZXJzcGVjdGl2ZUVsZW06IHBlcnNwZWN0aXZlRWxlbSxcclxuICAgIHN0YXJ0UG9zOiBwb3MsXHJcbiAgICBlbmRQb3M6IHBvcyxcclxuICAgIHR5cGU6IHR5cGUsXHJcbiAgfTtcclxuICB0aGlzLnRocmVlREVsZW1lbnRzLnB1c2godGhyZWVEQ29udGFpbmVyRGF0YSk7XHJcbiAgcmV0dXJuIHRocmVlRENvbnRhaW5lckRhdGE7XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuYnVpbGQzZENvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcclxuICB2YXIgbGFzdFRocmVlRENvbnRhaW5lckRhdGE7XHJcbiAgdmFyIGN1cnJlbnRDb250YWluZXIgPSAnJztcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmICh0aGlzLmxheWVyc1tpXS5kZGQgJiYgdGhpcy5sYXllcnNbaV0udHkgIT09IDMpIHtcclxuICAgICAgaWYgKGN1cnJlbnRDb250YWluZXIgIT09ICczZCcpIHtcclxuICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gJzNkJztcclxuICAgICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YSA9IHRoaXMuY3JlYXRlVGhyZWVEQ29udGFpbmVyKGksICczZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGxhc3RUaHJlZURDb250YWluZXJEYXRhLmVuZFBvcyA9IE1hdGgubWF4KGxhc3RUaHJlZURDb250YWluZXJEYXRhLmVuZFBvcywgaSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoY3VycmVudENvbnRhaW5lciAhPT0gJzJkJykge1xyXG4gICAgICAgIGN1cnJlbnRDb250YWluZXIgPSAnMmQnO1xyXG4gICAgICAgIGxhc3RUaHJlZURDb250YWluZXJEYXRhID0gdGhpcy5jcmVhdGVUaHJlZURDb250YWluZXIoaSwgJzJkJyk7XHJcbiAgICAgIH1cclxuICAgICAgbGFzdFRocmVlRENvbnRhaW5lckRhdGEuZW5kUG9zID0gTWF0aC5tYXgobGFzdFRocmVlRENvbnRhaW5lckRhdGEuZW5kUG9zLCBpKTtcclxuICAgIH1cclxuICB9XHJcbiAgbGVuID0gdGhpcy50aHJlZURFbGVtZW50cy5sZW5ndGg7XHJcbiAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgIHRoaXMucmVzaXplckVsZW0uYXBwZW5kQ2hpbGQodGhpcy50aHJlZURFbGVtZW50c1tpXS5wZXJzcGVjdGl2ZUVsZW0pO1xyXG4gIH1cclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5hZGRUbzNkQ29udGFpbmVyID0gZnVuY3Rpb24gKGVsZW0sIHBvcykge1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgbGVuID0gdGhpcy50aHJlZURFbGVtZW50cy5sZW5ndGg7XHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIGlmIChwb3MgPD0gdGhpcy50aHJlZURFbGVtZW50c1tpXS5lbmRQb3MpIHtcclxuICAgICAgdmFyIGogPSB0aGlzLnRocmVlREVsZW1lbnRzW2ldLnN0YXJ0UG9zO1xyXG4gICAgICB2YXIgbmV4dEVsZW1lbnQ7XHJcbiAgICAgIHdoaWxlIChqIDwgcG9zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbal0gJiYgdGhpcy5lbGVtZW50c1tqXS5nZXRCYXNlRWxlbWVudCkge1xyXG4gICAgICAgICAgbmV4dEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2pdLmdldEJhc2VFbGVtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGogKz0gMTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmV4dEVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLnRocmVlREVsZW1lbnRzW2ldLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZWxlbSwgbmV4dEVsZW1lbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudGhyZWVERWxlbWVudHNbaV0uY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW0pO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgaSArPSAxO1xyXG4gIH1cclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jb25maWdBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbURhdGEpIHtcclxuICB2YXIgcmVzaXplckVsZW0gPSBjcmVhdGVUYWcoJ2RpdicpO1xyXG4gIHZhciB3cmFwcGVyID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXI7XHJcbiAgdmFyIHN0eWxlID0gcmVzaXplckVsZW0uc3R5bGU7XHJcbiAgc3R5bGUud2lkdGggPSBhbmltRGF0YS53ICsgJ3B4JztcclxuICBzdHlsZS5oZWlnaHQgPSBhbmltRGF0YS5oICsgJ3B4JztcclxuICB0aGlzLnJlc2l6ZXJFbGVtID0gcmVzaXplckVsZW07XHJcbiAgc3R5bGVEaXYocmVzaXplckVsZW0pO1xyXG4gIHN0eWxlLnRyYW5zZm9ybVN0eWxlID0gJ2ZsYXQnO1xyXG4gIHN0eWxlLm1velRyYW5zZm9ybVN0eWxlID0gJ2ZsYXQnO1xyXG4gIHN0eWxlLndlYmtpdFRyYW5zZm9ybVN0eWxlID0gJ2ZsYXQnO1xyXG4gIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpIHtcclxuICAgIHJlc2l6ZXJFbGVtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpO1xyXG4gIH1cclxuICB3cmFwcGVyLmFwcGVuZENoaWxkKHJlc2l6ZXJFbGVtKTtcclxuXHJcbiAgc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICB2YXIgc3ZnID0gY3JlYXRlTlMoJ3N2ZycpO1xyXG4gIHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzEnKTtcclxuICBzdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMScpO1xyXG4gIHN0eWxlRGl2KHN2Zyk7XHJcbiAgdGhpcy5yZXNpemVyRWxlbS5hcHBlbmRDaGlsZChzdmcpO1xyXG4gIHZhciBkZWZzID0gY3JlYXRlTlMoJ2RlZnMnKTtcclxuICBzdmcuYXBwZW5kQ2hpbGQoZGVmcyk7XHJcbiAgdGhpcy5kYXRhID0gYW5pbURhdGE7XHJcbiAgLy8gTWFzayBhbmltYXRpb25cclxuICB0aGlzLnNldHVwR2xvYmFsRGF0YShhbmltRGF0YSwgc3ZnKTtcclxuICB0aGlzLmdsb2JhbERhdGEuZGVmcyA9IGRlZnM7XHJcbiAgdGhpcy5sYXllcnMgPSBhbmltRGF0YS5sYXllcnM7XHJcbiAgdGhpcy5sYXllckVsZW1lbnQgPSB0aGlzLnJlc2l6ZXJFbGVtO1xyXG4gIHRoaXMuYnVpbGQzZENvbnRhaW5lcnMoKTtcclxuICB0aGlzLnVwZGF0ZUNvbnRhaW5lclNpemUoKTtcclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcikge1xyXG4gICAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuaW5uZXJUZXh0ID0gJyc7XHJcbiAgfVxyXG4gIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIgPSBudWxsO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5kZWZzID0gbnVsbDtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5sYXllcnMgPyB0aGlzLmxheWVycy5sZW5ndGggOiAwO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XHJcbiAgfVxyXG4gIHRoaXMuZWxlbWVudHMubGVuZ3RoID0gMDtcclxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XHJcbiAgdGhpcy5hbmltYXRpb25JdGVtID0gbnVsbDtcclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVDb250YWluZXJTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBlbGVtZW50V2lkdGggPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5vZmZzZXRXaWR0aDtcclxuICB2YXIgZWxlbWVudEhlaWdodCA9IHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLm9mZnNldEhlaWdodDtcclxuICB2YXIgZWxlbWVudFJlbCA9IGVsZW1lbnRXaWR0aCAvIGVsZW1lbnRIZWlnaHQ7XHJcbiAgdmFyIGFuaW1hdGlvblJlbCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53IC8gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XHJcbiAgdmFyIHN4O1xyXG4gIHZhciBzeTtcclxuICB2YXIgdHg7XHJcbiAgdmFyIHR5O1xyXG4gIGlmIChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsKSB7XHJcbiAgICBzeCA9IGVsZW1lbnRXaWR0aCAvICh0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyk7XHJcbiAgICBzeSA9IGVsZW1lbnRXaWR0aCAvICh0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyk7XHJcbiAgICB0eCA9IDA7XHJcbiAgICB0eSA9ICgoZWxlbWVudEhlaWdodCAtIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oICogKGVsZW1lbnRXaWR0aCAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53KSkgLyAyKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3ggPSBlbGVtZW50SGVpZ2h0IC8gKHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oKTtcclxuICAgIHN5ID0gZWxlbWVudEhlaWdodCAvICh0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCk7XHJcbiAgICB0eCA9IChlbGVtZW50V2lkdGggLSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyAqIChlbGVtZW50SGVpZ2h0IC8gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmgpKSAvIDI7XHJcbiAgICB0eSA9IDA7XHJcbiAgfVxyXG4gIHZhciBzdHlsZSA9IHRoaXMucmVzaXplckVsZW0uc3R5bGU7XHJcbiAgc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ21hdHJpeDNkKCcgKyBzeCArICcsMCwwLDAsMCwnICsgc3kgKyAnLDAsMCwwLDAsMSwwLCcgKyB0eCArICcsJyArIHR5ICsgJywwLDEpJztcclxuICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm07XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBTVkdSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRnJhbWU7XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnJlc2l6ZXJFbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnJlc2l6ZXJFbGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmluaXRJdGVtcyA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcclxuICBpZiAodGhpcy5jYW1lcmEpIHtcclxuICAgIHRoaXMuY2FtZXJhLnNldHVwKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBjV2lkdGggPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudztcclxuICAgIHZhciBjSGVpZ2h0ID0gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLnRocmVlREVsZW1lbnRzW2ldLnBlcnNwZWN0aXZlRWxlbS5zdHlsZTtcclxuICAgICAgc3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPSBNYXRoLnNxcnQoTWF0aC5wb3coY1dpZHRoLCAyKSArIE1hdGgucG93KGNIZWlnaHQsIDIpKSArICdweCc7XHJcbiAgICAgIHN0eWxlLnBlcnNwZWN0aXZlID0gc3R5bGUud2Via2l0UGVyc3BlY3RpdmU7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLnNlYXJjaEV4dHJhQ29tcG9zaXRpb25zID0gZnVuY3Rpb24gKGFzc2V0cykge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBhc3NldHMubGVuZ3RoO1xyXG4gIHZhciBmbG9hdGluZ0NvbnRhaW5lciA9IGNyZWF0ZVRhZygnZGl2Jyk7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAoYXNzZXRzW2ldLnh0KSB7XHJcbiAgICAgIHZhciBjb21wID0gdGhpcy5jcmVhdGVDb21wKGFzc2V0c1tpXSwgZmxvYXRpbmdDb250YWluZXIsIHRoaXMuZ2xvYmFsRGF0YS5jb21wLCBudWxsKTtcclxuICAgICAgY29tcC5pbml0RXhwcmVzc2lvbnMoKTtcclxuICAgICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UucmVnaXN0ZXJDb21wb3NpdGlvbihjb21wKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlU2l6ZWRBcnJheSwgY3JlYXRlRWxlbWVudElELCBQcm9wZXJ0eUZhY3RvcnksIFNoYXBlUHJvcGVydHlGYWN0b3J5LCBjcmVhdGVOUywgbG9jYXRpb25IcmVmICovXHJcblxyXG5mdW5jdGlvbiBNYXNrRWxlbWVudChkYXRhLCBlbGVtZW50LCBnbG9iYWxEYXRhKSB7XHJcbiAgdGhpcy5kYXRhID0gZGF0YTtcclxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gIHRoaXMuZ2xvYmFsRGF0YSA9IGdsb2JhbERhdGE7XHJcbiAgdGhpcy5zdG9yZWREYXRhID0gW107XHJcbiAgdGhpcy5tYXNrc1Byb3BlcnRpZXMgPSB0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzIHx8IFtdO1xyXG4gIHRoaXMubWFza0VsZW1lbnQgPSBudWxsO1xyXG4gIHZhciBkZWZzID0gdGhpcy5nbG9iYWxEYXRhLmRlZnM7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMubWFza3NQcm9wZXJ0aWVzID8gdGhpcy5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoIDogMDtcclxuICB0aGlzLnZpZXdEYXRhID0gY3JlYXRlU2l6ZWRBcnJheShsZW4pO1xyXG4gIHRoaXMuc29saWRQYXRoID0gJyc7XHJcblxyXG4gIHZhciBwYXRoO1xyXG4gIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5tYXNrc1Byb3BlcnRpZXM7XHJcbiAgdmFyIGNvdW50ID0gMDtcclxuICB2YXIgY3VycmVudE1hc2tzID0gW107XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW47XHJcbiAgdmFyIGxheWVySWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuICB2YXIgcmVjdDtcclxuICB2YXIgZXhwYW5zb3I7XHJcbiAgdmFyIGZlTW9ycGg7XHJcbiAgdmFyIHg7XHJcbiAgdmFyIG1hc2tUeXBlID0gJ2NsaXBQYXRoJztcclxuICB2YXIgbWFza1JlZiA9ICdjbGlwLXBhdGgnO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgaWYgKChwcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICdhJyAmJiBwcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICduJykgfHwgcHJvcGVydGllc1tpXS5pbnYgfHwgcHJvcGVydGllc1tpXS5vLmsgIT09IDEwMCB8fCBwcm9wZXJ0aWVzW2ldLm8ueCkge1xyXG4gICAgICBtYXNrVHlwZSA9ICdtYXNrJztcclxuICAgICAgbWFza1JlZiA9ICdtYXNrJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoKHByb3BlcnRpZXNbaV0ubW9kZSA9PT0gJ3MnIHx8IHByb3BlcnRpZXNbaV0ubW9kZSA9PT0gJ2knKSAmJiBjb3VudCA9PT0gMCkge1xyXG4gICAgICByZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcclxuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnI2ZmZmZmZicpO1xyXG4gICAgICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmVsZW1lbnQuY29tcC5kYXRhLncgfHwgMCk7XHJcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmVsZW1lbnQuY29tcC5kYXRhLmggfHwgMCk7XHJcbiAgICAgIGN1cnJlbnRNYXNrcy5wdXNoKHJlY3QpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVjdCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcGF0aCA9IGNyZWF0ZU5TKCdwYXRoJyk7XHJcbiAgICBpZiAocHJvcGVydGllc1tpXS5tb2RlID09PSAnbicpIHtcclxuICAgICAgLy8gVE9ETyBtb3ZlIHRoaXMgdG8gYSBmYWN0b3J5IG9yIHRvIGEgY29uc3RydWN0b3JcclxuICAgICAgdGhpcy52aWV3RGF0YVtpXSA9IHtcclxuICAgICAgICBvcDogUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcy5lbGVtZW50LCBwcm9wZXJ0aWVzW2ldLm8sIDAsIDAuMDEsIHRoaXMuZWxlbWVudCksXHJcbiAgICAgICAgcHJvcDogU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wKHRoaXMuZWxlbWVudCwgcHJvcGVydGllc1tpXSwgMyksXHJcbiAgICAgICAgZWxlbTogcGF0aCxcclxuICAgICAgICBsYXN0UGF0aDogJycsXHJcbiAgICAgIH07XHJcbiAgICAgIGRlZnMuYXBwZW5kQ2hpbGQocGF0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb3VudCArPSAxO1xyXG5cclxuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdzJyA/ICcjMDAwMDAwJyA6ICcjZmZmZmZmJyk7XHJcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdjbGlwLXJ1bGUnLCAnbm9uemVybycpO1xyXG4gICAgICB2YXIgZmlsdGVySUQ7XHJcblxyXG4gICAgICBpZiAocHJvcGVydGllc1tpXS54LmsgIT09IDApIHtcclxuICAgICAgICBtYXNrVHlwZSA9ICdtYXNrJztcclxuICAgICAgICBtYXNrUmVmID0gJ21hc2snO1xyXG4gICAgICAgIHggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0ueCwgMCwgbnVsbCwgdGhpcy5lbGVtZW50KTtcclxuICAgICAgICBmaWx0ZXJJRCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xyXG4gICAgICAgIGV4cGFuc29yID0gY3JlYXRlTlMoJ2ZpbHRlcicpO1xyXG4gICAgICAgIGV4cGFuc29yLnNldEF0dHJpYnV0ZSgnaWQnLCBmaWx0ZXJJRCk7XHJcbiAgICAgICAgZmVNb3JwaCA9IGNyZWF0ZU5TKCdmZU1vcnBob2xvZ3knKTtcclxuICAgICAgICBmZU1vcnBoLnNldEF0dHJpYnV0ZSgnb3BlcmF0b3InLCAnZXJvZGUnKTtcclxuICAgICAgICBmZU1vcnBoLnNldEF0dHJpYnV0ZSgnaW4nLCAnU291cmNlR3JhcGhpYycpO1xyXG4gICAgICAgIGZlTW9ycGguc2V0QXR0cmlidXRlKCdyYWRpdXMnLCAnMCcpO1xyXG4gICAgICAgIGV4cGFuc29yLmFwcGVuZENoaWxkKGZlTW9ycGgpO1xyXG4gICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoZXhwYW5zb3IpO1xyXG4gICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdzJyA/ICcjMDAwMDAwJyA6ICcjZmZmZmZmJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmVNb3JwaCA9IG51bGw7XHJcbiAgICAgICAgeCA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRPRE8gbW92ZSB0aGlzIHRvIGEgZmFjdG9yeSBvciB0byBhIGNvbnN0cnVjdG9yXHJcbiAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXSA9IHtcclxuICAgICAgICBlbGVtOiBwYXRoLFxyXG4gICAgICAgIHg6IHgsXHJcbiAgICAgICAgZXhwYW46IGZlTW9ycGgsXHJcbiAgICAgICAgbGFzdFBhdGg6ICcnLFxyXG4gICAgICAgIGxhc3RPcGVyYXRvcjogJycsXHJcbiAgICAgICAgZmlsdGVySWQ6IGZpbHRlcklELFxyXG4gICAgICAgIGxhc3RSYWRpdXM6IDAsXHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdpJykge1xyXG4gICAgICAgIGpMZW4gPSBjdXJyZW50TWFza3MubGVuZ3RoO1xyXG4gICAgICAgIHZhciBnID0gY3JlYXRlTlMoJ2cnKTtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICBnLmFwcGVuZENoaWxkKGN1cnJlbnRNYXNrc1tqXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtYXNrID0gY3JlYXRlTlMoJ21hc2snKTtcclxuICAgICAgICBtYXNrLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2FscGhhJyk7XHJcbiAgICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgbGF5ZXJJZCArICdfJyArIGNvdW50KTtcclxuICAgICAgICBtYXNrLmFwcGVuZENoaWxkKHBhdGgpO1xyXG4gICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQobWFzayk7XHJcbiAgICAgICAgZy5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBsYXllcklkICsgJ18nICsgY291bnQgKyAnKScpO1xyXG5cclxuICAgICAgICBjdXJyZW50TWFza3MubGVuZ3RoID0gMDtcclxuICAgICAgICBjdXJyZW50TWFza3MucHVzaChnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJyZW50TWFza3MucHVzaChwYXRoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvcGVydGllc1tpXS5pbnYgJiYgIXRoaXMuc29saWRQYXRoKSB7XHJcbiAgICAgICAgdGhpcy5zb2xpZFBhdGggPSB0aGlzLmNyZWF0ZUxheWVyU29saWRQYXRoKCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gVE9ETyBtb3ZlIHRoaXMgdG8gYSBmYWN0b3J5IG9yIHRvIGEgY29uc3RydWN0b3JcclxuICAgICAgdGhpcy52aWV3RGF0YVtpXSA9IHtcclxuICAgICAgICBlbGVtOiBwYXRoLFxyXG4gICAgICAgIGxhc3RQYXRoOiAnJyxcclxuICAgICAgICBvcDogUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcy5lbGVtZW50LCBwcm9wZXJ0aWVzW2ldLm8sIDAsIDAuMDEsIHRoaXMuZWxlbWVudCksXHJcbiAgICAgICAgcHJvcDogU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wKHRoaXMuZWxlbWVudCwgcHJvcGVydGllc1tpXSwgMyksXHJcbiAgICAgICAgaW52UmVjdDogcmVjdCxcclxuICAgICAgfTtcclxuICAgICAgaWYgKCF0aGlzLnZpZXdEYXRhW2ldLnByb3Auaykge1xyXG4gICAgICAgIHRoaXMuZHJhd1BhdGgocHJvcGVydGllc1tpXSwgdGhpcy52aWV3RGF0YVtpXS5wcm9wLnYsIHRoaXMudmlld0RhdGFbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aGlzLm1hc2tFbGVtZW50ID0gY3JlYXRlTlMobWFza1R5cGUpO1xyXG5cclxuICBsZW4gPSBjdXJyZW50TWFza3MubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgdGhpcy5tYXNrRWxlbWVudC5hcHBlbmRDaGlsZChjdXJyZW50TWFza3NbaV0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNvdW50ID4gMCkge1xyXG4gICAgdGhpcy5tYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgbGF5ZXJJZCk7XHJcbiAgICB0aGlzLmVsZW1lbnQubWFza2VkRWxlbWVudC5zZXRBdHRyaWJ1dGUobWFza1JlZiwgJ3VybCgnICsgbG9jYXRpb25IcmVmICsgJyMnICsgbGF5ZXJJZCArICcpJyk7XHJcbiAgICBkZWZzLmFwcGVuZENoaWxkKHRoaXMubWFza0VsZW1lbnQpO1xyXG4gIH1cclxuICBpZiAodGhpcy52aWV3RGF0YS5sZW5ndGgpIHtcclxuICAgIHRoaXMuZWxlbWVudC5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xyXG4gIH1cclxufVxyXG5cclxuTWFza0VsZW1lbnQucHJvdG90eXBlLmdldE1hc2tQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwb3MpIHtcclxuICByZXR1cm4gdGhpcy52aWV3RGF0YVtwb3NdLnByb3A7XHJcbn07XHJcblxyXG5NYXNrRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoaXNGaXJzdEZyYW1lKSB7XHJcbiAgdmFyIGZpbmFsTWF0ID0gdGhpcy5lbGVtZW50LmZpbmFsVHJhbnNmb3JtLm1hdDtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgaWYgKHRoaXMudmlld0RhdGFbaV0ucHJvcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xyXG4gICAgICB0aGlzLmRyYXdQYXRoKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLCB0aGlzLnZpZXdEYXRhW2ldLnByb3AudiwgdGhpcy52aWV3RGF0YVtpXSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy52aWV3RGF0YVtpXS5vcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xyXG4gICAgICB0aGlzLnZpZXdEYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCB0aGlzLnZpZXdEYXRhW2ldLm9wLnYpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICduJykge1xyXG4gICAgICBpZiAodGhpcy52aWV3RGF0YVtpXS5pbnZSZWN0ICYmICh0aGlzLmVsZW1lbnQuZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCBpc0ZpcnN0RnJhbWUpKSB7XHJcbiAgICAgICAgdGhpcy52aWV3RGF0YVtpXS5pbnZSZWN0LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgZmluYWxNYXQuZ2V0SW52ZXJzZU1hdHJpeCgpLnRvMmRDU1MoKSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuc3RvcmVkRGF0YVtpXS54ICYmICh0aGlzLnN0b3JlZERhdGFbaV0ueC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkpIHtcclxuICAgICAgICB2YXIgZmVNb3JwaCA9IHRoaXMuc3RvcmVkRGF0YVtpXS5leHBhbjtcclxuICAgICAgICBpZiAodGhpcy5zdG9yZWREYXRhW2ldLngudiA8IDApIHtcclxuICAgICAgICAgIGlmICh0aGlzLnN0b3JlZERhdGFbaV0ubGFzdE9wZXJhdG9yICE9PSAnZXJvZGUnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgPSAnZXJvZGUnO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGxvY2F0aW9uSHJlZiArICcjJyArIHRoaXMuc3RvcmVkRGF0YVtpXS5maWx0ZXJJZCArICcpJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmZU1vcnBoLnNldEF0dHJpYnV0ZSgncmFkaXVzJywgLXRoaXMuc3RvcmVkRGF0YVtpXS54LnYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5zdG9yZWREYXRhW2ldLmxhc3RPcGVyYXRvciAhPT0gJ2RpbGF0ZScpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmxhc3RPcGVyYXRvciA9ICdkaWxhdGUnO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsIG51bGwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnN0b3JlZERhdGFbaV0ueC52ICogMik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuTWFza0VsZW1lbnQucHJvdG90eXBlLmdldE1hc2tlbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLm1hc2tFbGVtZW50O1xyXG59O1xyXG5cclxuTWFza0VsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUxheWVyU29saWRQYXRoID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwYXRoID0gJ00wLDAgJztcclxuICBwYXRoICs9ICcgaCcgKyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudztcclxuICBwYXRoICs9ICcgdicgKyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaDtcclxuICBwYXRoICs9ICcgaC0nICsgdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLnc7XHJcbiAgcGF0aCArPSAnIHYtJyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oICsgJyAnO1xyXG4gIHJldHVybiBwYXRoO1xyXG59O1xyXG5cclxuTWFza0VsZW1lbnQucHJvdG90eXBlLmRyYXdQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBwYXRoTm9kZXMsIHZpZXdEYXRhKSB7XHJcbiAgdmFyIHBhdGhTdHJpbmcgPSAnIE0nICsgcGF0aE5vZGVzLnZbMF1bMF0gKyAnLCcgKyBwYXRoTm9kZXMudlswXVsxXTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuO1xyXG4gIGxlbiA9IHBhdGhOb2Rlcy5fbGVuZ3RoO1xyXG4gIGZvciAoaSA9IDE7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgLy8gcGF0aFN0cmluZyArPSBcIiBDXCIrcGF0aE5vZGVzLm9baS0xXVswXSsnLCcrcGF0aE5vZGVzLm9baS0xXVsxXSArIFwiIFwiK3BhdGhOb2Rlcy5pW2ldWzBdKycsJytwYXRoTm9kZXMuaVtpXVsxXSArIFwiIFwiK3BhdGhOb2Rlcy52W2ldWzBdKycsJytwYXRoTm9kZXMudltpXVsxXTtcclxuICAgIHBhdGhTdHJpbmcgKz0gJyBDJyArIHBhdGhOb2Rlcy5vW2kgLSAxXVswXSArICcsJyArIHBhdGhOb2Rlcy5vW2kgLSAxXVsxXSArICcgJyArIHBhdGhOb2Rlcy5pW2ldWzBdICsgJywnICsgcGF0aE5vZGVzLmlbaV1bMV0gKyAnICcgKyBwYXRoTm9kZXMudltpXVswXSArICcsJyArIHBhdGhOb2Rlcy52W2ldWzFdO1xyXG4gIH1cclxuICAvLyBwYXRoU3RyaW5nICs9IFwiIENcIitwYXRoTm9kZXMub1tpLTFdWzBdKycsJytwYXRoTm9kZXMub1tpLTFdWzFdICsgXCIgXCIrcGF0aE5vZGVzLmlbMF1bMF0rJywnK3BhdGhOb2Rlcy5pWzBdWzFdICsgXCIgXCIrcGF0aE5vZGVzLnZbMF1bMF0rJywnK3BhdGhOb2Rlcy52WzBdWzFdO1xyXG4gIGlmIChwYXRoTm9kZXMuYyAmJiBsZW4gPiAxKSB7XHJcbiAgICBwYXRoU3RyaW5nICs9ICcgQycgKyBwYXRoTm9kZXMub1tpIC0gMV1bMF0gKyAnLCcgKyBwYXRoTm9kZXMub1tpIC0gMV1bMV0gKyAnICcgKyBwYXRoTm9kZXMuaVswXVswXSArICcsJyArIHBhdGhOb2Rlcy5pWzBdWzFdICsgJyAnICsgcGF0aE5vZGVzLnZbMF1bMF0gKyAnLCcgKyBwYXRoTm9kZXMudlswXVsxXTtcclxuICB9XHJcbiAgLy8gcGF0aE5vZGVzLl9fcmVuZGVyZWRTdHJpbmcgPSBwYXRoU3RyaW5nO1xyXG5cclxuICBpZiAodmlld0RhdGEubGFzdFBhdGggIT09IHBhdGhTdHJpbmcpIHtcclxuICAgIHZhciBwYXRoU2hhcGVWYWx1ZSA9ICcnO1xyXG4gICAgaWYgKHZpZXdEYXRhLmVsZW0pIHtcclxuICAgICAgaWYgKHBhdGhOb2Rlcy5jKSB7XHJcbiAgICAgICAgcGF0aFNoYXBlVmFsdWUgPSBwYXRoRGF0YS5pbnYgPyB0aGlzLnNvbGlkUGF0aCArIHBhdGhTdHJpbmcgOiBwYXRoU3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIHZpZXdEYXRhLmVsZW0uc2V0QXR0cmlidXRlKCdkJywgcGF0aFNoYXBlVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgdmlld0RhdGEubGFzdFBhdGggPSBwYXRoU3RyaW5nO1xyXG4gIH1cclxufTtcclxuXHJcbk1hc2tFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuZWxlbWVudCA9IG51bGw7XHJcbiAgdGhpcy5nbG9iYWxEYXRhID0gbnVsbDtcclxuICB0aGlzLm1hc2tFbGVtZW50ID0gbnVsbDtcclxuICB0aGlzLmRhdGEgPSBudWxsO1xyXG4gIHRoaXMubWFza3NQcm9wZXJ0aWVzID0gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZVxyXG4gKiBIYW5kbGVzIEFFJ3MgbGF5ZXIgcGFyZW50aW5nIHByb3BlcnR5LlxyXG4gKlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEhpZXJhcmNoeUVsZW1lbnQoKSB7fVxyXG5cclxuSGllcmFyY2h5RWxlbWVudC5wcm90b3R5cGUgPSB7XHJcbiAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEluaXRpYWxpemVzIGhpZXJhcmNoeSBwcm9wZXJ0aWVzXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgaW5pdEhpZXJhcmNoeTogZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gZWxlbWVudCdzIHBhcmVudCBsaXN0XHJcbiAgICB0aGlzLmhpZXJhcmNoeSA9IFtdO1xyXG4gICAgLy8gaWYgZWxlbWVudCBpcyBwYXJlbnQgb2YgYW5vdGhlciBsYXllciBfaXNQYXJlbnQgd2lsbCBiZSB0cnVlXHJcbiAgICB0aGlzLl9pc1BhcmVudCA9IGZhbHNlO1xyXG4gICAgdGhpcy5jaGVja1BhcmVudGluZygpO1xyXG4gIH0sXHJcbiAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIFNldHMgbGF5ZXIncyBoaWVyYXJjaHkuXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBoaWVyYXJjaFxyXG4gICAgICogbGF5ZXIncyBwYXJlbnQgbGlzdFxyXG4gICAgICpcclxuICAgICAqL1xyXG4gIHNldEhpZXJhcmNoeTogZnVuY3Rpb24gKGhpZXJhcmNoeSkge1xyXG4gICAgdGhpcy5oaWVyYXJjaHkgPSBoaWVyYXJjaHk7XHJcbiAgfSxcclxuICAvKipcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogU2V0cyBsYXllciBhcyBwYXJlbnQuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgc2V0QXNQYXJlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuX2lzUGFyZW50ID0gdHJ1ZTtcclxuICB9LFxyXG4gIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBTZWFyY2hlcyBsYXllcidzIHBhcmVudGluZyBjaGFpblxyXG4gICAgICpcclxuICAgICAqL1xyXG4gIGNoZWNrUGFyZW50aW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5kYXRhLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuY29tcC5idWlsZEVsZW1lbnRQYXJlbnRpbmcodGhpcywgdGhpcy5kYXRhLnBhcmVudCwgW10pO1xyXG4gICAgfVxyXG4gIH0sXHJcbn07XHJcblxyXG4vKipcclxuICogQGZpbGVcclxuICogSGFuZGxlcyBlbGVtZW50J3MgbGF5ZXIgZnJhbWUgdXBkYXRlLlxyXG4gKiBDaGVja3MgbGF5ZXIgaW4gcG9pbnQgYW5kIG91dCBwb2ludFxyXG4gKlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEZyYW1lRWxlbWVudCgpIHt9XHJcblxyXG5GcmFtZUVsZW1lbnQucHJvdG90eXBlID0ge1xyXG4gIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBJbml0aWFsaXplcyBmcmFtZSByZWxhdGVkIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgaW5pdEZyYW1lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBzZXQgdG8gdHJ1ZSB3aGVuIGlucG9pbnQgaXMgcmVuZGVyZWRcclxuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xyXG4gICAgLy8gbGlzdCBvZiBhbmltYXRlZCBwcm9wZXJ0aWVzXHJcbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XHJcbiAgICAvLyBJZiBsYXllciBoYXMgYmVlbiBtb2RpZmllZCBpbiBjdXJyZW50IHRpY2sgdGhpcyB3aWxsIGJlIHRydWVcclxuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gIH0sXHJcbiAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIENhbGN1bGF0ZXMgYWxsIGR5bmFtaWMgdmFsdWVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bVxyXG4gICAgICogY3VycmVudCBmcmFtZSBudW1iZXIgaW4gTGF5ZXIncyB0aW1lXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmlzaWJsZVxyXG4gICAgICogaWYgbGF5ZXJzIGlzIGN1cnJlbnRseSBpbiByYW5nZVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gIHByZXBhcmVQcm9wZXJ0aWVzOiBmdW5jdGlvbiAobnVtLCBpc1Zpc2libGUpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGlmIChpc1Zpc2libGUgfHwgKHRoaXMuX2lzUGFyZW50ICYmIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0ucHJvcFR5cGUgPT09ICd0cmFuc2Zvcm0nKSkge1xyXG4gICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcclxuICAgICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5fbWRmKSB7XHJcbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IHRydWU7XHJcbiAgICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgYWRkRHluYW1pY1Byb3BlcnR5OiBmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcclxuICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3ApO1xyXG4gICAgfVxyXG4gIH0sXHJcbn07XHJcblxyXG4vKiBnbG9iYWwgVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LCBNYXRyaXggKi9cclxuXHJcbmZ1bmN0aW9uIFRyYW5zZm9ybUVsZW1lbnQoKSB7fVxyXG5cclxuVHJhbnNmb3JtRWxlbWVudC5wcm90b3R5cGUgPSB7XHJcbiAgaW5pdFRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5maW5hbFRyYW5zZm9ybSA9IHtcclxuICAgICAgbVByb3A6IHRoaXMuZGF0YS5rcyA/IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSh0aGlzLCB0aGlzLmRhdGEua3MsIHRoaXMpIDogeyBvOiAwIH0sXHJcbiAgICAgIF9tYXRNZGY6IGZhbHNlLFxyXG4gICAgICBfb3BNZGY6IGZhbHNlLFxyXG4gICAgICBtYXQ6IG5ldyBNYXRyaXgoKSxcclxuICAgIH07XHJcbiAgICBpZiAodGhpcy5kYXRhLmFvKSB7XHJcbiAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AuYXV0b09yaWVudGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBjaGVjayBUWVBFIDExOiBHdWlkZWQgZWxlbWVudHNcclxuICAgIGlmICh0aGlzLmRhdGEudHkgIT09IDExKSB7XHJcbiAgICAgIC8vIHRoaXMuY3JlYXRlRWxlbWVudHMoKTtcclxuICAgIH1cclxuICB9LFxyXG4gIHJlbmRlclRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLm8uX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWU7XHJcbiAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lO1xyXG5cclxuICAgIGlmICh0aGlzLmhpZXJhcmNoeSkge1xyXG4gICAgICB2YXIgbWF0O1xyXG4gICAgICB2YXIgZmluYWxNYXQgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdDtcclxuICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICB2YXIgbGVuID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoO1xyXG4gICAgICAvLyBDaGVja2luZyBpZiBhbnkgb2YgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpY2VzIGluIHRoZSBoaWVyYXJjaHkgY2hhaW4gaGFzIGNoYW5nZWQuXHJcbiAgICAgIGlmICghdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICAgIGlmICh0aGlzLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5fbWRmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZiA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZikge1xyXG4gICAgICAgIG1hdCA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Audi5wcm9wcztcclxuICAgICAgICBmaW5hbE1hdC5jbG9uZUZyb21Qcm9wcyhtYXQpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgbWF0ID0gdGhpcy5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3Audi5wcm9wcztcclxuICAgICAgICAgIGZpbmFsTWF0LnRyYW5zZm9ybShtYXRbMF0sIG1hdFsxXSwgbWF0WzJdLCBtYXRbM10sIG1hdFs0XSwgbWF0WzVdLCBtYXRbNl0sIG1hdFs3XSwgbWF0WzhdLCBtYXRbOV0sIG1hdFsxMF0sIG1hdFsxMV0sIG1hdFsxMl0sIG1hdFsxM10sIG1hdFsxNF0sIG1hdFsxNV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZ2xvYmFsVG9Mb2NhbDogZnVuY3Rpb24gKHB0KSB7XHJcbiAgICB2YXIgdHJhbnNmb3JtcyA9IFtdO1xyXG4gICAgdHJhbnNmb3Jtcy5wdXNoKHRoaXMuZmluYWxUcmFuc2Zvcm0pO1xyXG4gICAgdmFyIGZsYWcgPSB0cnVlO1xyXG4gICAgdmFyIGNvbXAgPSB0aGlzLmNvbXA7XHJcbiAgICB3aGlsZSAoZmxhZykge1xyXG4gICAgICBpZiAoY29tcC5maW5hbFRyYW5zZm9ybSkge1xyXG4gICAgICAgIGlmIChjb21wLmRhdGEuaGFzTWFzaykge1xyXG4gICAgICAgICAgdHJhbnNmb3Jtcy5zcGxpY2UoMCwgMCwgY29tcC5maW5hbFRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXAgPSBjb21wLmNvbXA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmxhZyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aDtcclxuICAgIHZhciBwdE5ldztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBwdE5ldyA9IHRyYW5zZm9ybXNbaV0ubWF0LmFwcGx5VG9Qb2ludEFycmF5KDAsIDAsIDApO1xyXG4gICAgICAvLyBwdE5ldyA9IHRyYW5zZm9ybXNbaV0ubWF0LmFwcGx5VG9Qb2ludEFycmF5KHB0WzBdLHB0WzFdLHB0WzJdKTtcclxuICAgICAgcHQgPSBbcHRbMF0gLSBwdE5ld1swXSwgcHRbMV0gLSBwdE5ld1sxXSwgMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHQ7XHJcbiAgfSxcclxuICBtSGVscGVyOiBuZXcgTWF0cml4KCksXHJcbn07XHJcblxyXG5mdW5jdGlvbiBSZW5kZXJhYmxlRWxlbWVudCgpIHtcclxuXHJcbn1cclxuXHJcblJlbmRlcmFibGVFbGVtZW50LnByb3RvdHlwZSA9IHtcclxuICBpbml0UmVuZGVyYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gbGF5ZXIncyB2aXNpYmlsaXR5IHJlbGF0ZWQgdG8gaW5wb2ludCBhbmQgb3V0cG9pbnQuIFJlbmFtZSBpc1Zpc2libGUgdG8gaXNJblJhbmdlXHJcbiAgICB0aGlzLmlzSW5SYW5nZSA9IGZhbHNlO1xyXG4gICAgLy8gbGF5ZXIncyBkaXNwbGF5IHN0YXRlXHJcbiAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgLy8gSWYgbGF5ZXIncyB0cmFuc3BhcmVuY3kgZXF1YWxzIDAsIGl0IGNhbiBiZSBoaWRkZW5cclxuICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IGZhbHNlO1xyXG4gICAgLy8gbGlzdCBvZiBhbmltYXRlZCBjb21wb25lbnRzXHJcbiAgICB0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzID0gW107XHJcbiAgfSxcclxuICBhZGRSZW5kZXJhYmxlQ29tcG9uZW50OiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XHJcbiAgICBpZiAodGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCkgPT09IC0xKSB7XHJcbiAgICAgIHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVtb3ZlUmVuZGVyYWJsZUNvbXBvbmVudDogZnVuY3Rpb24gKGNvbXBvbmVudCkge1xyXG4gICAgaWYgKHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpICE9PSAtMSkge1xyXG4gICAgICB0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzLnNwbGljZSh0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KSwgMSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBwcmVwYXJlUmVuZGVyYWJsZUZyYW1lOiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICB0aGlzLmNoZWNrTGF5ZXJMaW1pdHMobnVtKTtcclxuICB9LFxyXG4gIGNoZWNrVHJhbnNwYXJlbmN5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5vLnYgPD0gMCkge1xyXG4gICAgICBpZiAoIXRoaXMuaXNUcmFuc3BhcmVudCAmJiB0aGlzLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmhpZGVPblRyYW5zcGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy5pc1RyYW5zcGFyZW50ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVHJhbnNwYXJlbnQpIHtcclxuICAgICAgdGhpcy5pc1RyYW5zcGFyZW50ID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEluaXRpYWxpemVzIGZyYW1lIHJlbGF0ZWQgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtXHJcbiAgICAgKiBjdXJyZW50IGZyYW1lIG51bWJlciBpbiBMYXllcidzIHRpbWVcclxuICAgICAqXHJcbiAgICAgKi9cclxuICBjaGVja0xheWVyTGltaXRzOiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICBpZiAodGhpcy5kYXRhLmlwIC0gdGhpcy5kYXRhLnN0IDw9IG51bSAmJiB0aGlzLmRhdGEub3AgLSB0aGlzLmRhdGEuc3QgPiBudW0pIHtcclxuICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLl9tZGYgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX21kZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc0luUmFuZ2UgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNJblJhbmdlICE9PSBmYWxzZSkge1xyXG4gICAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IHRydWU7XHJcbiAgICAgIHRoaXMuaXNJblJhbmdlID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVuZGVyUmVuZGVyYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50c1tpXS5yZW5kZXJGcmFtZSh0aGlzLl9pc0ZpcnN0RnJhbWUpO1xyXG4gICAgfVxyXG4gICAgLyogdGhpcy5tYXNrTWFuYWdlci5yZW5kZXJGcmFtZSh0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIucmVuZGVyRnJhbWUodGhpcy5faXNGaXJzdEZyYW1lKTsgKi9cclxuICB9LFxyXG4gIHNvdXJjZVJlY3RBdFRpbWU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvcDogMCxcclxuICAgICAgbGVmdDogMCxcclxuICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgaGVpZ2h0OiAxMDAsXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgZ2V0TGF5ZXJTaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5kYXRhLnR5ID09PSA1KSB7XHJcbiAgICAgIHJldHVybiB7IHc6IHRoaXMuZGF0YS50ZXh0RGF0YS53aWR0aCwgaDogdGhpcy5kYXRhLnRleHREYXRhLmhlaWdodCB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgdzogdGhpcy5kYXRhLndpZHRoLCBoOiB0aGlzLmRhdGEuaGVpZ2h0IH07XHJcbiAgfSxcclxufTtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIFJlbmRlcmFibGVFbGVtZW50LCBjcmVhdGVQcm94eUZ1bmN0aW9uICovXHJcblxyXG5mdW5jdGlvbiBSZW5kZXJhYmxlRE9NRWxlbWVudCgpIHt9XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG4gIHZhciBfcHJvdG90eXBlID0ge1xyXG4gICAgaW5pdEVsZW1lbnQ6IGZ1bmN0aW9uIChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgICAgIHRoaXMuaW5pdEZyYW1lKCk7XHJcbiAgICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG4gICAgICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgICAgIHRoaXMuaW5pdEhpZXJhcmNoeSgpO1xyXG4gICAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XHJcbiAgICAgIHRoaXMuaW5pdFJlbmRlcmVyRWxlbWVudCgpO1xyXG4gICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzKCk7XHJcbiAgICAgIHRoaXMuY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKTtcclxuICAgICAgdGhpcy5jcmVhdGVDb250ZW50KCk7XHJcbiAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgfSxcclxuICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKCF0aGlzLmhpZGRlbiAmJiAoIXRoaXMuaXNJblJhbmdlIHx8IHRoaXMuaXNUcmFuc3BhcmVudCkpIHtcclxuICAgICAgICB2YXIgZWxlbSA9IHRoaXMuYmFzZUVsZW1lbnQgfHwgdGhpcy5sYXllckVsZW1lbnQ7XHJcbiAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICYmICF0aGlzLmlzVHJhbnNwYXJlbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5oZCkge1xyXG4gICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmJhc2VFbGVtZW50IHx8IHRoaXMubGF5ZXJFbGVtZW50O1xyXG4gICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyRnJhbWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgLy8gSWYgaXQgaXMgZXhwb3J0ZWQgYXMgaGlkZGVuIChkYXRhLmhkID09PSB0cnVlKSBubyBuZWVkIHRvIHJlbmRlclxyXG4gICAgICAvLyBJZiBpdCBpcyBub3QgdmlzaWJsZSBubyBuZWVkIHRvIHJlbmRlclxyXG4gICAgICBpZiAodGhpcy5kYXRhLmhkIHx8IHRoaXMuaGlkZGVuKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucmVuZGVyVHJhbnNmb3JtKCk7XHJcbiAgICAgIHRoaXMucmVuZGVyUmVuZGVyYWJsZSgpO1xyXG4gICAgICB0aGlzLnJlbmRlckVsZW1lbnQoKTtcclxuICAgICAgdGhpcy5yZW5kZXJJbm5lckNvbnRlbnQoKTtcclxuICAgICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVuZGVySW5uZXJDb250ZW50OiBmdW5jdGlvbiAoKSB7fSxcclxuICAgIHByZXBhcmVGcmFtZTogZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICAgICAgdGhpcy5wcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSk7XHJcbiAgICAgIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0aGlzLmlzSW5SYW5nZSk7XHJcbiAgICAgIHRoaXMuY2hlY2tUcmFuc3BhcmVuY3koKTtcclxuICAgIH0sXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuaW5uZXJFbGVtID0gbnVsbDtcclxuICAgICAgdGhpcy5kZXN0cm95QmFzZUVsZW1lbnQoKTtcclxuICAgIH0sXHJcbiAgfTtcclxuICBleHRlbmRQcm90b3R5cGUoW1JlbmRlcmFibGVFbGVtZW50LCBjcmVhdGVQcm94eUZ1bmN0aW9uKF9wcm90b3R5cGUpXSwgUmVuZGVyYWJsZURPTUVsZW1lbnQpO1xyXG59KCkpO1xyXG5cclxuLyogZXhwb3J0ZWQgUHJvY2Vzc2VkRWxlbWVudCAqL1xyXG5cclxuZnVuY3Rpb24gUHJvY2Vzc2VkRWxlbWVudChlbGVtZW50LCBwb3NpdGlvbikge1xyXG4gIHRoaXMuZWxlbSA9IGVsZW1lbnQ7XHJcbiAgdGhpcy5wb3MgPSBwb3NpdGlvbjtcclxufVxyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZU5TICovXHJcblxyXG5mdW5jdGlvbiBTVkdTdHlsZURhdGEoZGF0YSwgbGV2ZWwpIHtcclxuICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gIHRoaXMudHlwZSA9IGRhdGEudHk7XHJcbiAgdGhpcy5kID0gJyc7XHJcbiAgdGhpcy5sdmwgPSBsZXZlbDtcclxuICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICB0aGlzLmNsb3NlZCA9IGRhdGEuaGQgPT09IHRydWU7XHJcbiAgdGhpcy5wRWxlbSA9IGNyZWF0ZU5TKCdwYXRoJyk7XHJcbiAgdGhpcy5tc0VsZW0gPSBudWxsO1xyXG59XHJcblxyXG5TVkdTdHlsZURhdGEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuZCA9ICcnO1xyXG4gIHRoaXMuX21kZiA9IGZhbHNlO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gU1ZHU2hhcGVEYXRhKHRyYW5zZm9ybWVycywgbGV2ZWwsIHNoYXBlKSB7XHJcbiAgdGhpcy5jYWNoZXMgPSBbXTtcclxuICB0aGlzLnN0eWxlcyA9IFtdO1xyXG4gIHRoaXMudHJhbnNmb3JtZXJzID0gdHJhbnNmb3JtZXJzO1xyXG4gIHRoaXMubFN0ciA9ICcnO1xyXG4gIHRoaXMuc2ggPSBzaGFwZTtcclxuICB0aGlzLmx2bCA9IGxldmVsO1xyXG4gIC8vIFRPRE8gZmluZCBpZiB0aGVyZSBhcmUgc29tZSBjYXNlcyB3aGVyZSBfaXNBbmltYXRlZCBjYW4gYmUgZmFsc2UuXHJcbiAgLy8gRm9yIG5vdywgc2luY2Ugc2hhcGVzIGFkZCB1cCB3aXRoIG90aGVyIHNoYXBlcy4gVGhleSBoYXZlIHRvIGJlIGNhbGN1bGF0ZWQgZXZlcnkgdGltZS5cclxuICAvLyBPbmUgd2F5IG9mIGZpbmRpbmcgb3V0IGlzIGNoZWNraW5nIGlmIGFsbCBzdHlsZXMgYXNzb2NpYXRlZCB0byB0aGlzIHNoYXBlIGRlcGVuZCBvbmx5IG9mIHRoaXMgc2hhcGVcclxuICB0aGlzLl9pc0FuaW1hdGVkID0gISFzaGFwZS5rO1xyXG4gIC8vIFRPRE86IGNvbW1lbnRpbmcgdGhpcyBmb3Igbm93IHNpbmNlIGFsbCBzaGFwZXMgYXJlIGFuaW1hdGVkXHJcbiAgdmFyIGkgPSAwO1xyXG4gIHZhciBsZW4gPSB0cmFuc2Zvcm1lcnMubGVuZ3RoO1xyXG4gIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICBpZiAodHJhbnNmb3JtZXJzW2ldLm1Qcm9wcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5faXNBbmltYXRlZCA9IHRydWU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgaSArPSAxO1xyXG4gIH1cclxufVxyXG5cclxuU1ZHU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuX2lzQW5pbWF0ZWQgPSB0cnVlO1xyXG59O1xyXG5cclxuLyogZXhwb3J0ZWQgU1ZHVHJhbnNmb3JtRGF0YSAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHVHJhbnNmb3JtRGF0YShtUHJvcHMsIG9wLCBjb250YWluZXIpIHtcclxuICB0aGlzLnRyYW5zZm9ybSA9IHtcclxuICAgIG1Qcm9wczogbVByb3BzLFxyXG4gICAgb3A6IG9wLFxyXG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgfTtcclxuICB0aGlzLmVsZW1lbnRzID0gW107XHJcbiAgdGhpcy5faXNBbmltYXRlZCA9IHRoaXMudHJhbnNmb3JtLm1Qcm9wcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGggfHwgdGhpcy50cmFuc2Zvcm0ub3AuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcclxufVxyXG5cclxuLyogZ2xvYmFsIERhc2hQcm9wZXJ0eSwgUHJvcGVydHlGYWN0b3J5LCBleHRlbmRQcm90b3R5cGUsIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lciAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHU3Ryb2tlU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcclxuICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XHJcbiAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xyXG4gIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgMC4wMSwgdGhpcyk7XHJcbiAgdGhpcy53ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS53LCAwLCBudWxsLCB0aGlzKTtcclxuICB0aGlzLmQgPSBuZXcgRGFzaFByb3BlcnR5KGVsZW0sIGRhdGEuZCB8fCB7fSwgJ3N2ZycsIHRoaXMpO1xyXG4gIHRoaXMuYyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYywgMSwgMjU1LCB0aGlzKTtcclxuICB0aGlzLnN0eWxlID0gc3R5bGVPYjtcclxuICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLl9pc0FuaW1hdGVkO1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFNWR1N0cm9rZVN0eWxlRGF0YSk7XHJcblxyXG4vKiBnbG9iYWwgUHJvcGVydHlGYWN0b3J5LCBleHRlbmRQcm90b3R5cGUsIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lciAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHRmlsbFN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XHJcbiAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xyXG4gIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcclxuICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpO1xyXG4gIHRoaXMuYyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYywgMSwgMjU1LCB0aGlzKTtcclxuICB0aGlzLnN0eWxlID0gc3R5bGVPYjtcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTVkdGaWxsU3R5bGVEYXRhKTtcclxuXHJcbi8qIGdsb2JhbCBQcm9wZXJ0eUZhY3RvcnksIGRlZ1RvUmFkcywgR3JhZGllbnRQcm9wZXJ0eSwgY3JlYXRlRWxlbWVudElELCBjcmVhdGVOUywgbG9jYXRpb25IcmVmLFxyXG5leHRlbmRQcm90b3R5cGUsIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lciAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcclxuICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XHJcbiAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xyXG4gIHRoaXMuaW5pdEdyYWRpZW50RGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKTtcclxufVxyXG5cclxuU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhLnByb3RvdHlwZS5pbml0R3JhZGllbnREYXRhID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcclxuICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpO1xyXG4gIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMSwgbnVsbCwgdGhpcyk7XHJcbiAgdGhpcy5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5lLCAxLCBudWxsLCB0aGlzKTtcclxuICB0aGlzLmggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmggfHwgeyBrOiAwIH0sIDAsIDAuMDEsIHRoaXMpO1xyXG4gIHRoaXMuYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSB8fCB7IGs6IDAgfSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcclxuICB0aGlzLmcgPSBuZXcgR3JhZGllbnRQcm9wZXJ0eShlbGVtLCBkYXRhLmcsIHRoaXMpO1xyXG4gIHRoaXMuc3R5bGUgPSBzdHlsZU9iO1xyXG4gIHRoaXMuc3RvcHMgPSBbXTtcclxuICB0aGlzLnNldEdyYWRpZW50RGF0YShzdHlsZU9iLnBFbGVtLCBkYXRhKTtcclxuICB0aGlzLnNldEdyYWRpZW50T3BhY2l0eShkYXRhLCBzdHlsZU9iKTtcclxuICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLl9pc0FuaW1hdGVkO1xyXG59O1xyXG5cclxuU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhLnByb3RvdHlwZS5zZXRHcmFkaWVudERhdGEgPSBmdW5jdGlvbiAocGF0aEVsZW1lbnQsIGRhdGEpIHtcclxuICB2YXIgZ3JhZGllbnRJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xyXG4gIHZhciBnZmlsbCA9IGNyZWF0ZU5TKGRhdGEudCA9PT0gMSA/ICdsaW5lYXJHcmFkaWVudCcgOiAncmFkaWFsR3JhZGllbnQnKTtcclxuICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2lkJywgZ3JhZGllbnRJZCk7XHJcbiAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdzcHJlYWRNZXRob2QnLCAncGFkJyk7XHJcbiAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XHJcbiAgdmFyIHN0b3BzID0gW107XHJcbiAgdmFyIHN0b3A7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW47XHJcbiAgakxlbiA9IGRhdGEuZy5wICogNDtcclxuICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSA0KSB7XHJcbiAgICBzdG9wID0gY3JlYXRlTlMoJ3N0b3AnKTtcclxuICAgIGdmaWxsLmFwcGVuZENoaWxkKHN0b3ApO1xyXG4gICAgc3RvcHMucHVzaChzdG9wKTtcclxuICB9XHJcbiAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGEudHkgPT09ICdnZicgPyAnZmlsbCcgOiAnc3Ryb2tlJywgJ3VybCgnICsgbG9jYXRpb25IcmVmICsgJyMnICsgZ3JhZGllbnRJZCArICcpJyk7XHJcblxyXG4gIHRoaXMuZ2YgPSBnZmlsbDtcclxuICB0aGlzLmNzdCA9IHN0b3BzO1xyXG59O1xyXG5cclxuU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhLnByb3RvdHlwZS5zZXRHcmFkaWVudE9wYWNpdHkgPSBmdW5jdGlvbiAoZGF0YSwgc3R5bGVPYikge1xyXG4gIGlmICh0aGlzLmcuX2hhc09wYWNpdHkgJiYgIXRoaXMuZy5fY29sbGFwc2FibGUpIHtcclxuICAgIHZhciBzdG9wO1xyXG4gICAgdmFyIGo7XHJcbiAgICB2YXIgakxlbjtcclxuICAgIHZhciBtYXNrID0gY3JlYXRlTlMoJ21hc2snKTtcclxuICAgIHZhciBtYXNrRWxlbWVudCA9IGNyZWF0ZU5TKCdwYXRoJyk7XHJcbiAgICBtYXNrLmFwcGVuZENoaWxkKG1hc2tFbGVtZW50KTtcclxuICAgIHZhciBvcGFjaXR5SWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuICAgIHZhciBtYXNrSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuICAgIG1hc2suc2V0QXR0cmlidXRlKCdpZCcsIG1hc2tJZCk7XHJcbiAgICB2YXIgb3BGaWxsID0gY3JlYXRlTlMoZGF0YS50ID09PSAxID8gJ2xpbmVhckdyYWRpZW50JyA6ICdyYWRpYWxHcmFkaWVudCcpO1xyXG4gICAgb3BGaWxsLnNldEF0dHJpYnV0ZSgnaWQnLCBvcGFjaXR5SWQpO1xyXG4gICAgb3BGaWxsLnNldEF0dHJpYnV0ZSgnc3ByZWFkTWV0aG9kJywgJ3BhZCcpO1xyXG4gICAgb3BGaWxsLnNldEF0dHJpYnV0ZSgnZ3JhZGllbnRVbml0cycsICd1c2VyU3BhY2VPblVzZScpO1xyXG4gICAgakxlbiA9IGRhdGEuZy5rLmtbMF0ucyA/IGRhdGEuZy5rLmtbMF0ucy5sZW5ndGggOiBkYXRhLmcuay5rLmxlbmd0aDtcclxuICAgIHZhciBzdG9wcyA9IHRoaXMuc3RvcHM7XHJcbiAgICBmb3IgKGogPSBkYXRhLmcucCAqIDQ7IGogPCBqTGVuOyBqICs9IDIpIHtcclxuICAgICAgc3RvcCA9IGNyZWF0ZU5TKCdzdG9wJyk7XHJcbiAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJywgJ3JnYigyNTUsMjU1LDI1NSknKTtcclxuICAgICAgb3BGaWxsLmFwcGVuZENoaWxkKHN0b3ApO1xyXG4gICAgICBzdG9wcy5wdXNoKHN0b3ApO1xyXG4gICAgfVxyXG4gICAgbWFza0VsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGEudHkgPT09ICdnZicgPyAnZmlsbCcgOiAnc3Ryb2tlJywgJ3VybCgnICsgbG9jYXRpb25IcmVmICsgJyMnICsgb3BhY2l0eUlkICsgJyknKTtcclxuICAgIHRoaXMub2YgPSBvcEZpbGw7XHJcbiAgICB0aGlzLm1zID0gbWFzaztcclxuICAgIHRoaXMub3N0ID0gc3RvcHM7XHJcbiAgICB0aGlzLm1hc2tJZCA9IG1hc2tJZDtcclxuICAgIHN0eWxlT2IubXNFbGVtID0gbWFza0VsZW1lbnQ7XHJcbiAgfVxyXG59O1xyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEpO1xyXG5cclxuLyogZ2xvYmFsIFByb3BlcnR5RmFjdG9yeSwgRGFzaFByb3BlcnR5LCBleHRlbmRQcm90b3R5cGUsIFNWR0dyYWRpZW50RmlsbFN0eWxlRGF0YSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyICovXHJcblxyXG5mdW5jdGlvbiBTVkdHcmFkaWVudFN0cm9rZVN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XHJcbiAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xyXG4gIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcclxuICB0aGlzLncgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLncsIDAsIG51bGwsIHRoaXMpO1xyXG4gIHRoaXMuZCA9IG5ldyBEYXNoUHJvcGVydHkoZWxlbSwgZGF0YS5kIHx8IHt9LCAnc3ZnJywgdGhpcyk7XHJcbiAgdGhpcy5pbml0R3JhZGllbnREYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpO1xyXG4gIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMuX2lzQW5pbWF0ZWQ7XHJcbn1cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhLCBEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTVkdHcmFkaWVudFN0cm9rZVN0eWxlRGF0YSk7XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlTlMgKi9cclxuLyogZXhwb3J0ZWQgU2hhcGVHcm91cERhdGEgKi9cclxuXHJcbmZ1bmN0aW9uIFNoYXBlR3JvdXBEYXRhKCkge1xyXG4gIHRoaXMuaXQgPSBbXTtcclxuICB0aGlzLnByZXZWaWV3RGF0YSA9IFtdO1xyXG4gIHRoaXMuZ3IgPSBjcmVhdGVOUygnZycpO1xyXG59XHJcblxyXG4vKiBnbG9iYWwgTWF0cml4LCBidWlsZFNoYXBlU3RyaW5nLCBibUZsb29yICovXHJcbi8qIGV4cG9ydGVkIFNWR0VsZW1lbnRzUmVuZGVyZXIgKi9cclxuXHJcbnZhciBTVkdFbGVtZW50c1JlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgX2lkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG4gIHZhciBfbWF0cml4SGVscGVyID0gbmV3IE1hdHJpeCgpO1xyXG5cclxuICB2YXIgb2IgPSB7XHJcbiAgICBjcmVhdGVSZW5kZXJGdW5jdGlvbjogY3JlYXRlUmVuZGVyRnVuY3Rpb24sXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyRnVuY3Rpb24oZGF0YSkge1xyXG4gICAgc3dpdGNoIChkYXRhLnR5KSB7XHJcbiAgICAgIGNhc2UgJ2ZsJzpcclxuICAgICAgICByZXR1cm4gcmVuZGVyRmlsbDtcclxuICAgICAgY2FzZSAnZ2YnOlxyXG4gICAgICAgIHJldHVybiByZW5kZXJHcmFkaWVudDtcclxuICAgICAgY2FzZSAnZ3MnOlxyXG4gICAgICAgIHJldHVybiByZW5kZXJHcmFkaWVudFN0cm9rZTtcclxuICAgICAgY2FzZSAnc3QnOlxyXG4gICAgICAgIHJldHVybiByZW5kZXJTdHJva2U7XHJcbiAgICAgIGNhc2UgJ3NoJzpcclxuICAgICAgY2FzZSAnZWwnOlxyXG4gICAgICBjYXNlICdyYyc6XHJcbiAgICAgIGNhc2UgJ3NyJzpcclxuICAgICAgICByZXR1cm4gcmVuZGVyUGF0aDtcclxuICAgICAgY2FzZSAndHInOlxyXG4gICAgICAgIHJldHVybiByZW5kZXJDb250ZW50VHJhbnNmb3JtO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVuZGVyQ29udGVudFRyYW5zZm9ybShzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcclxuICAgIGlmIChpc0ZpcnN0RnJhbWUgfHwgaXRlbURhdGEudHJhbnNmb3JtLm9wLl9tZGYpIHtcclxuICAgICAgaXRlbURhdGEudHJhbnNmb3JtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCBpdGVtRGF0YS50cmFuc2Zvcm0ub3Audik7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNGaXJzdEZyYW1lIHx8IGl0ZW1EYXRhLnRyYW5zZm9ybS5tUHJvcHMuX21kZikge1xyXG4gICAgICBpdGVtRGF0YS50cmFuc2Zvcm0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgaXRlbURhdGEudHJhbnNmb3JtLm1Qcm9wcy52LnRvMmRDU1MoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW5kZXJQYXRoKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSkge1xyXG4gICAgdmFyIGo7XHJcbiAgICB2YXIgakxlbjtcclxuICAgIHZhciBwYXRoU3RyaW5nVHJhbnNmb3JtZWQ7XHJcbiAgICB2YXIgcmVkcmF3O1xyXG4gICAgdmFyIHBhdGhOb2RlcztcclxuICAgIHZhciBsO1xyXG4gICAgdmFyIGxMZW4gPSBpdGVtRGF0YS5zdHlsZXMubGVuZ3RoO1xyXG4gICAgdmFyIGx2bCA9IGl0ZW1EYXRhLmx2bDtcclxuICAgIHZhciBwYXRocztcclxuICAgIHZhciBtYXQ7XHJcbiAgICB2YXIgcHJvcHM7XHJcbiAgICB2YXIgaXRlcmF0aW9ucztcclxuICAgIHZhciBrO1xyXG4gICAgZm9yIChsID0gMDsgbCA8IGxMZW47IGwgKz0gMSkge1xyXG4gICAgICByZWRyYXcgPSBpdGVtRGF0YS5zaC5fbWRmIHx8IGlzRmlyc3RGcmFtZTtcclxuICAgICAgaWYgKGl0ZW1EYXRhLnN0eWxlc1tsXS5sdmwgPCBsdmwpIHtcclxuICAgICAgICBtYXQgPSBfbWF0cml4SGVscGVyLnJlc2V0KCk7XHJcbiAgICAgICAgaXRlcmF0aW9ucyA9IGx2bCAtIGl0ZW1EYXRhLnN0eWxlc1tsXS5sdmw7XHJcbiAgICAgICAgayA9IGl0ZW1EYXRhLnRyYW5zZm9ybWVycy5sZW5ndGggLSAxO1xyXG4gICAgICAgIHdoaWxlICghcmVkcmF3ICYmIGl0ZXJhdGlvbnMgPiAwKSB7XHJcbiAgICAgICAgICByZWRyYXcgPSBpdGVtRGF0YS50cmFuc2Zvcm1lcnNba10ubVByb3BzLl9tZGYgfHwgcmVkcmF3O1xyXG4gICAgICAgICAgaXRlcmF0aW9ucyAtPSAxO1xyXG4gICAgICAgICAgayAtPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVkcmF3KSB7XHJcbiAgICAgICAgICBpdGVyYXRpb25zID0gbHZsIC0gaXRlbURhdGEuc3R5bGVzW2xdLmx2bDtcclxuICAgICAgICAgIGsgPSBpdGVtRGF0YS50cmFuc2Zvcm1lcnMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgIHdoaWxlIChpdGVyYXRpb25zID4gMCkge1xyXG4gICAgICAgICAgICBwcm9wcyA9IGl0ZW1EYXRhLnRyYW5zZm9ybWVyc1trXS5tUHJvcHMudi5wcm9wcztcclxuICAgICAgICAgICAgbWF0LnRyYW5zZm9ybShwcm9wc1swXSwgcHJvcHNbMV0sIHByb3BzWzJdLCBwcm9wc1szXSwgcHJvcHNbNF0sIHByb3BzWzVdLCBwcm9wc1s2XSwgcHJvcHNbN10sIHByb3BzWzhdLCBwcm9wc1s5XSwgcHJvcHNbMTBdLCBwcm9wc1sxMV0sIHByb3BzWzEyXSwgcHJvcHNbMTNdLCBwcm9wc1sxNF0sIHByb3BzWzE1XSk7XHJcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMgLT0gMTtcclxuICAgICAgICAgICAgayAtPSAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtYXQgPSBfaWRlbnRpdHlNYXRyaXg7XHJcbiAgICAgIH1cclxuICAgICAgcGF0aHMgPSBpdGVtRGF0YS5zaC5wYXRocztcclxuICAgICAgakxlbiA9IHBhdGhzLl9sZW5ndGg7XHJcbiAgICAgIGlmIChyZWRyYXcpIHtcclxuICAgICAgICBwYXRoU3RyaW5nVHJhbnNmb3JtZWQgPSAnJztcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICBwYXRoTm9kZXMgPSBwYXRocy5zaGFwZXNbal07XHJcbiAgICAgICAgICBpZiAocGF0aE5vZGVzICYmIHBhdGhOb2Rlcy5fbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHBhdGhTdHJpbmdUcmFuc2Zvcm1lZCArPSBidWlsZFNoYXBlU3RyaW5nKHBhdGhOb2RlcywgcGF0aE5vZGVzLl9sZW5ndGgsIHBhdGhOb2Rlcy5jLCBtYXQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpdGVtRGF0YS5jYWNoZXNbbF0gPSBwYXRoU3RyaW5nVHJhbnNmb3JtZWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGF0aFN0cmluZ1RyYW5zZm9ybWVkID0gaXRlbURhdGEuY2FjaGVzW2xdO1xyXG4gICAgICB9XHJcbiAgICAgIGl0ZW1EYXRhLnN0eWxlc1tsXS5kICs9IHN0eWxlRGF0YS5oZCA9PT0gdHJ1ZSA/ICcnIDogcGF0aFN0cmluZ1RyYW5zZm9ybWVkO1xyXG4gICAgICBpdGVtRGF0YS5zdHlsZXNbbF0uX21kZiA9IHJlZHJhdyB8fCBpdGVtRGF0YS5zdHlsZXNbbF0uX21kZjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbmRlckZpbGwoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XHJcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XHJcblxyXG4gICAgaWYgKGl0ZW1EYXRhLmMuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdyZ2IoJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlbURhdGEuby5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xyXG4gICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBpdGVtRGF0YS5vLnYpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVuZGVyR3JhZGllbnRTdHJva2Uoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XHJcbiAgICByZW5kZXJHcmFkaWVudChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpO1xyXG4gICAgcmVuZGVyU3Ryb2tlKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW5kZXJHcmFkaWVudChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcclxuICAgIHZhciBnZmlsbCA9IGl0ZW1EYXRhLmdmO1xyXG4gICAgdmFyIGhhc09wYWNpdHkgPSBpdGVtRGF0YS5nLl9oYXNPcGFjaXR5O1xyXG4gICAgdmFyIHB0MSA9IGl0ZW1EYXRhLnMudjtcclxuICAgIHZhciBwdDIgPSBpdGVtRGF0YS5lLnY7XHJcblxyXG4gICAgaWYgKGl0ZW1EYXRhLm8uX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgdmFyIGF0dHIgPSBzdHlsZURhdGEudHkgPT09ICdnZicgPyAnZmlsbC1vcGFjaXR5JyA6ICdzdHJva2Utb3BhY2l0eSc7XHJcbiAgICAgIGl0ZW1EYXRhLnN0eWxlLnBFbGVtLnNldEF0dHJpYnV0ZShhdHRyLCBpdGVtRGF0YS5vLnYpO1xyXG4gICAgfVxyXG4gICAgaWYgKGl0ZW1EYXRhLnMuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgdmFyIGF0dHIxID0gc3R5bGVEYXRhLnQgPT09IDEgPyAneDEnIDogJ2N4JztcclxuICAgICAgdmFyIGF0dHIyID0gYXR0cjEgPT09ICd4MScgPyAneTEnIDogJ2N5JztcclxuICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKGF0dHIxLCBwdDFbMF0pO1xyXG4gICAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoYXR0cjIsIHB0MVsxXSk7XHJcbiAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xyXG4gICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZShhdHRyMSwgcHQxWzBdKTtcclxuICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoYXR0cjIsIHB0MVsxXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBzdG9wcztcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbjtcclxuICAgIHZhciBzdG9wO1xyXG4gICAgaWYgKGl0ZW1EYXRhLmcuX2NtZGYgfHwgaXNGaXJzdEZyYW1lKSB7XHJcbiAgICAgIHN0b3BzID0gaXRlbURhdGEuY3N0O1xyXG4gICAgICB2YXIgY1ZhbHVlcyA9IGl0ZW1EYXRhLmcuYztcclxuICAgICAgbGVuID0gc3RvcHMubGVuZ3RoO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBzdG9wID0gc3RvcHNbaV07XHJcbiAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsIGNWYWx1ZXNbaSAqIDRdICsgJyUnKTtcclxuICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicsICdyZ2IoJyArIGNWYWx1ZXNbaSAqIDQgKyAxXSArICcsJyArIGNWYWx1ZXNbaSAqIDQgKyAyXSArICcsJyArIGNWYWx1ZXNbaSAqIDQgKyAzXSArICcpJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChoYXNPcGFjaXR5ICYmIChpdGVtRGF0YS5nLl9vbWRmIHx8IGlzRmlyc3RGcmFtZSkpIHtcclxuICAgICAgdmFyIG9WYWx1ZXMgPSBpdGVtRGF0YS5nLm87XHJcbiAgICAgIGlmIChpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xyXG4gICAgICAgIHN0b3BzID0gaXRlbURhdGEuY3N0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0b3BzID0gaXRlbURhdGEub3N0O1xyXG4gICAgICB9XHJcbiAgICAgIGxlbiA9IHN0b3BzLmxlbmd0aDtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgc3RvcCA9IHN0b3BzW2ldO1xyXG4gICAgICAgIGlmICghaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcclxuICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdvZmZzZXQnLCBvVmFsdWVzW2kgKiAyXSArICclJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknLCBvVmFsdWVzW2kgKiAyICsgMV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc3R5bGVEYXRhLnQgPT09IDEpIHtcclxuICAgICAgaWYgKGl0ZW1EYXRhLmUuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ3gyJywgcHQyWzBdKTtcclxuICAgICAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ3kyJywgcHQyWzFdKTtcclxuICAgICAgICBpZiAoaGFzT3BhY2l0eSAmJiAhaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcclxuICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgneDInLCBwdDJbMF0pO1xyXG4gICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCd5MicsIHB0MlsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgcmFkO1xyXG4gICAgICBpZiAoaXRlbURhdGEucy5fbWRmIHx8IGl0ZW1EYXRhLmUuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgICByYWQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocHQxWzBdIC0gcHQyWzBdLCAyKSArIE1hdGgucG93KHB0MVsxXSAtIHB0MlsxXSwgMikpO1xyXG4gICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgncicsIHJhZCk7XHJcbiAgICAgICAgaWYgKGhhc09wYWNpdHkgJiYgIWl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XHJcbiAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoJ3InLCByYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoaXRlbURhdGEuZS5fbWRmIHx8IGl0ZW1EYXRhLmguX21kZiB8fCBpdGVtRGF0YS5hLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XHJcbiAgICAgICAgaWYgKCFyYWQpIHtcclxuICAgICAgICAgIHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhwdDFbMF0gLSBwdDJbMF0sIDIpICsgTWF0aC5wb3cocHQxWzFdIC0gcHQyWzFdLCAyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhbmcgPSBNYXRoLmF0YW4yKHB0MlsxXSAtIHB0MVsxXSwgcHQyWzBdIC0gcHQxWzBdKTtcclxuXHJcbiAgICAgICAgdmFyIHBlcmNlbnQgPSBpdGVtRGF0YS5oLnY7XHJcbiAgICAgICAgaWYgKHBlcmNlbnQgPj0gMSkge1xyXG4gICAgICAgICAgcGVyY2VudCA9IDAuOTk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50IDw9IC0xKSB7XHJcbiAgICAgICAgICBwZXJjZW50ID0gLTAuOTk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkaXN0ID0gcmFkICogcGVyY2VudDtcclxuICAgICAgICB2YXIgeCA9IE1hdGguY29zKGFuZyArIGl0ZW1EYXRhLmEudikgKiBkaXN0ICsgcHQxWzBdO1xyXG4gICAgICAgIHZhciB5ID0gTWF0aC5zaW4oYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMV07XHJcbiAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdmeCcsIHgpO1xyXG4gICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgnZnknLCB5KTtcclxuICAgICAgICBpZiAoaGFzT3BhY2l0eSAmJiAhaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcclxuICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgnZngnLCB4KTtcclxuICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgnZnknLCB5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gZ2ZpbGwuc2V0QXR0cmlidXRlKCdmeScsJzIwMCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVuZGVyU3Ryb2tlKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSkge1xyXG4gICAgdmFyIHN0eWxlRWxlbSA9IGl0ZW1EYXRhLnN0eWxlO1xyXG4gICAgdmFyIGQgPSBpdGVtRGF0YS5kO1xyXG4gICAgaWYgKGQgJiYgKGQuX21kZiB8fCBpc0ZpcnN0RnJhbWUpICYmIGQuZGFzaFN0cikge1xyXG4gICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5JywgZC5kYXNoU3RyKTtcclxuICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBkLmRhc2hvZmZzZXRbMF0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGl0ZW1EYXRhLmMgJiYgKGl0ZW1EYXRhLmMuX21kZiB8fCBpc0ZpcnN0RnJhbWUpKSB7XHJcbiAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdyZ2IoJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlbURhdGEuby5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xyXG4gICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIGl0ZW1EYXRhLm8udik7XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlbURhdGEudy5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xyXG4gICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBpdGVtRGF0YS53LnYpO1xyXG4gICAgICBpZiAoc3R5bGVFbGVtLm1zRWxlbSkge1xyXG4gICAgICAgIHN0eWxlRWxlbS5tc0VsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBpdGVtRGF0YS53LnYpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2I7XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgTWF0cml4ICovXHJcblxyXG5mdW5jdGlvbiBTaGFwZVRyYW5zZm9ybU1hbmFnZXIoKSB7XHJcbiAgdGhpcy5zZXF1ZW5jZXMgPSB7fTtcclxuICB0aGlzLnNlcXVlbmNlTGlzdCA9IFtdO1xyXG4gIHRoaXMudHJhbnNmb3JtX2tleV9jb3VudCA9IDA7XHJcbn1cclxuXHJcblNoYXBlVHJhbnNmb3JtTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcbiAgYWRkVHJhbnNmb3JtU2VxdWVuY2U6IGZ1bmN0aW9uICh0cmFuc2Zvcm1zKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aDtcclxuICAgIHZhciBrZXkgPSAnXyc7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAga2V5ICs9IHRyYW5zZm9ybXNbaV0udHJhbnNmb3JtLmtleSArICdfJztcclxuICAgIH1cclxuICAgIHZhciBzZXF1ZW5jZSA9IHRoaXMuc2VxdWVuY2VzW2tleV07XHJcbiAgICBpZiAoIXNlcXVlbmNlKSB7XHJcbiAgICAgIHNlcXVlbmNlID0ge1xyXG4gICAgICAgIHRyYW5zZm9ybXM6IFtdLmNvbmNhdCh0cmFuc2Zvcm1zKSxcclxuICAgICAgICBmaW5hbFRyYW5zZm9ybTogbmV3IE1hdHJpeCgpLFxyXG4gICAgICAgIF9tZGY6IGZhbHNlLFxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnNlcXVlbmNlc1trZXldID0gc2VxdWVuY2U7XHJcbiAgICAgIHRoaXMuc2VxdWVuY2VMaXN0LnB1c2goc2VxdWVuY2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlcXVlbmNlO1xyXG4gIH0sXHJcbiAgcHJvY2Vzc1NlcXVlbmNlOiBmdW5jdGlvbiAoc2VxdWVuY2UsIGlzRmlyc3RGcmFtZSkge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIGxlbiA9IHNlcXVlbmNlLnRyYW5zZm9ybXMubGVuZ3RoO1xyXG4gICAgdmFyIF9tZGYgPSBpc0ZpcnN0RnJhbWU7XHJcbiAgICB3aGlsZSAoaSA8IGxlbiAmJiAhaXNGaXJzdEZyYW1lKSB7XHJcbiAgICAgIGlmIChzZXF1ZW5jZS50cmFuc2Zvcm1zW2ldLnRyYW5zZm9ybS5tUHJvcHMuX21kZikge1xyXG4gICAgICAgIF9tZGYgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICAgIGlmIChfbWRmKSB7XHJcbiAgICAgIHZhciBwcm9wcztcclxuICAgICAgc2VxdWVuY2UuZmluYWxUcmFuc2Zvcm0ucmVzZXQoKTtcclxuICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICBwcm9wcyA9IHNlcXVlbmNlLnRyYW5zZm9ybXNbaV0udHJhbnNmb3JtLm1Qcm9wcy52LnByb3BzO1xyXG4gICAgICAgIHNlcXVlbmNlLmZpbmFsVHJhbnNmb3JtLnRyYW5zZm9ybShwcm9wc1swXSwgcHJvcHNbMV0sIHByb3BzWzJdLCBwcm9wc1szXSwgcHJvcHNbNF0sIHByb3BzWzVdLCBwcm9wc1s2XSwgcHJvcHNbN10sIHByb3BzWzhdLCBwcm9wc1s5XSwgcHJvcHNbMTBdLCBwcm9wc1sxMV0sIHByb3BzWzEyXSwgcHJvcHNbMTNdLCBwcm9wc1sxNF0sIHByb3BzWzE1XSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHNlcXVlbmNlLl9tZGYgPSBfbWRmO1xyXG4gIH0sXHJcbiAgcHJvY2Vzc1NlcXVlbmNlczogZnVuY3Rpb24gKGlzRmlyc3RGcmFtZSkge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5zZXF1ZW5jZUxpc3QubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHRoaXMucHJvY2Vzc1NlcXVlbmNlKHRoaXMuc2VxdWVuY2VMaXN0W2ldLCBpc0ZpcnN0RnJhbWUpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgZ2V0TmV3S2V5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnRyYW5zZm9ybV9rZXlfY291bnQgKz0gMTtcclxuICAgIHJldHVybiAnXycgKyB0aGlzLnRyYW5zZm9ybV9rZXlfY291bnQ7XHJcbiAgfSxcclxufTtcclxuXHJcbi8qIGdsb2JhbCBTaGFwZVByb3BlcnR5RmFjdG9yeSwgU1ZHU2hhcGVEYXRhICovXHJcblxyXG5mdW5jdGlvbiBDVlNoYXBlRGF0YShlbGVtZW50LCBkYXRhLCBzdHlsZXMsIHRyYW5zZm9ybXNNYW5hZ2VyKSB7XHJcbiAgdGhpcy5zdHlsZWRTaGFwZXMgPSBbXTtcclxuICB0aGlzLnRyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xyXG4gIHZhciB0eSA9IDQ7XHJcbiAgaWYgKGRhdGEudHkgPT09ICdyYycpIHtcclxuICAgIHR5ID0gNTtcclxuICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdlbCcpIHtcclxuICAgIHR5ID0gNjtcclxuICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdzcicpIHtcclxuICAgIHR5ID0gNztcclxuICB9XHJcbiAgdGhpcy5zaCA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcChlbGVtZW50LCBkYXRhLCB0eSwgZWxlbWVudCk7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHN0eWxlcy5sZW5ndGg7XHJcbiAgdmFyIHN0eWxlZFNoYXBlO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgaWYgKCFzdHlsZXNbaV0uY2xvc2VkKSB7XHJcbiAgICAgIHN0eWxlZFNoYXBlID0ge1xyXG4gICAgICAgIHRyYW5zZm9ybXM6IHRyYW5zZm9ybXNNYW5hZ2VyLmFkZFRyYW5zZm9ybVNlcXVlbmNlKHN0eWxlc1tpXS50cmFuc2Zvcm1zKSxcclxuICAgICAgICB0ck5vZGVzOiBbXSxcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5zdHlsZWRTaGFwZXMucHVzaChzdHlsZWRTaGFwZSk7XHJcbiAgICAgIHN0eWxlc1tpXS5lbGVtZW50cy5wdXNoKHN0eWxlZFNoYXBlKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbkNWU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkID0gU1ZHU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkO1xyXG5cclxuLyogZ2xvYmFsIExheWVyRXhwcmVzc2lvbkludGVyZmFjZSwgRWZmZWN0c0V4cHJlc3Npb25JbnRlcmZhY2UsIENvbXBFeHByZXNzaW9uSW50ZXJmYWNlLCBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UsXHJcblRleHRFeHByZXNzaW9uSW50ZXJmYWNlLCBnZXRCbGVuZE1vZGUsY3JlYXRlRWxlbWVudElELCBFZmZlY3RzTWFuYWdlciAqL1xyXG5cclxuZnVuY3Rpb24gQmFzZUVsZW1lbnQoKSB7XHJcbn1cclxuXHJcbkJhc2VFbGVtZW50LnByb3RvdHlwZSA9IHtcclxuICBjaGVja01hc2tzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIXRoaXMuZGF0YS5oYXNNYXNrKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBsZW4gPSB0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgIGlmICgodGhpcy5kYXRhLm1hc2tzUHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicgJiYgdGhpcy5kYXRhLm1hc2tzUHJvcGVydGllc1tpXS5jbCAhPT0gZmFsc2UpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcbiAgaW5pdEV4cHJlc3Npb25zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmxheWVySW50ZXJmYWNlID0gTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlKHRoaXMpO1xyXG4gICAgaWYgKHRoaXMuZGF0YS5oYXNNYXNrICYmIHRoaXMubWFza01hbmFnZXIpIHtcclxuICAgICAgdGhpcy5sYXllckludGVyZmFjZS5yZWdpc3Rlck1hc2tJbnRlcmZhY2UodGhpcy5tYXNrTWFuYWdlcik7XHJcbiAgICB9XHJcbiAgICB2YXIgZWZmZWN0c0ludGVyZmFjZSA9IEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlLmNyZWF0ZUVmZmVjdHNJbnRlcmZhY2UodGhpcywgdGhpcy5sYXllckludGVyZmFjZSk7XHJcbiAgICB0aGlzLmxheWVySW50ZXJmYWNlLnJlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZShlZmZlY3RzSW50ZXJmYWNlKTtcclxuXHJcbiAgICBpZiAodGhpcy5kYXRhLnR5ID09PSAwIHx8IHRoaXMuZGF0YS54dCkge1xyXG4gICAgICB0aGlzLmNvbXBJbnRlcmZhY2UgPSBDb21wRXhwcmVzc2lvbkludGVyZmFjZSh0aGlzKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLnR5ID09PSA0KSB7XHJcbiAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2Uuc2hhcGVJbnRlcmZhY2UgPSBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UodGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5sYXllckludGVyZmFjZSk7XHJcbiAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UuY29udGVudCA9IHRoaXMubGF5ZXJJbnRlcmZhY2Uuc2hhcGVJbnRlcmZhY2U7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS50eSA9PT0gNSkge1xyXG4gICAgICB0aGlzLmxheWVySW50ZXJmYWNlLnRleHRJbnRlcmZhY2UgPSBUZXh0RXhwcmVzc2lvbkludGVyZmFjZSh0aGlzKTtcclxuICAgICAgdGhpcy5sYXllckludGVyZmFjZS50ZXh0ID0gdGhpcy5sYXllckludGVyZmFjZS50ZXh0SW50ZXJmYWNlO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgc2V0QmxlbmRNb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYmxlbmRNb2RlVmFsdWUgPSBnZXRCbGVuZE1vZGUodGhpcy5kYXRhLmJtKTtcclxuICAgIHZhciBlbGVtID0gdGhpcy5iYXNlRWxlbWVudCB8fCB0aGlzLmxheWVyRWxlbWVudDtcclxuXHJcbiAgICBlbGVtLnN0eWxlWydtaXgtYmxlbmQtbW9kZSddID0gYmxlbmRNb2RlVmFsdWU7XHJcbiAgfSxcclxuICBpbml0QmFzZURhdGE6IGZ1bmN0aW9uIChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgICB0aGlzLmdsb2JhbERhdGEgPSBnbG9iYWxEYXRhO1xyXG4gICAgdGhpcy5jb21wID0gY29tcDtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLmxheWVySWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuXHJcbiAgICAvLyBTdHJldGNoIGZhY3RvciBmb3Igb2xkIGFuaW1hdGlvbnMgbWlzc2luZyB0aGlzIHByb3BlcnR5LlxyXG4gICAgaWYgKCF0aGlzLmRhdGEuc3IpIHtcclxuICAgICAgdGhpcy5kYXRhLnNyID0gMTtcclxuICAgIH1cclxuICAgIC8vIGVmZmVjdHMgbWFuYWdlclxyXG4gICAgdGhpcy5lZmZlY3RzTWFuYWdlciA9IG5ldyBFZmZlY3RzTWFuYWdlcih0aGlzLmRhdGEsIHRoaXMsIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xyXG4gIH0sXHJcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHlwZTtcclxuICB9LFxyXG4gIHNvdXJjZVJlY3RBdFRpbWU6IGZ1bmN0aW9uICgpIHt9LFxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCAqL1xyXG5cclxuZnVuY3Rpb24gTnVsbEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMuaW5pdEZyYW1lKCk7XHJcbiAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgdGhpcy5pbml0RnJhbWUoKTtcclxuICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgdGhpcy5pbml0SGllcmFyY2h5KCk7XHJcbn1cclxuXHJcbk51bGxFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgdGhpcy5wcmVwYXJlUHJvcGVydGllcyhudW0sIHRydWUpO1xyXG59O1xyXG5cclxuTnVsbEVsZW1lbnQucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuTnVsbEVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuTnVsbEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblxyXG5OdWxsRWxlbWVudC5wcm90b3R5cGUuc291cmNlUmVjdEF0VGltZSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbk51bGxFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50XSwgTnVsbEVsZW1lbnQpO1xyXG5cclxuLyogZ2xvYmFsIGZpbHRlcnNGYWN0b3J5LCBmZWF0dXJlU3VwcG9ydCwgZmlsdGVyc0ZhY3RvcnksIGNyZWF0ZUVsZW1lbnRJRCwgY3JlYXRlTlMsIE1hc2tFbGVtZW50LCBTVkdFZmZlY3RzLCBsb2NhdGlvbkhyZWYgKi9cclxuXHJcbmZ1bmN0aW9uIFNWR0Jhc2VFbGVtZW50KCkge1xyXG59XHJcblxyXG5TVkdCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XHJcbiAgaW5pdFJlbmRlcmVyRWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQgPSBjcmVhdGVOUygnZycpO1xyXG4gIH0sXHJcbiAgY3JlYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMubWF0dGVFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcclxuICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XHJcbiAgICB0aGlzLm1hc2tlZEVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcclxuICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICB2YXIgbGF5ZXJFbGVtZW50UGFyZW50ID0gbnVsbDtcclxuICAgIC8vIElmIHRoaXMgbGF5ZXIgYWN0cyBhcyBhIG1hc2sgZm9yIHRoZSBmb2xsb3dpbmcgbGF5ZXJcclxuICAgIHZhciBmaWxJZDtcclxuICAgIHZhciBmaWw7XHJcbiAgICB2YXIgZ2c7XHJcbiAgICBpZiAodGhpcy5kYXRhLnRkKSB7XHJcbiAgICAgIGlmICh0aGlzLmRhdGEudGQgPT0gMyB8fCB0aGlzLmRhdGEudGQgPT0gMSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxyXG4gICAgICAgIHZhciBtYXNrZXIgPSBjcmVhdGVOUygnbWFzaycpO1xyXG4gICAgICAgIG1hc2tlci5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5sYXllcklkKTtcclxuICAgICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCB0aGlzLmRhdGEudGQgPT0gMyA/ICdsdW1pbmFuY2UnIDogJ2FscGhhJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcbiAgICAgICAgbWFza2VyLmFwcGVuZENoaWxkKHRoaXMubGF5ZXJFbGVtZW50KTtcclxuICAgICAgICBsYXllckVsZW1lbnRQYXJlbnQgPSBtYXNrZXI7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQobWFza2VyKTtcclxuICAgICAgICAvLyBUaGlzIGlzIG9ubHkgZm9yIElFIGFuZCBFZGdlIHdoZW4gbWFzayBpZiBvZiB0eXBlIGFscGhhXHJcbiAgICAgICAgaWYgKCFmZWF0dXJlU3VwcG9ydC5tYXNrVHlwZSAmJiB0aGlzLmRhdGEudGQgPT0gMSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxyXG4gICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2x1bWluYW5jZScpO1xyXG4gICAgICAgICAgZmlsSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuICAgICAgICAgIGZpbCA9IGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUZpbHRlcihmaWxJZCk7XHJcbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChmaWwpO1xyXG4gICAgICAgICAgZmlsLmFwcGVuZENoaWxkKGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSk7XHJcbiAgICAgICAgICBnZyA9IGNyZWF0ZU5TKCdnJyk7XHJcbiAgICAgICAgICBnZy5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XHJcbiAgICAgICAgICBsYXllckVsZW1lbnRQYXJlbnQgPSBnZztcclxuICAgICAgICAgIG1hc2tlci5hcHBlbmRDaGlsZChnZyk7XHJcbiAgICAgICAgICBnZy5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGxvY2F0aW9uSHJlZiArICcjJyArIGZpbElkICsgJyknKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLnRkID09IDIpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgICAgICB2YXIgbWFza0dyb3VwID0gY3JlYXRlTlMoJ21hc2snKTtcclxuICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMubGF5ZXJJZCk7XHJcbiAgICAgICAgbWFza0dyb3VwLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2FscGhhJyk7XHJcbiAgICAgICAgdmFyIG1hc2tHcm91cGVyID0gY3JlYXRlTlMoJ2cnKTtcclxuICAgICAgICBtYXNrR3JvdXAuYXBwZW5kQ2hpbGQobWFza0dyb3VwZXIpO1xyXG4gICAgICAgIGZpbElkID0gY3JlYXRlRWxlbWVudElEKCk7XHJcbiAgICAgICAgZmlsID0gZmlsdGVyc0ZhY3RvcnkuY3JlYXRlRmlsdGVyKGZpbElkKTtcclxuICAgICAgICAvLy8gL1xyXG5cclxuICAgICAgICAvLyBUaGlzIHNvbHV0aW9uIGRvZXNuJ3Qgd29yayBvbiBBbmRyb2lkIHdoZW4gbWV0YSB0YWcgd2l0aCB2aWV3cG9ydCBhdHRyaWJ1dGUgaXMgc2V0XHJcbiAgICAgICAgLyogdmFyIGZlQ29sb3JNYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xyXG4gICAgICAgICAgICAgICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XHJcbiAgICAgICAgICAgICAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcclxuICAgICAgICAgICAgICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCcxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAtMSAxJyk7XHJcbiAgICAgICAgICAgICAgICBmaWwuYXBwZW5kQ2hpbGQoZmVDb2xvck1hdHJpeCk7ICovXHJcbiAgICAgICAgLy8vIC9cclxuICAgICAgICB2YXIgZmVDVHIgPSBjcmVhdGVOUygnZmVDb21wb25lbnRUcmFuc2ZlcicpO1xyXG4gICAgICAgIGZlQ1RyLnNldEF0dHJpYnV0ZSgnaW4nLCAnU291cmNlR3JhcGhpYycpO1xyXG4gICAgICAgIGZpbC5hcHBlbmRDaGlsZChmZUNUcik7XHJcbiAgICAgICAgdmFyIGZlRnVuYyA9IGNyZWF0ZU5TKCdmZUZ1bmNBJyk7XHJcbiAgICAgICAgZmVGdW5jLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xyXG4gICAgICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgJzEuMCAwLjAnKTtcclxuICAgICAgICBmZUNUci5hcHBlbmRDaGlsZChmZUZ1bmMpO1xyXG4gICAgICAgIC8vLyAvXHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZmlsKTtcclxuICAgICAgICB2YXIgYWxwaGFSZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcclxuICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuY29tcC5kYXRhLncpO1xyXG4gICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuY29tcC5kYXRhLmgpO1xyXG4gICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCAnMCcpO1xyXG4gICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ3knLCAnMCcpO1xyXG4gICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnI2ZmZmZmZicpO1xyXG4gICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCAnMCcpO1xyXG4gICAgICAgIG1hc2tHcm91cGVyLnNldEF0dHJpYnV0ZSgnZmlsdGVyJywgJ3VybCgnICsgbG9jYXRpb25IcmVmICsgJyMnICsgZmlsSWQgKyAnKScpO1xyXG4gICAgICAgIG1hc2tHcm91cGVyLmFwcGVuZENoaWxkKGFscGhhUmVjdCk7XHJcbiAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xyXG4gICAgICAgIGxheWVyRWxlbWVudFBhcmVudCA9IG1hc2tHcm91cGVyO1xyXG4gICAgICAgIGlmICghZmVhdHVyZVN1cHBvcnQubWFza1R5cGUpIHtcclxuICAgICAgICAgIG1hc2tHcm91cC5zZXRBdHRyaWJ1dGUoJ21hc2stdHlwZScsICdsdW1pbmFuY2UnKTtcclxuICAgICAgICAgIGZpbC5hcHBlbmRDaGlsZChmaWx0ZXJzRmFjdG9yeS5jcmVhdGVBbHBoYVRvTHVtaW5hbmNlRmlsdGVyKCkpO1xyXG4gICAgICAgICAgZ2cgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQoYWxwaGFSZWN0KTtcclxuICAgICAgICAgIGdnLmFwcGVuZENoaWxkKHRoaXMubGF5ZXJFbGVtZW50KTtcclxuICAgICAgICAgIGxheWVyRWxlbWVudFBhcmVudCA9IGdnO1xyXG4gICAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQoZ2cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChtYXNrR3JvdXApO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS50dCkge1xyXG4gICAgICB0aGlzLm1hdHRlRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XHJcbiAgICAgIGxheWVyRWxlbWVudFBhcmVudCA9IHRoaXMubWF0dGVFbGVtZW50O1xyXG4gICAgICB0aGlzLmJhc2VFbGVtZW50ID0gdGhpcy5tYXR0ZUVsZW1lbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmJhc2VFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5kYXRhLmxuKSB7XHJcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmRhdGEubG4pO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZGF0YS5jbCkge1xyXG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5kYXRhLmNsKTtcclxuICAgIH1cclxuICAgIC8vIENsaXBwaW5nIGNvbXBvc2l0aW9ucyB0byBoaWRlIGNvbnRlbnQgdGhhdCBleGNlZWRzIGJvdW5kYXJpZXMuIElmIGNvbGxhcHNlZCB0cmFuc2Zvcm1hdGlvbnMgaXMgb24sIGNvbXBvbmVudCBzaG91bGQgbm90IGJlIGNsaXBwZWRcclxuICAgIGlmICh0aGlzLmRhdGEudHkgPT09IDAgJiYgIXRoaXMuZGF0YS5oZCkge1xyXG4gICAgICB2YXIgY3AgPSBjcmVhdGVOUygnY2xpcFBhdGgnKTtcclxuICAgICAgdmFyIHB0ID0gY3JlYXRlTlMoJ3BhdGgnKTtcclxuICAgICAgcHQuc2V0QXR0cmlidXRlKCdkJywgJ00wLDAgTCcgKyB0aGlzLmRhdGEudyArICcsMCBMJyArIHRoaXMuZGF0YS53ICsgJywnICsgdGhpcy5kYXRhLmggKyAnIEwwLCcgKyB0aGlzLmRhdGEuaCArICd6Jyk7XHJcbiAgICAgIHZhciBjbGlwSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuICAgICAgY3Auc2V0QXR0cmlidXRlKCdpZCcsIGNsaXBJZCk7XHJcbiAgICAgIGNwLmFwcGVuZENoaWxkKHB0KTtcclxuICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoY3ApO1xyXG5cclxuICAgICAgaWYgKHRoaXMuY2hlY2tNYXNrcygpKSB7XHJcbiAgICAgICAgdmFyIGNwR3JvdXAgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgICAgIGNwR3JvdXAuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCAndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBjbGlwSWQgKyAnKScpO1xyXG4gICAgICAgIGNwR3JvdXAuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gY3BHcm91cDtcclxuICAgICAgICBpZiAobGF5ZXJFbGVtZW50UGFyZW50KSB7XHJcbiAgICAgICAgICBsYXllckVsZW1lbnRQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmJhc2VFbGVtZW50ID0gdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xpcC1wYXRoJywgJ3VybCgnICsgbG9jYXRpb25IcmVmICsgJyMnICsgY2xpcElkICsgJyknKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZGF0YS5ibSAhPT0gMCkge1xyXG4gICAgICB0aGlzLnNldEJsZW5kTW9kZSgpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVuZGVyRWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZikge1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHRoaXMuZmluYWxUcmFuc2Zvcm0ubWF0LnRvMmRDU1MoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcclxuICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQuc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5vLnYpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgZGVzdHJveUJhc2VFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudCA9IG51bGw7XHJcbiAgICB0aGlzLm1hdHRlRWxlbWVudCA9IG51bGw7XHJcbiAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcclxuICB9LFxyXG4gIGdldEJhc2VFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5kYXRhLmhkKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuYmFzZUVsZW1lbnQ7XHJcbiAgfSxcclxuICBjcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMsIHRoaXMuZ2xvYmFsRGF0YSk7XHJcbiAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlciA9IG5ldyBTVkdFZmZlY3RzKHRoaXMpO1xyXG4gIH0sXHJcbiAgc2V0TWF0dGU6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgaWYgKCF0aGlzLm1hdHRlRWxlbWVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLm1hdHRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBpZCArICcpJyk7XHJcbiAgfSxcclxufTtcclxuXHJcbi8qIGdsb2JhbCBQcm9jZXNzZWRFbGVtZW50ICovXHJcblxyXG5mdW5jdGlvbiBJU2hhcGVFbGVtZW50KCkge1xyXG59XHJcblxyXG5JU2hhcGVFbGVtZW50LnByb3RvdHlwZSA9IHtcclxuICBhZGRTaGFwZVRvTW9kaWZpZXJzOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZU1vZGlmaWVycy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgdGhpcy5zaGFwZU1vZGlmaWVyc1tpXS5hZGRTaGFwZShkYXRhKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGlzU2hhcGVJbkFuaW1hdGVkTW9kaWZpZXJzOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVNb2RpZmllcnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgaWYgKHRoaXMuc2hhcGVNb2RpZmllcnNbaV0uaXNBbmltYXRlZFdpdGhTaGFwZShkYXRhKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuICByZW5kZXJNb2RpZmllcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghdGhpcy5zaGFwZU1vZGlmaWVycy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHRoaXMuc2hhcGVzW2ldLnNoLnJlc2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGVuID0gdGhpcy5zaGFwZU1vZGlmaWVycy5sZW5ndGg7XHJcbiAgICB2YXIgc2hvdWxkQnJlYWtQcm9jZXNzO1xyXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgc2hvdWxkQnJlYWtQcm9jZXNzID0gdGhpcy5zaGFwZU1vZGlmaWVyc1tpXS5wcm9jZXNzU2hhcGVzKHRoaXMuX2lzRmlyc3RGcmFtZSk7XHJcbiAgICAgIC8vIHdvcmthcm91bmQgdG8gZml4IGNhc2VzIHdoZXJlIGEgcmVwZWF0ZXIgcmVzZXRzIHRoZSBzaGFwZSBzbyB0aGUgZm9sbG93aW5nIHByb2Nlc3NlcyBnZXQgY2FsbGVkIHR3aWNlXHJcbiAgICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb24gZm9yIHRoaXNcclxuICAgICAgaWYgKHNob3VsZEJyZWFrUHJvY2Vzcykge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBsY0VudW06IHtcclxuICAgIDE6ICdidXR0JyxcclxuICAgIDI6ICdyb3VuZCcsXHJcbiAgICAzOiAnc3F1YXJlJyxcclxuICB9LFxyXG4gIGxqRW51bToge1xyXG4gICAgMTogJ21pdGVyJyxcclxuICAgIDI6ICdyb3VuZCcsXHJcbiAgICAzOiAnYmV2ZWwnLFxyXG4gIH0sXHJcbiAgc2VhcmNoUHJvY2Vzc2VkRWxlbWVudDogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgIHZhciBlbGVtZW50cyA9IHRoaXMucHJvY2Vzc2VkRWxlbWVudHM7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgaWYgKGVsZW1lbnRzW2ldLmVsZW0gPT09IGVsZW0pIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudHNbaV0ucG9zO1xyXG4gICAgICB9XHJcbiAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG4gIH0sXHJcbiAgYWRkUHJvY2Vzc2VkRWxlbWVudDogZnVuY3Rpb24gKGVsZW0sIHBvcykge1xyXG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5wcm9jZXNzZWRFbGVtZW50cztcclxuICAgIHZhciBpID0gZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGkpIHtcclxuICAgICAgaSAtPSAxO1xyXG4gICAgICBpZiAoZWxlbWVudHNbaV0uZWxlbSA9PT0gZWxlbSkge1xyXG4gICAgICAgIGVsZW1lbnRzW2ldLnBvcyA9IHBvcztcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsZW1lbnRzLnB1c2gobmV3IFByb2Nlc3NlZEVsZW1lbnQoZWxlbSwgcG9zKSk7XHJcbiAgfSxcclxuICBwcmVwYXJlRnJhbWU6IGZ1bmN0aW9uIChudW0pIHtcclxuICAgIHRoaXMucHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pO1xyXG4gICAgdGhpcy5wcmVwYXJlUHJvcGVydGllcyhudW0sIHRoaXMuaXNJblJhbmdlKTtcclxuICB9LFxyXG59O1xyXG5cclxuLyogZ2xvYmFsIFRleHRQcm9wZXJ0eSwgVGV4dEFuaW1hdG9yUHJvcGVydHksIGJ1aWxkU2hhcGVTdHJpbmcsIExldHRlclByb3BzICovXHJcblxyXG5mdW5jdGlvbiBJVGV4dEVsZW1lbnQoKSB7XHJcbn1cclxuXHJcbklUZXh0RWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gdHJ1ZTtcclxuICB0aGlzLmluaXRGcmFtZSgpO1xyXG4gIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG4gIHRoaXMudGV4dFByb3BlcnR5ID0gbmV3IFRleHRQcm9wZXJ0eSh0aGlzLCBkYXRhLnQsIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xyXG4gIHRoaXMudGV4dEFuaW1hdG9yID0gbmV3IFRleHRBbmltYXRvclByb3BlcnR5KGRhdGEudCwgdGhpcy5yZW5kZXJUeXBlLCB0aGlzKTtcclxuICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgdGhpcy5pbml0SGllcmFyY2h5KCk7XHJcbiAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xyXG4gIHRoaXMuaW5pdFJlbmRlcmVyRWxlbWVudCgpO1xyXG4gIHRoaXMuY3JlYXRlQ29udGFpbmVyRWxlbWVudHMoKTtcclxuICB0aGlzLmNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCk7XHJcbiAgdGhpcy5jcmVhdGVDb250ZW50KCk7XHJcbiAgdGhpcy5oaWRlKCk7XHJcbiAgdGhpcy50ZXh0QW5pbWF0b3Iuc2VhcmNoUHJvcGVydGllcyh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzKTtcclxufTtcclxuXHJcbklUZXh0RWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gKG51bSkge1xyXG4gIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gIHRoaXMucHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pO1xyXG4gIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0aGlzLmlzSW5SYW5nZSk7XHJcbiAgaWYgKHRoaXMudGV4dFByb3BlcnR5Ll9tZGYgfHwgdGhpcy50ZXh0UHJvcGVydHkuX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgdGhpcy5idWlsZE5ld1RleHQoKTtcclxuICAgIHRoaXMudGV4dFByb3BlcnR5Ll9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcclxuICAgIHRoaXMudGV4dFByb3BlcnR5Ll9tZGYgPSBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG5JVGV4dEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVBhdGhTaGFwZSA9IGZ1bmN0aW9uIChtYXRyaXhIZWxwZXIsIHNoYXBlcykge1xyXG4gIHZhciBqO1xyXG4gIHZhciBqTGVuID0gc2hhcGVzLmxlbmd0aDtcclxuICB2YXIgcGF0aE5vZGVzO1xyXG4gIHZhciBzaGFwZVN0ciA9ICcnO1xyXG4gIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgIHBhdGhOb2RlcyA9IHNoYXBlc1tqXS5rcy5rO1xyXG4gICAgc2hhcGVTdHIgKz0gYnVpbGRTaGFwZVN0cmluZyhwYXRoTm9kZXMsIHBhdGhOb2Rlcy5pLmxlbmd0aCwgdHJ1ZSwgbWF0cml4SGVscGVyKTtcclxuICB9XHJcbiAgcmV0dXJuIHNoYXBlU3RyO1xyXG59O1xyXG5cclxuSVRleHRFbGVtZW50LnByb3RvdHlwZS51cGRhdGVEb2N1bWVudERhdGEgPSBmdW5jdGlvbiAobmV3RGF0YSwgaW5kZXgpIHtcclxuICB0aGlzLnRleHRQcm9wZXJ0eS51cGRhdGVEb2N1bWVudERhdGEobmV3RGF0YSwgaW5kZXgpO1xyXG59O1xyXG5cclxuSVRleHRFbGVtZW50LnByb3RvdHlwZS5jYW5SZXNpemVGb250ID0gZnVuY3Rpb24gKF9jYW5SZXNpemUpIHtcclxuICB0aGlzLnRleHRQcm9wZXJ0eS5jYW5SZXNpemVGb250KF9jYW5SZXNpemUpO1xyXG59O1xyXG5cclxuSVRleHRFbGVtZW50LnByb3RvdHlwZS5zZXRNaW5pbXVtRm9udFNpemUgPSBmdW5jdGlvbiAoX2ZvbnRTaXplKSB7XHJcbiAgdGhpcy50ZXh0UHJvcGVydHkuc2V0TWluaW11bUZvbnRTaXplKF9mb250U2l6ZSk7XHJcbn07XHJcblxyXG5JVGV4dEVsZW1lbnQucHJvdG90eXBlLmFwcGx5VGV4dFByb3BlcnRpZXNUb01hdHJpeCA9IGZ1bmN0aW9uIChkb2N1bWVudERhdGEsIG1hdHJpeEhlbHBlciwgbGluZU51bWJlciwgeFBvcywgeVBvcykge1xyXG4gIGlmIChkb2N1bWVudERhdGEucHMpIHtcclxuICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLCBkb2N1bWVudERhdGEucHNbMV0gKyBkb2N1bWVudERhdGEuYXNjZW50LCAwKTtcclxuICB9XHJcbiAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCAtZG9jdW1lbnREYXRhLmxzLCAwKTtcclxuICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XHJcbiAgICBjYXNlIDE6XHJcbiAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgKyAoZG9jdW1lbnREYXRhLmJveFdpZHRoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGluZU51bWJlcl0pLCAwLCAwKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDI6XHJcbiAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgKyAoZG9jdW1lbnREYXRhLmJveFdpZHRoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGluZU51bWJlcl0pIC8gMiwgMCwgMCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoeFBvcywgeVBvcywgMCk7XHJcbn07XHJcblxyXG5JVGV4dEVsZW1lbnQucHJvdG90eXBlLmJ1aWxkQ29sb3IgPSBmdW5jdGlvbiAoY29sb3JEYXRhKSB7XHJcbiAgcmV0dXJuICdyZ2IoJyArIE1hdGgucm91bmQoY29sb3JEYXRhWzBdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoY29sb3JEYXRhWzFdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoY29sb3JEYXRhWzJdICogMjU1KSArICcpJztcclxufTtcclxuXHJcbklUZXh0RWxlbWVudC5wcm90b3R5cGUuZW1wdHlQcm9wID0gbmV3IExldHRlclByb3BzKCk7XHJcblxyXG5JVGV4dEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZURPTUVsZW1lbnQgKi9cclxuXHJcbmZ1bmN0aW9uIElDb21wRWxlbWVudCgpIHt9XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgSUNvbXBFbGVtZW50KTtcclxuXHJcbklDb21wRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMuaW5pdEZyYW1lKCk7XHJcbiAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgdGhpcy5pbml0VHJhbnNmb3JtKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG4gIHRoaXMuaW5pdFJlbmRlcmFibGUoKTtcclxuICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcclxuICB0aGlzLmluaXRSZW5kZXJlckVsZW1lbnQoKTtcclxuICB0aGlzLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzKCk7XHJcbiAgdGhpcy5jcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50cygpO1xyXG4gIGlmICh0aGlzLmRhdGEueHQgfHwgIWdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkKSB7XHJcbiAgICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcclxuICB9XHJcbiAgdGhpcy5oaWRlKCk7XHJcbn07XHJcblxyXG4vKiBJQ29tcEVsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYoIXRoaXMuaGlkZGVuKXtcclxuICAgICAgICB0aGlzLmhpZGVFbGVtZW50KCk7XHJcbiAgICAgICAgdmFyIGksbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yKCBpID0gMDsgaSA8IGxlbjsgaSs9MSApe1xyXG4gICAgICAgICAgICBpZih0aGlzLmVsZW1lbnRzW2ldKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0uaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59OyAqL1xyXG5cclxuSUNvbXBFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgdGhpcy5wcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSk7XHJcbiAgdGhpcy5wcmVwYXJlUHJvcGVydGllcyhudW0sIHRoaXMuaXNJblJhbmdlKTtcclxuICBpZiAoIXRoaXMuaXNJblJhbmdlICYmICF0aGlzLmRhdGEueHQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmICghdGhpcy50bS5fcGxhY2Vob2xkZXIpIHtcclxuICAgIHZhciB0aW1lUmVtYXBwZWQgPSB0aGlzLnRtLnY7XHJcbiAgICBpZiAodGltZVJlbWFwcGVkID09PSB0aGlzLmRhdGEub3ApIHtcclxuICAgICAgdGltZVJlbWFwcGVkID0gdGhpcy5kYXRhLm9wIC0gMTtcclxuICAgIH1cclxuICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IHRpbWVSZW1hcHBlZDtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gbnVtIC8gdGhpcy5kYXRhLnNyO1xyXG4gIH1cclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHJcbiAgaWYgKCF0aGlzLmNvbXBsZXRlTGF5ZXJzKSB7XHJcbiAgICB0aGlzLmNoZWNrTGF5ZXJzKHRoaXMucmVuZGVyZWRGcmFtZSk7XHJcbiAgfVxyXG4gIC8vIFRoaXMgaXRlcmF0aW9uIG5lZWRzIHRvIGJlIGJhY2t3YXJkcyBiZWNhdXNlIG9mIGhvdyBleHByZXNzaW9ucyBjb25uZWN0IGJldHdlZW4gZWFjaCBvdGhlclxyXG4gIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbaV0ucHJlcGFyZUZyYW1lKHRoaXMucmVuZGVyZWRGcmFtZSAtIHRoaXMubGF5ZXJzW2ldLnN0KTtcclxuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0uX21kZikge1xyXG4gICAgICAgIHRoaXMuX21kZiA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5JQ29tcEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xyXG4gICAgICB0aGlzLmVsZW1lbnRzW2ldLnJlbmRlckZyYW1lKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuSUNvbXBFbGVtZW50LnByb3RvdHlwZS5zZXRFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVtcykge1xyXG4gIHRoaXMuZWxlbWVudHMgPSBlbGVtcztcclxufTtcclxuXHJcbklDb21wRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuZWxlbWVudHM7XHJcbn07XHJcblxyXG5JQ29tcEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3lFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgaWYgKHRoaXMuZWxlbWVudHNbaV0pIHtcclxuICAgICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuSUNvbXBFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuZGVzdHJveUVsZW1lbnRzKCk7XHJcbiAgdGhpcy5kZXN0cm95QmFzZUVsZW1lbnQoKTtcclxufTtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIEJhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudCwgY3JlYXRlTlMgKi9cclxuXHJcbmZ1bmN0aW9uIElJbWFnZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMuYXNzZXREYXRhID0gZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEoZGF0YS5yZWZJZCk7XHJcbiAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxuICB0aGlzLnNvdXJjZVJlY3QgPSB7XHJcbiAgICB0b3A6IDAsIGxlZnQ6IDAsIHdpZHRoOiB0aGlzLmFzc2V0RGF0YS53LCBoZWlnaHQ6IHRoaXMuYXNzZXREYXRhLmgsXHJcbiAgfTtcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgU1ZHQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZURPTUVsZW1lbnRdLCBJSW1hZ2VFbGVtZW50KTtcclxuXHJcbklJbWFnZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGFzc2V0UGF0aCA9IHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldHNQYXRoKHRoaXMuYXNzZXREYXRhKTtcclxuXHJcbiAgdGhpcy5pbm5lckVsZW0gPSBjcmVhdGVOUygnaW1hZ2UnKTtcclxuICB0aGlzLmlubmVyRWxlbS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5hc3NldERhdGEudyArICdweCcpO1xyXG4gIHRoaXMuaW5uZXJFbGVtLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5hc3NldERhdGEuaCArICdweCcpO1xyXG4gIHRoaXMuaW5uZXJFbGVtLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsIHRoaXMuYXNzZXREYXRhLnByIHx8IHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJDb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcclxuICB0aGlzLmlubmVyRWxlbS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJywgYXNzZXRQYXRoKTtcclxuXHJcbiAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5pbm5lckVsZW0pO1xyXG59O1xyXG5cclxuSUltYWdlRWxlbWVudC5wcm90b3R5cGUuc291cmNlUmVjdEF0VGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5zb3VyY2VSZWN0O1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgSUltYWdlRWxlbWVudCwgY3JlYXRlTlMgKi9cclxuXHJcbmZ1bmN0aW9uIElTb2xpZEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbn1cclxuZXh0ZW5kUHJvdG90eXBlKFtJSW1hZ2VFbGVtZW50XSwgSVNvbGlkRWxlbWVudCk7XHJcblxyXG5JU29saWRFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciByZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcclxuICAvLy8gL3JlY3Quc3R5bGUud2lkdGggPSB0aGlzLmRhdGEuc3c7XHJcbiAgLy8vIC9yZWN0LnN0eWxlLmhlaWdodCA9IHRoaXMuZGF0YS5zaDtcclxuICAvLy8gL3JlY3Quc3R5bGUuZmlsbCA9IHRoaXMuZGF0YS5zYztcclxuICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmRhdGEuc3cpO1xyXG4gIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmRhdGEuc2gpO1xyXG4gIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgdGhpcy5kYXRhLnNjKTtcclxuICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChyZWN0KTtcclxufTtcclxuXHJcbi8qIGdsb2JhbCBQcm9wZXJ0eUZhY3RvcnksIGV4dGVuZFByb3RvdHlwZSwgUmVuZGVyYWJsZUVsZW1lbnQsIEJhc2VFbGVtZW50LCBGcmFtZUVsZW1lbnQgKi9cclxuXHJcbmZ1bmN0aW9uIEF1ZGlvRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy5pbml0RnJhbWUoKTtcclxuICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XHJcbiAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcclxuICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxuICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICB0aGlzLl9jYW5QbGF5ID0gZmFsc2U7XHJcbiAgdmFyIGFzc2V0UGF0aCA9IHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldHNQYXRoKHRoaXMuYXNzZXREYXRhKTtcclxuICB0aGlzLmF1ZGlvID0gdGhpcy5nbG9iYWxEYXRhLmF1ZGlvQ29udHJvbGxlci5jcmVhdGVBdWRpbyhhc3NldFBhdGgpO1xyXG4gIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcclxuICB0aGlzLmdsb2JhbERhdGEuYXVkaW9Db250cm9sbGVyLmFkZEF1ZGlvKHRoaXMpO1xyXG4gIHRoaXMudG0gPSBkYXRhLnRtID8gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS50bSwgMCwgZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIHRoaXMpIDogeyBfcGxhY2Vob2xkZXI6IHRydWUgfTtcclxufVxyXG5cclxuQXVkaW9FbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgdGhpcy5wcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSwgdHJ1ZSk7XHJcbiAgdGhpcy5wcmVwYXJlUHJvcGVydGllcyhudW0sIHRydWUpO1xyXG4gIGlmICghdGhpcy50bS5fcGxhY2Vob2xkZXIpIHtcclxuICAgIHZhciB0aW1lUmVtYXBwZWQgPSB0aGlzLnRtLnY7XHJcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IHRpbWVSZW1hcHBlZDtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSBudW0gLyB0aGlzLmRhdGEuc3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtSZW5kZXJhYmxlRWxlbWVudCwgQmFzZUVsZW1lbnQsIEZyYW1lRWxlbWVudF0sIEF1ZGlvRWxlbWVudCk7XHJcblxyXG5BdWRpb0VsZW1lbnQucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICh0aGlzLmlzSW5SYW5nZSAmJiB0aGlzLl9jYW5QbGF5KSB7XHJcbiAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICB0aGlzLmF1ZGlvLnBsYXkoKTtcclxuICAgICAgdGhpcy5hdWRpby5zZWVrKHRoaXMuX2N1cnJlbnRUaW1lIC8gdGhpcy5nbG9iYWxEYXRhLmZyYW1lUmF0ZSk7XHJcbiAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmF1ZGlvLnBsYXlpbmcoKVxyXG4gICAgICB8fCBNYXRoLmFicyh0aGlzLl9jdXJyZW50VGltZSAvIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgLSB0aGlzLmF1ZGlvLnNlZWsoKSkgPiAwLjFcclxuICAgICkge1xyXG4gICAgICB0aGlzLmF1ZGlvLnNlZWsodGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLmdsb2JhbERhdGEuZnJhbWVSYXRlKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5BdWRpb0VsZW1lbnQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgLy8gdGhpcy5hdWRpby5wbGF5KClcclxufTtcclxuXHJcbkF1ZGlvRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmF1ZGlvLnBhdXNlKCk7XHJcbiAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbn07XHJcblxyXG5BdWRpb0VsZW1lbnQucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuYXVkaW8ucGF1c2UoKTtcclxuICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICB0aGlzLl9jYW5QbGF5ID0gZmFsc2U7XHJcbn07XHJcblxyXG5BdWRpb0VsZW1lbnQucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLl9jYW5QbGF5ID0gdHJ1ZTtcclxufTtcclxuXHJcbkF1ZGlvRWxlbWVudC5wcm90b3R5cGUuc2V0UmF0ZSA9IGZ1bmN0aW9uIChyYXRlVmFsdWUpIHtcclxuICB0aGlzLmF1ZGlvLnJhdGUocmF0ZVZhbHVlKTtcclxufTtcclxuXHJcbkF1ZGlvRWxlbWVudC5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24gKHZvbHVtZVZhbHVlKSB7XHJcbiAgdGhpcy5hdWRpby52b2x1bWUodm9sdW1lVmFsdWUpO1xyXG59O1xyXG5cclxuQXVkaW9FbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbkF1ZGlvRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbkF1ZGlvRWxlbWVudC5wcm90b3R5cGUuc291cmNlUmVjdEF0VGltZSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbkF1ZGlvRWxlbWVudC5wcm90b3R5cGUuaW5pdEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgUmVuZGVyYWJsZUVsZW1lbnQsIEJhc2VFbGVtZW50LCBGcmFtZUVsZW1lbnQsIEZvb3RhZ2VJbnRlcmZhY2UgKi9cclxuXHJcbmZ1bmN0aW9uIEZvb3RhZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICB0aGlzLmluaXRGcmFtZSgpO1xyXG4gIHRoaXMuaW5pdFJlbmRlcmFibGUoKTtcclxuICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xyXG4gIHRoaXMuZm9vdGFnZURhdGEgPSBnbG9iYWxEYXRhLmltYWdlTG9hZGVyLmdldEFzc2V0KHRoaXMuYXNzZXREYXRhKTtcclxuICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxufVxyXG5cclxuRm9vdGFnZUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbmV4dGVuZFByb3RvdHlwZShbUmVuZGVyYWJsZUVsZW1lbnQsIEJhc2VFbGVtZW50LCBGcmFtZUVsZW1lbnRdLCBGb290YWdlRWxlbWVudCk7XHJcblxyXG5Gb290YWdlRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5Gb290YWdlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblxyXG5Gb290YWdlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbkZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5pbml0RXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5sYXllckludGVyZmFjZSA9IEZvb3RhZ2VJbnRlcmZhY2UodGhpcyk7XHJcbn07XHJcblxyXG5Gb290YWdlRWxlbWVudC5wcm90b3R5cGUuZ2V0Rm9vdGFnZURhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuZm9vdGFnZURhdGE7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlU2l6ZWRBcnJheSwgUHJvcGVydHlGYWN0b3J5LCBleHRlbmRQcm90b3R5cGUsIFNWR1JlbmRlcmVyLCBJQ29tcEVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50ICovXHJcblxyXG5mdW5jdGlvbiBTVkdDb21wRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy5sYXllcnMgPSBkYXRhLmxheWVycztcclxuICB0aGlzLnN1cHBvcnRzM2QgPSB0cnVlO1xyXG4gIHRoaXMuY29tcGxldGVMYXllcnMgPSBmYWxzZTtcclxuICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xyXG4gIHRoaXMuZWxlbWVudHMgPSB0aGlzLmxheWVycyA/IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5sYXllcnMubGVuZ3RoKSA6IFtdO1xyXG4gIC8vIHRoaXMubGF5ZXJFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcclxuICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG4gIHRoaXMudG0gPSBkYXRhLnRtID8gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS50bSwgMCwgZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIHRoaXMpIDogeyBfcGxhY2Vob2xkZXI6IHRydWUgfTtcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtTVkdSZW5kZXJlciwgSUNvbXBFbGVtZW50LCBTVkdCYXNlRWxlbWVudF0sIFNWR0NvbXBFbGVtZW50KTtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIEJhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LFxyXG5SZW5kZXJhYmxlRE9NRWxlbWVudCwgSVRleHRFbGVtZW50LCBjcmVhdGVTaXplZEFycmF5LCBjcmVhdGVOUyAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHVGV4dExvdHRpZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMudGV4dFNwYW5zID0gW107XHJcbiAgdGhpcy5yZW5kZXJUeXBlID0gJ3N2Zyc7XHJcbiAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgU1ZHQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZURPTUVsZW1lbnQsIElUZXh0RWxlbWVudF0sIFNWR1RleHRMb3R0aWVFbGVtZW50KTtcclxuXHJcblNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICh0aGlzLmRhdGEuc2luZ2xlU2hhcGUgJiYgIXRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5jaGFycykge1xyXG4gICAgdGhpcy50ZXh0Q29udGFpbmVyID0gY3JlYXRlTlMoJ3RleHQnKTtcclxuICB9XHJcbn07XHJcblxyXG5TVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUuYnVpbGRUZXh0Q29udGVudHMgPSBmdW5jdGlvbiAodGV4dEFycmF5KSB7XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHZhciBsZW4gPSB0ZXh0QXJyYXkubGVuZ3RoO1xyXG4gIHZhciB0ZXh0Q29udGVudHMgPSBbXTtcclxuICB2YXIgY3VycmVudFRleHRDb250ZW50ID0gJyc7XHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIGlmICh0ZXh0QXJyYXlbaV0gPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMTMpIHx8IHRleHRBcnJheVtpXSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgzKSkge1xyXG4gICAgICB0ZXh0Q29udGVudHMucHVzaChjdXJyZW50VGV4dENvbnRlbnQpO1xyXG4gICAgICBjdXJyZW50VGV4dENvbnRlbnQgPSAnJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN1cnJlbnRUZXh0Q29udGVudCArPSB0ZXh0QXJyYXlbaV07XHJcbiAgICB9XHJcbiAgICBpICs9IDE7XHJcbiAgfVxyXG4gIHRleHRDb250ZW50cy5wdXNoKGN1cnJlbnRUZXh0Q29udGVudCk7XHJcbiAgcmV0dXJuIHRleHRDb250ZW50cztcclxufTtcclxuXHJcblNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5idWlsZE5ld1RleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbjtcclxuXHJcbiAgdmFyIGRvY3VtZW50RGF0YSA9IHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhO1xyXG4gIHRoaXMucmVuZGVyZWRMZXR0ZXJzID0gY3JlYXRlU2l6ZWRBcnJheShkb2N1bWVudERhdGEgPyBkb2N1bWVudERhdGEubC5sZW5ndGggOiAwKTtcclxuICBpZiAoZG9jdW1lbnREYXRhLmZjKSB7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLmZjKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbCcsICdyZ2JhKDAsMCwwLDApJyk7XHJcbiAgfVxyXG4gIGlmIChkb2N1bWVudERhdGEuc2MpIHtcclxuICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5zYykpO1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBkb2N1bWVudERhdGEuc3cpO1xyXG4gIH1cclxuICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScsIGRvY3VtZW50RGF0YS5maW5hbFNpemUpO1xyXG4gIHZhciBmb250RGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKTtcclxuICBpZiAoZm9udERhdGEuZkNsYXNzKSB7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZm9udERhdGEuZkNsYXNzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LWZhbWlseScsIGZvbnREYXRhLmZGYW1pbHkpO1xyXG4gICAgdmFyIGZXZWlnaHQgPSBkb2N1bWVudERhdGEuZldlaWdodDtcclxuICAgIHZhciBmU3R5bGUgPSBkb2N1bWVudERhdGEuZlN0eWxlO1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LXN0eWxlJywgZlN0eWxlKTtcclxuICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9udC13ZWlnaHQnLCBmV2VpZ2h0KTtcclxuICB9XHJcbiAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgZG9jdW1lbnREYXRhLnQpO1xyXG5cclxuICB2YXIgbGV0dGVycyA9IGRvY3VtZW50RGF0YS5sIHx8IFtdO1xyXG4gIHZhciB1c2VzR2x5cGhzID0gISF0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuY2hhcnM7XHJcbiAgbGVuID0gbGV0dGVycy5sZW5ndGg7XHJcblxyXG4gIHZhciB0U3BhbjtcclxuICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xyXG4gIHZhciBzaGFwZXM7XHJcbiAgdmFyIHNoYXBlU3RyID0gJyc7XHJcbiAgdmFyIHNpbmdsZVNoYXBlID0gdGhpcy5kYXRhLnNpbmdsZVNoYXBlO1xyXG4gIHZhciB4UG9zID0gMDtcclxuICB2YXIgeVBvcyA9IDA7XHJcbiAgdmFyIGZpcnN0TGluZSA9IHRydWU7XHJcbiAgdmFyIHRyYWNraW5nT2Zmc2V0ID0gZG9jdW1lbnREYXRhLnRyICogMC4wMDEgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xyXG4gIGlmIChzaW5nbGVTaGFwZSAmJiAhdXNlc0dseXBocyAmJiAhZG9jdW1lbnREYXRhLnN6KSB7XHJcbiAgICB2YXIgdEVsZW1lbnQgPSB0aGlzLnRleHRDb250YWluZXI7XHJcbiAgICB2YXIganVzdGlmeSA9ICdzdGFydCc7XHJcbiAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICBqdXN0aWZ5ID0gJ2VuZCc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMjpcclxuICAgICAgICBqdXN0aWZ5ID0gJ21pZGRsZSc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAganVzdGlmeSA9ICdzdGFydCc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywganVzdGlmeSk7XHJcbiAgICB0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2xldHRlci1zcGFjaW5nJywgdHJhY2tpbmdPZmZzZXQpO1xyXG4gICAgdmFyIHRleHRDb250ZW50ID0gdGhpcy5idWlsZFRleHRDb250ZW50cyhkb2N1bWVudERhdGEuZmluYWxUZXh0KTtcclxuICAgIGxlbiA9IHRleHRDb250ZW50Lmxlbmd0aDtcclxuICAgIHlQb3MgPSBkb2N1bWVudERhdGEucHMgPyBkb2N1bWVudERhdGEucHNbMV0gKyBkb2N1bWVudERhdGEuYXNjZW50IDogMDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICB0U3BhbiA9IHRoaXMudGV4dFNwYW5zW2ldIHx8IGNyZWF0ZU5TKCd0c3BhbicpO1xyXG4gICAgICB0U3Bhbi50ZXh0Q29udGVudCA9IHRleHRDb250ZW50W2ldO1xyXG4gICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcclxuICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCd5JywgeVBvcyk7XHJcbiAgICAgIHRTcGFuLnN0eWxlLmRpc3BsYXkgPSAnaW5oZXJpdCc7XHJcbiAgICAgIHRFbGVtZW50LmFwcGVuZENoaWxkKHRTcGFuKTtcclxuICAgICAgdGhpcy50ZXh0U3BhbnNbaV0gPSB0U3BhbjtcclxuICAgICAgeVBvcyArPSBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRFbGVtZW50KTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGNhY2hlZFNwYW5zTGVuZ3RoID0gdGhpcy50ZXh0U3BhbnMubGVuZ3RoO1xyXG4gICAgdmFyIHNoYXBlRGF0YTtcclxuICAgIHZhciBjaGFyRGF0YTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBpZiAoIXVzZXNHbHlwaHMgfHwgIXNpbmdsZVNoYXBlIHx8IGkgPT09IDApIHtcclxuICAgICAgICB0U3BhbiA9IGNhY2hlZFNwYW5zTGVuZ3RoID4gaSA/IHRoaXMudGV4dFNwYW5zW2ldIDogY3JlYXRlTlModXNlc0dseXBocyA/ICdwYXRoJyA6ICd0ZXh0Jyk7XHJcbiAgICAgICAgaWYgKGNhY2hlZFNwYW5zTGVuZ3RoIDw9IGkpIHtcclxuICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAnYnV0dCcpO1xyXG4gICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCAncm91bmQnKTtcclxuICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW1pdGVybGltaXQnLCAnNCcpO1xyXG4gICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0gPSB0U3BhbjtcclxuICAgICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRTcGFuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdFNwYW4uc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0JztcclxuICAgICAgfVxyXG5cclxuICAgICAgbWF0cml4SGVscGVyLnJlc2V0KCk7XHJcbiAgICAgIG1hdHJpeEhlbHBlci5zY2FsZShkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwLCBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwKTtcclxuICAgICAgaWYgKHNpbmdsZVNoYXBlKSB7XHJcbiAgICAgICAgaWYgKGxldHRlcnNbaV0ubikge1xyXG4gICAgICAgICAgeFBvcyA9IC10cmFja2luZ09mZnNldDtcclxuICAgICAgICAgIHlQb3MgKz0gZG9jdW1lbnREYXRhLnlPZmZzZXQ7XHJcbiAgICAgICAgICB5UG9zICs9IGZpcnN0TGluZSA/IDEgOiAwO1xyXG4gICAgICAgICAgZmlyc3RMaW5lID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXBwbHlUZXh0UHJvcGVydGllc1RvTWF0cml4KGRvY3VtZW50RGF0YSwgbWF0cml4SGVscGVyLCBsZXR0ZXJzW2ldLmxpbmUsIHhQb3MsIHlQb3MpO1xyXG4gICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sIHx8IDA7XHJcbiAgICAgICAgLy8geFBvcyArPSBsZXR0ZXJzW2ldLnZhbCA9PT0gJyAnID8gMCA6IHRyYWNraW5nT2Zmc2V0O1xyXG4gICAgICAgIHhQb3MgKz0gdHJhY2tpbmdPZmZzZXQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHVzZXNHbHlwaHMpIHtcclxuICAgICAgICBjaGFyRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRDaGFyRGF0YShkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcclxuICAgICAgICBzaGFwZURhdGEgPSAoY2hhckRhdGEgJiYgY2hhckRhdGEuZGF0YSkgfHwge307XHJcbiAgICAgICAgc2hhcGVzID0gc2hhcGVEYXRhLnNoYXBlcyA/IHNoYXBlRGF0YS5zaGFwZXNbMF0uaXQgOiBbXTtcclxuICAgICAgICBpZiAoIXNpbmdsZVNoYXBlKSB7XHJcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLmNyZWF0ZVBhdGhTaGFwZShtYXRyaXhIZWxwZXIsIHNoYXBlcykpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzaGFwZVN0ciArPSB0aGlzLmNyZWF0ZVBhdGhTaGFwZShtYXRyaXhIZWxwZXIsIHNoYXBlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChzaW5nbGVTaGFwZSkge1xyXG4gICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXRyaXhIZWxwZXIucHJvcHNbMTJdICsgJywnICsgbWF0cml4SGVscGVyLnByb3BzWzEzXSArICcpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRTcGFuLnRleHRDb250ZW50ID0gbGV0dGVyc1tpXS52YWw7XHJcbiAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsICd4bWw6c3BhY2UnLCAncHJlc2VydmUnKTtcclxuICAgICAgfVxyXG4gICAgICAvL1xyXG4gICAgfVxyXG4gICAgaWYgKHNpbmdsZVNoYXBlICYmIHRTcGFuKSB7XHJcbiAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnZCcsIHNoYXBlU3RyKTtcclxuICAgIH1cclxuICB9XHJcbiAgd2hpbGUgKGkgPCB0aGlzLnRleHRTcGFucy5sZW5ndGgpIHtcclxuICAgIHRoaXMudGV4dFNwYW5zW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICBpICs9IDE7XHJcbiAgfVxyXG5cclxuICB0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcbn07XHJcblxyXG5TVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUuc291cmNlUmVjdEF0VGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnByZXBhcmVGcmFtZSh0aGlzLmNvbXAucmVuZGVyZWRGcmFtZSAtIHRoaXMuZGF0YS5zdCk7XHJcbiAgdGhpcy5yZW5kZXJJbm5lckNvbnRlbnQoKTtcclxuICBpZiAodGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICB2YXIgdGV4dEJveCA9IHRoaXMubGF5ZXJFbGVtZW50LmdldEJCb3goKTtcclxuICAgIHRoaXMuYmJveCA9IHtcclxuICAgICAgdG9wOiB0ZXh0Qm94LnksXHJcbiAgICAgIGxlZnQ6IHRleHRCb3gueCxcclxuICAgICAgd2lkdGg6IHRleHRCb3gud2lkdGgsXHJcbiAgICAgIGhlaWdodDogdGV4dEJveC5oZWlnaHQsXHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gdGhpcy5iYm94O1xyXG59O1xyXG5cclxuU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAoIXRoaXMuZGF0YS5zaW5nbGVTaGFwZSkge1xyXG4gICAgdGhpcy50ZXh0QW5pbWF0b3IuZ2V0TWVhc3VyZXModGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEsIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnKTtcclxuICAgIGlmICh0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyB8fCB0aGlzLnRleHRBbmltYXRvci5sZXR0ZXJzQ2hhbmdlZEZsYWcpIHtcclxuICAgICAgdGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbjtcclxuICAgICAgdmFyIHJlbmRlcmVkTGV0dGVycyA9IHRoaXMudGV4dEFuaW1hdG9yLnJlbmRlcmVkTGV0dGVycztcclxuXHJcbiAgICAgIHZhciBsZXR0ZXJzID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubDtcclxuXHJcbiAgICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xyXG4gICAgICB2YXIgcmVuZGVyZWRMZXR0ZXI7XHJcbiAgICAgIHZhciB0ZXh0U3BhbjtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgaWYgKCFsZXR0ZXJzW2ldLm4pIHtcclxuICAgICAgICAgIHJlbmRlcmVkTGV0dGVyID0gcmVuZGVyZWRMZXR0ZXJzW2ldO1xyXG4gICAgICAgICAgdGV4dFNwYW4gPSB0aGlzLnRleHRTcGFuc1tpXTtcclxuICAgICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLm0pIHtcclxuICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCByZW5kZXJlZExldHRlci5tKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLm8pIHtcclxuICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgcmVuZGVyZWRMZXR0ZXIubyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5zdykge1xyXG4gICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHJlbmRlcmVkTGV0dGVyLnN3KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLnNjKSB7XHJcbiAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgcmVuZGVyZWRMZXR0ZXIuc2MpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYuZmMpIHtcclxuICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdmaWxsJywgcmVuZGVyZWRMZXR0ZXIuZmMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIEJhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSVNoYXBlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCxcclxuRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudCwgTWF0cml4LCBTVkdTdHlsZURhdGEsIFNWR1N0cm9rZVN0eWxlRGF0YSwgU1ZHRmlsbFN0eWxlRGF0YSxcclxuU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhLCBTVkdHcmFkaWVudFN0cm9rZVN0eWxlRGF0YSwgbG9jYXRpb25IcmVmLCBnZXRCbGVuZE1vZGUsIFNoYXBlR3JvdXBEYXRhLFxyXG5UcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnksIFNWR1RyYW5zZm9ybURhdGEsIFNoYXBlUHJvcGVydHlGYWN0b3J5LCBTVkdTaGFwZURhdGEsIFNWR0VsZW1lbnRzUmVuZGVyZXIsIFNoYXBlTW9kaWZpZXJzICovXHJcblxyXG5mdW5jdGlvbiBTVkdTaGFwZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIC8vIExpc3Qgb2YgZHJhd2FibGUgZWxlbWVudHNcclxuICB0aGlzLnNoYXBlcyA9IFtdO1xyXG4gIC8vIEZ1bGwgc2hhcGUgZGF0YVxyXG4gIHRoaXMuc2hhcGVzRGF0YSA9IGRhdGEuc2hhcGVzO1xyXG4gIC8vIExpc3Qgb2Ygc3R5bGVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHNoYXBlc1xyXG4gIHRoaXMuc3R5bGVzTGlzdCA9IFtdO1xyXG4gIC8vIExpc3Qgb2YgbW9kaWZpZXJzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHNoYXBlc1xyXG4gIHRoaXMuc2hhcGVNb2RpZmllcnMgPSBbXTtcclxuICAvLyBMaXN0IG9mIGl0ZW1zIGluIHNoYXBlIHRyZWVcclxuICB0aGlzLml0ZW1zRGF0YSA9IFtdO1xyXG4gIC8vIExpc3Qgb2YgaXRlbXMgaW4gcHJldmlvdXMgc2hhcGUgdHJlZVxyXG4gIHRoaXMucHJvY2Vzc2VkRWxlbWVudHMgPSBbXTtcclxuICAvLyBMaXN0IG9mIGFuaW1hdGVkIGNvbXBvbmVudHNcclxuICB0aGlzLmFuaW1hdGVkQ29udGVudHMgPSBbXTtcclxuICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG4gIC8vIE1vdmluZyBhbnkgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGdldCB0b28gbXVjaCBhY2Nlc3MgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYmVjYXVzZSBvZiB2OCB3YXkgb2YgaGFuZGxpbmcgbW9yZSB0aGFuIDEwIHByb3BlcnRpZXMuXHJcbiAgLy8gTGlzdCBvZiBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBjcmVhdGVkXHJcbiAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcclxuICAvLyBNb3ZpbmcgYW55IHByb3BlcnR5IHRoYXQgZG9lc24ndCBnZXQgdG9vIG11Y2ggYWNjZXNzIGFmdGVyIGluaXRpYWxpemF0aW9uIGJlY2F1c2Ugb2Ygdjggd2F5IG9mIGhhbmRsaW5nIG1vcmUgdGhhbiAxMCBwcm9wZXJ0aWVzLlxyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSVNoYXBlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudF0sIFNWR1NoYXBlRWxlbWVudCk7XHJcblxyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmluaXRTZWNvbmRhcnlFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuYnVpbGRFeHByZXNzaW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge307XHJcblxyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5wcmV2Vmlld0RhdGEsIHRoaXMubGF5ZXJFbGVtZW50LCAwLCBbXSwgdHJ1ZSk7XHJcbiAgdGhpcy5maWx0ZXJVbmlxdWVTaGFwZXMoKTtcclxufTtcclxuXHJcbi8qXHJcblRoaXMgbWV0aG9kIHNlYXJjaGVzIGZvciBtdWx0aXBsZSBzaGFwZXMgdGhhdCBhZmZlY3QgYSBzaW5nbGUgZWxlbWVudCBhbmQgb25lIG9mIHRoZW0gaXMgYW5pbWF0ZWRcclxuKi9cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5maWx0ZXJVbmlxdWVTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcclxuICB2YXIgc2hhcGU7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xyXG4gIHZhciBzdHlsZTtcclxuICB2YXIgdGVtcFNoYXBlcyA9IFtdO1xyXG4gIHZhciBhcmVBbmltYXRlZCA9IGZhbHNlO1xyXG4gIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgIHN0eWxlID0gdGhpcy5zdHlsZXNMaXN0W2pdO1xyXG4gICAgYXJlQW5pbWF0ZWQgPSBmYWxzZTtcclxuICAgIHRlbXBTaGFwZXMubGVuZ3RoID0gMDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBzaGFwZSA9IHRoaXMuc2hhcGVzW2ldO1xyXG4gICAgICBpZiAoc2hhcGUuc3R5bGVzLmluZGV4T2Yoc3R5bGUpICE9PSAtMSkge1xyXG4gICAgICAgIHRlbXBTaGFwZXMucHVzaChzaGFwZSk7XHJcbiAgICAgICAgYXJlQW5pbWF0ZWQgPSBzaGFwZS5faXNBbmltYXRlZCB8fCBhcmVBbmltYXRlZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRlbXBTaGFwZXMubGVuZ3RoID4gMSAmJiBhcmVBbmltYXRlZCkge1xyXG4gICAgICB0aGlzLnNldFNoYXBlc0FzQW5pbWF0ZWQodGVtcFNoYXBlcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5zZXRTaGFwZXNBc0FuaW1hdGVkID0gZnVuY3Rpb24gKHNoYXBlcykge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBzaGFwZXMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgc2hhcGVzW2ldLnNldEFzQW5pbWF0ZWQoKTtcclxuICB9XHJcbn07XHJcblxyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBsZXZlbCkge1xyXG4gIC8vIFRPRE86IHByZXZlbnQgZHJhd2luZyBvZiBoaWRkZW4gc3R5bGVzXHJcbiAgdmFyIGVsZW1lbnREYXRhO1xyXG4gIHZhciBzdHlsZU9iID0gbmV3IFNWR1N0eWxlRGF0YShkYXRhLCBsZXZlbCk7XHJcblxyXG4gIHZhciBwYXRoRWxlbWVudCA9IHN0eWxlT2IucEVsZW07XHJcbiAgaWYgKGRhdGEudHkgPT09ICdzdCcpIHtcclxuICAgIGVsZW1lbnREYXRhID0gbmV3IFNWR1N0cm9rZVN0eWxlRGF0YSh0aGlzLCBkYXRhLCBzdHlsZU9iKTtcclxuICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdmbCcpIHtcclxuICAgIGVsZW1lbnREYXRhID0gbmV3IFNWR0ZpbGxTdHlsZURhdGEodGhpcywgZGF0YSwgc3R5bGVPYik7XHJcbiAgfSBlbHNlIGlmIChkYXRhLnR5ID09PSAnZ2YnIHx8IGRhdGEudHkgPT09ICdncycpIHtcclxuICAgIHZhciBHcmFkaWVudENvbnN0cnVjdG9yID0gZGF0YS50eSA9PT0gJ2dmJyA/IFNWR0dyYWRpZW50RmlsbFN0eWxlRGF0YSA6IFNWR0dyYWRpZW50U3Ryb2tlU3R5bGVEYXRhO1xyXG4gICAgZWxlbWVudERhdGEgPSBuZXcgR3JhZGllbnRDb25zdHJ1Y3Rvcih0aGlzLCBkYXRhLCBzdHlsZU9iKTtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGVsZW1lbnREYXRhLmdmKTtcclxuICAgIGlmIChlbGVtZW50RGF0YS5tYXNrSWQpIHtcclxuICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZWxlbWVudERhdGEubXMpO1xyXG4gICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChlbGVtZW50RGF0YS5vZik7XHJcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWFzaycsICd1cmwoJyArIGxvY2F0aW9uSHJlZiArICcjJyArIGVsZW1lbnREYXRhLm1hc2tJZCArICcpJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoZGF0YS50eSA9PT0gJ3N0JyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XHJcbiAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgdGhpcy5sY0VudW1bZGF0YS5sY10gfHwgJ3JvdW5kJyk7XHJcbiAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIHRoaXMubGpFbnVtW2RhdGEubGpdIHx8ICdyb3VuZCcpO1xyXG4gICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCAnMCcpO1xyXG4gICAgaWYgKGRhdGEubGogPT09IDEpIHtcclxuICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UtbWl0ZXJsaW1pdCcsIGRhdGEubWwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGRhdGEuciA9PT0gMikge1xyXG4gICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCAnZXZlbm9kZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGRhdGEubG4pIHtcclxuICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBkYXRhLmxuKTtcclxuICB9XHJcbiAgaWYgKGRhdGEuY2wpIHtcclxuICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBkYXRhLmNsKTtcclxuICB9XHJcbiAgaWYgKGRhdGEuYm0pIHtcclxuICAgIHBhdGhFbGVtZW50LnN0eWxlWydtaXgtYmxlbmQtbW9kZSddID0gZ2V0QmxlbmRNb2RlKGRhdGEuYm0pO1xyXG4gIH1cclxuICB0aGlzLnN0eWxlc0xpc3QucHVzaChzdHlsZU9iKTtcclxuICB0aGlzLmFkZFRvQW5pbWF0ZWRDb250ZW50cyhkYXRhLCBlbGVtZW50RGF0YSk7XHJcbiAgcmV0dXJuIGVsZW1lbnREYXRhO1xyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVHcm91cEVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHZhciBlbGVtZW50RGF0YSA9IG5ldyBTaGFwZUdyb3VwRGF0YSgpO1xyXG4gIGlmIChkYXRhLmxuKSB7XHJcbiAgICBlbGVtZW50RGF0YS5nci5zZXRBdHRyaWJ1dGUoJ2lkJywgZGF0YS5sbik7XHJcbiAgfVxyXG4gIGlmIChkYXRhLmNsKSB7XHJcbiAgICBlbGVtZW50RGF0YS5nci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZGF0YS5jbCk7XHJcbiAgfVxyXG4gIGlmIChkYXRhLmJtKSB7XHJcbiAgICBlbGVtZW50RGF0YS5nci5zdHlsZVsnbWl4LWJsZW5kLW1vZGUnXSA9IGdldEJsZW5kTW9kZShkYXRhLmJtKTtcclxuICB9XHJcbiAgcmV0dXJuIGVsZW1lbnREYXRhO1xyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVUcmFuc2Zvcm1FbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRhaW5lcikge1xyXG4gIHZhciB0cmFuc2Zvcm1Qcm9wZXJ0eSA9IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSh0aGlzLCBkYXRhLCB0aGlzKTtcclxuICB2YXIgZWxlbWVudERhdGEgPSBuZXcgU1ZHVHJhbnNmb3JtRGF0YSh0cmFuc2Zvcm1Qcm9wZXJ0eSwgdHJhbnNmb3JtUHJvcGVydHkubywgY29udGFpbmVyKTtcclxuICB0aGlzLmFkZFRvQW5pbWF0ZWRDb250ZW50cyhkYXRhLCBlbGVtZW50RGF0YSk7XHJcbiAgcmV0dXJuIGVsZW1lbnREYXRhO1xyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFwZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgb3duVHJhbnNmb3JtZXJzLCBsZXZlbCkge1xyXG4gIHZhciB0eSA9IDQ7XHJcbiAgaWYgKGRhdGEudHkgPT09ICdyYycpIHtcclxuICAgIHR5ID0gNTtcclxuICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdlbCcpIHtcclxuICAgIHR5ID0gNjtcclxuICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdzcicpIHtcclxuICAgIHR5ID0gNztcclxuICB9XHJcbiAgdmFyIHNoYXBlUHJvcGVydHkgPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcywgZGF0YSwgdHksIHRoaXMpO1xyXG4gIHZhciBlbGVtZW50RGF0YSA9IG5ldyBTVkdTaGFwZURhdGEob3duVHJhbnNmb3JtZXJzLCBsZXZlbCwgc2hhcGVQcm9wZXJ0eSk7XHJcbiAgdGhpcy5zaGFwZXMucHVzaChlbGVtZW50RGF0YSk7XHJcbiAgdGhpcy5hZGRTaGFwZVRvTW9kaWZpZXJzKGVsZW1lbnREYXRhKTtcclxuICB0aGlzLmFkZFRvQW5pbWF0ZWRDb250ZW50cyhkYXRhLCBlbGVtZW50RGF0YSk7XHJcbiAgcmV0dXJuIGVsZW1lbnREYXRhO1xyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5hZGRUb0FuaW1hdGVkQ29udGVudHMgPSBmdW5jdGlvbiAoZGF0YSwgZWxlbWVudCkge1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgbGVuID0gdGhpcy5hbmltYXRlZENvbnRlbnRzLmxlbmd0aDtcclxuICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgaWYgKHRoaXMuYW5pbWF0ZWRDb250ZW50c1tpXS5lbGVtZW50ID09PSBlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGkgKz0gMTtcclxuICB9XHJcbiAgdGhpcy5hbmltYXRlZENvbnRlbnRzLnB1c2goe1xyXG4gICAgZm46IFNWR0VsZW1lbnRzUmVuZGVyZXIuY3JlYXRlUmVuZGVyRnVuY3Rpb24oZGF0YSksXHJcbiAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgZGF0YTogZGF0YSxcclxuICB9KTtcclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuc2V0RWxlbWVudFN0eWxlcyA9IGZ1bmN0aW9uIChlbGVtZW50RGF0YSkge1xyXG4gIHZhciBhcnIgPSBlbGVtZW50RGF0YS5zdHlsZXM7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xyXG4gIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgIGlmICghdGhpcy5zdHlsZXNMaXN0W2pdLmNsb3NlZCkge1xyXG4gICAgICBhcnIucHVzaCh0aGlzLnN0eWxlc0xpc3Rbal0pO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVsb2FkU2hhcGVzID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuaXRlbXNEYXRhLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIHRoaXMucHJldlZpZXdEYXRhW2ldID0gdGhpcy5pdGVtc0RhdGFbaV07XHJcbiAgfVxyXG4gIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0aGlzLmxheWVyRWxlbWVudCwgMCwgW10sIHRydWUpO1xyXG4gIHRoaXMuZmlsdGVyVW5pcXVlU2hhcGVzKCk7XHJcbiAgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLmdldFZhbHVlKCk7XHJcbiAgfVxyXG4gIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XHJcbn07XHJcblxyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLnNlYXJjaFNoYXBlcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZW1zRGF0YSwgcHJldlZpZXdEYXRhLCBjb250YWluZXIsIGxldmVsLCB0cmFuc2Zvcm1lcnMsIHJlbmRlcikge1xyXG4gIHZhciBvd25UcmFuc2Zvcm1lcnMgPSBbXS5jb25jYXQodHJhbnNmb3JtZXJzKTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gYXJyLmxlbmd0aCAtIDE7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW47XHJcbiAgdmFyIG93blN0eWxlcyA9IFtdO1xyXG4gIHZhciBvd25Nb2RpZmllcnMgPSBbXTtcclxuICB2YXIgY3VycmVudFRyYW5zZm9ybTtcclxuICB2YXIgbW9kaWZpZXI7XHJcbiAgdmFyIHByb2Nlc3NlZFBvcztcclxuICBmb3IgKGkgPSBsZW47IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICBwcm9jZXNzZWRQb3MgPSB0aGlzLnNlYXJjaFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldKTtcclxuICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XHJcbiAgICAgIGFycltpXS5fcmVuZGVyID0gcmVuZGVyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaXRlbXNEYXRhW2ldID0gcHJldlZpZXdEYXRhW3Byb2Nlc3NlZFBvcyAtIDFdO1xyXG4gICAgfVxyXG4gICAgaWYgKGFycltpXS50eSA9PT0gJ2ZsJyB8fCBhcnJbaV0udHkgPT09ICdzdCcgfHwgYXJyW2ldLnR5ID09PSAnZ2YnIHx8IGFycltpXS50eSA9PT0gJ2dzJykge1xyXG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xyXG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlU3R5bGVFbGVtZW50KGFycltpXSwgbGV2ZWwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGl0ZW1zRGF0YVtpXS5zdHlsZS5jbG9zZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYXJyW2ldLl9yZW5kZXIpIHtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaXRlbXNEYXRhW2ldLnN0eWxlLnBFbGVtKTtcclxuICAgICAgfVxyXG4gICAgICBvd25TdHlsZXMucHVzaChpdGVtc0RhdGFbaV0uc3R5bGUpO1xyXG4gICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdncicpIHtcclxuICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcclxuICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZUdyb3VwRWxlbWVudChhcnJbaV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGpMZW4gPSBpdGVtc0RhdGFbaV0uaXQubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGFbal0gPSBpdGVtc0RhdGFbaV0uaXRbal07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2VhcmNoU2hhcGVzKGFycltpXS5pdCwgaXRlbXNEYXRhW2ldLml0LCBpdGVtc0RhdGFbaV0ucHJldlZpZXdEYXRhLCBpdGVtc0RhdGFbaV0uZ3IsIGxldmVsICsgMSwgb3duVHJhbnNmb3JtZXJzLCByZW5kZXIpO1xyXG4gICAgICBpZiAoYXJyW2ldLl9yZW5kZXIpIHtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaXRlbXNEYXRhW2ldLmdyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICd0cicpIHtcclxuICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcclxuICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQoYXJyW2ldLCBjb250YWluZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIGN1cnJlbnRUcmFuc2Zvcm0gPSBpdGVtc0RhdGFbaV0udHJhbnNmb3JtO1xyXG4gICAgICBvd25UcmFuc2Zvcm1lcnMucHVzaChjdXJyZW50VHJhbnNmb3JtKTtcclxuICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnc2gnIHx8IGFycltpXS50eSA9PT0gJ3JjJyB8fCBhcnJbaV0udHkgPT09ICdlbCcgfHwgYXJyW2ldLnR5ID09PSAnc3InKSB7XHJcbiAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XHJcbiAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVTaGFwZUVsZW1lbnQoYXJyW2ldLCBvd25UcmFuc2Zvcm1lcnMsIGxldmVsKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNldEVsZW1lbnRTdHlsZXMoaXRlbXNEYXRhW2ldKTtcclxuICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAndG0nIHx8IGFycltpXS50eSA9PT0gJ3JkJyB8fCBhcnJbaV0udHkgPT09ICdtcycgfHwgYXJyW2ldLnR5ID09PSAncGInKSB7XHJcbiAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XHJcbiAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xyXG4gICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyW2ldKTtcclxuICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcclxuICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xyXG4gICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIG93bk1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAncnAnKSB7XHJcbiAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XHJcbiAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xyXG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IG1vZGlmaWVyO1xyXG4gICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyLCBpLCBpdGVtc0RhdGEpO1xyXG4gICAgICAgIHRoaXMuc2hhcGVNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgcmVuZGVyID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbW9kaWZpZXIgPSBpdGVtc0RhdGFbaV07XHJcbiAgICAgICAgbW9kaWZpZXIuY2xvc2VkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBvd25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkZFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldLCBpICsgMSk7XHJcbiAgfVxyXG4gIGxlbiA9IG93blN0eWxlcy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBvd25TdHlsZXNbaV0uY2xvc2VkID0gdHJ1ZTtcclxuICB9XHJcbiAgbGVuID0gb3duTW9kaWZpZXJzLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIG93bk1vZGlmaWVyc1tpXS5jbG9zZWQgPSB0cnVlO1xyXG4gIH1cclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICB0aGlzLnN0eWxlc0xpc3RbaV0ucmVzZXQoKTtcclxuICB9XHJcbiAgdGhpcy5yZW5kZXJTaGFwZSgpO1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmICh0aGlzLnN0eWxlc0xpc3RbaV0uX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgaWYgKHRoaXMuc3R5bGVzTGlzdFtpXS5tc0VsZW0pIHtcclxuICAgICAgICB0aGlzLnN0eWxlc0xpc3RbaV0ubXNFbGVtLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMuc3R5bGVzTGlzdFtpXS5kKTtcclxuICAgICAgICAvLyBBZGRpbmcgTTAgMCBmaXhlcyBzYW1lIG1hc2sgYnVnIG9uIGFsbCBicm93c2Vyc1xyXG4gICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5kID0gJ00wIDAnICsgdGhpcy5zdHlsZXNMaXN0W2ldLmQ7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zdHlsZXNMaXN0W2ldLnBFbGVtLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMuc3R5bGVzTGlzdFtpXS5kIHx8ICdNMCAwJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTaGFwZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5hbmltYXRlZENvbnRlbnRzLmxlbmd0aDtcclxuICB2YXIgYW5pbWF0ZWRDb250ZW50O1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgYW5pbWF0ZWRDb250ZW50ID0gdGhpcy5hbmltYXRlZENvbnRlbnRzW2ldO1xyXG4gICAgaWYgKCh0aGlzLl9pc0ZpcnN0RnJhbWUgfHwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQuX2lzQW5pbWF0ZWQpICYmIGFuaW1hdGVkQ29udGVudC5kYXRhICE9PSB0cnVlKSB7XHJcbiAgICAgIGFuaW1hdGVkQ29udGVudC5mbihhbmltYXRlZENvbnRlbnQuZGF0YSwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQsIHRoaXMuX2lzRmlyc3RGcmFtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuZGVzdHJveUJhc2VFbGVtZW50KCk7XHJcbiAgdGhpcy5zaGFwZXNEYXRhID0gbnVsbDtcclxuICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlTlMgKi9cclxuXHJcbmZ1bmN0aW9uIFNWR1RpbnRGaWx0ZXIoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyKSB7XHJcbiAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcclxuICB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XHJcbiAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XHJcbiAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdsaW5lYXJSR0InKTtcclxuICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndmFsdWVzJywgJzAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAgMCAwIDEgMCcpO1xyXG4gIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdyZXN1bHQnLCAnZjEnKTtcclxuICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb2xvck1hdHJpeCk7XHJcbiAgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XHJcbiAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XHJcbiAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XHJcbiAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAnKTtcclxuICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgncmVzdWx0JywgJ2YyJyk7XHJcbiAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xyXG4gIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb2xvck1hdHJpeDtcclxuICBpZiAoZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLnYgIT09IDEwMCB8fCBmaWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAuaykge1xyXG4gICAgdmFyIGZlTWVyZ2UgPSBjcmVhdGVOUygnZmVNZXJnZScpO1xyXG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlTWVyZ2UpO1xyXG4gICAgdmFyIGZlTWVyZ2VOb2RlO1xyXG4gICAgZmVNZXJnZU5vZGUgPSBjcmVhdGVOUygnZmVNZXJnZU5vZGUnKTtcclxuICAgIGZlTWVyZ2VOb2RlLnNldEF0dHJpYnV0ZSgnaW4nLCAnU291cmNlR3JhcGhpYycpO1xyXG4gICAgZmVNZXJnZS5hcHBlbmRDaGlsZChmZU1lcmdlTm9kZSk7XHJcbiAgICBmZU1lcmdlTm9kZSA9IGNyZWF0ZU5TKCdmZU1lcmdlTm9kZScpO1xyXG4gICAgZmVNZXJnZU5vZGUuc2V0QXR0cmlidXRlKCdpbicsICdmMicpO1xyXG4gICAgZmVNZXJnZS5hcHBlbmRDaGlsZChmZU1lcmdlTm9kZSk7XHJcbiAgfVxyXG59XHJcblxyXG5TVkdUaW50RmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xyXG4gIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xyXG4gICAgdmFyIGNvbG9yQmxhY2sgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52O1xyXG4gICAgdmFyIGNvbG9yV2hpdGUgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52O1xyXG4gICAgdmFyIG9wYWNpdHkgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52IC8gMTAwO1xyXG4gICAgdGhpcy5tYXRyaXhGaWx0ZXIuc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAoY29sb3JXaGl0ZVswXSAtIGNvbG9yQmxhY2tbMF0pICsgJyAwIDAgMCAnICsgY29sb3JCbGFja1swXSArICcgJyArIChjb2xvcldoaXRlWzFdIC0gY29sb3JCbGFja1sxXSkgKyAnIDAgMCAwICcgKyBjb2xvckJsYWNrWzFdICsgJyAnICsgKGNvbG9yV2hpdGVbMl0gLSBjb2xvckJsYWNrWzJdKSArICcgMCAwIDAgJyArIGNvbG9yQmxhY2tbMl0gKyAnIDAgMCAwICcgKyBvcGFjaXR5ICsgJyAwJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZU5TICovXHJcblxyXG5mdW5jdGlvbiBTVkdGaWxsRmlsdGVyKGZpbHRlciwgZmlsdGVyTWFuYWdlcikge1xyXG4gIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XHJcbiAgdmFyIGZlQ29sb3JNYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xyXG4gIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xyXG4gIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xyXG4gIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwJyk7XHJcbiAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xyXG4gIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb2xvck1hdHJpeDtcclxufVxyXG5TVkdGaWxsRmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xyXG4gIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xyXG4gICAgdmFyIGNvbG9yID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudjtcclxuICAgIHZhciBvcGFjaXR5ID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzZdLnAudjtcclxuICAgIHRoaXMubWF0cml4RmlsdGVyLnNldEF0dHJpYnV0ZSgndmFsdWVzJywgJzAgMCAwIDAgJyArIGNvbG9yWzBdICsgJyAwIDAgMCAwICcgKyBjb2xvclsxXSArICcgMCAwIDAgMCAnICsgY29sb3JbMl0gKyAnIDAgMCAwICcgKyBvcGFjaXR5ICsgJyAwJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZU5TICovXHJcblxyXG5mdW5jdGlvbiBTVkdHYXVzc2lhbkJsdXJFZmZlY3QoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyKSB7XHJcbiAgLy8gT3V0c2V0IHRoZSBmaWx0ZXIgcmVnaW9uIGJ5IDEwMCUgb24gYWxsIHNpZGVzIHRvIGFjY29tbW9kYXRlIGJsdXIgZXhwYW5zaW9uLlxyXG4gIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3gnLCAnLTEwMCUnKTtcclxuICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd5JywgJy0xMDAlJyk7XHJcbiAgZmlsdGVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMzAwJScpO1xyXG4gIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICczMDAlJyk7XHJcblxyXG4gIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XHJcbiAgdmFyIGZlR2F1c3NpYW5CbHVyID0gY3JlYXRlTlMoJ2ZlR2F1c3NpYW5CbHVyJyk7XHJcbiAgZmlsdGVyLmFwcGVuZENoaWxkKGZlR2F1c3NpYW5CbHVyKTtcclxuICB0aGlzLmZlR2F1c3NpYW5CbHVyID0gZmVHYXVzc2lhbkJsdXI7XHJcbn1cclxuXHJcblNWR0dhdXNzaWFuQmx1ckVmZmVjdC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcclxuICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpIHtcclxuICAgIC8vIEVtcGlyaWNhbCB2YWx1ZSwgbWF0Y2hpbmcgQUUncyBibHVyIGFwcGVhcmFuY2UuXHJcbiAgICB2YXIga0JsdXJyaW5lc3NUb1NpZ21hID0gMC4zO1xyXG4gICAgdmFyIHNpZ21hID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAudiAqIGtCbHVycmluZXNzVG9TaWdtYTtcclxuXHJcbiAgICAvLyBEaW1lbnNpb25zIG1hcHBpbmc6XHJcbiAgICAvL1xyXG4gICAgLy8gICAxIC0+IGhvcml6b250YWwgJiB2ZXJ0aWNhbFxyXG4gICAgLy8gICAyIC0+IGhvcml6b250YWwgb25seVxyXG4gICAgLy8gICAzIC0+IHZlcnRpY2FsIG9ubHlcclxuICAgIC8vXHJcbiAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnY7XHJcbiAgICB2YXIgc2lnbWFYID0gKGRpbWVuc2lvbnMgPT0gMykgPyAwIDogc2lnbWE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcbiAgICB2YXIgc2lnbWFZID0gKGRpbWVuc2lvbnMgPT0gMikgPyAwIDogc2lnbWE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcblxyXG4gICAgdGhpcy5mZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsIHNpZ21hWCArICcgJyArIHNpZ21hWSk7XHJcblxyXG4gICAgLy8gUmVwZWF0IGVkZ2VzIG1hcHBpbmc6XHJcbiAgICAvL1xyXG4gICAgLy8gICAwIC0+IG9mZiAtPiBkdXBsaWNhdGVcclxuICAgIC8vICAgMSAtPiBvbiAgLT4gd3JhcFxyXG4gICAgdmFyIGVkZ2VNb2RlID0gKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLnYgPT0gMSkgPyAnd3JhcCcgOiAnZHVwbGljYXRlJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgIHRoaXMuZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdlZGdlTW9kZScsIGVkZ2VNb2RlKTtcclxuICB9XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlTlMsIGNyZWF0ZUVsZW1lbnRJRCwgbG9jYXRpb25IcmVmLCBibUZsb29yICovXHJcblxyXG5mdW5jdGlvbiBTVkdTdHJva2VFZmZlY3QoZWxlbSwgZmlsdGVyTWFuYWdlcikge1xyXG4gIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xyXG4gIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgdGhpcy5wYXRocyA9IFtdO1xyXG59XHJcblxyXG5TVkdTdHJva2VFZmZlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGVsZW1DaGlsZHJlbiA9IHRoaXMuZWxlbS5sYXllckVsZW1lbnQuY2hpbGRyZW4gfHwgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5jaGlsZE5vZGVzO1xyXG4gIHZhciBwYXRoO1xyXG4gIHZhciBncm91cFBhdGg7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbjtcclxuICBpZiAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzFdLnAudiA9PT0gMSkge1xyXG4gICAgbGVuID0gdGhpcy5lbGVtLm1hc2tNYW5hZ2VyLm1hc2tzUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgICBpID0gMDtcclxuICB9IGVsc2Uge1xyXG4gICAgaSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnYgLSAxO1xyXG4gICAgbGVuID0gaSArIDE7XHJcbiAgfVxyXG4gIGdyb3VwUGF0aCA9IGNyZWF0ZU5TKCdnJyk7XHJcbiAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XHJcbiAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKTtcclxuICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIDEpO1xyXG4gIGZvciAoaTsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBwYXRoID0gY3JlYXRlTlMoJ3BhdGgnKTtcclxuICAgIGdyb3VwUGF0aC5hcHBlbmRDaGlsZChwYXRoKTtcclxuICAgIHRoaXMucGF0aHMucHVzaCh7IHA6IHBhdGgsIG06IGkgfSk7XHJcbiAgfVxyXG4gIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMykge1xyXG4gICAgdmFyIG1hc2sgPSBjcmVhdGVOUygnbWFzaycpO1xyXG4gICAgdmFyIGlkID0gY3JlYXRlRWxlbWVudElEKCk7XHJcbiAgICBtYXNrLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XHJcbiAgICBtYXNrLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2FscGhhJyk7XHJcbiAgICBtYXNrLmFwcGVuZENoaWxkKGdyb3VwUGF0aCk7XHJcbiAgICB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKG1hc2spO1xyXG4gICAgdmFyIGcgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgZy5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBpZCArICcpJyk7XHJcbiAgICB3aGlsZSAoZWxlbUNoaWxkcmVuWzBdKSB7XHJcbiAgICAgIGcuYXBwZW5kQ2hpbGQoZWxlbUNoaWxkcmVuWzBdKTtcclxuICAgIH1cclxuICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoZyk7XHJcbiAgICB0aGlzLm1hc2tlciA9IG1hc2s7XHJcbiAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnI2ZmZicpO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzEwXS5wLnYgPT09IDEgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzEwXS5wLnYgPT09IDIpIHtcclxuICAgIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMikge1xyXG4gICAgICBlbGVtQ2hpbGRyZW4gPSB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LmNoaWxkcmVuIHx8IHRoaXMuZWxlbS5sYXllckVsZW1lbnQuY2hpbGROb2RlcztcclxuICAgICAgd2hpbGUgKGVsZW1DaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1DaGlsZHJlblswXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoZ3JvdXBQYXRoKTtcclxuICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdtYXNrJyk7XHJcbiAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnI2ZmZicpO1xyXG4gIH1cclxuICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICB0aGlzLnBhdGhNYXNrZXIgPSBncm91cFBhdGg7XHJcbn07XHJcblxyXG5TVkdTdHJva2VFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XHJcbiAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICB9XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMucGF0aHMubGVuZ3RoO1xyXG4gIHZhciBtYXNrO1xyXG4gIHZhciBwYXRoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgaWYgKHRoaXMucGF0aHNbaV0ubSAhPT0gLTEpIHtcclxuICAgICAgbWFzayA9IHRoaXMuZWxlbS5tYXNrTWFuYWdlci52aWV3RGF0YVt0aGlzLnBhdGhzW2ldLm1dO1xyXG4gICAgICBwYXRoID0gdGhpcy5wYXRoc1tpXS5wO1xyXG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYgfHwgbWFzay5wcm9wLl9tZGYpIHtcclxuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIG1hc2subGFzdFBhdGgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOV0ucC5fbWRmIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLl9tZGYgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzddLnAuX21kZiB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC5fbWRmIHx8IG1hc2sucHJvcC5fbWRmKSB7XHJcbiAgICAgICAgdmFyIGRhc2hhcnJheVZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC52ICE9PSAwIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s4XS5wLnYgIT09IDEwMCkge1xyXG4gICAgICAgICAgdmFyIHMgPSBNYXRoLm1pbih0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC52LCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC52KSAqIDAuMDE7XHJcbiAgICAgICAgICB2YXIgZSA9IE1hdGgubWF4KHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s3XS5wLnYsIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s4XS5wLnYpICogMC4wMTtcclxuICAgICAgICAgIHZhciBsID0gcGF0aC5nZXRUb3RhbExlbmd0aCgpO1xyXG4gICAgICAgICAgZGFzaGFycmF5VmFsdWUgPSAnMCAwIDAgJyArIGwgKiBzICsgJyAnO1xyXG4gICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsICogKGUgLSBzKTtcclxuICAgICAgICAgIHZhciBzZWdtZW50ID0gMSArIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgKiAyICogdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudiAqIDAuMDE7XHJcbiAgICAgICAgICB2YXIgdW5pdHMgPSBNYXRoLmZsb29yKGxpbmVMZW5ndGggLyBzZWdtZW50KTtcclxuICAgICAgICAgIHZhciBqO1xyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHVuaXRzOyBqICs9IDEpIHtcclxuICAgICAgICAgICAgZGFzaGFycmF5VmFsdWUgKz0gJzEgJyArIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgKiAyICogdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudiAqIDAuMDEgKyAnICc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkYXNoYXJyYXlWYWx1ZSArPSAnMCAnICsgbCAqIDEwICsgJyAwIDAnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkYXNoYXJyYXlWYWx1ZSA9ICcxICcgKyB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC52ICogMiAqIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s5XS5wLnYgKiAwLjAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIGRhc2hhcnJheVZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZikge1xyXG4gICAgdGhpcy5wYXRoTWFza2VyLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAqIDIpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s2XS5wLl9tZGYpIHtcclxuICAgIHRoaXMucGF0aE1hc2tlci5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNl0ucC52KTtcclxuICB9XHJcbiAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAxIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAyKSB7XHJcbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzNdLnAuX21kZikge1xyXG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC52O1xyXG4gICAgICB0aGlzLnBhdGhNYXNrZXIuc2V0QXR0cmlidXRlKCdzdHJva2UnLCAncmdiKCcgKyBibUZsb29yKGNvbG9yWzBdICogMjU1KSArICcsJyArIGJtRmxvb3IoY29sb3JbMV0gKiAyNTUpICsgJywnICsgYm1GbG9vcihjb2xvclsyXSAqIDI1NSkgKyAnKScpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVOUyAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHVHJpdG9uZUZpbHRlcihmaWx0ZXIsIGZpbHRlck1hbmFnZXIpIHtcclxuICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xyXG4gIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcclxuICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcclxuICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2xpbmVhclJHQicpO1xyXG4gIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMCAwIDAgMSAwJyk7XHJcbiAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsICdmMScpO1xyXG4gIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbG9yTWF0cml4KTtcclxuICB2YXIgZmVDb21wb25lbnRUcmFuc2ZlciA9IGNyZWF0ZU5TKCdmZUNvbXBvbmVudFRyYW5zZmVyJyk7XHJcbiAgZmVDb21wb25lbnRUcmFuc2Zlci5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XHJcbiAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xyXG4gIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb21wb25lbnRUcmFuc2ZlcjtcclxuICB2YXIgZmVGdW5jUiA9IGNyZWF0ZU5TKCdmZUZ1bmNSJyk7XHJcbiAgZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcclxuICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZENoaWxkKGZlRnVuY1IpO1xyXG4gIHRoaXMuZmVGdW5jUiA9IGZlRnVuY1I7XHJcbiAgdmFyIGZlRnVuY0cgPSBjcmVhdGVOUygnZmVGdW5jRycpO1xyXG4gIGZlRnVuY0cuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RhYmxlJyk7XHJcbiAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmRDaGlsZChmZUZ1bmNHKTtcclxuICB0aGlzLmZlRnVuY0cgPSBmZUZ1bmNHO1xyXG4gIHZhciBmZUZ1bmNCID0gY3JlYXRlTlMoJ2ZlRnVuY0InKTtcclxuICBmZUZ1bmNCLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xyXG4gIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jQik7XHJcbiAgdGhpcy5mZUZ1bmNCID0gZmVGdW5jQjtcclxufVxyXG5cclxuU1ZHVHJpdG9uZUZpbHRlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcclxuICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpIHtcclxuICAgIHZhciBjb2xvcjEgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52O1xyXG4gICAgdmFyIGNvbG9yMiA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnY7XHJcbiAgICB2YXIgY29sb3IzID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudjtcclxuICAgIHZhciB0YWJsZVIgPSBjb2xvcjNbMF0gKyAnICcgKyBjb2xvcjJbMF0gKyAnICcgKyBjb2xvcjFbMF07XHJcbiAgICB2YXIgdGFibGVHID0gY29sb3IzWzFdICsgJyAnICsgY29sb3IyWzFdICsgJyAnICsgY29sb3IxWzFdO1xyXG4gICAgdmFyIHRhYmxlQiA9IGNvbG9yM1syXSArICcgJyArIGNvbG9yMlsyXSArICcgJyArIGNvbG9yMVsyXTtcclxuICAgIHRoaXMuZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdGFibGVSKTtcclxuICAgIHRoaXMuZmVGdW5jRy5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdGFibGVHKTtcclxuICAgIHRoaXMuZmVGdW5jQi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdGFibGVCKTtcclxuICAgIC8vIHZhciBvcGFjaXR5ID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudi8xMDA7XHJcbiAgICAvLyB0aGlzLm1hdHJpeEZpbHRlci5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsKGNvbG9yV2hpdGVbMF0tIGNvbG9yQmxhY2tbMF0pKycgMCAwIDAgJysgY29sb3JCbGFja1swXSArJyAnKyAoY29sb3JXaGl0ZVsxXS0gY29sb3JCbGFja1sxXSkgKycgMCAwIDAgJysgY29sb3JCbGFja1sxXSArJyAnKyAoY29sb3JXaGl0ZVsyXS0gY29sb3JCbGFja1syXSkgKycgMCAwIDAgJysgY29sb3JCbGFja1syXSArJyAwIDAgMCAnICsgb3BhY2l0eSArICcgMCcpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVOUyAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHUHJvTGV2ZWxzRmlsdGVyKGZpbHRlciwgZmlsdGVyTWFuYWdlcikge1xyXG4gIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XHJcbiAgdmFyIGVmZmVjdEVsZW1lbnRzID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzO1xyXG4gIHZhciBmZUNvbXBvbmVudFRyYW5zZmVyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcclxuXHJcbiAgaWYgKGVmZmVjdEVsZW1lbnRzWzEwXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTBdLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1sxMV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzExXS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMTJdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxMl0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzEzXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTNdLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1sxNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzE0XS5wLnYgIT09IDEpIHtcclxuICAgIHRoaXMuZmVGdW5jUiA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNSJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgfVxyXG4gIGlmIChlZmZlY3RFbGVtZW50c1sxN10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzE3XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMThdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxOF0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzE5XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTldLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syMF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzIwXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMjFdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syMV0ucC52ICE9PSAxKSB7XHJcbiAgICB0aGlzLmZlRnVuY0cgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jRycsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xyXG4gIH1cclxuICBpZiAoZWZmZWN0RWxlbWVudHNbMjRdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syNF0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzI1XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjVdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syNl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMjddLnAuayB8fCBlZmZlY3RFbGVtZW50c1syN10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzI4XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjhdLnAudiAhPT0gMSkge1xyXG4gICAgdGhpcy5mZUZ1bmNCID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY0InLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcclxuICB9XHJcbiAgaWYgKGVmZmVjdEVsZW1lbnRzWzMxXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMzFdLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1szMl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzMyXS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMzNdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szM10ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzM0XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMzRdLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1szNV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzM1XS5wLnYgIT09IDEpIHtcclxuICAgIHRoaXMuZmVGdW5jQSA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNBJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy5mZUZ1bmNSIHx8IHRoaXMuZmVGdW5jRyB8fCB0aGlzLmZlRnVuY0IgfHwgdGhpcy5mZUZ1bmNBKSB7XHJcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcclxuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcclxuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIgPSBjcmVhdGVOUygnZmVDb21wb25lbnRUcmFuc2ZlcicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVmZmVjdEVsZW1lbnRzWzNdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1s1XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbNV0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzZdLnAuayB8fCBlZmZlY3RFbGVtZW50c1s2XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbN10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAudiAhPT0gMSkge1xyXG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XHJcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgICB0aGlzLmZlRnVuY1JDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNSJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgICB0aGlzLmZlRnVuY0dDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNHJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgICB0aGlzLmZlRnVuY0JDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNCJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgfVxyXG59XHJcblxyXG5TVkdQcm9MZXZlbHNGaWx0ZXIucHJvdG90eXBlLmNyZWF0ZUZlRnVuYyA9IGZ1bmN0aW9uICh0eXBlLCBmZUNvbXBvbmVudFRyYW5zZmVyKSB7XHJcbiAgdmFyIGZlRnVuYyA9IGNyZWF0ZU5TKHR5cGUpO1xyXG4gIGZlRnVuYy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcclxuICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZENoaWxkKGZlRnVuYyk7XHJcbiAgcmV0dXJuIGZlRnVuYztcclxufTtcclxuXHJcblNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUuZ2V0VGFibGVWYWx1ZSA9IGZ1bmN0aW9uIChpbnB1dEJsYWNrLCBpbnB1dFdoaXRlLCBnYW1tYSwgb3V0cHV0QmxhY2ssIG91dHB1dFdoaXRlKSB7XHJcbiAgdmFyIGNudCA9IDA7XHJcbiAgdmFyIHNlZ21lbnRzID0gMjU2O1xyXG4gIHZhciBwZXJjO1xyXG4gIHZhciBtaW4gPSBNYXRoLm1pbihpbnB1dEJsYWNrLCBpbnB1dFdoaXRlKTtcclxuICB2YXIgbWF4ID0gTWF0aC5tYXgoaW5wdXRCbGFjaywgaW5wdXRXaGl0ZSk7XHJcbiAgdmFyIHRhYmxlID0gQXJyYXkuY2FsbChudWxsLCB7IGxlbmd0aDogc2VnbWVudHMgfSk7XHJcbiAgdmFyIGNvbG9yVmFsdWU7XHJcbiAgdmFyIHBvcyA9IDA7XHJcbiAgdmFyIG91dHB1dERlbHRhID0gb3V0cHV0V2hpdGUgLSBvdXRwdXRCbGFjaztcclxuICB2YXIgaW5wdXREZWx0YSA9IGlucHV0V2hpdGUgLSBpbnB1dEJsYWNrO1xyXG4gIHdoaWxlIChjbnQgPD0gMjU2KSB7XHJcbiAgICBwZXJjID0gY250IC8gMjU2O1xyXG4gICAgaWYgKHBlcmMgPD0gbWluKSB7XHJcbiAgICAgIGNvbG9yVmFsdWUgPSBpbnB1dERlbHRhIDwgMCA/IG91dHB1dFdoaXRlIDogb3V0cHV0QmxhY2s7XHJcbiAgICB9IGVsc2UgaWYgKHBlcmMgPj0gbWF4KSB7XHJcbiAgICAgIGNvbG9yVmFsdWUgPSBpbnB1dERlbHRhIDwgMCA/IG91dHB1dEJsYWNrIDogb3V0cHV0V2hpdGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb2xvclZhbHVlID0gKG91dHB1dEJsYWNrICsgb3V0cHV0RGVsdGEgKiBNYXRoLnBvdygocGVyYyAtIGlucHV0QmxhY2spIC8gaW5wdXREZWx0YSwgMSAvIGdhbW1hKSk7XHJcbiAgICB9XHJcbiAgICB0YWJsZVtwb3NdID0gY29sb3JWYWx1ZTtcclxuICAgIHBvcyArPSAxO1xyXG4gICAgY250ICs9IDI1NiAvIChzZWdtZW50cyAtIDEpO1xyXG4gIH1cclxuICByZXR1cm4gdGFibGUuam9pbignICcpO1xyXG59O1xyXG5cclxuU1ZHUHJvTGV2ZWxzRmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xyXG4gIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xyXG4gICAgdmFyIHZhbDtcclxuICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50cztcclxuICAgIGlmICh0aGlzLmZlRnVuY1JDb21wb3NlZCAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbM10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1s1XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbNl0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAuX21kZikpIHtcclxuICAgICAgdmFsID0gdGhpcy5nZXRUYWJsZVZhbHVlKGVmZmVjdEVsZW1lbnRzWzNdLnAudiwgZWZmZWN0RWxlbWVudHNbNF0ucC52LCBlZmZlY3RFbGVtZW50c1s1XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzZdLnAudiwgZWZmZWN0RWxlbWVudHNbN10ucC52KTtcclxuICAgICAgdGhpcy5mZUZ1bmNSQ29tcG9zZWQuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHZhbCk7XHJcbiAgICAgIHRoaXMuZmVGdW5jR0NvbXBvc2VkLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xyXG4gICAgICB0aGlzLmZlRnVuY0JDb21wb3NlZC5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5mZUZ1bmNSICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1sxMF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzExXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMTJdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxM10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzE0XS5wLl9tZGYpKSB7XHJcbiAgICAgIHZhbCA9IHRoaXMuZ2V0VGFibGVWYWx1ZShlZmZlY3RFbGVtZW50c1sxMF0ucC52LCBlZmZlY3RFbGVtZW50c1sxMV0ucC52LCBlZmZlY3RFbGVtZW50c1sxMl0ucC52LCBlZmZlY3RFbGVtZW50c1sxM10ucC52LCBlZmZlY3RFbGVtZW50c1sxNF0ucC52KTtcclxuICAgICAgdGhpcy5mZUZ1bmNSLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmZlRnVuY0cgJiYgKGZvcmNlUmVuZGVyIHx8IGVmZmVjdEVsZW1lbnRzWzE3XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMThdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxOV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzIwXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjFdLnAuX21kZikpIHtcclxuICAgICAgdmFsID0gdGhpcy5nZXRUYWJsZVZhbHVlKGVmZmVjdEVsZW1lbnRzWzE3XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzE4XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzE5XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzIwXS5wLnYsIGVmZmVjdEVsZW1lbnRzWzIxXS5wLnYpO1xyXG4gICAgICB0aGlzLmZlRnVuY0cuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHZhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZmVGdW5jQiAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMjRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syNV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjddLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syOF0ucC5fbWRmKSkge1xyXG4gICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMjRdLnAudiwgZWZmZWN0RWxlbWVudHNbMjVdLnAudiwgZWZmZWN0RWxlbWVudHNbMjZdLnAudiwgZWZmZWN0RWxlbWVudHNbMjddLnAudiwgZWZmZWN0RWxlbWVudHNbMjhdLnAudik7XHJcbiAgICAgIHRoaXMuZmVGdW5jQi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5mZUZ1bmNBICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1szMV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzMyXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMzNdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1szNF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzM1XS5wLl9tZGYpKSB7XHJcbiAgICAgIHZhbCA9IHRoaXMuZ2V0VGFibGVWYWx1ZShlZmZlY3RFbGVtZW50c1szMV0ucC52LCBlZmZlY3RFbGVtZW50c1szMl0ucC52LCBlZmZlY3RFbGVtZW50c1szM10ucC52LCBlZmZlY3RFbGVtZW50c1szNF0ucC52LCBlZmZlY3RFbGVtZW50c1szNV0ucC52KTtcclxuICAgICAgdGhpcy5mZUZ1bmNBLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVOUywgcmdiVG9IZXgsIGRlZ1RvUmFkcyAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHRHJvcFNoYWRvd0VmZmVjdChmaWx0ZXIsIGZpbHRlck1hbmFnZXIpIHtcclxuICB2YXIgZmlsdGVyU2l6ZSA9IGZpbHRlck1hbmFnZXIuY29udGFpbmVyLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmZpbHRlclNpemU7XHJcbiAgZmlsdGVyLnNldEF0dHJpYnV0ZSgneCcsIGZpbHRlclNpemUueCk7XHJcbiAgZmlsdGVyLnNldEF0dHJpYnV0ZSgneScsIGZpbHRlclNpemUueSk7XHJcbiAgZmlsdGVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBmaWx0ZXJTaXplLndpZHRoKTtcclxuICBmaWx0ZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBmaWx0ZXJTaXplLmhlaWdodCk7XHJcbiAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcclxuXHJcbiAgdmFyIGZlR2F1c3NpYW5CbHVyID0gY3JlYXRlTlMoJ2ZlR2F1c3NpYW5CbHVyJyk7XHJcbiAgZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdpbicsICdTb3VyY2VBbHBoYScpO1xyXG4gIGZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgJ2Ryb3Bfc2hhZG93XzEnKTtcclxuICBmZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsICcwJyk7XHJcbiAgdGhpcy5mZUdhdXNzaWFuQmx1ciA9IGZlR2F1c3NpYW5CbHVyO1xyXG4gIGZpbHRlci5hcHBlbmRDaGlsZChmZUdhdXNzaWFuQmx1cik7XHJcblxyXG4gIHZhciBmZU9mZnNldCA9IGNyZWF0ZU5TKCdmZU9mZnNldCcpO1xyXG4gIGZlT2Zmc2V0LnNldEF0dHJpYnV0ZSgnZHgnLCAnMjUnKTtcclxuICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R5JywgJzAnKTtcclxuICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2luJywgJ2Ryb3Bfc2hhZG93XzEnKTtcclxuICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsICdkcm9wX3NoYWRvd18yJyk7XHJcbiAgdGhpcy5mZU9mZnNldCA9IGZlT2Zmc2V0O1xyXG4gIGZpbHRlci5hcHBlbmRDaGlsZChmZU9mZnNldCk7XHJcbiAgdmFyIGZlRmxvb2QgPSBjcmVhdGVOUygnZmVGbG9vZCcpO1xyXG4gIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdmbG9vZC1jb2xvcicsICcjMDBmZjAwJyk7XHJcbiAgZmVGbG9vZC5zZXRBdHRyaWJ1dGUoJ2Zsb29kLW9wYWNpdHknLCAnMScpO1xyXG4gIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdyZXN1bHQnLCAnZHJvcF9zaGFkb3dfMycpO1xyXG4gIHRoaXMuZmVGbG9vZCA9IGZlRmxvb2Q7XHJcbiAgZmlsdGVyLmFwcGVuZENoaWxkKGZlRmxvb2QpO1xyXG5cclxuICB2YXIgZmVDb21wb3NpdGUgPSBjcmVhdGVOUygnZmVDb21wb3NpdGUnKTtcclxuICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ2luJywgJ2Ryb3Bfc2hhZG93XzMnKTtcclxuICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ2luMicsICdkcm9wX3NoYWRvd18yJyk7XHJcbiAgZmVDb21wb3NpdGUuc2V0QXR0cmlidXRlKCdvcGVyYXRvcicsICdpbicpO1xyXG4gIGZlQ29tcG9zaXRlLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgJ2Ryb3Bfc2hhZG93XzQnKTtcclxuICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb3NpdGUpO1xyXG5cclxuICB2YXIgZmVNZXJnZSA9IGNyZWF0ZU5TKCdmZU1lcmdlJyk7XHJcbiAgZmlsdGVyLmFwcGVuZENoaWxkKGZlTWVyZ2UpO1xyXG4gIHZhciBmZU1lcmdlTm9kZTtcclxuICBmZU1lcmdlTm9kZSA9IGNyZWF0ZU5TKCdmZU1lcmdlTm9kZScpO1xyXG4gIGZlTWVyZ2UuYXBwZW5kQ2hpbGQoZmVNZXJnZU5vZGUpO1xyXG4gIGZlTWVyZ2VOb2RlID0gY3JlYXRlTlMoJ2ZlTWVyZ2VOb2RlJyk7XHJcbiAgZmVNZXJnZU5vZGUuc2V0QXR0cmlidXRlKCdpbicsICdTb3VyY2VHcmFwaGljJyk7XHJcbiAgdGhpcy5mZU1lcmdlTm9kZSA9IGZlTWVyZ2VOb2RlO1xyXG4gIHRoaXMuZmVNZXJnZSA9IGZlTWVyZ2U7XHJcbiAgdGhpcy5vcmlnaW5hbE5vZGVBZGRlZCA9IGZhbHNlO1xyXG4gIGZlTWVyZ2UuYXBwZW5kQ2hpbGQoZmVNZXJnZU5vZGUpO1xyXG59XHJcblxyXG5TVkdEcm9wU2hhZG93RWZmZWN0LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xyXG4gIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xyXG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLl9tZGYpIHtcclxuICAgICAgdGhpcy5mZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgLyA0KTtcclxuICAgIH1cclxuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC5fbWRmKSB7XHJcbiAgICAgIHZhciBjb2wgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52O1xyXG4gICAgICB0aGlzLmZlRmxvb2Quc2V0QXR0cmlidXRlKCdmbG9vZC1jb2xvcicsIHJnYlRvSGV4KE1hdGgucm91bmQoY29sWzBdICogMjU1KSwgTWF0aC5yb3VuZChjb2xbMV0gKiAyNTUpLCBNYXRoLnJvdW5kKGNvbFsyXSAqIDI1NSkpKTtcclxuICAgIH1cclxuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC5fbWRmKSB7XHJcbiAgICAgIHRoaXMuZmVGbG9vZC5zZXRBdHRyaWJ1dGUoJ2Zsb29kLW9wYWNpdHknLCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52IC8gMjU1KTtcclxuICAgIH1cclxuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC5fbWRmIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1szXS5wLl9tZGYpIHtcclxuICAgICAgdmFyIGRpc3RhbmNlID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzNdLnAudjtcclxuICAgICAgdmFyIGFuZ2xlID0gKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLnYgLSA5MCkgKiBkZWdUb1JhZHM7XHJcbiAgICAgIHZhciB4ID0gZGlzdGFuY2UgKiBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgIHZhciB5ID0gZGlzdGFuY2UgKiBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgIHRoaXMuZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdkeCcsIHgpO1xyXG4gICAgICB0aGlzLmZlT2Zmc2V0LnNldEF0dHJpYnV0ZSgnZHknLCB5KTtcclxuICAgIH1cclxuICAgIC8qIGlmKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s1XS5wLl9tZGYpe1xyXG4gICAgICAgICAgICBpZih0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNV0ucC52ID09PSAxICYmIHRoaXMub3JpZ2luYWxOb2RlQWRkZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmVNZXJnZS5yZW1vdmVDaGlsZCh0aGlzLmZlTWVyZ2VOb2RlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxOb2RlQWRkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s1XS5wLnYgPT09IDAgJiYgIXRoaXMub3JpZ2luYWxOb2RlQWRkZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmVNZXJnZS5hcHBlbmRDaGlsZCh0aGlzLmZlTWVyZ2VOb2RlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxOb2RlQWRkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSAqL1xyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVFbGVtZW50SUQsIGNyZWF0ZU5TICovXHJcblxyXG52YXIgX3N2Z01hdHRlU3ltYm9scyA9IFtdO1xyXG5cclxuZnVuY3Rpb24gU1ZHTWF0dGUzRWZmZWN0KGZpbHRlckVsZW0sIGZpbHRlck1hbmFnZXIsIGVsZW0pIHtcclxuICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcclxuICB0aGlzLmZpbHRlckVsZW0gPSBmaWx0ZXJFbGVtO1xyXG4gIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgZWxlbS5tYXR0ZUVsZW1lbnQgPSBjcmVhdGVOUygnZycpO1xyXG4gIGVsZW0ubWF0dGVFbGVtZW50LmFwcGVuZENoaWxkKGVsZW0ubGF5ZXJFbGVtZW50KTtcclxuICBlbGVtLm1hdHRlRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtLnRyYW5zZm9ybWVkRWxlbWVudCk7XHJcbiAgZWxlbS5iYXNlRWxlbWVudCA9IGVsZW0ubWF0dGVFbGVtZW50O1xyXG59XHJcblxyXG5TVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLmZpbmRTeW1ib2wgPSBmdW5jdGlvbiAobWFzaykge1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgbGVuID0gX3N2Z01hdHRlU3ltYm9scy5sZW5ndGg7XHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIGlmIChfc3ZnTWF0dGVTeW1ib2xzW2ldID09PSBtYXNrKSB7XHJcbiAgICAgIHJldHVybiBfc3ZnTWF0dGVTeW1ib2xzW2ldO1xyXG4gICAgfVxyXG4gICAgaSArPSAxO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcblNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUucmVwbGFjZUluUGFyZW50ID0gZnVuY3Rpb24gKG1hc2ssIHN5bWJvbElkKSB7XHJcbiAgdmFyIHBhcmVudE5vZGUgPSBtYXNrLmxheWVyRWxlbWVudC5wYXJlbnROb2RlO1xyXG4gIGlmICghcGFyZW50Tm9kZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgY2hpbGRyZW4gPSBwYXJlbnROb2RlLmNoaWxkcmVuO1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICBpZiAoY2hpbGRyZW5baV0gPT09IG1hc2subGF5ZXJFbGVtZW50KSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgaSArPSAxO1xyXG4gIH1cclxuICB2YXIgbmV4dENoaWxkO1xyXG4gIGlmIChpIDw9IGxlbiAtIDIpIHtcclxuICAgIG5leHRDaGlsZCA9IGNoaWxkcmVuW2kgKyAxXTtcclxuICB9XHJcbiAgdmFyIHVzZUVsZW0gPSBjcmVhdGVOUygndXNlJyk7XHJcbiAgdXNlRWxlbS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycgKyBzeW1ib2xJZCk7XHJcbiAgaWYgKG5leHRDaGlsZCkge1xyXG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodXNlRWxlbSwgbmV4dENoaWxkKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh1c2VFbGVtKTtcclxuICB9XHJcbn07XHJcblxyXG5TVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLnNldEVsZW1lbnRBc01hc2sgPSBmdW5jdGlvbiAoZWxlbSwgbWFzaykge1xyXG4gIGlmICghdGhpcy5maW5kU3ltYm9sKG1hc2spKSB7XHJcbiAgICB2YXIgc3ltYm9sSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuICAgIHZhciBtYXNrZXIgPSBjcmVhdGVOUygnbWFzaycpO1xyXG4gICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnaWQnLCBtYXNrLmxheWVySWQpO1xyXG4gICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2FscGhhJyk7XHJcbiAgICBfc3ZnTWF0dGVTeW1ib2xzLnB1c2gobWFzayk7XHJcbiAgICB2YXIgZGVmcyA9IGVsZW0uZ2xvYmFsRGF0YS5kZWZzO1xyXG4gICAgZGVmcy5hcHBlbmRDaGlsZChtYXNrZXIpO1xyXG4gICAgdmFyIHN5bWJvbCA9IGNyZWF0ZU5TKCdzeW1ib2wnKTtcclxuICAgIHN5bWJvbC5zZXRBdHRyaWJ1dGUoJ2lkJywgc3ltYm9sSWQpO1xyXG4gICAgdGhpcy5yZXBsYWNlSW5QYXJlbnQobWFzaywgc3ltYm9sSWQpO1xyXG4gICAgc3ltYm9sLmFwcGVuZENoaWxkKG1hc2subGF5ZXJFbGVtZW50KTtcclxuICAgIGRlZnMuYXBwZW5kQ2hpbGQoc3ltYm9sKTtcclxuICAgIHZhciB1c2VFbGVtID0gY3JlYXRlTlMoJ3VzZScpO1xyXG4gICAgdXNlRWxlbS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycgKyBzeW1ib2xJZCk7XHJcbiAgICBtYXNrZXIuYXBwZW5kQ2hpbGQodXNlRWxlbSk7XHJcbiAgICBtYXNrLmRhdGEuaGQgPSBmYWxzZTtcclxuICAgIG1hc2suc2hvdygpO1xyXG4gIH1cclxuICBlbGVtLnNldE1hdHRlKG1hc2subGF5ZXJJZCk7XHJcbn07XHJcblxyXG5TVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGluZCA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XHJcbiAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtLmNvbXAuZWxlbWVudHM7XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIGlmIChlbGVtZW50c1tpXSAmJiBlbGVtZW50c1tpXS5kYXRhLmluZCA9PT0gaW5kKSB7XHJcbiAgICAgIHRoaXMuc2V0RWxlbWVudEFzTWFzayh0aGlzLmVsZW0sIGVsZW1lbnRzW2ldKTtcclxuICAgIH1cclxuICAgIGkgKz0gMTtcclxuICB9XHJcbiAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbn07XHJcblxyXG5TVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xyXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZUVsZW1lbnRJRCwgZmlsdGVyc0ZhY3RvcnksIFNWR1RpbnRGaWx0ZXIsIFNWR0ZpbGxGaWx0ZXIsIFNWR1N0cm9rZUVmZmVjdCwgU1ZHVHJpdG9uZUZpbHRlcixcclxuU1ZHUHJvTGV2ZWxzRmlsdGVyLCBTVkdEcm9wU2hhZG93RWZmZWN0LCBTVkdNYXR0ZTNFZmZlY3QsIFNWR0dhdXNzaWFuQmx1ckVmZmVjdCwgbG9jYXRpb25IcmVmICovXHJcblxyXG5mdW5jdGlvbiBTVkdFZmZlY3RzKGVsZW0pIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gZWxlbS5kYXRhLmVmID8gZWxlbS5kYXRhLmVmLmxlbmd0aCA6IDA7XHJcbiAgdmFyIGZpbElkID0gY3JlYXRlRWxlbWVudElEKCk7XHJcbiAgdmFyIGZpbCA9IGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUZpbHRlcihmaWxJZCwgdHJ1ZSk7XHJcbiAgdmFyIGNvdW50ID0gMDtcclxuICB0aGlzLmZpbHRlcnMgPSBbXTtcclxuICB2YXIgZmlsdGVyTWFuYWdlcjtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGZpbHRlck1hbmFnZXIgPSBudWxsO1xyXG4gICAgaWYgKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjApIHtcclxuICAgICAgY291bnQgKz0gMTtcclxuICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBTVkdUaW50RmlsdGVyKGZpbCwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSk7XHJcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjEpIHtcclxuICAgICAgY291bnQgKz0gMTtcclxuICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBTVkdGaWxsRmlsdGVyKGZpbCwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSk7XHJcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjIpIHtcclxuICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBTVkdTdHJva2VFZmZlY3QoZWxlbSwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSk7XHJcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjMpIHtcclxuICAgICAgY291bnQgKz0gMTtcclxuICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBTVkdUcml0b25lRmlsdGVyKGZpbCwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSk7XHJcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjQpIHtcclxuICAgICAgY291bnQgKz0gMTtcclxuICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBTVkdQcm9MZXZlbHNGaWx0ZXIoZmlsLCBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzW2ldKTtcclxuICAgIH0gZWxzZSBpZiAoZWxlbS5kYXRhLmVmW2ldLnR5ID09PSAyNSkge1xyXG4gICAgICBjb3VudCArPSAxO1xyXG4gICAgICBmaWx0ZXJNYW5hZ2VyID0gbmV3IFNWR0Ryb3BTaGFkb3dFZmZlY3QoZmlsLCBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzW2ldKTtcclxuICAgIH0gZWxzZSBpZiAoZWxlbS5kYXRhLmVmW2ldLnR5ID09PSAyOCkge1xyXG4gICAgICAvLyBjb3VudCArPSAxO1xyXG4gICAgICBmaWx0ZXJNYW5hZ2VyID0gbmV3IFNWR01hdHRlM0VmZmVjdChmaWwsIGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW0pO1xyXG4gICAgfSBlbHNlIGlmIChlbGVtLmRhdGEuZWZbaV0udHkgPT09IDI5KSB7XHJcbiAgICAgIGNvdW50ICs9IDE7XHJcbiAgICAgIGZpbHRlck1hbmFnZXIgPSBuZXcgU1ZHR2F1c3NpYW5CbHVyRWZmZWN0KGZpbCwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZmlsdGVyTWFuYWdlcikge1xyXG4gICAgICB0aGlzLmZpbHRlcnMucHVzaChmaWx0ZXJNYW5hZ2VyKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGNvdW50KSB7XHJcbiAgICBlbGVtLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChmaWwpO1xyXG4gICAgZWxlbS5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWx0ZXInLCAndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBmaWxJZCArICcpJyk7XHJcbiAgfVxyXG4gIGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICBlbGVtLmFkZFJlbmRlcmFibGVDb21wb25lbnQodGhpcyk7XHJcbiAgfVxyXG59XHJcblxyXG5TVkdFZmZlY3RzLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICB0aGlzLmZpbHRlcnNbaV0ucmVuZGVyRnJhbWUoX2lzRmlyc3RGcmFtZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIE1hdHJpeCwgY3JlYXRlVHlwZWRBcnJheSAqL1xyXG5cclxuZnVuY3Rpb24gQ1ZDb250ZXh0RGF0YSgpIHtcclxuICB0aGlzLnNhdmVkID0gW107XHJcbiAgdGhpcy5jQXJyUG9zID0gMDtcclxuICB0aGlzLmNUciA9IG5ldyBNYXRyaXgoKTtcclxuICB0aGlzLmNPID0gMTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gMTU7XHJcbiAgdGhpcy5zYXZlZE9wID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICB0aGlzLnNhdmVkW2ldID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDE2KTtcclxuICB9XHJcbiAgdGhpcy5fbGVuZ3RoID0gbGVuO1xyXG59XHJcblxyXG5DVkNvbnRleHREYXRhLnByb3RvdHlwZS5kdXBsaWNhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG5ld0xlbmd0aCA9IHRoaXMuX2xlbmd0aCAqIDI7XHJcbiAgdmFyIGN1cnJlbnRTYXZlZE9wID0gdGhpcy5zYXZlZE9wO1xyXG4gIHRoaXMuc2F2ZWRPcCA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBuZXdMZW5ndGgpO1xyXG4gIHRoaXMuc2F2ZWRPcC5zZXQoY3VycmVudFNhdmVkT3ApO1xyXG4gIHZhciBpID0gMDtcclxuICBmb3IgKGkgPSB0aGlzLl9sZW5ndGg7IGkgPCBuZXdMZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgdGhpcy5zYXZlZFtpXSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAxNik7XHJcbiAgfVxyXG4gIHRoaXMuX2xlbmd0aCA9IG5ld0xlbmd0aDtcclxufTtcclxuXHJcbkNWQ29udGV4dERhdGEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuY0FyclBvcyA9IDA7XHJcbiAgdGhpcy5jVHIucmVzZXQoKTtcclxuICB0aGlzLmNPID0gMTtcclxufTtcclxuXHJcbi8qIGdsb2JhbCBDVkVmZmVjdHMsIGdldEJsZW5kTW9kZSwgQ1ZNYXNrRWxlbWVudCwgTWF0cml4ICovXHJcblxyXG5mdW5jdGlvbiBDVkJhc2VFbGVtZW50KCkge1xyXG59XHJcblxyXG5DVkJhc2VFbGVtZW50LnByb3RvdHlwZSA9IHtcclxuICBjcmVhdGVFbGVtZW50czogZnVuY3Rpb24gKCkge30sXHJcbiAgaW5pdFJlbmRlcmVyRWxlbWVudDogZnVuY3Rpb24gKCkge30sXHJcbiAgY3JlYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0O1xyXG4gICAgdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIgPSBuZXcgQ1ZFZmZlY3RzKHRoaXMpO1xyXG4gIH0sXHJcbiAgY3JlYXRlQ29udGVudDogZnVuY3Rpb24gKCkge30sXHJcbiAgc2V0QmxlbmRNb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZ2xvYmFsRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YTtcclxuICAgIGlmIChnbG9iYWxEYXRhLmJsZW5kTW9kZSAhPT0gdGhpcy5kYXRhLmJtKSB7XHJcbiAgICAgIGdsb2JhbERhdGEuYmxlbmRNb2RlID0gdGhpcy5kYXRhLmJtO1xyXG4gICAgICB2YXIgYmxlbmRNb2RlVmFsdWUgPSBnZXRCbGVuZE1vZGUodGhpcy5kYXRhLmJtKTtcclxuICAgICAgZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZVZhbHVlO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgQ1ZNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMpO1xyXG4gIH0sXHJcbiAgaGlkZUVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghdGhpcy5oaWRkZW4gJiYgKCF0aGlzLmlzSW5SYW5nZSB8fCB0aGlzLmlzVHJhbnNwYXJlbnQpKSB7XHJcbiAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcclxuICAgIH1cclxuICB9LFxyXG4gIHNob3dFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5pc0luUmFuZ2UgJiYgIXRoaXMuaXNUcmFuc3BhcmVudCkge1xyXG4gICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVuZGVyRnJhbWU6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmhpZGRlbiB8fCB0aGlzLmRhdGEuaGQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZW5kZXJUcmFuc2Zvcm0oKTtcclxuICAgIHRoaXMucmVuZGVyUmVuZGVyYWJsZSgpO1xyXG4gICAgdGhpcy5zZXRCbGVuZE1vZGUoKTtcclxuICAgIHZhciBmb3JjZVJlYWxTdGFjayA9IHRoaXMuZGF0YS50eSA9PT0gMDtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5zYXZlKGZvcmNlUmVhbFN0YWNrKTtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhUcmFuc2Zvcm0odGhpcy5maW5hbFRyYW5zZm9ybS5tYXQucHJvcHMpO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eE9wYWNpdHkodGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5vLnYpO1xyXG4gICAgdGhpcy5yZW5kZXJJbm5lckNvbnRlbnQoKTtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5yZXN0b3JlKGZvcmNlUmVhbFN0YWNrKTtcclxuICAgIGlmICh0aGlzLm1hc2tNYW5hZ2VyLmhhc01hc2tzKSB7XHJcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5yZXN0b3JlKHRydWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcclxuICAgIH1cclxuICB9LFxyXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IG51bGw7XHJcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhID0gbnVsbDtcclxuICAgIHRoaXMubWFza01hbmFnZXIuZGVzdHJveSgpO1xyXG4gIH0sXHJcbiAgbUhlbHBlcjogbmV3IE1hdHJpeCgpLFxyXG59O1xyXG5DVkJhc2VFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUuaGlkZUVsZW1lbnQ7XHJcbkNWQmFzZUVsZW1lbnQucHJvdG90eXBlLnNob3cgPSBDVkJhc2VFbGVtZW50LnByb3RvdHlwZS5zaG93RWxlbWVudDtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIEJhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBDVkJhc2VFbGVtZW50LEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCxcclxuUmVuZGVyYWJsZUVsZW1lbnQsIFNWR1NoYXBlRWxlbWVudCwgSUltYWdlRWxlbWVudCwgY3JlYXRlVGFnICovXHJcblxyXG5mdW5jdGlvbiBDVkltYWdlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcclxuICB0aGlzLmltZyA9IGdsb2JhbERhdGEuaW1hZ2VMb2FkZXIuZ2V0QXNzZXQodGhpcy5hc3NldERhdGEpO1xyXG4gIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbn1cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudF0sIENWSW1hZ2VFbGVtZW50KTtcclxuXHJcbkNWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQ7XHJcbkNWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBJSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWU7XHJcblxyXG5DVkltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAodGhpcy5pbWcud2lkdGggJiYgKHRoaXMuYXNzZXREYXRhLncgIT09IHRoaXMuaW1nLndpZHRoIHx8IHRoaXMuYXNzZXREYXRhLmggIT09IHRoaXMuaW1nLmhlaWdodCkpIHtcclxuICAgIHZhciBjYW52YXMgPSBjcmVhdGVUYWcoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gdGhpcy5hc3NldERhdGEudztcclxuICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmFzc2V0RGF0YS5oO1xyXG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgIHZhciBpbWdXID0gdGhpcy5pbWcud2lkdGg7XHJcbiAgICB2YXIgaW1nSCA9IHRoaXMuaW1nLmhlaWdodDtcclxuICAgIHZhciBpbWdSZWwgPSBpbWdXIC8gaW1nSDtcclxuICAgIHZhciBjYW52YXNSZWwgPSB0aGlzLmFzc2V0RGF0YS53IC8gdGhpcy5hc3NldERhdGEuaDtcclxuICAgIHZhciB3aWR0aENyb3A7XHJcbiAgICB2YXIgaGVpZ2h0Q3JvcDtcclxuICAgIHZhciBwYXIgPSB0aGlzLmFzc2V0RGF0YS5wciB8fCB0aGlzLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbztcclxuICAgIGlmICgoaW1nUmVsID4gY2FudmFzUmVsICYmIHBhciA9PT0gJ3hNaWRZTWlkIHNsaWNlJykgfHwgKGltZ1JlbCA8IGNhbnZhc1JlbCAmJiBwYXIgIT09ICd4TWlkWU1pZCBzbGljZScpKSB7XHJcbiAgICAgIGhlaWdodENyb3AgPSBpbWdIO1xyXG4gICAgICB3aWR0aENyb3AgPSBoZWlnaHRDcm9wICogY2FudmFzUmVsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2lkdGhDcm9wID0gaW1nVztcclxuICAgICAgaGVpZ2h0Q3JvcCA9IHdpZHRoQ3JvcCAvIGNhbnZhc1JlbDtcclxuICAgIH1cclxuICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWcsIChpbWdXIC0gd2lkdGhDcm9wKSAvIDIsIChpbWdIIC0gaGVpZ2h0Q3JvcCkgLyAyLCB3aWR0aENyb3AsIGhlaWdodENyb3AsIDAsIDAsIHRoaXMuYXNzZXREYXRhLncsIHRoaXMuYXNzZXREYXRhLmgpO1xyXG4gICAgdGhpcy5pbWcgPSBjYW52YXM7XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1nLCAwLCAwKTtcclxufTtcclxuXHJcbkNWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuaW1nID0gbnVsbDtcclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVTaXplZEFycmF5LCBQcm9wZXJ0eUZhY3RvcnksIGV4dGVuZFByb3RvdHlwZSwgQ2FudmFzUmVuZGVyZXIsIElDb21wRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCAqL1xyXG5cclxuZnVuY3Rpb24gQ1ZDb21wRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xyXG4gIHRoaXMubGF5ZXJzID0gZGF0YS5sYXllcnM7XHJcbiAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcclxuICB0aGlzLmVsZW1lbnRzID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLmxheWVycy5sZW5ndGgpO1xyXG4gIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLnRtLCAwLCBnbG9iYWxEYXRhLmZyYW1lUmF0ZSwgdGhpcykgOiB7IF9wbGFjZWhvbGRlcjogdHJ1ZSB9O1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0NhbnZhc1JlbmRlcmVyLCBJQ29tcEVsZW1lbnQsIENWQmFzZUVsZW1lbnRdLCBDVkNvbXBFbGVtZW50KTtcclxuXHJcbkNWQ29tcEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgY3R4ID0gdGhpcy5jYW52YXNDb250ZXh0O1xyXG4gIGN0eC5iZWdpblBhdGgoKTtcclxuICBjdHgubW92ZVRvKDAsIDApO1xyXG4gIGN0eC5saW5lVG8odGhpcy5kYXRhLncsIDApO1xyXG4gIGN0eC5saW5lVG8odGhpcy5kYXRhLncsIHRoaXMuZGF0YS5oKTtcclxuICBjdHgubGluZVRvKDAsIHRoaXMuZGF0YS5oKTtcclxuICBjdHgubGluZVRvKDAsIDApO1xyXG4gIGN0eC5jbGlwKCk7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcclxuICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xyXG4gICAgICB0aGlzLmVsZW1lbnRzW2ldLnJlbmRlckZyYW1lKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZDb21wRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICBpZiAodGhpcy5lbGVtZW50c1tpXSkge1xyXG4gICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICB9XHJcbiAgdGhpcy5sYXllcnMgPSBudWxsO1xyXG4gIHRoaXMuZWxlbWVudHMgPSBudWxsO1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZVNpemVkQXJyYXksIFNoYXBlUHJvcGVydHlGYWN0b3J5LCBNYXNrRWxlbWVudCAqL1xyXG5cclxuZnVuY3Rpb24gQ1ZNYXNrRWxlbWVudChkYXRhLCBlbGVtZW50KSB7XHJcbiAgdGhpcy5kYXRhID0gZGF0YTtcclxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gIHRoaXMubWFza3NQcm9wZXJ0aWVzID0gdGhpcy5kYXRhLm1hc2tzUHJvcGVydGllcyB8fCBbXTtcclxuICB0aGlzLnZpZXdEYXRhID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGgpO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgdmFyIGhhc01hc2tzID0gZmFsc2U7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAodGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nKSB7XHJcbiAgICAgIGhhc01hc2tzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHRoaXMudmlld0RhdGFbaV0gPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcy5lbGVtZW50LCB0aGlzLm1hc2tzUHJvcGVydGllc1tpXSwgMyk7XHJcbiAgfVxyXG4gIHRoaXMuaGFzTWFza3MgPSBoYXNNYXNrcztcclxuICBpZiAoaGFzTWFza3MpIHtcclxuICAgIHRoaXMuZWxlbWVudC5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xyXG4gIH1cclxufVxyXG5cclxuQ1ZNYXNrRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKCF0aGlzLmhhc01hc2tzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciB0cmFuc2Zvcm0gPSB0aGlzLmVsZW1lbnQuZmluYWxUcmFuc2Zvcm0ubWF0O1xyXG4gIHZhciBjdHggPSB0aGlzLmVsZW1lbnQuY2FudmFzQ29udGV4dDtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xyXG4gIHZhciBwdDtcclxuICB2YXIgcHRzO1xyXG4gIHZhciBkYXRhO1xyXG4gIGN0eC5iZWdpblBhdGgoKTtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmICh0aGlzLm1hc2tzUHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicpIHtcclxuICAgICAgaWYgKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLmludikge1xyXG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmVsZW1lbnQuZ2xvYmFsRGF0YS5jb21wU2l6ZS53LCAwKTtcclxuICAgICAgICBjdHgubGluZVRvKHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLncsIHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLmgpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oMCwgdGhpcy5lbGVtZW50Lmdsb2JhbERhdGEuY29tcFNpemUuaCk7XHJcbiAgICAgICAgY3R4LmxpbmVUbygwLCAwKTtcclxuICAgICAgfVxyXG4gICAgICBkYXRhID0gdGhpcy52aWV3RGF0YVtpXS52O1xyXG4gICAgICBwdCA9IHRyYW5zZm9ybS5hcHBseVRvUG9pbnRBcnJheShkYXRhLnZbMF1bMF0sIGRhdGEudlswXVsxXSwgMCk7XHJcbiAgICAgIGN0eC5tb3ZlVG8ocHRbMF0sIHB0WzFdKTtcclxuICAgICAgdmFyIGo7XHJcbiAgICAgIHZhciBqTGVuID0gZGF0YS5fbGVuZ3RoO1xyXG4gICAgICBmb3IgKGogPSAxOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgcHRzID0gdHJhbnNmb3JtLmFwcGx5VG9UcmlwbGVQb2ludHMoZGF0YS5vW2ogLSAxXSwgZGF0YS5pW2pdLCBkYXRhLnZbal0pO1xyXG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHB0c1swXSwgcHRzWzFdLCBwdHNbMl0sIHB0c1szXSwgcHRzWzRdLCBwdHNbNV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHB0cyA9IHRyYW5zZm9ybS5hcHBseVRvVHJpcGxlUG9pbnRzKGRhdGEub1tqIC0gMV0sIGRhdGEuaVswXSwgZGF0YS52WzBdKTtcclxuICAgICAgY3R4LmJlemllckN1cnZlVG8ocHRzWzBdLCBwdHNbMV0sIHB0c1syXSwgcHRzWzNdLCBwdHNbNF0sIHB0c1s1XSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLnJlbmRlcmVyLnNhdmUodHJ1ZSk7XHJcbiAgY3R4LmNsaXAoKTtcclxufTtcclxuXHJcbkNWTWFza0VsZW1lbnQucHJvdG90eXBlLmdldE1hc2tQcm9wZXJ0eSA9IE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrUHJvcGVydHk7XHJcblxyXG5DVk1hc2tFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuZWxlbWVudCA9IG51bGw7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgU2hhcGVUcmFuc2Zvcm1NYW5hZ2VyLCBleHRlbmRQcm90b3R5cGUsIEJhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBDVkJhc2VFbGVtZW50LCBJU2hhcGVFbGVtZW50LFxyXG5IaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudCwgUHJvcGVydHlGYWN0b3J5LCBkZWdUb1JhZHMsIEdyYWRpZW50UHJvcGVydHksXHJcbkRhc2hQcm9wZXJ0eSwgVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LCBDVlNoYXBlRGF0YSwgU2hhcGVNb2RpZmllcnMsIGJtRmxvb3IgKi9cclxuXHJcbmZ1bmN0aW9uIENWU2hhcGVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICB0aGlzLnNoYXBlcyA9IFtdO1xyXG4gIHRoaXMuc2hhcGVzRGF0YSA9IGRhdGEuc2hhcGVzO1xyXG4gIHRoaXMuc3R5bGVzTGlzdCA9IFtdO1xyXG4gIHRoaXMuaXRlbXNEYXRhID0gW107XHJcbiAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcclxuICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107XHJcbiAgdGhpcy5wcm9jZXNzZWRFbGVtZW50cyA9IFtdO1xyXG4gIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIgPSBuZXcgU2hhcGVUcmFuc2Zvcm1NYW5hZ2VyKCk7XHJcbiAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSVNoYXBlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudF0sIENWU2hhcGVFbGVtZW50KTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFJlbmRlcmFibGVET01FbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudDtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS50cmFuc2Zvcm1IZWxwZXIgPSB7IG9wYWNpdHk6IDEsIF9vcE1kZjogZmFsc2UgfTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5kYXNoUmVzZXR0ZXIgPSBbXTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0cnVlLCBbXSk7XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIHRyYW5zZm9ybXMpIHtcclxuICB2YXIgc3R5bGVFbGVtID0ge1xyXG4gICAgZGF0YTogZGF0YSxcclxuICAgIHR5cGU6IGRhdGEudHksXHJcbiAgICBwcmVUcmFuc2Zvcm1zOiB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyLmFkZFRyYW5zZm9ybVNlcXVlbmNlKHRyYW5zZm9ybXMpLFxyXG4gICAgdHJhbnNmb3JtczogW10sXHJcbiAgICBlbGVtZW50czogW10sXHJcbiAgICBjbG9zZWQ6IGRhdGEuaGQgPT09IHRydWUsXHJcbiAgfTtcclxuICB2YXIgZWxlbWVudERhdGEgPSB7fTtcclxuICBpZiAoZGF0YS50eSA9PT0gJ2ZsJyB8fCBkYXRhLnR5ID09PSAnc3QnKSB7XHJcbiAgICBlbGVtZW50RGF0YS5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5jLCAxLCAyNTUsIHRoaXMpO1xyXG4gICAgaWYgKCFlbGVtZW50RGF0YS5jLmspIHtcclxuICAgICAgc3R5bGVFbGVtLmNvID0gJ3JnYignICsgYm1GbG9vcihlbGVtZW50RGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihlbGVtZW50RGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihlbGVtZW50RGF0YS5jLnZbMl0pICsgJyknO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2dmJyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XHJcbiAgICBlbGVtZW50RGF0YS5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5zLCAxLCBudWxsLCB0aGlzKTtcclxuICAgIGVsZW1lbnREYXRhLmUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmUsIDEsIG51bGwsIHRoaXMpO1xyXG4gICAgZWxlbWVudERhdGEuaCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEuaCB8fCB7IGs6IDAgfSwgMCwgMC4wMSwgdGhpcyk7XHJcbiAgICBlbGVtZW50RGF0YS5hID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5hIHx8IHsgazogMCB9LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gICAgZWxlbWVudERhdGEuZyA9IG5ldyBHcmFkaWVudFByb3BlcnR5KHRoaXMsIGRhdGEuZywgdGhpcyk7XHJcbiAgfVxyXG4gIGVsZW1lbnREYXRhLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpO1xyXG4gIGlmIChkYXRhLnR5ID09PSAnc3QnIHx8IGRhdGEudHkgPT09ICdncycpIHtcclxuICAgIHN0eWxlRWxlbS5sYyA9IHRoaXMubGNFbnVtW2RhdGEubGNdIHx8ICdyb3VuZCc7XHJcbiAgICBzdHlsZUVsZW0ubGogPSB0aGlzLmxqRW51bVtkYXRhLmxqXSB8fCAncm91bmQnO1xyXG4gICAgaWYgKGRhdGEubGogPT0gMSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxyXG4gICAgICBzdHlsZUVsZW0ubWwgPSBkYXRhLm1sO1xyXG4gICAgfVxyXG4gICAgZWxlbWVudERhdGEudyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEudywgMCwgbnVsbCwgdGhpcyk7XHJcbiAgICBpZiAoIWVsZW1lbnREYXRhLncuaykge1xyXG4gICAgICBzdHlsZUVsZW0ud2kgPSBlbGVtZW50RGF0YS53LnY7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YS5kKSB7XHJcbiAgICAgIHZhciBkID0gbmV3IERhc2hQcm9wZXJ0eSh0aGlzLCBkYXRhLmQsICdjYW52YXMnLCB0aGlzKTtcclxuICAgICAgZWxlbWVudERhdGEuZCA9IGQ7XHJcbiAgICAgIGlmICghZWxlbWVudERhdGEuZC5rKSB7XHJcbiAgICAgICAgc3R5bGVFbGVtLmRhID0gZWxlbWVudERhdGEuZC5kYXNoQXJyYXk7XHJcbiAgICAgICAgc3R5bGVFbGVtLmRvID0gZWxlbWVudERhdGEuZC5kYXNob2Zmc2V0WzBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0eWxlRWxlbS5yID0gZGF0YS5yID09PSAyID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nO1xyXG4gIH1cclxuICB0aGlzLnN0eWxlc0xpc3QucHVzaChzdHlsZUVsZW0pO1xyXG4gIGVsZW1lbnREYXRhLnN0eWxlID0gc3R5bGVFbGVtO1xyXG4gIHJldHVybiBlbGVtZW50RGF0YTtcclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVHcm91cEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGVsZW1lbnREYXRhID0ge1xyXG4gICAgaXQ6IFtdLFxyXG4gICAgcHJldlZpZXdEYXRhOiBbXSxcclxuICB9O1xyXG4gIHJldHVybiBlbGVtZW50RGF0YTtcclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVUcmFuc2Zvcm1FbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICB2YXIgZWxlbWVudERhdGEgPSB7XHJcbiAgICB0cmFuc2Zvcm06IHtcclxuICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgX29wTWRmOiBmYWxzZSxcclxuICAgICAga2V5OiB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyLmdldE5ld0tleSgpLFxyXG4gICAgICBvcDogUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5vLCAwLCAwLjAxLCB0aGlzKSxcclxuICAgICAgbVByb3BzOiBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkodGhpcywgZGF0YSwgdGhpcyksXHJcbiAgICB9LFxyXG4gIH07XHJcbiAgcmV0dXJuIGVsZW1lbnREYXRhO1xyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNoYXBlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgdmFyIGVsZW1lbnREYXRhID0gbmV3IENWU2hhcGVEYXRhKHRoaXMsIGRhdGEsIHRoaXMuc3R5bGVzTGlzdCwgdGhpcy50cmFuc2Zvcm1zTWFuYWdlcik7XHJcblxyXG4gIHRoaXMuc2hhcGVzLnB1c2goZWxlbWVudERhdGEpO1xyXG4gIHRoaXMuYWRkU2hhcGVUb01vZGlmaWVycyhlbGVtZW50RGF0YSk7XHJcbiAgcmV0dXJuIGVsZW1lbnREYXRhO1xyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbG9hZFNoYXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLml0ZW1zRGF0YS5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICB0aGlzLnByZXZWaWV3RGF0YVtpXSA9IHRoaXMuaXRlbXNEYXRhW2ldO1xyXG4gIH1cclxuICB0aGlzLnNlYXJjaFNoYXBlcyh0aGlzLnNoYXBlc0RhdGEsIHRoaXMuaXRlbXNEYXRhLCB0aGlzLnByZXZWaWV3RGF0YSwgdHJ1ZSwgW10pO1xyXG4gIGxlbiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgdGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5nZXRWYWx1ZSgpO1xyXG4gIH1cclxuICB0aGlzLnJlbmRlck1vZGlmaWVycygpO1xyXG4gIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIucHJvY2Vzc1NlcXVlbmNlcyh0aGlzLl9pc0ZpcnN0RnJhbWUpO1xyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmFkZFRyYW5zZm9ybVRvU3R5bGVMaXN0ID0gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgaWYgKCF0aGlzLnN0eWxlc0xpc3RbaV0uY2xvc2VkKSB7XHJcbiAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS50cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlVHJhbnNmb3JtRnJvbVN0eWxlTGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmICghdGhpcy5zdHlsZXNMaXN0W2ldLmNsb3NlZCkge1xyXG4gICAgICB0aGlzLnN0eWxlc0xpc3RbaV0udHJhbnNmb3Jtcy5wb3AoKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2xvc2VTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHN0eWxlcy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBzdHlsZXNbaV0uY2xvc2VkID0gdHJ1ZTtcclxuICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuc2VhcmNoU2hhcGVzID0gZnVuY3Rpb24gKGFyciwgaXRlbXNEYXRhLCBwcmV2Vmlld0RhdGEsIHNob3VsZFJlbmRlciwgdHJhbnNmb3Jtcykge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoIC0gMTtcclxuICB2YXIgajtcclxuICB2YXIgakxlbjtcclxuICB2YXIgb3duU3R5bGVzID0gW107XHJcbiAgdmFyIG93bk1vZGlmaWVycyA9IFtdO1xyXG4gIHZhciBwcm9jZXNzZWRQb3M7XHJcbiAgdmFyIG1vZGlmaWVyO1xyXG4gIHZhciBjdXJyZW50VHJhbnNmb3JtO1xyXG4gIHZhciBvd25UcmFuc2Zvcm1zID0gW10uY29uY2F0KHRyYW5zZm9ybXMpO1xyXG4gIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgIHByb2Nlc3NlZFBvcyA9IHRoaXMuc2VhcmNoUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0pO1xyXG4gICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcclxuICAgICAgYXJyW2ldLl9zaG91bGRSZW5kZXIgPSBzaG91bGRSZW5kZXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpdGVtc0RhdGFbaV0gPSBwcmV2Vmlld0RhdGFbcHJvY2Vzc2VkUG9zIC0gMV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXJyW2ldLnR5ID09PSAnZmwnIHx8IGFycltpXS50eSA9PT0gJ3N0JyB8fCBhcnJbaV0udHkgPT09ICdnZicgfHwgYXJyW2ldLnR5ID09PSAnZ3MnKSB7XHJcbiAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XHJcbiAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVTdHlsZUVsZW1lbnQoYXJyW2ldLCBvd25UcmFuc2Zvcm1zKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpdGVtc0RhdGFbaV0uc3R5bGUuY2xvc2VkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG93blN0eWxlcy5wdXNoKGl0ZW1zRGF0YVtpXS5zdHlsZSk7XHJcbiAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ2dyJykge1xyXG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xyXG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlR3JvdXBFbGVtZW50KGFycltpXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgakxlbiA9IGl0ZW1zRGF0YVtpXS5pdC5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgaXRlbXNEYXRhW2ldLnByZXZWaWV3RGF0YVtqXSA9IGl0ZW1zRGF0YVtpXS5pdFtqXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zZWFyY2hTaGFwZXMoYXJyW2ldLml0LCBpdGVtc0RhdGFbaV0uaXQsIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGEsIHNob3VsZFJlbmRlciwgb3duVHJhbnNmb3Jtcyk7XHJcbiAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3RyJykge1xyXG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xyXG4gICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0gPSB0aGlzLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQoYXJyW2ldKTtcclxuICAgICAgICBpdGVtc0RhdGFbaV0gPSBjdXJyZW50VHJhbnNmb3JtO1xyXG4gICAgICB9XHJcbiAgICAgIG93blRyYW5zZm9ybXMucHVzaChpdGVtc0RhdGFbaV0pO1xyXG4gICAgICB0aGlzLmFkZFRyYW5zZm9ybVRvU3R5bGVMaXN0KGl0ZW1zRGF0YVtpXSk7XHJcbiAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3NoJyB8fCBhcnJbaV0udHkgPT09ICdyYycgfHwgYXJyW2ldLnR5ID09PSAnZWwnIHx8IGFycltpXS50eSA9PT0gJ3NyJykge1xyXG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xyXG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlU2hhcGVFbGVtZW50KGFycltpXSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAndG0nIHx8IGFycltpXS50eSA9PT0gJ3JkJyB8fCBhcnJbaV0udHkgPT09ICdwYicpIHtcclxuICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcclxuICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XHJcbiAgICAgICAgbW9kaWZpZXIuaW5pdCh0aGlzLCBhcnJbaV0pO1xyXG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IG1vZGlmaWVyO1xyXG4gICAgICAgIHRoaXMuc2hhcGVNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbW9kaWZpZXIgPSBpdGVtc0RhdGFbaV07XHJcbiAgICAgICAgbW9kaWZpZXIuY2xvc2VkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdycCcpIHtcclxuICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcclxuICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XHJcbiAgICAgICAgaXRlbXNEYXRhW2ldID0gbW9kaWZpZXI7XHJcbiAgICAgICAgbW9kaWZpZXIuaW5pdCh0aGlzLCBhcnIsIGksIGl0ZW1zRGF0YSk7XHJcbiAgICAgICAgdGhpcy5zaGFwZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICBzaG91bGRSZW5kZXIgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtb2RpZmllciA9IGl0ZW1zRGF0YVtpXTtcclxuICAgICAgICBtb2RpZmllci5jbG9zZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIG93bk1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgIH1cclxuICAgIHRoaXMuYWRkUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0sIGkgKyAxKTtcclxuICB9XHJcbiAgdGhpcy5yZW1vdmVUcmFuc2Zvcm1Gcm9tU3R5bGVMaXN0KCk7XHJcbiAgdGhpcy5jbG9zZVN0eWxlcyhvd25TdHlsZXMpO1xyXG4gIGxlbiA9IG93bk1vZGlmaWVycy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBvd25Nb2RpZmllcnNbaV0uY2xvc2VkID0gdHJ1ZTtcclxuICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMudHJhbnNmb3JtSGVscGVyLm9wYWNpdHkgPSAxO1xyXG4gIHRoaXMudHJhbnNmb3JtSGVscGVyLl9vcE1kZiA9IGZhbHNlO1xyXG4gIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XHJcbiAgdGhpcy50cmFuc2Zvcm1zTWFuYWdlci5wcm9jZXNzU2VxdWVuY2VzKHRoaXMuX2lzRmlyc3RGcmFtZSk7XHJcbiAgdGhpcy5yZW5kZXJTaGFwZSh0aGlzLnRyYW5zZm9ybUhlbHBlciwgdGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU2hhcGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAocGFyZW50VHJhbnNmb3JtLCBncm91cFRyYW5zZm9ybSkge1xyXG4gIGlmIChwYXJlbnRUcmFuc2Zvcm0uX29wTWRmIHx8IGdyb3VwVHJhbnNmb3JtLm9wLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XHJcbiAgICBncm91cFRyYW5zZm9ybS5vcGFjaXR5ID0gcGFyZW50VHJhbnNmb3JtLm9wYWNpdHk7XHJcbiAgICBncm91cFRyYW5zZm9ybS5vcGFjaXR5ICo9IGdyb3VwVHJhbnNmb3JtLm9wLnY7XHJcbiAgICBncm91cFRyYW5zZm9ybS5fb3BNZGYgPSB0cnVlO1xyXG4gIH1cclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5kcmF3TGF5ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW47XHJcbiAgdmFyIGs7XHJcbiAgdmFyIGtMZW47XHJcbiAgdmFyIGVsZW1zO1xyXG4gIHZhciBub2RlcztcclxuICB2YXIgcmVuZGVyZXIgPSB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXI7XHJcbiAgdmFyIGN0eCA9IHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0O1xyXG4gIHZhciB0eXBlO1xyXG4gIHZhciBjdXJyZW50U3R5bGU7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBjdXJyZW50U3R5bGUgPSB0aGlzLnN0eWxlc0xpc3RbaV07XHJcbiAgICB0eXBlID0gY3VycmVudFN0eWxlLnR5cGU7XHJcblxyXG4gICAgLy8gU2tpcHBpbmcgc3R5bGUgd2hlblxyXG4gICAgLy8gU3Ryb2tlIHdpZHRoIGVxdWFscyAwXHJcbiAgICAvLyBzdHlsZSBzaG91bGQgbm90IGJlIHJlbmRlcmVkIChleHRyYSB1bnVzZWQgcmVwZWF0ZXJzKVxyXG4gICAgLy8gY3VycmVudCBvcGFjaXR5IGVxdWFscyAwXHJcbiAgICAvLyBnbG9iYWwgb3BhY2l0eSBlcXVhbHMgMFxyXG4gICAgaWYgKCEoKCh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpICYmIGN1cnJlbnRTdHlsZS53aSA9PT0gMCkgfHwgIWN1cnJlbnRTdHlsZS5kYXRhLl9zaG91bGRSZW5kZXIgfHwgY3VycmVudFN0eWxlLmNvT3AgPT09IDAgfHwgdGhpcy5nbG9iYWxEYXRhLmN1cnJlbnRHbG9iYWxBbHBoYSA9PT0gMCkpIHtcclxuICAgICAgcmVuZGVyZXIuc2F2ZSgpO1xyXG4gICAgICBlbGVtcyA9IGN1cnJlbnRTdHlsZS5lbGVtZW50cztcclxuICAgICAgaWYgKHR5cGUgPT09ICdzdCcgfHwgdHlwZSA9PT0gJ2dzJykge1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHR5cGUgPT09ICdzdCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkO1xyXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBjdXJyZW50U3R5bGUud2k7XHJcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBjdXJyZW50U3R5bGUubGM7XHJcbiAgICAgICAgY3R4LmxpbmVKb2luID0gY3VycmVudFN0eWxlLmxqO1xyXG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gY3VycmVudFN0eWxlLm1sIHx8IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHR5cGUgPT09ICdmbCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkO1xyXG4gICAgICB9XHJcbiAgICAgIHJlbmRlcmVyLmN0eE9wYWNpdHkoY3VycmVudFN0eWxlLmNvT3ApO1xyXG4gICAgICBpZiAodHlwZSAhPT0gJ3N0JyAmJiB0eXBlICE9PSAnZ3MnKSB7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJlbmRlcmVyLmN0eFRyYW5zZm9ybShjdXJyZW50U3R5bGUucHJlVHJhbnNmb3Jtcy5maW5hbFRyYW5zZm9ybS5wcm9wcyk7XHJcbiAgICAgIGpMZW4gPSBlbGVtcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0JyB8fCB0eXBlID09PSAnZ3MnKSB7XHJcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICBpZiAoY3VycmVudFN0eWxlLmRhKSB7XHJcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChjdXJyZW50U3R5bGUuZGEpO1xyXG4gICAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBjdXJyZW50U3R5bGUuZG87XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGVzID0gZWxlbXNbal0udHJOb2RlcztcclxuICAgICAgICBrTGVuID0gbm9kZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XHJcbiAgICAgICAgICBpZiAobm9kZXNba10udCA9PT0gJ20nKSB7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8obm9kZXNba10ucFswXSwgbm9kZXNba10ucFsxXSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGVzW2tdLnQgPT09ICdjJykge1xyXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhub2Rlc1trXS5wdHNbMF0sIG5vZGVzW2tdLnB0c1sxXSwgbm9kZXNba10ucHRzWzJdLCBub2Rlc1trXS5wdHNbM10sIG5vZGVzW2tdLnB0c1s0XSwgbm9kZXNba10ucHRzWzVdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdCcgfHwgdHlwZSA9PT0gJ2dzJykge1xyXG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgaWYgKGN1cnJlbnRTdHlsZS5kYSkge1xyXG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5kYXNoUmVzZXR0ZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZSAhPT0gJ3N0JyAmJiB0eXBlICE9PSAnZ3MnKSB7XHJcbiAgICAgICAgY3R4LmZpbGwoY3VycmVudFN0eWxlLnIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJlbmRlcmVyLnJlc3RvcmUoKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU2hhcGUgPSBmdW5jdGlvbiAocGFyZW50VHJhbnNmb3JtLCBpdGVtcywgZGF0YSwgaXNNYWluKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aCAtIDE7XHJcbiAgdmFyIGdyb3VwVHJhbnNmb3JtO1xyXG4gIGdyb3VwVHJhbnNmb3JtID0gcGFyZW50VHJhbnNmb3JtO1xyXG4gIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgIGlmIChpdGVtc1tpXS50eSA9PT0gJ3RyJykge1xyXG4gICAgICBncm91cFRyYW5zZm9ybSA9IGRhdGFbaV0udHJhbnNmb3JtO1xyXG4gICAgICB0aGlzLnJlbmRlclNoYXBlVHJhbnNmb3JtKHBhcmVudFRyYW5zZm9ybSwgZ3JvdXBUcmFuc2Zvcm0pO1xyXG4gICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ3NoJyB8fCBpdGVtc1tpXS50eSA9PT0gJ2VsJyB8fCBpdGVtc1tpXS50eSA9PT0gJ3JjJyB8fCBpdGVtc1tpXS50eSA9PT0gJ3NyJykge1xyXG4gICAgICB0aGlzLnJlbmRlclBhdGgoaXRlbXNbaV0sIGRhdGFbaV0pO1xyXG4gICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ2ZsJykge1xyXG4gICAgICB0aGlzLnJlbmRlckZpbGwoaXRlbXNbaV0sIGRhdGFbaV0sIGdyb3VwVHJhbnNmb3JtKTtcclxuICAgIH0gZWxzZSBpZiAoaXRlbXNbaV0udHkgPT09ICdzdCcpIHtcclxuICAgICAgdGhpcy5yZW5kZXJTdHJva2UoaXRlbXNbaV0sIGRhdGFbaV0sIGdyb3VwVHJhbnNmb3JtKTtcclxuICAgIH0gZWxzZSBpZiAoaXRlbXNbaV0udHkgPT09ICdnZicgfHwgaXRlbXNbaV0udHkgPT09ICdncycpIHtcclxuICAgICAgdGhpcy5yZW5kZXJHcmFkaWVudEZpbGwoaXRlbXNbaV0sIGRhdGFbaV0sIGdyb3VwVHJhbnNmb3JtKTtcclxuICAgIH0gZWxzZSBpZiAoaXRlbXNbaV0udHkgPT09ICdncicpIHtcclxuICAgICAgdGhpcy5yZW5kZXJTaGFwZShncm91cFRyYW5zZm9ybSwgaXRlbXNbaV0uaXQsIGRhdGFbaV0uaXQpO1xyXG4gICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ3RtJykge1xyXG4gICAgICAvL1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoaXNNYWluKSB7XHJcbiAgICB0aGlzLmRyYXdMYXllcigpO1xyXG4gIH1cclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTdHlsZWRTaGFwZSA9IGZ1bmN0aW9uIChzdHlsZWRTaGFwZSwgc2hhcGUpIHtcclxuICBpZiAodGhpcy5faXNGaXJzdEZyYW1lIHx8IHNoYXBlLl9tZGYgfHwgc3R5bGVkU2hhcGUudHJhbnNmb3Jtcy5fbWRmKSB7XHJcbiAgICB2YXIgc2hhcGVOb2RlcyA9IHN0eWxlZFNoYXBlLnRyTm9kZXM7XHJcbiAgICB2YXIgcGF0aHMgPSBzaGFwZS5wYXRocztcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbjtcclxuICAgIHZhciBqO1xyXG4gICAgdmFyIGpMZW4gPSBwYXRocy5fbGVuZ3RoO1xyXG4gICAgc2hhcGVOb2Rlcy5sZW5ndGggPSAwO1xyXG4gICAgdmFyIGdyb3VwVHJhbnNmb3JtTWF0ID0gc3R5bGVkU2hhcGUudHJhbnNmb3Jtcy5maW5hbFRyYW5zZm9ybTtcclxuICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgdmFyIHBhdGhOb2RlcyA9IHBhdGhzLnNoYXBlc1tqXTtcclxuICAgICAgaWYgKHBhdGhOb2RlcyAmJiBwYXRoTm9kZXMudikge1xyXG4gICAgICAgIGxlbiA9IHBhdGhOb2Rlcy5fbGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgaWYgKGkgPT09IDEpIHtcclxuICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcclxuICAgICAgICAgICAgICB0OiAnbScsXHJcbiAgICAgICAgICAgICAgcDogZ3JvdXBUcmFuc2Zvcm1NYXQuYXBwbHlUb1BvaW50QXJyYXkocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzaGFwZU5vZGVzLnB1c2goe1xyXG4gICAgICAgICAgICB0OiAnYycsXHJcbiAgICAgICAgICAgIHB0czogZ3JvdXBUcmFuc2Zvcm1NYXQuYXBwbHlUb1RyaXBsZVBvaW50cyhwYXRoTm9kZXMub1tpIC0gMV0sIHBhdGhOb2Rlcy5pW2ldLCBwYXRoTm9kZXMudltpXSksXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xyXG4gICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcclxuICAgICAgICAgICAgdDogJ20nLFxyXG4gICAgICAgICAgICBwOiBncm91cFRyYW5zZm9ybU1hdC5hcHBseVRvUG9pbnRBcnJheShwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXRoTm9kZXMuYyAmJiBsZW4pIHtcclxuICAgICAgICAgIHNoYXBlTm9kZXMucHVzaCh7XHJcbiAgICAgICAgICAgIHQ6ICdjJyxcclxuICAgICAgICAgICAgcHRzOiBncm91cFRyYW5zZm9ybU1hdC5hcHBseVRvVHJpcGxlUG9pbnRzKHBhdGhOb2Rlcy5vW2kgLSAxXSwgcGF0aE5vZGVzLmlbMF0sIHBhdGhOb2Rlcy52WzBdKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcclxuICAgICAgICAgICAgdDogJ3onLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzdHlsZWRTaGFwZS50ck5vZGVzID0gc2hhcGVOb2RlcztcclxuICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyUGF0aCA9IGZ1bmN0aW9uIChwYXRoRGF0YSwgaXRlbURhdGEpIHtcclxuICBpZiAocGF0aERhdGEuaGQgIT09IHRydWUgJiYgcGF0aERhdGEuX3Nob3VsZFJlbmRlcikge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gaXRlbURhdGEuc3R5bGVkU2hhcGVzLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICB0aGlzLnJlbmRlclN0eWxlZFNoYXBlKGl0ZW1EYXRhLnN0eWxlZFNoYXBlc1tpXSwgaXRlbURhdGEuc2gpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGaWxsID0gZnVuY3Rpb24gKHN0eWxlRGF0YSwgaXRlbURhdGEsIGdyb3VwVHJhbnNmb3JtKSB7XHJcbiAgdmFyIHN0eWxlRWxlbSA9IGl0ZW1EYXRhLnN0eWxlO1xyXG5cclxuICBpZiAoaXRlbURhdGEuYy5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgc3R5bGVFbGVtLmNvID0gJ3JnYignXHJcbiAgICAgICAgKyBibUZsb29yKGl0ZW1EYXRhLmMudlswXSkgKyAnLCdcclxuICAgICAgICArIGJtRmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJ1xyXG4gICAgICAgICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMl0pICsgJyknO1xyXG4gIH1cclxuICBpZiAoaXRlbURhdGEuby5fbWRmIHx8IGdyb3VwVHJhbnNmb3JtLl9vcE1kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgIHN0eWxlRWxlbS5jb09wID0gaXRlbURhdGEuby52ICogZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eTtcclxuICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyR3JhZGllbnRGaWxsID0gZnVuY3Rpb24gKHN0eWxlRGF0YSwgaXRlbURhdGEsIGdyb3VwVHJhbnNmb3JtKSB7XHJcbiAgdmFyIHN0eWxlRWxlbSA9IGl0ZW1EYXRhLnN0eWxlO1xyXG4gIHZhciBncmQ7XHJcbiAgaWYgKCFzdHlsZUVsZW0uZ3JkIHx8IGl0ZW1EYXRhLmcuX21kZiB8fCBpdGVtRGF0YS5zLl9tZGYgfHwgaXRlbURhdGEuZS5fbWRmIHx8IChzdHlsZURhdGEudCAhPT0gMSAmJiAoaXRlbURhdGEuaC5fbWRmIHx8IGl0ZW1EYXRhLmEuX21kZikpKSB7XHJcbiAgICB2YXIgY3R4ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XHJcbiAgICB2YXIgcHQxID0gaXRlbURhdGEucy52O1xyXG4gICAgdmFyIHB0MiA9IGl0ZW1EYXRhLmUudjtcclxuICAgIGlmIChzdHlsZURhdGEudCA9PT0gMSkge1xyXG4gICAgICBncmQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQocHQxWzBdLCBwdDFbMV0sIHB0MlswXSwgcHQyWzFdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciByYWQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocHQxWzBdIC0gcHQyWzBdLCAyKSArIE1hdGgucG93KHB0MVsxXSAtIHB0MlsxXSwgMikpO1xyXG4gICAgICB2YXIgYW5nID0gTWF0aC5hdGFuMihwdDJbMV0gLSBwdDFbMV0sIHB0MlswXSAtIHB0MVswXSk7XHJcblxyXG4gICAgICB2YXIgcGVyY2VudCA9IGl0ZW1EYXRhLmgudjtcclxuICAgICAgaWYgKHBlcmNlbnQgPj0gMSkge1xyXG4gICAgICAgIHBlcmNlbnQgPSAwLjk5O1xyXG4gICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPD0gLTEpIHtcclxuICAgICAgICBwZXJjZW50ID0gLTAuOTk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGRpc3QgPSByYWQgKiBwZXJjZW50O1xyXG4gICAgICB2YXIgeCA9IE1hdGguY29zKGFuZyArIGl0ZW1EYXRhLmEudikgKiBkaXN0ICsgcHQxWzBdO1xyXG4gICAgICB2YXIgeSA9IE1hdGguc2luKGFuZyArIGl0ZW1EYXRhLmEudikgKiBkaXN0ICsgcHQxWzFdO1xyXG4gICAgICBncmQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoeCwgeSwgMCwgcHQxWzBdLCBwdDFbMV0sIHJhZCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gc3R5bGVEYXRhLmcucDtcclxuICAgIHZhciBjVmFsdWVzID0gaXRlbURhdGEuZy5jO1xyXG4gICAgdmFyIG9wYWNpdHkgPSAxO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBpZiAoaXRlbURhdGEuZy5faGFzT3BhY2l0eSAmJiBpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xyXG4gICAgICAgIG9wYWNpdHkgPSBpdGVtRGF0YS5nLm9baSAqIDIgKyAxXTtcclxuICAgICAgfVxyXG4gICAgICBncmQuYWRkQ29sb3JTdG9wKGNWYWx1ZXNbaSAqIDRdIC8gMTAwLCAncmdiYSgnICsgY1ZhbHVlc1tpICogNCArIDFdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDJdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDNdICsgJywnICsgb3BhY2l0eSArICcpJyk7XHJcbiAgICB9XHJcbiAgICBzdHlsZUVsZW0uZ3JkID0gZ3JkO1xyXG4gIH1cclxuICBzdHlsZUVsZW0uY29PcCA9IGl0ZW1EYXRhLm8udiAqIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHk7XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU3Ryb2tlID0gZnVuY3Rpb24gKHN0eWxlRGF0YSwgaXRlbURhdGEsIGdyb3VwVHJhbnNmb3JtKSB7XHJcbiAgdmFyIHN0eWxlRWxlbSA9IGl0ZW1EYXRhLnN0eWxlO1xyXG4gIHZhciBkID0gaXRlbURhdGEuZDtcclxuICBpZiAoZCAmJiAoZC5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkpIHtcclxuICAgIHN0eWxlRWxlbS5kYSA9IGQuZGFzaEFycmF5O1xyXG4gICAgc3R5bGVFbGVtLmRvID0gZC5kYXNob2Zmc2V0WzBdO1xyXG4gIH1cclxuICBpZiAoaXRlbURhdGEuYy5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgc3R5bGVFbGVtLmNvID0gJ3JnYignICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMl0pICsgJyknO1xyXG4gIH1cclxuICBpZiAoaXRlbURhdGEuby5fbWRmIHx8IGdyb3VwVHJhbnNmb3JtLl9vcE1kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgIHN0eWxlRWxlbS5jb09wID0gaXRlbURhdGEuby52ICogZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eTtcclxuICB9XHJcbiAgaWYgKGl0ZW1EYXRhLncuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgIHN0eWxlRWxlbS53aSA9IGl0ZW1EYXRhLncudjtcclxuICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnNoYXBlc0RhdGEgPSBudWxsO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YSA9IG51bGw7XHJcbiAgdGhpcy5jYW52YXNDb250ZXh0ID0gbnVsbDtcclxuICB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoID0gMDtcclxuICB0aGlzLml0ZW1zRGF0YS5sZW5ndGggPSAwO1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIENWQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnQsXHJcblNWR1NoYXBlRWxlbWVudCwgSUltYWdlRWxlbWVudCAqL1xyXG5cclxuZnVuY3Rpb24gQ1ZTb2xpZEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbn1cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudF0sIENWU29saWRFbGVtZW50KTtcclxuXHJcbkNWU29saWRFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQ7XHJcbkNWU29saWRFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBJSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWU7XHJcblxyXG5DVlNvbGlkRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XHJcbiAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZGF0YS5zYztcclxuICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5kYXRhLnN3LCB0aGlzLmRhdGEuc2gpO1xyXG4gIC8vXHJcbn07XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCBCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LFxyXG5SZW5kZXJhYmxlRWxlbWVudCwgSVRleHRFbGVtZW50LCBjcmVhdGVUYWcsIGNyZWF0ZVNpemVkQXJyYXkgKi9cclxuXHJcbmZ1bmN0aW9uIENWVGV4dEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMudGV4dFNwYW5zID0gW107XHJcbiAgdGhpcy55T2Zmc2V0ID0gMDtcclxuICB0aGlzLmZpbGxDb2xvckFuaW0gPSBmYWxzZTtcclxuICB0aGlzLnN0cm9rZUNvbG9yQW5pbSA9IGZhbHNlO1xyXG4gIHRoaXMuc3Ryb2tlV2lkdGhBbmltID0gZmFsc2U7XHJcbiAgdGhpcy5zdHJva2UgPSBmYWxzZTtcclxuICB0aGlzLmZpbGwgPSBmYWxzZTtcclxuICB0aGlzLmp1c3RpZnlPZmZzZXQgPSAwO1xyXG4gIHRoaXMuY3VycmVudFJlbmRlciA9IG51bGw7XHJcbiAgdGhpcy5yZW5kZXJUeXBlID0gJ2NhbnZhcyc7XHJcbiAgdGhpcy52YWx1ZXMgPSB7XHJcbiAgICBmaWxsOiAncmdiYSgwLDAsMCwwKScsXHJcbiAgICBzdHJva2U6ICdyZ2JhKDAsMCwwLDApJyxcclxuICAgIHNXaWR0aDogMCxcclxuICAgIGZWYWx1ZTogJycsXHJcbiAgfTtcclxuICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG59XHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIENWQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnQsIElUZXh0RWxlbWVudF0sIENWVGV4dEVsZW1lbnQpO1xyXG5cclxuQ1ZUZXh0RWxlbWVudC5wcm90b3R5cGUudEhlbHBlciA9IGNyZWF0ZVRhZygnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbkNWVGV4dEVsZW1lbnQucHJvdG90eXBlLmJ1aWxkTmV3VGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgZG9jdW1lbnREYXRhID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGE7XHJcbiAgdGhpcy5yZW5kZXJlZExldHRlcnMgPSBjcmVhdGVTaXplZEFycmF5KGRvY3VtZW50RGF0YS5sID8gZG9jdW1lbnREYXRhLmwubGVuZ3RoIDogMCk7XHJcblxyXG4gIHZhciBoYXNGaWxsID0gZmFsc2U7XHJcbiAgaWYgKGRvY3VtZW50RGF0YS5mYykge1xyXG4gICAgaGFzRmlsbCA9IHRydWU7XHJcbiAgICB0aGlzLnZhbHVlcy5maWxsID0gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5mYyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMudmFsdWVzLmZpbGwgPSAncmdiYSgwLDAsMCwwKSc7XHJcbiAgfVxyXG4gIHRoaXMuZmlsbCA9IGhhc0ZpbGw7XHJcbiAgdmFyIGhhc1N0cm9rZSA9IGZhbHNlO1xyXG4gIGlmIChkb2N1bWVudERhdGEuc2MpIHtcclxuICAgIGhhc1N0cm9rZSA9IHRydWU7XHJcbiAgICB0aGlzLnZhbHVlcy5zdHJva2UgPSB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLnNjKTtcclxuICAgIHRoaXMudmFsdWVzLnNXaWR0aCA9IGRvY3VtZW50RGF0YS5zdztcclxuICB9XHJcbiAgdmFyIGZvbnREYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW47XHJcbiAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubDtcclxuICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xyXG4gIHRoaXMuc3Ryb2tlID0gaGFzU3Ryb2tlO1xyXG4gIHRoaXMudmFsdWVzLmZWYWx1ZSA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKyAncHggJyArIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5O1xyXG4gIGxlbiA9IGRvY3VtZW50RGF0YS5maW5hbFRleHQubGVuZ3RoO1xyXG4gIC8vIHRoaXMudEhlbHBlci5mb250ID0gdGhpcy52YWx1ZXMuZlZhbHVlO1xyXG4gIHZhciBjaGFyRGF0YTtcclxuICB2YXIgc2hhcGVEYXRhO1xyXG4gIHZhciBrO1xyXG4gIHZhciBrTGVuO1xyXG4gIHZhciBzaGFwZXM7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW47XHJcbiAgdmFyIHBhdGhOb2RlcztcclxuICB2YXIgY29tbWFuZHM7XHJcbiAgdmFyIHBhdGhBcnI7XHJcbiAgdmFyIHNpbmdsZVNoYXBlID0gdGhpcy5kYXRhLnNpbmdsZVNoYXBlO1xyXG4gIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAqIDAuMDAxICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcclxuICB2YXIgeFBvcyA9IDA7XHJcbiAgdmFyIHlQb3MgPSAwO1xyXG4gIHZhciBmaXJzdExpbmUgPSB0cnVlO1xyXG4gIHZhciBjbnQgPSAwO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgY2hhckRhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoZG9jdW1lbnREYXRhLmZpbmFsVGV4dFtpXSwgZm9udERhdGEuZlN0eWxlLCB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseSk7XHJcbiAgICBzaGFwZURhdGEgPSAoY2hhckRhdGEgJiYgY2hhckRhdGEuZGF0YSkgfHwge307XHJcbiAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcclxuICAgIGlmIChzaW5nbGVTaGFwZSAmJiBsZXR0ZXJzW2ldLm4pIHtcclxuICAgICAgeFBvcyA9IC10cmFja2luZ09mZnNldDtcclxuICAgICAgeVBvcyArPSBkb2N1bWVudERhdGEueU9mZnNldDtcclxuICAgICAgeVBvcyArPSBmaXJzdExpbmUgPyAxIDogMDtcclxuICAgICAgZmlyc3RMaW5lID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgc2hhcGVzID0gc2hhcGVEYXRhLnNoYXBlcyA/IHNoYXBlRGF0YS5zaGFwZXNbMF0uaXQgOiBbXTtcclxuICAgIGpMZW4gPSBzaGFwZXMubGVuZ3RoO1xyXG4gICAgbWF0cml4SGVscGVyLnNjYWxlKGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDAsIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDApO1xyXG4gICAgaWYgKHNpbmdsZVNoYXBlKSB7XHJcbiAgICAgIHRoaXMuYXBwbHlUZXh0UHJvcGVydGllc1RvTWF0cml4KGRvY3VtZW50RGF0YSwgbWF0cml4SGVscGVyLCBsZXR0ZXJzW2ldLmxpbmUsIHhQb3MsIHlQb3MpO1xyXG4gICAgfVxyXG4gICAgY29tbWFuZHMgPSBjcmVhdGVTaXplZEFycmF5KGpMZW4pO1xyXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICBrTGVuID0gc2hhcGVzW2pdLmtzLmsuaS5sZW5ndGg7XHJcbiAgICAgIHBhdGhOb2RlcyA9IHNoYXBlc1tqXS5rcy5rO1xyXG4gICAgICBwYXRoQXJyID0gW107XHJcbiAgICAgIGZvciAoayA9IDE7IGsgPCBrTGVuOyBrICs9IDEpIHtcclxuICAgICAgICBpZiAoayA9PT0gMSkge1xyXG4gICAgICAgICAgcGF0aEFyci5wdXNoKG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdGhBcnIucHVzaChtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLm9bayAtIDFdWzBdLCBwYXRoTm9kZXMub1trIC0gMV1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLm9bayAtIDFdWzBdLCBwYXRoTm9kZXMub1trIC0gMV1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLmlba11bMF0sIHBhdGhOb2Rlcy5pW2tdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy5pW2tdWzBdLCBwYXRoTm9kZXMuaVtrXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMudltrXVswXSwgcGF0aE5vZGVzLnZba11bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLnZba11bMF0sIHBhdGhOb2Rlcy52W2tdWzFdLCAwKSk7XHJcbiAgICAgIH1cclxuICAgICAgcGF0aEFyci5wdXNoKG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMub1trIC0gMV1bMF0sIHBhdGhOb2Rlcy5vW2sgLSAxXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMub1trIC0gMV1bMF0sIHBhdGhOb2Rlcy5vW2sgLSAxXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMuaVswXVswXSwgcGF0aE5vZGVzLmlbMF1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLmlbMF1bMF0sIHBhdGhOb2Rlcy5pWzBdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApKTtcclxuICAgICAgY29tbWFuZHNbal0gPSBwYXRoQXJyO1xyXG4gICAgfVxyXG4gICAgaWYgKHNpbmdsZVNoYXBlKSB7XHJcbiAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sO1xyXG4gICAgICB4UG9zICs9IHRyYWNraW5nT2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMudGV4dFNwYW5zW2NudF0pIHtcclxuICAgICAgdGhpcy50ZXh0U3BhbnNbY250XS5lbGVtID0gY29tbWFuZHM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnRleHRTcGFuc1tjbnRdID0geyBlbGVtOiBjb21tYW5kcyB9O1xyXG4gICAgfVxyXG4gICAgY250ICs9IDE7XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZUZXh0RWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XHJcbiAgY3R4LmZvbnQgPSB0aGlzLnZhbHVlcy5mVmFsdWU7XHJcbiAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XHJcbiAgY3R4LmxpbmVKb2luID0gJ21pdGVyJztcclxuICBjdHgubWl0ZXJMaW1pdCA9IDQ7XHJcblxyXG4gIGlmICghdGhpcy5kYXRhLnNpbmdsZVNoYXBlKSB7XHJcbiAgICB0aGlzLnRleHRBbmltYXRvci5nZXRNZWFzdXJlcyh0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YSwgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbjtcclxuICB2YXIgajtcclxuICB2YXIgakxlbjtcclxuICB2YXIgaztcclxuICB2YXIga0xlbjtcclxuICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xyXG5cclxuICB2YXIgbGV0dGVycyA9IHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmw7XHJcblxyXG4gIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xyXG4gIHZhciByZW5kZXJlZExldHRlcjtcclxuICB2YXIgbGFzdEZpbGwgPSBudWxsO1xyXG4gIHZhciBsYXN0U3Ryb2tlID0gbnVsbDtcclxuICB2YXIgbGFzdFN0cm9rZVcgPSBudWxsO1xyXG4gIHZhciBjb21tYW5kcztcclxuICB2YXIgcGF0aEFycjtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmICghbGV0dGVyc1tpXS5uKSB7XHJcbiAgICAgIHJlbmRlcmVkTGV0dGVyID0gcmVuZGVyZWRMZXR0ZXJzW2ldO1xyXG4gICAgICBpZiAocmVuZGVyZWRMZXR0ZXIpIHtcclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhUcmFuc2Zvcm0ocmVuZGVyZWRMZXR0ZXIucCk7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eE9wYWNpdHkocmVuZGVyZWRMZXR0ZXIubyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuZmlsbCkge1xyXG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlciAmJiByZW5kZXJlZExldHRlci5mYykge1xyXG4gICAgICAgICAgaWYgKGxhc3RGaWxsICE9PSByZW5kZXJlZExldHRlci5mYykge1xyXG4gICAgICAgICAgICBsYXN0RmlsbCA9IHJlbmRlcmVkTGV0dGVyLmZjO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gcmVuZGVyZWRMZXR0ZXIuZmM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RmlsbCAhPT0gdGhpcy52YWx1ZXMuZmlsbCkge1xyXG4gICAgICAgICAgbGFzdEZpbGwgPSB0aGlzLnZhbHVlcy5maWxsO1xyXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMudmFsdWVzLmZpbGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbW1hbmRzID0gdGhpcy50ZXh0U3BhbnNbaV0uZWxlbTtcclxuICAgICAgICBqTGVuID0gY29tbWFuZHMubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgIHBhdGhBcnIgPSBjb21tYW5kc1tqXTtcclxuICAgICAgICAgIGtMZW4gPSBwYXRoQXJyLmxlbmd0aDtcclxuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0Lm1vdmVUbyhwYXRoQXJyWzBdLCBwYXRoQXJyWzFdKTtcclxuICAgICAgICAgIGZvciAoayA9IDI7IGsgPCBrTGVuOyBrICs9IDYpIHtcclxuICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuYmV6aWVyQ3VydmVUbyhwYXRoQXJyW2tdLCBwYXRoQXJyW2sgKyAxXSwgcGF0aEFycltrICsgMl0sIHBhdGhBcnJbayArIDNdLCBwYXRoQXJyW2sgKyA0XSwgcGF0aEFycltrICsgNV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5maWxsKCk7XHJcbiAgICAgICAgLy8vIGN0eC5maWxsVGV4dCh0aGlzLnRleHRTcGFuc1tpXS52YWwsMCwwKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5zdHJva2UpIHtcclxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIgJiYgcmVuZGVyZWRMZXR0ZXIuc3cpIHtcclxuICAgICAgICAgIGlmIChsYXN0U3Ryb2tlVyAhPT0gcmVuZGVyZWRMZXR0ZXIuc3cpIHtcclxuICAgICAgICAgICAgbGFzdFN0cm9rZVcgPSByZW5kZXJlZExldHRlci5zdztcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHJlbmRlcmVkTGV0dGVyLnN3O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFN0cm9rZVcgIT09IHRoaXMudmFsdWVzLnNXaWR0aCkge1xyXG4gICAgICAgICAgbGFzdFN0cm9rZVcgPSB0aGlzLnZhbHVlcy5zV2lkdGg7XHJcbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy52YWx1ZXMuc1dpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIgJiYgcmVuZGVyZWRMZXR0ZXIuc2MpIHtcclxuICAgICAgICAgIGlmIChsYXN0U3Ryb2tlICE9PSByZW5kZXJlZExldHRlci5zYykge1xyXG4gICAgICAgICAgICBsYXN0U3Ryb2tlID0gcmVuZGVyZWRMZXR0ZXIuc2M7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHJlbmRlcmVkTGV0dGVyLnNjO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFN0cm9rZSAhPT0gdGhpcy52YWx1ZXMuc3Ryb2tlKSB7XHJcbiAgICAgICAgICBsYXN0U3Ryb2tlID0gdGhpcy52YWx1ZXMuc3Ryb2tlO1xyXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy52YWx1ZXMuc3Ryb2tlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21tYW5kcyA9IHRoaXMudGV4dFNwYW5zW2ldLmVsZW07XHJcbiAgICAgICAgakxlbiA9IGNvbW1hbmRzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICBwYXRoQXJyID0gY29tbWFuZHNbal07XHJcbiAgICAgICAgICBrTGVuID0gcGF0aEFyci5sZW5ndGg7XHJcbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5tb3ZlVG8ocGF0aEFyclswXSwgcGF0aEFyclsxXSk7XHJcbiAgICAgICAgICBmb3IgKGsgPSAyOyBrIDwga0xlbjsgayArPSA2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlemllckN1cnZlVG8ocGF0aEFycltrXSwgcGF0aEFycltrICsgMV0sIHBhdGhBcnJbayArIDJdLCBwYXRoQXJyW2sgKyAzXSwgcGF0aEFycltrICsgNF0sIHBhdGhBcnJbayArIDVdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICAgICAgLy8vIGN0eC5zdHJva2VUZXh0KGxldHRlcnNbaV0udmFsLDAsMCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyKSB7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLnJlc3RvcmUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIENWRWZmZWN0cygpIHtcclxuXHJcbn1cclxuQ1ZFZmZlY3RzLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZVRhZywgY3JlYXRlTlMsIHN0eWxlRGl2LCBDVkVmZmVjdHMsIE1hc2tFbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSHlicmlkUmVuZGVyZXIgKi9cclxuXHJcbmZ1bmN0aW9uIEhCYXNlRWxlbWVudCgpIHt9XHJcbkhCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XHJcbiAgY2hlY2tCbGVuZE1vZGU6IGZ1bmN0aW9uICgpIHt9LFxyXG4gIGluaXRSZW5kZXJlckVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuYmFzZUVsZW1lbnQgPSBjcmVhdGVUYWcodGhpcy5kYXRhLnRnIHx8ICdkaXYnKTtcclxuICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xyXG4gICAgICB0aGlzLnN2Z0VsZW1lbnQgPSBjcmVhdGVOUygnc3ZnJyk7XHJcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcclxuICAgICAgdGhpcy5tYXNrZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XHJcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XHJcbiAgICAgIHRoaXMuYmFzZUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zdmdFbGVtZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gdGhpcy5iYXNlRWxlbWVudDtcclxuICAgIH1cclxuICAgIHN0eWxlRGl2KHRoaXMuYmFzZUVsZW1lbnQpO1xyXG4gIH0sXHJcbiAgY3JlYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyID0gbmV3IENWRWZmZWN0cyh0aGlzKTtcclxuICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5iYXNlRWxlbWVudDtcclxuICAgIHRoaXMubWFza2VkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xyXG4gICAgaWYgKHRoaXMuZGF0YS5sbikge1xyXG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5kYXRhLmxuKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmRhdGEuY2wpIHtcclxuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMuZGF0YS5jbCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5kYXRhLmJtICE9PSAwKSB7XHJcbiAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICByZW5kZXJFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUgPSB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA/IHRoaXMudHJhbnNmb3JtZWRFbGVtZW50LnN0eWxlIDoge307XHJcbiAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XHJcbiAgICAgIHZhciBtYXRyaXhWYWx1ZSA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubWF0LnRvQ1NTKCk7XHJcbiAgICAgIHRyYW5zZm9ybWVkRWxlbWVudFN0eWxlLnRyYW5zZm9ybSA9IG1hdHJpeFZhbHVlO1xyXG4gICAgICB0cmFuc2Zvcm1lZEVsZW1lbnRTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBtYXRyaXhWYWx1ZTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZikge1xyXG4gICAgICB0cmFuc2Zvcm1lZEVsZW1lbnRTdHlsZS5vcGFjaXR5ID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5vLnY7XHJcbiAgICB9XHJcbiAgfSxcclxuICByZW5kZXJGcmFtZTogZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gSWYgaXQgaXMgZXhwb3J0ZWQgYXMgaGlkZGVuIChkYXRhLmhkID09PSB0cnVlKSBubyBuZWVkIHRvIHJlbmRlclxyXG4gICAgLy8gSWYgaXQgaXMgbm90IHZpc2libGUgbm8gbmVlZCB0byByZW5kZXJcclxuICAgIGlmICh0aGlzLmRhdGEuaGQgfHwgdGhpcy5oaWRkZW4pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZW5kZXJUcmFuc2Zvcm0oKTtcclxuICAgIHRoaXMucmVuZGVyUmVuZGVyYWJsZSgpO1xyXG4gICAgdGhpcy5yZW5kZXJFbGVtZW50KCk7XHJcbiAgICB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpO1xyXG4gICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcclxuICAgIH1cclxuICB9LFxyXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gbnVsbDtcclxuICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gbnVsbDtcclxuICAgIGlmICh0aGlzLm1hdHRlRWxlbWVudCkge1xyXG4gICAgICB0aGlzLm1hdHRlRWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tYXNrTWFuYWdlcikge1xyXG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcclxuICAgICAgdGhpcy5tYXNrTWFuYWdlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfSxcclxuICBjcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMsIHRoaXMuZ2xvYmFsRGF0YSk7XHJcbiAgfSxcclxuICBhZGRFZmZlY3RzOiBmdW5jdGlvbiAoKSB7XHJcbiAgfSxcclxuICBzZXRNYXR0ZTogZnVuY3Rpb24gKCkge30sXHJcbn07XHJcbkhCYXNlRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQgPSBTVkdCYXNlRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQ7XHJcbkhCYXNlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveUJhc2VFbGVtZW50ID0gSEJhc2VFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95O1xyXG5IQmFzZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkRWxlbWVudFBhcmVudGluZyA9IEh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5idWlsZEVsZW1lbnRQYXJlbnRpbmc7XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCBCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsXHJcblJlbmRlcmFibGVET01FbGVtZW50LCBjcmVhdGVOUywgY3JlYXRlVGFnICovXHJcblxyXG5mdW5jdGlvbiBIU29saWRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG59XHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudF0sIEhTb2xpZEVsZW1lbnQpO1xyXG5cclxuSFNvbGlkRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcmVjdDtcclxuICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcclxuICAgIHJlY3QgPSBjcmVhdGVOUygncmVjdCcpO1xyXG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5kYXRhLnN3KTtcclxuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmRhdGEuc2gpO1xyXG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCB0aGlzLmRhdGEuc2MpO1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmRhdGEuc3cpO1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5kYXRhLnNoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVjdCA9IGNyZWF0ZVRhZygnZGl2Jyk7XHJcbiAgICByZWN0LnN0eWxlLndpZHRoID0gdGhpcy5kYXRhLnN3ICsgJ3B4JztcclxuICAgIHJlY3Quc3R5bGUuaGVpZ2h0ID0gdGhpcy5kYXRhLnNoICsgJ3B4JztcclxuICAgIHJlY3Quc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5kYXRhLnNjO1xyXG4gIH1cclxuICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChyZWN0KTtcclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVTaXplZEFycmF5LCBQcm9wZXJ0eUZhY3RvcnksIGV4dGVuZFByb3RvdHlwZSwgSHlicmlkUmVuZGVyZXIsIElDb21wRWxlbWVudCwgSEJhc2VFbGVtZW50ICovXHJcblxyXG5mdW5jdGlvbiBIQ29tcEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMubGF5ZXJzID0gZGF0YS5sYXllcnM7XHJcbiAgdGhpcy5zdXBwb3J0czNkID0gIWRhdGEuaGFzTWFzaztcclxuICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XHJcbiAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcclxuICB0aGlzLmVsZW1lbnRzID0gdGhpcy5sYXllcnMgPyBjcmVhdGVTaXplZEFycmF5KHRoaXMubGF5ZXJzLmxlbmd0aCkgOiBbXTtcclxuICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG4gIHRoaXMudG0gPSBkYXRhLnRtID8gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS50bSwgMCwgZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIHRoaXMpIDogeyBfcGxhY2Vob2xkZXI6IHRydWUgfTtcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtIeWJyaWRSZW5kZXJlciwgSUNvbXBFbGVtZW50LCBIQmFzZUVsZW1lbnRdLCBIQ29tcEVsZW1lbnQpO1xyXG5IQ29tcEVsZW1lbnQucHJvdG90eXBlLl9jcmVhdGVCYXNlQ29udGFpbmVyRWxlbWVudHMgPSBIQ29tcEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzO1xyXG5cclxuSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250YWluZXJFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLl9jcmVhdGVCYXNlQ29udGFpbmVyRWxlbWVudHMoKTtcclxuICAvLyBkaXZFbGVtZW50LnN0eWxlLmNsaXAgPSAncmVjdCgwcHgsICcrdGhpcy5kYXRhLncrJ3B4LCAnK3RoaXMuZGF0YS5oKydweCwgMHB4KSc7XHJcbiAgaWYgKHRoaXMuZGF0YS5oYXNNYXNrKSB7XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZGF0YS53KTtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZGF0YS5oKTtcclxuICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5iYXNlRWxlbWVudDtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcclxuICB9XHJcbn07XHJcblxyXG5IQ29tcEVsZW1lbnQucHJvdG90eXBlLmFkZFRvM2RDb250YWluZXIgPSBmdW5jdGlvbiAoZWxlbSwgcG9zKSB7XHJcbiAgdmFyIGogPSAwO1xyXG4gIHZhciBuZXh0RWxlbWVudDtcclxuICB3aGlsZSAoaiA8IHBvcykge1xyXG4gICAgaWYgKHRoaXMuZWxlbWVudHNbal0gJiYgdGhpcy5lbGVtZW50c1tqXS5nZXRCYXNlRWxlbWVudCkge1xyXG4gICAgICBuZXh0RWxlbWVudCA9IHRoaXMuZWxlbWVudHNbal0uZ2V0QmFzZUVsZW1lbnQoKTtcclxuICAgIH1cclxuICAgIGogKz0gMTtcclxuICB9XHJcbiAgaWYgKG5leHRFbGVtZW50KSB7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5pbnNlcnRCZWZvcmUoZWxlbSwgbmV4dEVsZW1lbnQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtKTtcclxuICB9XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlTlMsIGV4dGVuZFByb3RvdHlwZSwgQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhTb2xpZEVsZW1lbnQsIFNWR1NoYXBlRWxlbWVudCwgSEJhc2VFbGVtZW50LFxyXG5IaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50LCBjcmVhdGVOUywgYm1NaW4sIGJtU3FydCwgYm1NaW4sIGJtTWF4LCBibVBvdyAqL1xyXG5cclxuZnVuY3Rpb24gSFNoYXBlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgLy8gTGlzdCBvZiBkcmF3YWJsZSBlbGVtZW50c1xyXG4gIHRoaXMuc2hhcGVzID0gW107XHJcbiAgLy8gRnVsbCBzaGFwZSBkYXRhXHJcbiAgdGhpcy5zaGFwZXNEYXRhID0gZGF0YS5zaGFwZXM7XHJcbiAgLy8gTGlzdCBvZiBzdHlsZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXHJcbiAgdGhpcy5zdHlsZXNMaXN0ID0gW107XHJcbiAgLy8gTGlzdCBvZiBtb2RpZmllcnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXHJcbiAgdGhpcy5zaGFwZU1vZGlmaWVycyA9IFtdO1xyXG4gIC8vIExpc3Qgb2YgaXRlbXMgaW4gc2hhcGUgdHJlZVxyXG4gIHRoaXMuaXRlbXNEYXRhID0gW107XHJcbiAgLy8gTGlzdCBvZiBpdGVtcyBpbiBwcmV2aW91cyBzaGFwZSB0cmVlXHJcbiAgdGhpcy5wcm9jZXNzZWRFbGVtZW50cyA9IFtdO1xyXG4gIC8vIExpc3Qgb2YgYW5pbWF0ZWQgY29tcG9uZW50c1xyXG4gIHRoaXMuYW5pbWF0ZWRDb250ZW50cyA9IFtdO1xyXG4gIHRoaXMuc2hhcGVzQ29udGFpbmVyID0gY3JlYXRlTlMoJ2cnKTtcclxuICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG4gIC8vIE1vdmluZyBhbnkgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGdldCB0b28gbXVjaCBhY2Nlc3MgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYmVjYXVzZSBvZiB2OCB3YXkgb2YgaGFuZGxpbmcgbW9yZSB0aGFuIDEwIHByb3BlcnRpZXMuXHJcbiAgLy8gTGlzdCBvZiBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBjcmVhdGVkXHJcbiAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcclxuICB0aGlzLmN1cnJlbnRCQm94ID0ge1xyXG4gICAgeDogOTk5OTk5LFxyXG4gICAgeTogLTk5OTk5OSxcclxuICAgIGg6IDAsXHJcbiAgICB3OiAwLFxyXG4gIH07XHJcbn1cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSFNvbGlkRWxlbWVudCwgU1ZHU2hhcGVFbGVtZW50LCBIQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnRdLCBIU2hhcGVFbGVtZW50KTtcclxuSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuX3JlbmRlclNoYXBlRnJhbWUgPSBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQ7XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBjb250O1xyXG4gIHRoaXMuYmFzZUVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSAwO1xyXG4gIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zaGFwZXNDb250YWluZXIpO1xyXG4gICAgY29udCA9IHRoaXMuc3ZnRWxlbWVudDtcclxuICB9IGVsc2Uge1xyXG4gICAgY29udCA9IGNyZWF0ZU5TKCdzdmcnKTtcclxuICAgIHZhciBzaXplID0gdGhpcy5jb21wLmRhdGEgPyB0aGlzLmNvbXAuZGF0YSA6IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZTtcclxuICAgIGNvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUudyk7XHJcbiAgICBjb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS5oKTtcclxuICAgIGNvbnQuYXBwZW5kQ2hpbGQodGhpcy5zaGFwZXNDb250YWluZXIpO1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udCk7XHJcbiAgfVxyXG5cclxuICB0aGlzLnNlYXJjaFNoYXBlcyh0aGlzLnNoYXBlc0RhdGEsIHRoaXMuaXRlbXNEYXRhLCB0aGlzLnByZXZWaWV3RGF0YSwgdGhpcy5zaGFwZXNDb250YWluZXIsIDAsIFtdLCB0cnVlKTtcclxuICB0aGlzLmZpbHRlclVuaXF1ZVNoYXBlcygpO1xyXG4gIHRoaXMuc2hhcGVDb250ID0gY29udDtcclxufTtcclxuXHJcbkhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkUG9pbnQgPSBmdW5jdGlvbiAodHJhbnNmb3JtZXJzLCBwb2ludCkge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0cmFuc2Zvcm1lcnMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgcG9pbnQgPSB0cmFuc2Zvcm1lcnNbaV0ubVByb3BzLnYuYXBwbHlUb1BvaW50QXJyYXkocG9pbnRbMF0sIHBvaW50WzFdLCAwKTtcclxuICB9XHJcbiAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxuSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2FsY3VsYXRlU2hhcGVCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChpdGVtLCBib3VuZGluZ0JveCkge1xyXG4gIHZhciBzaGFwZSA9IGl0ZW0uc2gudjtcclxuICB2YXIgdHJhbnNmb3JtZXJzID0gaXRlbS50cmFuc2Zvcm1lcnM7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHNoYXBlLl9sZW5ndGg7XHJcbiAgdmFyIHZQb2ludDtcclxuICB2YXIgb1BvaW50O1xyXG4gIHZhciBuZXh0SVBvaW50O1xyXG4gIHZhciBuZXh0VlBvaW50O1xyXG4gIGlmIChsZW4gPD0gMSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSArPSAxKSB7XHJcbiAgICB2UG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2ldKTtcclxuICAgIG9Qb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLm9baV0pO1xyXG4gICAgbmV4dElQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLmlbaSArIDFdKTtcclxuICAgIG5leHRWUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2kgKyAxXSk7XHJcbiAgICB0aGlzLmNoZWNrQm91bmRzKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZGluZ0JveCk7XHJcbiAgfVxyXG4gIGlmIChzaGFwZS5jKSB7XHJcbiAgICB2UG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2ldKTtcclxuICAgIG9Qb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLm9baV0pO1xyXG4gICAgbmV4dElQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLmlbMF0pO1xyXG4gICAgbmV4dFZQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLnZbMF0pO1xyXG4gICAgdGhpcy5jaGVja0JvdW5kcyh2UG9pbnQsIG9Qb2ludCwgbmV4dElQb2ludCwgbmV4dFZQb2ludCwgYm91bmRpbmdCb3gpO1xyXG4gIH1cclxufTtcclxuXHJcbkhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNoZWNrQm91bmRzID0gZnVuY3Rpb24gKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZGluZ0JveCkge1xyXG4gIHRoaXMuZ2V0Qm91bmRzT2ZDdXJ2ZSh2UG9pbnQsIG9Qb2ludCwgbmV4dElQb2ludCwgbmV4dFZQb2ludCk7XHJcbiAgdmFyIGJvdW5kcyA9IHRoaXMuc2hhcGVCb3VuZGluZ0JveDtcclxuICBib3VuZGluZ0JveC54ID0gYm1NaW4oYm91bmRzLmxlZnQsIGJvdW5kaW5nQm94LngpO1xyXG4gIGJvdW5kaW5nQm94LnhNYXggPSBibU1heChib3VuZHMucmlnaHQsIGJvdW5kaW5nQm94LnhNYXgpO1xyXG4gIGJvdW5kaW5nQm94LnkgPSBibU1pbihib3VuZHMudG9wLCBib3VuZGluZ0JveC55KTtcclxuICBib3VuZGluZ0JveC55TWF4ID0gYm1NYXgoYm91bmRzLmJvdHRvbSwgYm91bmRpbmdCb3gueU1heCk7XHJcbn07XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5zaGFwZUJvdW5kaW5nQm94ID0ge1xyXG4gIGxlZnQ6IDAsXHJcbiAgcmlnaHQ6IDAsXHJcbiAgdG9wOiAwLFxyXG4gIGJvdHRvbTogMCxcclxufTtcclxuXHJcbkhTaGFwZUVsZW1lbnQucHJvdG90eXBlLnRlbXBCb3VuZGluZ0JveCA9IHtcclxuICB4OiAwLFxyXG4gIHhNYXg6IDAsXHJcbiAgeTogMCxcclxuICB5TWF4OiAwLFxyXG4gIHdpZHRoOiAwLFxyXG4gIGhlaWdodDogMCxcclxufTtcclxuXHJcbkhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmdldEJvdW5kc09mQ3VydmUgPSBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMpIHtcclxuICB2YXIgYm91bmRzID0gW1twMFswXSwgcDNbMF1dLCBbcDBbMV0sIHAzWzFdXV07XHJcblxyXG4gIGZvciAodmFyIGEsIGIsIGMsIHQsIGIyYWMsIHQxLCB0MiwgaSA9IDA7IGkgPCAyOyArK2kpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wbHVzcGx1c1xyXG4gICAgYiA9IDYgKiBwMFtpXSAtIDEyICogcDFbaV0gKyA2ICogcDJbaV07XHJcbiAgICBhID0gLTMgKiBwMFtpXSArIDkgKiBwMVtpXSAtIDkgKiBwMltpXSArIDMgKiBwM1tpXTtcclxuICAgIGMgPSAzICogcDFbaV0gLSAzICogcDBbaV07XHJcblxyXG4gICAgYiB8PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcclxuICAgIGEgfD0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1iaXR3aXNlXHJcbiAgICBjIHw9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYml0d2lzZVxyXG5cclxuICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcclxuICAgICAgLy9cclxuICAgIH0gZWxzZSBpZiAoYSA9PT0gMCkge1xyXG4gICAgICB0ID0gLWMgLyBiO1xyXG5cclxuICAgICAgaWYgKHQgPiAwICYmIHQgPCAxKSB7XHJcbiAgICAgICAgYm91bmRzW2ldLnB1c2godGhpcy5jYWxjdWxhdGVGKHQsIHAwLCBwMSwgcDIsIHAzLCBpKSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGIyYWMgPSBiICogYiAtIDQgKiBjICogYTtcclxuXHJcbiAgICAgIGlmIChiMmFjID49IDApIHtcclxuICAgICAgICB0MSA9ICgtYiArIGJtU3FydChiMmFjKSkgLyAoMiAqIGEpO1xyXG4gICAgICAgIGlmICh0MSA+IDAgJiYgdDEgPCAxKSBib3VuZHNbaV0ucHVzaCh0aGlzLmNhbGN1bGF0ZUYodDEsIHAwLCBwMSwgcDIsIHAzLCBpKSk7XHJcbiAgICAgICAgdDIgPSAoLWIgLSBibVNxcnQoYjJhYykpIC8gKDIgKiBhKTtcclxuICAgICAgICBpZiAodDIgPiAwICYmIHQyIDwgMSkgYm91bmRzW2ldLnB1c2godGhpcy5jYWxjdWxhdGVGKHQyLCBwMCwgcDEsIHAyLCBwMywgaSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aGlzLnNoYXBlQm91bmRpbmdCb3gubGVmdCA9IGJtTWluLmFwcGx5KG51bGwsIGJvdW5kc1swXSk7XHJcbiAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LnRvcCA9IGJtTWluLmFwcGx5KG51bGwsIGJvdW5kc1sxXSk7XHJcbiAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LnJpZ2h0ID0gYm1NYXguYXBwbHkobnVsbCwgYm91bmRzWzBdKTtcclxuICB0aGlzLnNoYXBlQm91bmRpbmdCb3guYm90dG9tID0gYm1NYXguYXBwbHkobnVsbCwgYm91bmRzWzFdKTtcclxufTtcclxuXHJcbkhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNhbGN1bGF0ZUYgPSBmdW5jdGlvbiAodCwgcDAsIHAxLCBwMiwgcDMsIGkpIHtcclxuICByZXR1cm4gYm1Qb3coMSAtIHQsIDMpICogcDBbaV1cclxuICAgICAgICArIDMgKiBibVBvdygxIC0gdCwgMikgKiB0ICogcDFbaV1cclxuICAgICAgICArIDMgKiAoMSAtIHQpICogYm1Qb3codCwgMikgKiBwMltpXVxyXG4gICAgICAgICsgYm1Qb3codCwgMykgKiBwM1tpXTtcclxufTtcclxuXHJcbkhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNhbGN1bGF0ZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKGl0ZW1zRGF0YSwgYm91bmRpbmdCb3gpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gaXRlbXNEYXRhLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmIChpdGVtc0RhdGFbaV0gJiYgaXRlbXNEYXRhW2ldLnNoKSB7XHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlU2hhcGVCb3VuZGluZ0JveChpdGVtc0RhdGFbaV0sIGJvdW5kaW5nQm94KTtcclxuICAgIH0gZWxzZSBpZiAoaXRlbXNEYXRhW2ldICYmIGl0ZW1zRGF0YVtpXS5pdCkge1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kaW5nQm94KGl0ZW1zRGF0YVtpXS5pdCwgYm91bmRpbmdCb3gpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbkhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmN1cnJlbnRCb3hDb250YWlucyA9IGZ1bmN0aW9uIChib3gpIHtcclxuICByZXR1cm4gdGhpcy5jdXJyZW50QkJveC54IDw9IGJveC54XHJcbiAgICAmJiB0aGlzLmN1cnJlbnRCQm94LnkgPD0gYm94LnlcclxuICAgICYmIHRoaXMuY3VycmVudEJCb3gud2lkdGggKyB0aGlzLmN1cnJlbnRCQm94LnggPj0gYm94LnggKyBib3gud2lkdGhcclxuICAgICYmIHRoaXMuY3VycmVudEJCb3guaGVpZ2h0ICsgdGhpcy5jdXJyZW50QkJveC55ID49IGJveC55ICsgYm94LmhlaWdodDtcclxufTtcclxuXHJcbkhTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLl9yZW5kZXJTaGFwZUZyYW1lKCk7XHJcblxyXG4gIGlmICghdGhpcy5oaWRkZW4gJiYgKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCB0aGlzLl9tZGYpKSB7XHJcbiAgICB2YXIgdGVtcEJvdW5kaW5nQm94ID0gdGhpcy50ZW1wQm91bmRpbmdCb3g7XHJcbiAgICB2YXIgbWF4ID0gOTk5OTk5O1xyXG4gICAgdGVtcEJvdW5kaW5nQm94LnggPSBtYXg7XHJcbiAgICB0ZW1wQm91bmRpbmdCb3gueE1heCA9IC1tYXg7XHJcbiAgICB0ZW1wQm91bmRpbmdCb3gueSA9IG1heDtcclxuICAgIHRlbXBCb3VuZGluZ0JveC55TWF4ID0gLW1heDtcclxuICAgIHRoaXMuY2FsY3VsYXRlQm91bmRpbmdCb3godGhpcy5pdGVtc0RhdGEsIHRlbXBCb3VuZGluZ0JveCk7XHJcbiAgICB0ZW1wQm91bmRpbmdCb3gud2lkdGggPSB0ZW1wQm91bmRpbmdCb3gueE1heCA8IHRlbXBCb3VuZGluZ0JveC54ID8gMCA6IHRlbXBCb3VuZGluZ0JveC54TWF4IC0gdGVtcEJvdW5kaW5nQm94Lng7XHJcbiAgICB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0ID0gdGVtcEJvdW5kaW5nQm94LnlNYXggPCB0ZW1wQm91bmRpbmdCb3gueSA/IDAgOiB0ZW1wQm91bmRpbmdCb3gueU1heCAtIHRlbXBCb3VuZGluZ0JveC55O1xyXG4gICAgLy8gdmFyIHRlbXBCb3VuZGluZ0JveCA9IHRoaXMuc2hhcGVDb250LmdldEJCb3goKTtcclxuICAgIGlmICh0aGlzLmN1cnJlbnRCb3hDb250YWlucyh0ZW1wQm91bmRpbmdCb3gpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50QkJveC53ICE9PSB0ZW1wQm91bmRpbmdCb3gud2lkdGgpIHtcclxuICAgICAgdGhpcy5jdXJyZW50QkJveC53ID0gdGVtcEJvdW5kaW5nQm94LndpZHRoO1xyXG4gICAgICB0aGlzLnNoYXBlQ29udC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGVtcEJvdW5kaW5nQm94LndpZHRoKTtcclxuICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jdXJyZW50QkJveC5oICE9PSB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0KSB7XHJcbiAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IHRlbXBCb3VuZGluZ0JveC5oZWlnaHQ7XHJcbiAgICAgIHRoaXMuc2hhcGVDb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGVtcEJvdW5kaW5nQm94LmhlaWdodCk7XHJcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGNoYW5nZWQgfHwgdGhpcy5jdXJyZW50QkJveC54ICE9PSB0ZW1wQm91bmRpbmdCb3gueCB8fCB0aGlzLmN1cnJlbnRCQm94LnkgIT09IHRlbXBCb3VuZGluZ0JveC55KSB7XHJcbiAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IHRlbXBCb3VuZGluZ0JveC53aWR0aDtcclxuICAgICAgdGhpcy5jdXJyZW50QkJveC5oID0gdGVtcEJvdW5kaW5nQm94LmhlaWdodDtcclxuICAgICAgdGhpcy5jdXJyZW50QkJveC54ID0gdGVtcEJvdW5kaW5nQm94Lng7XHJcbiAgICAgIHRoaXMuY3VycmVudEJCb3gueSA9IHRlbXBCb3VuZGluZ0JveC55O1xyXG5cclxuICAgICAgdGhpcy5zaGFwZUNvbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgdGhpcy5jdXJyZW50QkJveC54ICsgJyAnICsgdGhpcy5jdXJyZW50QkJveC55ICsgJyAnICsgdGhpcy5jdXJyZW50QkJveC53ICsgJyAnICsgdGhpcy5jdXJyZW50QkJveC5oKTtcclxuICAgICAgdmFyIHNoYXBlU3R5bGUgPSB0aGlzLnNoYXBlQ29udC5zdHlsZTtcclxuICAgICAgdmFyIHNoYXBlVHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgdGhpcy5jdXJyZW50QkJveC54ICsgJ3B4LCcgKyB0aGlzLmN1cnJlbnRCQm94LnkgKyAncHgpJztcclxuICAgICAgc2hhcGVTdHlsZS50cmFuc2Zvcm0gPSBzaGFwZVRyYW5zZm9ybTtcclxuICAgICAgc2hhcGVTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzaGFwZVRyYW5zZm9ybTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCBCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsXHJcblJlbmRlcmFibGVET01FbGVtZW50LCBJVGV4dEVsZW1lbnQsIGNyZWF0ZVNpemVkQXJyYXksIGNyZWF0ZVRhZywgc3R5bGVEaXYsIGNyZWF0ZU5TICovXHJcblxyXG5mdW5jdGlvbiBIVGV4dEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMudGV4dFNwYW5zID0gW107XHJcbiAgdGhpcy50ZXh0UGF0aHMgPSBbXTtcclxuICB0aGlzLmN1cnJlbnRCQm94ID0ge1xyXG4gICAgeDogOTk5OTk5LFxyXG4gICAgeTogLTk5OTk5OSxcclxuICAgIGg6IDAsXHJcbiAgICB3OiAwLFxyXG4gIH07XHJcbiAgdGhpcy5yZW5kZXJUeXBlID0gJ3N2Zyc7XHJcbiAgdGhpcy5pc01hc2tlZCA9IGZhbHNlO1xyXG4gIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbn1cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50LCBJVGV4dEVsZW1lbnRdLCBIVGV4dEVsZW1lbnQpO1xyXG5cclxuSFRleHRFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuaXNNYXNrZWQgPSB0aGlzLmNoZWNrTWFza3MoKTtcclxuICBpZiAodGhpcy5pc01hc2tlZCkge1xyXG4gICAgdGhpcy5yZW5kZXJUeXBlID0gJ3N2Zyc7XHJcbiAgICB0aGlzLmNvbXBXID0gdGhpcy5jb21wLmRhdGEudztcclxuICAgIHRoaXMuY29tcEggPSB0aGlzLmNvbXAuZGF0YS5oO1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmNvbXBXKTtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuY29tcEgpO1xyXG4gICAgdmFyIGcgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgdGhpcy5tYXNrZWRFbGVtZW50LmFwcGVuZENoaWxkKGcpO1xyXG4gICAgdGhpcy5pbm5lckVsZW0gPSBnO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnJlbmRlclR5cGUgPSAnaHRtbCc7XHJcbiAgICB0aGlzLmlubmVyRWxlbSA9IHRoaXMubGF5ZXJFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgdGhpcy5jaGVja1BhcmVudGluZygpO1xyXG59O1xyXG5cclxuSFRleHRFbGVtZW50LnByb3RvdHlwZS5idWlsZE5ld1RleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGRvY3VtZW50RGF0YSA9IHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhO1xyXG4gIHRoaXMucmVuZGVyZWRMZXR0ZXJzID0gY3JlYXRlU2l6ZWRBcnJheShkb2N1bWVudERhdGEubCA/IGRvY3VtZW50RGF0YS5sLmxlbmd0aCA6IDApO1xyXG4gIHZhciBpbm5lckVsZW1TdHlsZSA9IHRoaXMuaW5uZXJFbGVtLnN0eWxlO1xyXG4gIHZhciB0ZXh0Q29sb3IgPSBkb2N1bWVudERhdGEuZmMgPyB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLmZjKSA6ICdyZ2JhKDAsMCwwLDApJztcclxuICBpbm5lckVsZW1TdHlsZS5maWxsID0gdGV4dENvbG9yO1xyXG4gIGlubmVyRWxlbVN0eWxlLmNvbG9yID0gdGV4dENvbG9yO1xyXG4gIGlmIChkb2N1bWVudERhdGEuc2MpIHtcclxuICAgIGlubmVyRWxlbVN0eWxlLnN0cm9rZSA9IHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuc2MpO1xyXG4gICAgaW5uZXJFbGVtU3R5bGUuc3Ryb2tlV2lkdGggPSBkb2N1bWVudERhdGEuc3cgKyAncHgnO1xyXG4gIH1cclxuICB2YXIgZm9udERhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZik7XHJcbiAgaWYgKCF0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuY2hhcnMpIHtcclxuICAgIGlubmVyRWxlbVN0eWxlLmZvbnRTaXplID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSArICdweCc7XHJcbiAgICBpbm5lckVsZW1TdHlsZS5saW5lSGVpZ2h0ID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSArICdweCc7XHJcbiAgICBpZiAoZm9udERhdGEuZkNsYXNzKSB7XHJcbiAgICAgIHRoaXMuaW5uZXJFbGVtLmNsYXNzTmFtZSA9IGZvbnREYXRhLmZDbGFzcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlubmVyRWxlbVN0eWxlLmZvbnRGYW1pbHkgPSBmb250RGF0YS5mRmFtaWx5O1xyXG4gICAgICB2YXIgZldlaWdodCA9IGRvY3VtZW50RGF0YS5mV2VpZ2h0O1xyXG4gICAgICB2YXIgZlN0eWxlID0gZG9jdW1lbnREYXRhLmZTdHlsZTtcclxuICAgICAgaW5uZXJFbGVtU3R5bGUuZm9udFN0eWxlID0gZlN0eWxlO1xyXG4gICAgICBpbm5lckVsZW1TdHlsZS5mb250V2VpZ2h0ID0gZldlaWdodDtcclxuICAgIH1cclxuICB9XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbjtcclxuXHJcbiAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubDtcclxuICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcclxuICB2YXIgdFNwYW47XHJcbiAgdmFyIHRQYXJlbnQ7XHJcbiAgdmFyIHRDb250O1xyXG4gIHZhciBtYXRyaXhIZWxwZXIgPSB0aGlzLm1IZWxwZXI7XHJcbiAgdmFyIHNoYXBlcztcclxuICB2YXIgc2hhcGVTdHIgPSAnJztcclxuICB2YXIgY250ID0gMDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmICh0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuY2hhcnMpIHtcclxuICAgICAgaWYgKCF0aGlzLnRleHRQYXRoc1tjbnRdKSB7XHJcbiAgICAgICAgdFNwYW4gPSBjcmVhdGVOUygncGF0aCcpO1xyXG4gICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAnYnV0dCcpO1xyXG4gICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgJ3JvdW5kJyk7XHJcbiAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UtbWl0ZXJsaW1pdCcsICc0Jyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRQYXRoc1tjbnRdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRleHRTcGFuc1tjbnRdKSB7XHJcbiAgICAgICAgICB0UGFyZW50ID0gdGhpcy50ZXh0U3BhbnNbY250XTtcclxuICAgICAgICAgIHRDb250ID0gdFBhcmVudC5jaGlsZHJlblswXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdFBhcmVudCA9IGNyZWF0ZVRhZygnZGl2Jyk7XHJcbiAgICAgICAgICB0UGFyZW50LnN0eWxlLmxpbmVIZWlnaHQgPSAwO1xyXG4gICAgICAgICAgdENvbnQgPSBjcmVhdGVOUygnc3ZnJyk7XHJcbiAgICAgICAgICB0Q29udC5hcHBlbmRDaGlsZCh0U3Bhbik7XHJcbiAgICAgICAgICBzdHlsZURpdih0UGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcclxuICAgICAgaWYgKHRoaXMudGV4dFNwYW5zW2NudF0pIHtcclxuICAgICAgICB0UGFyZW50ID0gdGhpcy50ZXh0U3BhbnNbY250XTtcclxuICAgICAgICB0U3BhbiA9IHRoaXMudGV4dFBhdGhzW2NudF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdFBhcmVudCA9IGNyZWF0ZVRhZygnc3BhbicpO1xyXG4gICAgICAgIHN0eWxlRGl2KHRQYXJlbnQpO1xyXG4gICAgICAgIHRTcGFuID0gY3JlYXRlVGFnKCdzcGFuJyk7XHJcbiAgICAgICAgc3R5bGVEaXYodFNwYW4pO1xyXG4gICAgICAgIHRQYXJlbnQuYXBwZW5kQ2hpbGQodFNwYW4pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0U3BhbiA9IHRoaXMudGV4dFBhdGhzW2NudF0gPyB0aGlzLnRleHRQYXRoc1tjbnRdIDogY3JlYXRlTlMoJ3RleHQnKTtcclxuICAgIH1cclxuICAgIC8vIHRTcGFuLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcclxuICAgIGlmICh0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuY2hhcnMpIHtcclxuICAgICAgdmFyIGNoYXJEYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldENoYXJEYXRhKGRvY3VtZW50RGF0YS5maW5hbFRleHRbaV0sIGZvbnREYXRhLmZTdHlsZSwgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHkpO1xyXG4gICAgICB2YXIgc2hhcGVEYXRhO1xyXG4gICAgICBpZiAoY2hhckRhdGEpIHtcclxuICAgICAgICBzaGFwZURhdGEgPSBjaGFyRGF0YS5kYXRhO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNoYXBlRGF0YSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgbWF0cml4SGVscGVyLnJlc2V0KCk7XHJcbiAgICAgIGlmIChzaGFwZURhdGEgJiYgc2hhcGVEYXRhLnNoYXBlcykge1xyXG4gICAgICAgIHNoYXBlcyA9IHNoYXBlRGF0YS5zaGFwZXNbMF0uaXQ7XHJcbiAgICAgICAgbWF0cml4SGVscGVyLnNjYWxlKGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDAsIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDApO1xyXG4gICAgICAgIHNoYXBlU3RyID0gdGhpcy5jcmVhdGVQYXRoU2hhcGUobWF0cml4SGVscGVyLCBzaGFwZXMpO1xyXG4gICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnZCcsIHNoYXBlU3RyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcclxuICAgICAgICB0aGlzLmlubmVyRWxlbS5hcHBlbmRDaGlsZCh0UGFyZW50KTtcclxuICAgICAgICBpZiAoc2hhcGVEYXRhICYmIHNoYXBlRGF0YS5zaGFwZXMpIHtcclxuICAgICAgICAgIC8vIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQgaXMgbmVlZGVkIHRvIGdldCBleGFjdCBtZWFzdXJlIG9mIHNoYXBlXHJcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRDb250KTtcclxuICAgICAgICAgIHZhciBib3VuZGluZ0JveCA9IHRDb250LmdldEJCb3goKTtcclxuICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBib3VuZGluZ0JveC53aWR0aCArIDIpO1xyXG4gICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBib3VuZGluZ0JveC5oZWlnaHQgKyAyKTtcclxuICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIChib3VuZGluZ0JveC54IC0gMSkgKyAnICcgKyAoYm91bmRpbmdCb3gueSAtIDEpICsgJyAnICsgKGJvdW5kaW5nQm94LndpZHRoICsgMikgKyAnICcgKyAoYm91bmRpbmdCb3guaGVpZ2h0ICsgMikpO1xyXG4gICAgICAgICAgdmFyIHRDb250U3R5bGUgPSB0Q29udC5zdHlsZTtcclxuICAgICAgICAgIHZhciB0Q29udFRyYW5zbGF0aW9uID0gJ3RyYW5zbGF0ZSgnICsgKGJvdW5kaW5nQm94LnggLSAxKSArICdweCwnICsgKGJvdW5kaW5nQm94LnkgLSAxKSArICdweCknO1xyXG4gICAgICAgICAgdENvbnRTdHlsZS50cmFuc2Zvcm0gPSB0Q29udFRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgdENvbnRTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0Q29udFRyYW5zbGF0aW9uO1xyXG5cclxuICAgICAgICAgIGxldHRlcnNbaV0ueU9mZnNldCA9IGJvdW5kaW5nQm94LnkgLSAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0Q29udC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMSk7XHJcbiAgICAgICAgICB0Q29udC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0UGFyZW50LmFwcGVuZENoaWxkKHRDb250KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmlubmVyRWxlbS5hcHBlbmRDaGlsZCh0U3Bhbik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRTcGFuLnRleHRDb250ZW50ID0gbGV0dGVyc1tpXS52YWw7XHJcbiAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLCAneG1sOnNwYWNlJywgJ3ByZXNlcnZlJyk7XHJcbiAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xyXG4gICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRQYXJlbnQpO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgdmFyIHRTdHlsZSA9IHRTcGFuLnN0eWxlO1xyXG4gICAgICAgIHZhciB0U3BhblRyYW5zbGF0aW9uID0gJ3RyYW5zbGF0ZTNkKDAsJyArIC1kb2N1bWVudERhdGEuZmluYWxTaXplIC8gMS4yICsgJ3B4LDApJztcclxuICAgICAgICB0U3R5bGUudHJhbnNmb3JtID0gdFNwYW5UcmFuc2xhdGlvbjtcclxuICAgICAgICB0U3R5bGUud2Via2l0VHJhbnNmb3JtID0gdFNwYW5UcmFuc2xhdGlvbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmlubmVyRWxlbS5hcHBlbmRDaGlsZCh0U3Bhbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vXHJcbiAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcclxuICAgICAgdGhpcy50ZXh0U3BhbnNbY250XSA9IHRQYXJlbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnRleHRTcGFuc1tjbnRdID0gdFNwYW47XHJcbiAgICB9XHJcbiAgICB0aGlzLnRleHRTcGFuc1tjbnRdLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgdGhpcy50ZXh0UGF0aHNbY250XSA9IHRTcGFuO1xyXG4gICAgY250ICs9IDE7XHJcbiAgfVxyXG4gIHdoaWxlIChjbnQgPCB0aGlzLnRleHRTcGFucy5sZW5ndGgpIHtcclxuICAgIHRoaXMudGV4dFNwYW5zW2NudF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIGNudCArPSAxO1xyXG4gIH1cclxufTtcclxuXHJcbkhUZXh0RWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzdmdTdHlsZTtcclxuICBpZiAodGhpcy5kYXRhLnNpbmdsZVNoYXBlKSB7XHJcbiAgICBpZiAoIXRoaXMuX2lzRmlyc3RGcmFtZSAmJiAhdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSBpZiAodGhpcy5pc01hc2tlZCAmJiB0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcclxuICAgICAgLy8gVG9kbyBCZW5jaG1hcmsgaWYgdXNpbmcgdGhpcyBpcyBiZXR0ZXIgdGhhbiBnZXRCQm94XHJcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMF0gKyAnICcgKyAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMV0gKyAnICcgKyB0aGlzLmNvbXBXICsgJyAnICsgdGhpcy5jb21wSCk7XHJcbiAgICAgIHN2Z1N0eWxlID0gdGhpcy5zdmdFbGVtZW50LnN0eWxlO1xyXG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSAndHJhbnNsYXRlKCcgKyAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMF0gKyAncHgsJyArIC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlsxXSArICdweCknO1xyXG4gICAgICBzdmdTdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGlvbjtcclxuICAgICAgc3ZnU3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNsYXRpb247XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aGlzLnRleHRBbmltYXRvci5nZXRNZWFzdXJlcyh0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YSwgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcpO1xyXG4gIGlmICghdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgJiYgIXRoaXMudGV4dEFuaW1hdG9yLmxldHRlcnNDaGFuZ2VkRmxhZykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgaTtcclxuICB2YXIgbGVuO1xyXG4gIHZhciBjb3VudCA9IDA7XHJcbiAgdmFyIHJlbmRlcmVkTGV0dGVycyA9IHRoaXMudGV4dEFuaW1hdG9yLnJlbmRlcmVkTGV0dGVycztcclxuXHJcbiAgdmFyIGxldHRlcnMgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS5sO1xyXG5cclxuICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcclxuICB2YXIgcmVuZGVyZWRMZXR0ZXI7XHJcbiAgdmFyIHRleHRTcGFuO1xyXG4gIHZhciB0ZXh0UGF0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmIChsZXR0ZXJzW2ldLm4pIHtcclxuICAgICAgY291bnQgKz0gMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRleHRTcGFuID0gdGhpcy50ZXh0U3BhbnNbaV07XHJcbiAgICAgIHRleHRQYXRoID0gdGhpcy50ZXh0UGF0aHNbaV07XHJcbiAgICAgIHJlbmRlcmVkTGV0dGVyID0gcmVuZGVyZWRMZXR0ZXJzW2NvdW50XTtcclxuICAgICAgY291bnQgKz0gMTtcclxuICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYubSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xyXG4gICAgICAgICAgdGV4dFNwYW4uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gcmVuZGVyZWRMZXR0ZXIubTtcclxuICAgICAgICAgIHRleHRTcGFuLnN0eWxlLnRyYW5zZm9ybSA9IHJlbmRlcmVkTGV0dGVyLm07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgcmVuZGVyZWRMZXR0ZXIubSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vLyAvdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdvcGFjaXR5JyxyZW5kZXJlZExldHRlci5vKTtcclxuICAgICAgdGV4dFNwYW4uc3R5bGUub3BhY2l0eSA9IHJlbmRlcmVkTGV0dGVyLm87XHJcbiAgICAgIGlmIChyZW5kZXJlZExldHRlci5zdyAmJiByZW5kZXJlZExldHRlci5fbWRmLnN3KSB7XHJcbiAgICAgICAgdGV4dFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCByZW5kZXJlZExldHRlci5zdyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLnNjICYmIHJlbmRlcmVkTGV0dGVyLl9tZGYuc2MpIHtcclxuICAgICAgICB0ZXh0UGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHJlbmRlcmVkTGV0dGVyLnNjKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuZmMgJiYgcmVuZGVyZWRMZXR0ZXIuX21kZi5mYykge1xyXG4gICAgICAgIHRleHRQYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHJlbmRlcmVkTGV0dGVyLmZjKTtcclxuICAgICAgICB0ZXh0UGF0aC5zdHlsZS5jb2xvciA9IHJlbmRlcmVkTGV0dGVyLmZjO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy5pbm5lckVsZW0uZ2V0QkJveCAmJiAhdGhpcy5oaWRkZW4gJiYgKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCB0aGlzLl9tZGYpKSB7XHJcbiAgICB2YXIgYm91bmRpbmdCb3ggPSB0aGlzLmlubmVyRWxlbS5nZXRCQm94KCk7XHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudEJCb3gudyAhPT0gYm91bmRpbmdCb3gud2lkdGgpIHtcclxuICAgICAgdGhpcy5jdXJyZW50QkJveC53ID0gYm91bmRpbmdCb3gud2lkdGg7XHJcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgYm91bmRpbmdCb3gud2lkdGgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY3VycmVudEJCb3guaCAhPT0gYm91bmRpbmdCb3guaGVpZ2h0KSB7XHJcbiAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IGJvdW5kaW5nQm94LmhlaWdodDtcclxuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYm91bmRpbmdCb3guaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWFyZ2luID0gMTtcclxuICAgIGlmICh0aGlzLmN1cnJlbnRCQm94LncgIT09IChib3VuZGluZ0JveC53aWR0aCArIG1hcmdpbiAqIDIpIHx8IHRoaXMuY3VycmVudEJCb3guaCAhPT0gKGJvdW5kaW5nQm94LmhlaWdodCArIG1hcmdpbiAqIDIpIHx8IHRoaXMuY3VycmVudEJCb3gueCAhPT0gKGJvdW5kaW5nQm94LnggLSBtYXJnaW4pIHx8IHRoaXMuY3VycmVudEJCb3gueSAhPT0gKGJvdW5kaW5nQm94LnkgLSBtYXJnaW4pKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IGJvdW5kaW5nQm94LndpZHRoICsgbWFyZ2luICogMjtcclxuICAgICAgdGhpcy5jdXJyZW50QkJveC5oID0gYm91bmRpbmdCb3guaGVpZ2h0ICsgbWFyZ2luICogMjtcclxuICAgICAgdGhpcy5jdXJyZW50QkJveC54ID0gYm91bmRpbmdCb3gueCAtIG1hcmdpbjtcclxuICAgICAgdGhpcy5jdXJyZW50QkJveC55ID0gYm91bmRpbmdCb3gueSAtIG1hcmdpbjtcclxuXHJcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB0aGlzLmN1cnJlbnRCQm94LnggKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LnkgKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LncgKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LmgpO1xyXG4gICAgICBzdmdTdHlsZSA9IHRoaXMuc3ZnRWxlbWVudC5zdHlsZTtcclxuICAgICAgdmFyIHN2Z1RyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHRoaXMuY3VycmVudEJCb3gueCArICdweCwnICsgdGhpcy5jdXJyZW50QkJveC55ICsgJ3B4KSc7XHJcbiAgICAgIHN2Z1N0eWxlLnRyYW5zZm9ybSA9IHN2Z1RyYW5zZm9ybTtcclxuICAgICAgc3ZnU3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3ZnVHJhbnNmb3JtO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIEJhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIQmFzZUVsZW1lbnQsIEhTb2xpZEVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsXHJcbkZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnQsIGNyZWF0ZU5TICovXHJcblxyXG5mdW5jdGlvbiBISW1hZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xyXG4gIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbn1cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhCYXNlRWxlbWVudCwgSFNvbGlkRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudF0sIEhJbWFnZUVsZW1lbnQpO1xyXG5cclxuSEltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgYXNzZXRQYXRoID0gdGhpcy5nbG9iYWxEYXRhLmdldEFzc2V0c1BhdGgodGhpcy5hc3NldERhdGEpO1xyXG4gIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgaWYgKHRoaXMuZGF0YS5oYXNNYXNrKSB7XHJcbiAgICB0aGlzLmltYWdlRWxlbSA9IGNyZWF0ZU5TKCdpbWFnZScpO1xyXG4gICAgdGhpcy5pbWFnZUVsZW0uc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuYXNzZXREYXRhLncgKyAncHgnKTtcclxuICAgIHRoaXMuaW1hZ2VFbGVtLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5hc3NldERhdGEuaCArICdweCcpO1xyXG4gICAgdGhpcy5pbWFnZUVsZW0uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIGFzc2V0UGF0aCk7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmltYWdlRWxlbSk7XHJcbiAgICB0aGlzLmJhc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmFzc2V0RGF0YS53KTtcclxuICAgIHRoaXMuYmFzZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmFzc2V0RGF0YS5oKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoaW1nKTtcclxuICB9XHJcbiAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcbiAgaW1nLnNyYyA9IGFzc2V0UGF0aDtcclxuICBpZiAodGhpcy5kYXRhLmxuKSB7XHJcbiAgICB0aGlzLmJhc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmRhdGEubG4pO1xyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBQcm9wZXJ0eUZhY3RvcnksIGRlZ1RvUmFkcywgTWF0cml4LCBleHRlbmRQcm90b3R5cGUsIEJhc2VFbGVtZW50LCBGcmFtZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQgKi9cclxuXHJcbmZ1bmN0aW9uIEhDYW1lcmFFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICB0aGlzLmluaXRGcmFtZSgpO1xyXG4gIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG4gIHRoaXMuaW5pdEhpZXJhcmNoeSgpO1xyXG4gIHZhciBnZXRQcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3A7XHJcbiAgdGhpcy5wZSA9IGdldFByb3AodGhpcywgZGF0YS5wZSwgMCwgMCwgdGhpcyk7XHJcbiAgaWYgKGRhdGEua3MucC5zKSB7XHJcbiAgICB0aGlzLnB4ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAueCwgMSwgMCwgdGhpcyk7XHJcbiAgICB0aGlzLnB5ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAueSwgMSwgMCwgdGhpcyk7XHJcbiAgICB0aGlzLnB6ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAueiwgMSwgMCwgdGhpcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMucCA9IGdldFByb3AodGhpcywgZGF0YS5rcy5wLCAxLCAwLCB0aGlzKTtcclxuICB9XHJcbiAgaWYgKGRhdGEua3MuYSkge1xyXG4gICAgdGhpcy5hID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLmEsIDEsIDAsIHRoaXMpO1xyXG4gIH1cclxuICBpZiAoZGF0YS5rcy5vci5rLmxlbmd0aCAmJiBkYXRhLmtzLm9yLmtbMF0udG8pIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IGRhdGEua3Mub3Iuay5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgZGF0YS5rcy5vci5rW2ldLnRvID0gbnVsbDtcclxuICAgICAgZGF0YS5rcy5vci5rW2ldLnRpID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbiAgdGhpcy5vciA9IGdldFByb3AodGhpcywgZGF0YS5rcy5vciwgMSwgZGVnVG9SYWRzLCB0aGlzKTtcclxuICB0aGlzLm9yLnNoID0gdHJ1ZTtcclxuICB0aGlzLnJ4ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnJ4LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gIHRoaXMucnkgPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucnksIDAsIGRlZ1RvUmFkcywgdGhpcyk7XHJcbiAgdGhpcy5yeiA9IGdldFByb3AodGhpcywgZGF0YS5rcy5yeiwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcclxuICB0aGlzLm1hdCA9IG5ldyBNYXRyaXgoKTtcclxuICB0aGlzLl9wcmV2TWF0ID0gbmV3IE1hdHJpeCgpO1xyXG4gIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XHJcblxyXG4gIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgd2F5IHRvIG1ha2UgdGhlIEhDYW1lcmEgZWxlbWVudCB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIExheWVySW50ZXJmYWNlIGFuZCBUcmFuc2Zvcm1JbnRlcmZhY2UuXHJcbiAgdGhpcy5maW5hbFRyYW5zZm9ybSA9IHtcclxuICAgIG1Qcm9wOiB0aGlzLFxyXG4gIH07XHJcbn1cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgRnJhbWVFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50XSwgSENhbWVyYUVsZW1lbnQpO1xyXG5cclxuSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLmNvbXAudGhyZWVERWxlbWVudHMubGVuZ3RoO1xyXG4gIHZhciBjb21wO1xyXG4gIHZhciBwZXJzcGVjdGl2ZVN0eWxlO1xyXG4gIHZhciBjb250YWluZXJTdHlsZTtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIC8vIFtwZXJzcGVjdGl2ZUVsZW0sY29udGFpbmVyXVxyXG4gICAgY29tcCA9IHRoaXMuY29tcC50aHJlZURFbGVtZW50c1tpXTtcclxuICAgIGlmIChjb21wLnR5cGUgPT09ICczZCcpIHtcclxuICAgICAgcGVyc3BlY3RpdmVTdHlsZSA9IGNvbXAucGVyc3BlY3RpdmVFbGVtLnN0eWxlO1xyXG4gICAgICBjb250YWluZXJTdHlsZSA9IGNvbXAuY29udGFpbmVyLnN0eWxlO1xyXG4gICAgICB2YXIgcGVyc3BlY3RpdmUgPSB0aGlzLnBlLnYgKyAncHgnO1xyXG4gICAgICB2YXIgb3JpZ2luID0gJzBweCAwcHggMHB4JztcclxuICAgICAgdmFyIG1hdHJpeCA9ICdtYXRyaXgzZCgxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxKSc7XHJcbiAgICAgIHBlcnNwZWN0aXZlU3R5bGUucGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZTtcclxuICAgICAgcGVyc3BlY3RpdmVTdHlsZS53ZWJraXRQZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlO1xyXG4gICAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XHJcbiAgICAgIGNvbnRhaW5lclN0eWxlLm1velRyYW5zZm9ybU9yaWdpbiA9IG9yaWdpbjtcclxuICAgICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xyXG4gICAgICBwZXJzcGVjdGl2ZVN0eWxlLnRyYW5zZm9ybSA9IG1hdHJpeDtcclxuICAgICAgcGVyc3BlY3RpdmVTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBtYXRyaXg7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblxyXG5IQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIF9tZGYgPSB0aGlzLl9pc0ZpcnN0RnJhbWU7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbjtcclxuICBpZiAodGhpcy5oaWVyYXJjaHkpIHtcclxuICAgIGxlbiA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBfbWRmID0gdGhpcy5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCBfbWRmO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoX21kZiB8fCB0aGlzLnBlLl9tZGYgfHwgKHRoaXMucCAmJiB0aGlzLnAuX21kZikgfHwgKHRoaXMucHggJiYgKHRoaXMucHguX21kZiB8fCB0aGlzLnB5Ll9tZGYgfHwgdGhpcy5wei5fbWRmKSkgfHwgdGhpcy5yeC5fbWRmIHx8IHRoaXMucnkuX21kZiB8fCB0aGlzLnJ6Ll9tZGYgfHwgdGhpcy5vci5fbWRmIHx8ICh0aGlzLmEgJiYgdGhpcy5hLl9tZGYpKSB7XHJcbiAgICB0aGlzLm1hdC5yZXNldCgpO1xyXG5cclxuICAgIGlmICh0aGlzLmhpZXJhcmNoeSkge1xyXG4gICAgICBsZW4gPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGggLSAxO1xyXG4gICAgICBmb3IgKGkgPSBsZW47IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICAgICAgdmFyIG1UcmFuc2YgPSB0aGlzLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcDtcclxuICAgICAgICB0aGlzLm1hdC50cmFuc2xhdGUoLW1UcmFuc2YucC52WzBdLCAtbVRyYW5zZi5wLnZbMV0sIG1UcmFuc2YucC52WzJdKTtcclxuICAgICAgICB0aGlzLm1hdC5yb3RhdGVYKC1tVHJhbnNmLm9yLnZbMF0pLnJvdGF0ZVkoLW1UcmFuc2Yub3IudlsxXSkucm90YXRlWihtVHJhbnNmLm9yLnZbMl0pO1xyXG4gICAgICAgIHRoaXMubWF0LnJvdGF0ZVgoLW1UcmFuc2Yucngudikucm90YXRlWSgtbVRyYW5zZi5yeS52KS5yb3RhdGVaKG1UcmFuc2Yucnoudik7XHJcbiAgICAgICAgdGhpcy5tYXQuc2NhbGUoMSAvIG1UcmFuc2Yucy52WzBdLCAxIC8gbVRyYW5zZi5zLnZbMV0sIDEgLyBtVHJhbnNmLnMudlsyXSk7XHJcbiAgICAgICAgdGhpcy5tYXQudHJhbnNsYXRlKG1UcmFuc2YuYS52WzBdLCBtVHJhbnNmLmEudlsxXSwgbVRyYW5zZi5hLnZbMl0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5wKSB7XHJcbiAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgtdGhpcy5wLnZbMF0sIC10aGlzLnAudlsxXSwgdGhpcy5wLnZbMl0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5tYXQudHJhbnNsYXRlKC10aGlzLnB4LnYsIC10aGlzLnB5LnYsIHRoaXMucHoudik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5hKSB7XHJcbiAgICAgIHZhciBkaWZmVmVjdG9yO1xyXG4gICAgICBpZiAodGhpcy5wKSB7XHJcbiAgICAgICAgZGlmZlZlY3RvciA9IFt0aGlzLnAudlswXSAtIHRoaXMuYS52WzBdLCB0aGlzLnAudlsxXSAtIHRoaXMuYS52WzFdLCB0aGlzLnAudlsyXSAtIHRoaXMuYS52WzJdXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkaWZmVmVjdG9yID0gW3RoaXMucHgudiAtIHRoaXMuYS52WzBdLCB0aGlzLnB5LnYgLSB0aGlzLmEudlsxXSwgdGhpcy5wei52IC0gdGhpcy5hLnZbMl1dO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBtYWcgPSBNYXRoLnNxcnQoTWF0aC5wb3coZGlmZlZlY3RvclswXSwgMikgKyBNYXRoLnBvdyhkaWZmVmVjdG9yWzFdLCAyKSArIE1hdGgucG93KGRpZmZWZWN0b3JbMl0sIDIpKTtcclxuICAgICAgLy8gdmFyIGxvb2tEaXIgPSBnZXROb3JtYWxpemVkUG9pbnQoZ2V0RGlmZlZlY3Rvcih0aGlzLmEudix0aGlzLnAudikpO1xyXG4gICAgICB2YXIgbG9va0RpciA9IFtkaWZmVmVjdG9yWzBdIC8gbWFnLCBkaWZmVmVjdG9yWzFdIC8gbWFnLCBkaWZmVmVjdG9yWzJdIC8gbWFnXTtcclxuICAgICAgdmFyIGxvb2tMZW5ndGhPblhaID0gTWF0aC5zcXJ0KGxvb2tEaXJbMl0gKiBsb29rRGlyWzJdICsgbG9va0RpclswXSAqIGxvb2tEaXJbMF0pO1xyXG4gICAgICB2YXIgbVJvdGF0aW9uWCA9IChNYXRoLmF0YW4yKGxvb2tEaXJbMV0sIGxvb2tMZW5ndGhPblhaKSk7XHJcbiAgICAgIHZhciBtUm90YXRpb25ZID0gKE1hdGguYXRhbjIobG9va0RpclswXSwgLWxvb2tEaXJbMl0pKTtcclxuICAgICAgdGhpcy5tYXQucm90YXRlWShtUm90YXRpb25ZKS5yb3RhdGVYKC1tUm90YXRpb25YKTtcclxuICAgIH1cclxuICAgIHRoaXMubWF0LnJvdGF0ZVgoLXRoaXMucngudikucm90YXRlWSgtdGhpcy5yeS52KS5yb3RhdGVaKHRoaXMucnoudik7XHJcbiAgICB0aGlzLm1hdC5yb3RhdGVYKC10aGlzLm9yLnZbMF0pLnJvdGF0ZVkoLXRoaXMub3IudlsxXSkucm90YXRlWih0aGlzLm9yLnZbMl0pO1xyXG4gICAgdGhpcy5tYXQudHJhbnNsYXRlKHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53IC8gMiwgdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmggLyAyLCAwKTtcclxuICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgwLCAwLCB0aGlzLnBlLnYpO1xyXG5cclxuICAgIHZhciBoYXNNYXRyaXhDaGFuZ2VkID0gIXRoaXMuX3ByZXZNYXQuZXF1YWxzKHRoaXMubWF0KTtcclxuICAgIGlmICgoaGFzTWF0cml4Q2hhbmdlZCB8fCB0aGlzLnBlLl9tZGYpICYmIHRoaXMuY29tcC50aHJlZURFbGVtZW50cykge1xyXG4gICAgICBsZW4gPSB0aGlzLmNvbXAudGhyZWVERWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICB2YXIgY29tcDtcclxuICAgICAgdmFyIHBlcnNwZWN0aXZlU3R5bGU7XHJcbiAgICAgIHZhciBjb250YWluZXJTdHlsZTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgY29tcCA9IHRoaXMuY29tcC50aHJlZURFbGVtZW50c1tpXTtcclxuICAgICAgICBpZiAoY29tcC50eXBlID09PSAnM2QnKSB7XHJcbiAgICAgICAgICBpZiAoaGFzTWF0cml4Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICB2YXIgbWF0VmFsdWUgPSB0aGlzLm1hdC50b0NTUygpO1xyXG4gICAgICAgICAgICBjb250YWluZXJTdHlsZSA9IGNvbXAuY29udGFpbmVyLnN0eWxlO1xyXG4gICAgICAgICAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm0gPSBtYXRWYWx1ZTtcclxuICAgICAgICAgICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0VmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5wZS5fbWRmKSB7XHJcbiAgICAgICAgICAgIHBlcnNwZWN0aXZlU3R5bGUgPSBjb21wLnBlcnNwZWN0aXZlRWxlbS5zdHlsZTtcclxuICAgICAgICAgICAgcGVyc3BlY3RpdmVTdHlsZS5wZXJzcGVjdGl2ZSA9IHRoaXMucGUudiArICdweCc7XHJcbiAgICAgICAgICAgIHBlcnNwZWN0aXZlU3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPSB0aGlzLnBlLnYgKyAncHgnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1hdC5jbG9uZSh0aGlzLl9wcmV2TWF0KTtcclxuICAgIH1cclxuICB9XHJcbiAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XHJcbn07XHJcblxyXG5IQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gKG51bSkge1xyXG4gIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0cnVlKTtcclxufTtcclxuXHJcbkhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5IQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xyXG5cclxuZnVuY3Rpb24gSEVmZmVjdHMoKSB7XHJcbn1cclxuSEVmZmVjdHMucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge307XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlVGFnLCBBbmltYXRpb25JdGVtICovXHJcbi8qIGV4cG9ydGVkIGFuaW1hdGlvbk1hbmFnZXIgKi9cclxuXHJcbnZhciBhbmltYXRpb25NYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbW9kdWxlT2IgPSB7fTtcclxuICB2YXIgcmVnaXN0ZXJlZEFuaW1hdGlvbnMgPSBbXTtcclxuICB2YXIgaW5pdFRpbWUgPSAwO1xyXG4gIHZhciBsZW4gPSAwO1xyXG4gIHZhciBwbGF5aW5nQW5pbWF0aW9uc051bSA9IDA7XHJcbiAgdmFyIF9zdG9wcGVkID0gdHJ1ZTtcclxuICB2YXIgX2lzRnJvemVuID0gZmFsc2U7XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZXYpIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBhbmltSXRlbSA9IGV2LnRhcmdldDtcclxuICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgIGlmIChyZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24gPT09IGFuaW1JdGVtKSB7XHJcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIGkgLT0gMTtcclxuICAgICAgICBsZW4gLT0gMTtcclxuICAgICAgICBpZiAoIWFuaW1JdGVtLmlzUGF1c2VkKSB7XHJcbiAgICAgICAgICBzdWJ0cmFjdFBsYXlpbmdDb3VudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWdpc3RlckFuaW1hdGlvbihlbGVtZW50LCBhbmltYXRpb25EYXRhKSB7XHJcbiAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICBpZiAocmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uZWxlbSA9PT0gZWxlbWVudCAmJiByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5lbGVtICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbjtcclxuICAgICAgfVxyXG4gICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgICB2YXIgYW5pbUl0ZW0gPSBuZXcgQW5pbWF0aW9uSXRlbSgpO1xyXG4gICAgc2V0dXBBbmltYXRpb24oYW5pbUl0ZW0sIGVsZW1lbnQpO1xyXG4gICAgYW5pbUl0ZW0uc2V0RGF0YShlbGVtZW50LCBhbmltYXRpb25EYXRhKTtcclxuICAgIHJldHVybiBhbmltSXRlbTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRBbmltYXRpb25zKCkge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuQW5pbXMgPSByZWdpc3RlcmVkQW5pbWF0aW9ucy5sZW5ndGg7XHJcbiAgICB2YXIgYW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbkFuaW1zOyBpICs9IDEpIHtcclxuICAgICAgYW5pbWF0aW9ucy5wdXNoKHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYW5pbWF0aW9ucztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFkZFBsYXlpbmdDb3VudCgpIHtcclxuICAgIHBsYXlpbmdBbmltYXRpb25zTnVtICs9IDE7XHJcbiAgICBhY3RpdmF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3VidHJhY3RQbGF5aW5nQ291bnQoKSB7XHJcbiAgICBwbGF5aW5nQW5pbWF0aW9uc051bSAtPSAxO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0dXBBbmltYXRpb24oYW5pbUl0ZW0sIGVsZW1lbnQpIHtcclxuICAgIGFuaW1JdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Rlc3Ryb3knLCByZW1vdmVFbGVtZW50KTtcclxuICAgIGFuaW1JdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ19hY3RpdmUnLCBhZGRQbGF5aW5nQ291bnQpO1xyXG4gICAgYW5pbUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignX2lkbGUnLCBzdWJ0cmFjdFBsYXlpbmdDb3VudCk7XHJcbiAgICByZWdpc3RlcmVkQW5pbWF0aW9ucy5wdXNoKHsgZWxlbTogZWxlbWVudCwgYW5pbWF0aW9uOiBhbmltSXRlbSB9KTtcclxuICAgIGxlbiArPSAxO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbG9hZEFuaW1hdGlvbihwYXJhbXMpIHtcclxuICAgIHZhciBhbmltSXRlbSA9IG5ldyBBbmltYXRpb25JdGVtKCk7XHJcbiAgICBzZXR1cEFuaW1hdGlvbihhbmltSXRlbSwgbnVsbCk7XHJcbiAgICBhbmltSXRlbS5zZXRQYXJhbXMocGFyYW1zKTtcclxuICAgIHJldHVybiBhbmltSXRlbTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldFNwZWVkKHZhbCwgYW5pbWF0aW9uKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uc2V0U3BlZWQodmFsLCBhbmltYXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0RGlyZWN0aW9uKHZhbCwgYW5pbWF0aW9uKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uc2V0RGlyZWN0aW9uKHZhbCwgYW5pbWF0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBsYXkoYW5pbWF0aW9uKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24ucGxheShhbmltYXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiByZXN1bWUobm93VGltZSkge1xyXG4gICAgdmFyIGVsYXBzZWRUaW1lID0gbm93VGltZSAtIGluaXRUaW1lO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLmFkdmFuY2VUaW1lKGVsYXBzZWRUaW1lKTtcclxuICAgIH1cclxuICAgIGluaXRUaW1lID0gbm93VGltZTtcclxuICAgIGlmIChwbGF5aW5nQW5pbWF0aW9uc051bSAmJiAhX2lzRnJvemVuKSB7XHJcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVzdW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZpcnN0KG5vd1RpbWUpIHtcclxuICAgIGluaXRUaW1lID0gbm93VGltZTtcclxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVzdW1lKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhdXNlKGFuaW1hdGlvbikge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnBhdXNlKGFuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnb1RvQW5kU3RvcCh2YWx1ZSwgaXNGcmFtZSwgYW5pbWF0aW9uKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uZ29Ub0FuZFN0b3AodmFsdWUsIGlzRnJhbWUsIGFuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdG9wKGFuaW1hdGlvbikge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnN0b3AoYW5pbWF0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRvZ2dsZVBhdXNlKGFuaW1hdGlvbikge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnRvZ2dsZVBhdXNlKGFuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZXN0cm95KGFuaW1hdGlvbikge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAobGVuIC0gMSk7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5kZXN0cm95KGFuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZWFyY2hBbmltYXRpb25zKGFuaW1hdGlvbkRhdGEsIHN0YW5kYWxvbmUsIHJlbmRlcmVyKSB7XHJcbiAgICB2YXIgYW5pbUVsZW1lbnRzID0gW10uY29uY2F0KFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbG90dGllJykpLFxyXG4gICAgICBbXS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2JvZHltb3ZpbicpKSk7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW5BbmltcyA9IGFuaW1FbGVtZW50cy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuQW5pbXM7IGkgKz0gMSkge1xyXG4gICAgICBpZiAocmVuZGVyZXIpIHtcclxuICAgICAgICBhbmltRWxlbWVudHNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWJtLXR5cGUnLCByZW5kZXJlcik7XHJcbiAgICAgIH1cclxuICAgICAgcmVnaXN0ZXJBbmltYXRpb24oYW5pbUVsZW1lbnRzW2ldLCBhbmltYXRpb25EYXRhKTtcclxuICAgIH1cclxuICAgIGlmIChzdGFuZGFsb25lICYmIGxlbkFuaW1zID09PSAwKSB7XHJcbiAgICAgIGlmICghcmVuZGVyZXIpIHtcclxuICAgICAgICByZW5kZXJlciA9ICdzdmcnO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcclxuICAgICAgYm9keS5pbm5lclRleHQgPSAnJztcclxuICAgICAgdmFyIGRpdiA9IGNyZWF0ZVRhZygnZGl2Jyk7XHJcbiAgICAgIGRpdi5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgICAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcclxuICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnZGF0YS1ibS10eXBlJywgcmVuZGVyZXIpO1xyXG4gICAgICBib2R5LmFwcGVuZENoaWxkKGRpdik7XHJcbiAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uKGRpdiwgYW5pbWF0aW9uRGF0YSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZXNpemUoKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24ucmVzaXplKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhY3RpdmF0ZSgpIHtcclxuICAgIGlmICghX2lzRnJvemVuICYmIHBsYXlpbmdBbmltYXRpb25zTnVtKSB7XHJcbiAgICAgIGlmIChfc3RvcHBlZCkge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmlyc3QpO1xyXG4gICAgICAgIF9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZyZWV6ZSgpIHtcclxuICAgIF9pc0Zyb3plbiA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1bmZyZWV6ZSgpIHtcclxuICAgIF9pc0Zyb3plbiA9IGZhbHNlO1xyXG4gICAgYWN0aXZhdGUoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldFZvbHVtZSh2YWwsIGFuaW1hdGlvbikge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnNldFZvbHVtZSh2YWwsIGFuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtdXRlKGFuaW1hdGlvbikge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLm11dGUoYW5pbWF0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVubXV0ZShhbmltYXRpb24pIHtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi51bm11dGUoYW5pbWF0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG1vZHVsZU9iLnJlZ2lzdGVyQW5pbWF0aW9uID0gcmVnaXN0ZXJBbmltYXRpb247XHJcbiAgbW9kdWxlT2IubG9hZEFuaW1hdGlvbiA9IGxvYWRBbmltYXRpb247XHJcbiAgbW9kdWxlT2Iuc2V0U3BlZWQgPSBzZXRTcGVlZDtcclxuICBtb2R1bGVPYi5zZXREaXJlY3Rpb24gPSBzZXREaXJlY3Rpb247XHJcbiAgbW9kdWxlT2IucGxheSA9IHBsYXk7XHJcbiAgbW9kdWxlT2IucGF1c2UgPSBwYXVzZTtcclxuICBtb2R1bGVPYi5zdG9wID0gc3RvcDtcclxuICBtb2R1bGVPYi50b2dnbGVQYXVzZSA9IHRvZ2dsZVBhdXNlO1xyXG4gIG1vZHVsZU9iLnNlYXJjaEFuaW1hdGlvbnMgPSBzZWFyY2hBbmltYXRpb25zO1xyXG4gIG1vZHVsZU9iLnJlc2l6ZSA9IHJlc2l6ZTtcclxuICAvLyBtb2R1bGVPYi5zdGFydCA9IHN0YXJ0O1xyXG4gIG1vZHVsZU9iLmdvVG9BbmRTdG9wID0gZ29Ub0FuZFN0b3A7XHJcbiAgbW9kdWxlT2IuZGVzdHJveSA9IGRlc3Ryb3k7XHJcbiAgbW9kdWxlT2IuZnJlZXplID0gZnJlZXplO1xyXG4gIG1vZHVsZU9iLnVuZnJlZXplID0gdW5mcmVlemU7XHJcbiAgbW9kdWxlT2Iuc2V0Vm9sdW1lID0gc2V0Vm9sdW1lO1xyXG4gIG1vZHVsZU9iLm11dGUgPSBtdXRlO1xyXG4gIG1vZHVsZU9iLnVubXV0ZSA9IHVubXV0ZTtcclxuICBtb2R1bGVPYi5nZXRSZWdpc3RlcmVkQW5pbWF0aW9ucyA9IGdldFJlZ2lzdGVyZWRBbmltYXRpb25zO1xyXG4gIHJldHVybiBtb2R1bGVPYjtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVFbGVtZW50SUQsIHN1YmZyYW1lRW5hYmxlZCwgUHJvamVjdEludGVyZmFjZSwgSW1hZ2VQcmVsb2FkZXIsIGF1ZGlvQ29udHJvbGxlckZhY3RvcnksIGV4dGVuZFByb3RvdHlwZSwgQmFzZUV2ZW50LFxyXG5DYW52YXNSZW5kZXJlciwgU1ZHUmVuZGVyZXIsIEh5YnJpZFJlbmRlcmVyLCBhc3NldExvYWRlciwgZGF0YU1hbmFnZXIsIGV4cHJlc3Npb25zUGx1Z2luLCBCTUVudGVyRnJhbWVFdmVudCwgQk1Db21wbGV0ZUxvb3BFdmVudCxcclxuQk1Db21wbGV0ZUV2ZW50LCBCTVNlZ21lbnRTdGFydEV2ZW50LCBCTURlc3Ryb3lFdmVudCwgQk1FbnRlckZyYW1lRXZlbnQsIEJNQ29tcGxldGVMb29wRXZlbnQsIEJNQ29tcGxldGVFdmVudCwgQk1TZWdtZW50U3RhcnRFdmVudCxcclxuQk1EZXN0cm95RXZlbnQsIEJNUmVuZGVyRnJhbWVFcnJvckV2ZW50LCBCTUNvbmZpZ0Vycm9yRXZlbnQsIG1hcmtlclBhcnNlciAqL1xyXG5cclxudmFyIEFuaW1hdGlvbkl0ZW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5fY2JzID0gW107XHJcbiAgdGhpcy5uYW1lID0gJyc7XHJcbiAgdGhpcy5wYXRoID0gJyc7XHJcbiAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xyXG4gIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICB0aGlzLmN1cnJlbnRSYXdGcmFtZSA9IDA7XHJcbiAgdGhpcy5maXJzdEZyYW1lID0gMDtcclxuICB0aGlzLnRvdGFsRnJhbWVzID0gMDtcclxuICB0aGlzLmZyYW1lUmF0ZSA9IDA7XHJcbiAgdGhpcy5mcmFtZU11bHQgPSAwO1xyXG4gIHRoaXMucGxheVNwZWVkID0gMTtcclxuICB0aGlzLnBsYXlEaXJlY3Rpb24gPSAxO1xyXG4gIHRoaXMucGxheUNvdW50ID0gMDtcclxuICB0aGlzLmFuaW1hdGlvbkRhdGEgPSB7fTtcclxuICB0aGlzLmFzc2V0cyA9IFtdO1xyXG4gIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xyXG4gIHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcclxuICB0aGlzLmxvb3AgPSB0cnVlO1xyXG4gIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG4gIHRoaXMuYW5pbWF0aW9uSUQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuICB0aGlzLmFzc2V0c1BhdGggPSAnJztcclxuICB0aGlzLnRpbWVDb21wbGV0ZWQgPSAwO1xyXG4gIHRoaXMuc2VnbWVudFBvcyA9IDA7XHJcbiAgdGhpcy5pc1N1YmZyYW1lRW5hYmxlZCA9IHN1YmZyYW1lRW5hYmxlZDtcclxuICB0aGlzLnNlZ21lbnRzID0gW107XHJcbiAgdGhpcy5faWRsZSA9IHRydWU7XHJcbiAgdGhpcy5fY29tcGxldGVkTG9vcCA9IGZhbHNlO1xyXG4gIHRoaXMucHJvamVjdEludGVyZmFjZSA9IFByb2plY3RJbnRlcmZhY2UoKTtcclxuICB0aGlzLmltYWdlUHJlbG9hZGVyID0gbmV3IEltYWdlUHJlbG9hZGVyKCk7XHJcbiAgdGhpcy5hdWRpb0NvbnRyb2xsZXIgPSBhdWRpb0NvbnRyb2xsZXJGYWN0b3J5KCk7XHJcbiAgdGhpcy5tYXJrZXJzID0gW107XHJcbn07XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VFdmVudF0sIEFuaW1hdGlvbkl0ZW0pO1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0UGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gIGlmIChwYXJhbXMud3JhcHBlciB8fCBwYXJhbXMuY29udGFpbmVyKSB7XHJcbiAgICB0aGlzLndyYXBwZXIgPSBwYXJhbXMud3JhcHBlciB8fCBwYXJhbXMuY29udGFpbmVyO1xyXG4gIH1cclxuICB2YXIgYW5pbVR5cGUgPSAnc3ZnJztcclxuICBpZiAocGFyYW1zLmFuaW1UeXBlKSB7XHJcbiAgICBhbmltVHlwZSA9IHBhcmFtcy5hbmltVHlwZTtcclxuICB9IGVsc2UgaWYgKHBhcmFtcy5yZW5kZXJlcikge1xyXG4gICAgYW5pbVR5cGUgPSBwYXJhbXMucmVuZGVyZXI7XHJcbiAgfVxyXG4gIHN3aXRjaCAoYW5pbVR5cGUpIHtcclxuICAgIGNhc2UgJ2NhbnZhcyc6XHJcbiAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgQ2FudmFzUmVuZGVyZXIodGhpcywgcGFyYW1zLnJlbmRlcmVyU2V0dGluZ3MpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ3N2Zyc6XHJcbiAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgU1ZHUmVuZGVyZXIodGhpcywgcGFyYW1zLnJlbmRlcmVyU2V0dGluZ3MpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgSHlicmlkUmVuZGVyZXIodGhpcywgcGFyYW1zLnJlbmRlcmVyU2V0dGluZ3MpO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgdGhpcy5pbWFnZVByZWxvYWRlci5zZXRDYWNoZVR5cGUoYW5pbVR5cGUsIHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5kZWZzKTtcclxuICB0aGlzLnJlbmRlcmVyLnNldFByb2plY3RJbnRlcmZhY2UodGhpcy5wcm9qZWN0SW50ZXJmYWNlKTtcclxuICB0aGlzLmFuaW1UeXBlID0gYW5pbVR5cGU7XHJcbiAgaWYgKHBhcmFtcy5sb29wID09PSAnJ1xyXG4gICAgICAgIHx8IHBhcmFtcy5sb29wID09PSBudWxsXHJcbiAgICAgICAgfHwgcGFyYW1zLmxvb3AgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgIHx8IHBhcmFtcy5sb29wID09PSB0cnVlKSB7XHJcbiAgICB0aGlzLmxvb3AgPSB0cnVlO1xyXG4gIH0gZWxzZSBpZiAocGFyYW1zLmxvb3AgPT09IGZhbHNlKSB7XHJcbiAgICB0aGlzLmxvb3AgPSBmYWxzZTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5sb29wID0gcGFyc2VJbnQocGFyYW1zLmxvb3AsIDEwKTtcclxuICB9XHJcbiAgdGhpcy5hdXRvcGxheSA9ICdhdXRvcGxheScgaW4gcGFyYW1zID8gcGFyYW1zLmF1dG9wbGF5IDogdHJ1ZTtcclxuICB0aGlzLm5hbWUgPSBwYXJhbXMubmFtZSA/IHBhcmFtcy5uYW1lIDogJyc7XHJcbiAgdGhpcy5hdXRvbG9hZFNlZ21lbnRzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgJ2F1dG9sb2FkU2VnbWVudHMnKSA/IHBhcmFtcy5hdXRvbG9hZFNlZ21lbnRzIDogdHJ1ZTtcclxuICB0aGlzLmFzc2V0c1BhdGggPSBwYXJhbXMuYXNzZXRzUGF0aDtcclxuICB0aGlzLmluaXRpYWxTZWdtZW50ID0gcGFyYW1zLmluaXRpYWxTZWdtZW50O1xyXG4gIGlmIChwYXJhbXMuYXVkaW9GYWN0b3J5KSB7XHJcbiAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5zZXRBdWRpb0ZhY3RvcnkocGFyYW1zLmF1ZGlvRmFjdG9yeSk7XHJcbiAgfVxyXG4gIGlmIChwYXJhbXMuYW5pbWF0aW9uRGF0YSkge1xyXG4gICAgdGhpcy5jb25maWdBbmltYXRpb24ocGFyYW1zLmFuaW1hdGlvbkRhdGEpO1xyXG4gIH0gZWxzZSBpZiAocGFyYW1zLnBhdGgpIHtcclxuICAgIGlmIChwYXJhbXMucGF0aC5sYXN0SW5kZXhPZignXFxcXCcpICE9PSAtMSkge1xyXG4gICAgICB0aGlzLnBhdGggPSBwYXJhbXMucGF0aC5zdWJzdHIoMCwgcGFyYW1zLnBhdGgubGFzdEluZGV4T2YoJ1xcXFwnKSArIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5wYXRoID0gcGFyYW1zLnBhdGguc3Vic3RyKDAsIHBhcmFtcy5wYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcclxuICAgIH1cclxuICAgIHRoaXMuZmlsZU5hbWUgPSBwYXJhbXMucGF0aC5zdWJzdHIocGFyYW1zLnBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpO1xyXG4gICAgdGhpcy5maWxlTmFtZSA9IHRoaXMuZmlsZU5hbWUuc3Vic3RyKDAsIHRoaXMuZmlsZU5hbWUubGFzdEluZGV4T2YoJy5qc29uJykpO1xyXG5cclxuICAgIGFzc2V0TG9hZGVyLmxvYWQocGFyYW1zLnBhdGgsIHRoaXMuY29uZmlnQW5pbWF0aW9uLmJpbmQodGhpcyksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhX2ZhaWxlZCcpO1xyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxuICB9XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKHdyYXBwZXIsIGFuaW1hdGlvbkRhdGEpIHtcclxuICBpZiAoYW5pbWF0aW9uRGF0YSkge1xyXG4gICAgaWYgKHR5cGVvZiBhbmltYXRpb25EYXRhICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICBhbmltYXRpb25EYXRhID0gSlNPTi5wYXJzZShhbmltYXRpb25EYXRhKTtcclxuICAgIH1cclxuICB9XHJcbiAgdmFyIHBhcmFtcyA9IHtcclxuICAgIHdyYXBwZXI6IHdyYXBwZXIsXHJcbiAgICBhbmltYXRpb25EYXRhOiBhbmltYXRpb25EYXRhLFxyXG4gIH07XHJcbiAgdmFyIHdyYXBwZXJBdHRyaWJ1dGVzID0gd3JhcHBlci5hdHRyaWJ1dGVzO1xyXG5cclxuICBwYXJhbXMucGF0aCA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltYXRpb24tcGF0aCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW1hdGlvbi1wYXRoJykudmFsdWVcclxuICAgIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXBhdGgnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXBhdGgnKS52YWx1ZVxyXG4gICAgICA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcGF0aCcpXHJcbiAgICAgICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXBhdGgnKS52YWx1ZVxyXG4gICAgICAgIDogJyc7XHJcbiAgcGFyYW1zLmFuaW1UeXBlID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tdHlwZScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tdHlwZScpLnZhbHVlXHJcbiAgICA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS10eXBlJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxyXG4gICAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS10eXBlJykudmFsdWVcclxuICAgICAgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXR5cGUnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICAgICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXR5cGUnKS52YWx1ZVxyXG4gICAgICAgIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXJlbmRlcmVyJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxyXG4gICAgICAgICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcmVuZGVyZXInKS52YWx1ZVxyXG4gICAgICAgICAgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXJlbmRlcmVyJylcclxuICAgICAgICAgICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXJlbmRlcmVyJykudmFsdWVcclxuICAgICAgICAgICAgOiAnY2FudmFzJztcclxuXHJcbiAgdmFyIGxvb3AgPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1sb29wJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxyXG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1sb29wJykudmFsdWVcclxuICAgIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLWxvb3AnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLWxvb3AnKS52YWx1ZVxyXG4gICAgICA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbG9vcCcpXHJcbiAgICAgICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLWxvb3AnKS52YWx1ZVxyXG4gICAgICAgIDogJyc7XHJcbiAgaWYgKGxvb3AgPT09ICdmYWxzZScpIHtcclxuICAgIHBhcmFtcy5sb29wID0gZmFsc2U7XHJcbiAgfSBlbHNlIGlmIChsb29wID09PSAndHJ1ZScpIHtcclxuICAgIHBhcmFtcy5sb29wID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKGxvb3AgIT09ICcnKSB7XHJcbiAgICBwYXJhbXMubG9vcCA9IHBhcnNlSW50KGxvb3AsIDEwKTtcclxuICB9XHJcbiAgdmFyIGF1dG9wbGF5ID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tYXV0b3BsYXknKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWF1dG9wbGF5JykudmFsdWVcclxuICAgIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLWF1dG9wbGF5JykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxyXG4gICAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1hdXRvcGxheScpLnZhbHVlXHJcbiAgICAgIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1hdXRvcGxheScpXHJcbiAgICAgICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLWF1dG9wbGF5JykudmFsdWVcclxuICAgICAgICA6IHRydWU7XHJcbiAgcGFyYW1zLmF1dG9wbGF5ID0gYXV0b3BsYXkgIT09ICdmYWxzZSc7XHJcblxyXG4gIHBhcmFtcy5uYW1lID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLW5hbWUnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1uYW1lJykudmFsdWVcclxuICAgIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLW5hbWUnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLW5hbWUnKS52YWx1ZVxyXG4gICAgICA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbmFtZScpXHJcbiAgICAgICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLW5hbWUnKS52YWx1ZVxyXG4gICAgICAgIDogJyc7XHJcbiAgdmFyIHByZXJlbmRlciA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLXByZXJlbmRlcicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tcHJlcmVuZGVyJykudmFsdWVcclxuICAgIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXByZXJlbmRlcicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcHJlcmVuZGVyJykudmFsdWVcclxuICAgICAgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXByZXJlbmRlcicpXHJcbiAgICAgICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXByZXJlbmRlcicpLnZhbHVlXHJcbiAgICAgICAgOiAnJztcclxuXHJcbiAgaWYgKHByZXJlbmRlciA9PT0gJ2ZhbHNlJykge1xyXG4gICAgcGFyYW1zLnByZXJlbmRlciA9IGZhbHNlO1xyXG4gIH1cclxuICB0aGlzLnNldFBhcmFtcyhwYXJhbXMpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuaW5jbHVkZUxheWVycyA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgaWYgKGRhdGEub3AgPiB0aGlzLmFuaW1hdGlvbkRhdGEub3ApIHtcclxuICAgIHRoaXMuYW5pbWF0aW9uRGF0YS5vcCA9IGRhdGEub3A7XHJcbiAgICB0aGlzLnRvdGFsRnJhbWVzID0gTWF0aC5mbG9vcihkYXRhLm9wIC0gdGhpcy5hbmltYXRpb25EYXRhLmlwKTtcclxuICB9XHJcbiAgdmFyIGxheWVycyA9IHRoaXMuYW5pbWF0aW9uRGF0YS5sYXllcnM7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XHJcbiAgdmFyIG5ld0xheWVycyA9IGRhdGEubGF5ZXJzO1xyXG4gIHZhciBqO1xyXG4gIHZhciBqTGVuID0gbmV3TGF5ZXJzLmxlbmd0aDtcclxuICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgIGlmIChsYXllcnNbaV0uaWQgPT09IG5ld0xheWVyc1tqXS5pZCkge1xyXG4gICAgICAgIGxheWVyc1tpXSA9IG5ld0xheWVyc1tqXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChkYXRhLmNoYXJzIHx8IGRhdGEuZm9udHMpIHtcclxuICAgIHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRDaGFycyhkYXRhLmNoYXJzKTtcclxuICAgIHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRGb250cyhkYXRhLmZvbnRzLCB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZGVmcyk7XHJcbiAgfVxyXG4gIGlmIChkYXRhLmFzc2V0cykge1xyXG4gICAgbGVuID0gZGF0YS5hc3NldHMubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGF0YS5hc3NldHMucHVzaChkYXRhLmFzc2V0c1tpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRoaXMuYW5pbWF0aW9uRGF0YS5fX2NvbXBsZXRlID0gZmFsc2U7XHJcbiAgZGF0YU1hbmFnZXIuY29tcGxldGVEYXRhKHRoaXMuYW5pbWF0aW9uRGF0YSwgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyKTtcclxuICB0aGlzLnJlbmRlcmVyLmluY2x1ZGVMYXllcnMoZGF0YS5sYXllcnMpO1xyXG4gIGlmIChleHByZXNzaW9uc1BsdWdpbikge1xyXG4gICAgZXhwcmVzc2lvbnNQbHVnaW4uaW5pdEV4cHJlc3Npb25zKHRoaXMpO1xyXG4gIH1cclxuICB0aGlzLmxvYWROZXh0U2VnbWVudCgpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUubG9hZE5leHRTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzZWdtZW50cyA9IHRoaXMuYW5pbWF0aW9uRGF0YS5zZWdtZW50cztcclxuICBpZiAoIXNlZ21lbnRzIHx8IHNlZ21lbnRzLmxlbmd0aCA9PT0gMCB8fCAhdGhpcy5hdXRvbG9hZFNlZ21lbnRzKSB7XHJcbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGFfcmVhZHknKTtcclxuICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBzZWdtZW50ID0gc2VnbWVudHMuc2hpZnQoKTtcclxuICB0aGlzLnRpbWVDb21wbGV0ZWQgPSBzZWdtZW50LnRpbWUgKiB0aGlzLmZyYW1lUmF0ZTtcclxuICB2YXIgc2VnbWVudFBhdGggPSB0aGlzLnBhdGggKyB0aGlzLmZpbGVOYW1lICsgJ18nICsgdGhpcy5zZWdtZW50UG9zICsgJy5qc29uJztcclxuICB0aGlzLnNlZ21lbnRQb3MgKz0gMTtcclxuICBhc3NldExvYWRlci5sb2FkKHNlZ21lbnRQYXRoLCB0aGlzLmluY2x1ZGVMYXllcnMuYmluZCh0aGlzKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy50cmlnZ2VyKCdkYXRhX2ZhaWxlZCcpO1xyXG4gIH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5sb2FkU2VnbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5hbmltYXRpb25EYXRhLnNlZ21lbnRzO1xyXG4gIGlmICghc2VnbWVudHMpIHtcclxuICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XHJcbiAgfVxyXG4gIHRoaXMubG9hZE5leHRTZWdtZW50KCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5pbWFnZXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy50cmlnZ2VyKCdsb2FkZWRfaW1hZ2VzJyk7XHJcbiAgdGhpcy5jaGVja0xvYWRlZCgpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucHJlbG9hZEltYWdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmltYWdlUHJlbG9hZGVyLnNldEFzc2V0c1BhdGgodGhpcy5hc3NldHNQYXRoKTtcclxuICB0aGlzLmltYWdlUHJlbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcclxuICB0aGlzLmltYWdlUHJlbG9hZGVyLmxvYWRBc3NldHModGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cywgdGhpcy5pbWFnZXNMb2FkZWQuYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5jb25maWdBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbURhdGEpIHtcclxuICBpZiAoIXRoaXMucmVuZGVyZXIpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIHRoaXMuYW5pbWF0aW9uRGF0YSA9IGFuaW1EYXRhO1xyXG5cclxuICAgIGlmICh0aGlzLmluaXRpYWxTZWdtZW50KSB7XHJcbiAgICAgIHRoaXMudG90YWxGcmFtZXMgPSBNYXRoLmZsb29yKHRoaXMuaW5pdGlhbFNlZ21lbnRbMV0gLSB0aGlzLmluaXRpYWxTZWdtZW50WzBdKTtcclxuICAgICAgdGhpcy5maXJzdEZyYW1lID0gTWF0aC5yb3VuZCh0aGlzLmluaXRpYWxTZWdtZW50WzBdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMudG90YWxGcmFtZXMgPSBNYXRoLmZsb29yKHRoaXMuYW5pbWF0aW9uRGF0YS5vcCAtIHRoaXMuYW5pbWF0aW9uRGF0YS5pcCk7XHJcbiAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IE1hdGgucm91bmQodGhpcy5hbmltYXRpb25EYXRhLmlwKTtcclxuICAgIH1cclxuICAgIHRoaXMucmVuZGVyZXIuY29uZmlnQW5pbWF0aW9uKGFuaW1EYXRhKTtcclxuICAgIGlmICghYW5pbURhdGEuYXNzZXRzKSB7XHJcbiAgICAgIGFuaW1EYXRhLmFzc2V0cyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYXNzZXRzID0gdGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cztcclxuICAgIHRoaXMuZnJhbWVSYXRlID0gdGhpcy5hbmltYXRpb25EYXRhLmZyO1xyXG4gICAgdGhpcy5mcmFtZU11bHQgPSB0aGlzLmFuaW1hdGlvbkRhdGEuZnIgLyAxMDAwO1xyXG4gICAgdGhpcy5yZW5kZXJlci5zZWFyY2hFeHRyYUNvbXBvc2l0aW9ucyhhbmltRGF0YS5hc3NldHMpO1xyXG4gICAgdGhpcy5tYXJrZXJzID0gbWFya2VyUGFyc2VyKGFuaW1EYXRhLm1hcmtlcnMgfHwgW10pO1xyXG4gICAgdGhpcy50cmlnZ2VyKCdjb25maWdfcmVhZHknKTtcclxuICAgIHRoaXMucHJlbG9hZEltYWdlcygpO1xyXG4gICAgdGhpcy5sb2FkU2VnbWVudHMoKTtcclxuICAgIHRoaXMudXBkYUZyYW1lTW9kaWZpZXIoKTtcclxuICAgIHRoaXMud2FpdEZvckZvbnRzTG9hZGVkKCk7XHJcbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xyXG4gICAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5wYXVzZSgpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICB0aGlzLnRyaWdnZXJDb25maWdFcnJvcihlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUud2FpdEZvckZvbnRzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICghdGhpcy5yZW5kZXJlcikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAodGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmlzTG9hZGVkKSB7XHJcbiAgICB0aGlzLmNoZWNrTG9hZGVkKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNldFRpbWVvdXQodGhpcy53YWl0Rm9yRm9udHNMb2FkZWQuYmluZCh0aGlzKSwgMjApO1xyXG4gIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmNoZWNrTG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICghdGhpcy5pc0xvYWRlZFxyXG4gICAgICAgICYmIHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5pc0xvYWRlZFxyXG4gICAgICAgICYmICh0aGlzLmltYWdlUHJlbG9hZGVyLmxvYWRlZEltYWdlcygpIHx8IHRoaXMucmVuZGVyZXIucmVuZGVyZXJUeXBlICE9PSAnY2FudmFzJylcclxuICAgICAgICAmJiAodGhpcy5pbWFnZVByZWxvYWRlci5sb2FkZWRGb290YWdlcygpKVxyXG4gICkge1xyXG4gICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XHJcbiAgICBkYXRhTWFuYWdlci5jb21wbGV0ZURhdGEodGhpcy5hbmltYXRpb25EYXRhLCB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIpO1xyXG4gICAgaWYgKGV4cHJlc3Npb25zUGx1Z2luKSB7XHJcbiAgICAgIGV4cHJlc3Npb25zUGx1Z2luLmluaXRFeHByZXNzaW9ucyh0aGlzKTtcclxuICAgIH1cclxuICAgIHRoaXMucmVuZGVyZXIuaW5pdEl0ZW1zKCk7XHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdET01Mb2FkZWQnKTtcclxuICAgIH0uYmluZCh0aGlzKSwgMCk7XHJcbiAgICB0aGlzLmdvdG9GcmFtZSgpO1xyXG4gICAgaWYgKHRoaXMuYXV0b3BsYXkpIHtcclxuICAgICAgdGhpcy5wbGF5KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMucmVuZGVyZXIudXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0U3ViZnJhbWUgPSBmdW5jdGlvbiAoZmxhZykge1xyXG4gIHRoaXMuaXNTdWJmcmFtZUVuYWJsZWQgPSAhIWZsYWc7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5nb3RvRnJhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5jdXJyZW50RnJhbWUgPSB0aGlzLmlzU3ViZnJhbWVFbmFibGVkID8gdGhpcy5jdXJyZW50UmF3RnJhbWUgOiB+fnRoaXMuY3VycmVudFJhd0ZyYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcclxuXHJcbiAgaWYgKHRoaXMudGltZUNvbXBsZXRlZCAhPT0gdGhpcy50b3RhbEZyYW1lcyAmJiB0aGlzLmN1cnJlbnRGcmFtZSA+IHRoaXMudGltZUNvbXBsZXRlZCkge1xyXG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSB0aGlzLnRpbWVDb21wbGV0ZWQ7XHJcbiAgfVxyXG4gIHRoaXMudHJpZ2dlcignZW50ZXJGcmFtZScpO1xyXG4gIHRoaXMucmVuZGVyRnJhbWUoKTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICh0aGlzLmlzTG9hZGVkID09PSBmYWxzZSB8fCAhdGhpcy5yZW5kZXJlcikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0cnkge1xyXG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXJGcmFtZSh0aGlzLmN1cnJlbnRGcmFtZSArIHRoaXMuZmlyc3RGcmFtZSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHRoaXMudHJpZ2dlclJlbmRlckZyYW1lRXJyb3IoZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAodGhpcy5pc1BhdXNlZCA9PT0gdHJ1ZSkge1xyXG4gICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIucmVzdW1lKCk7XHJcbiAgICBpZiAodGhpcy5faWRsZSkge1xyXG4gICAgICB0aGlzLl9pZGxlID0gZmFsc2U7XHJcbiAgICAgIHRoaXMudHJpZ2dlcignX2FjdGl2ZScpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IGZhbHNlKSB7XHJcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcclxuICAgIHRoaXMuX2lkbGUgPSB0cnVlO1xyXG4gICAgdGhpcy50cmlnZ2VyKCdfaWRsZScpO1xyXG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIucGF1c2UoKTtcclxuICB9XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS50b2dnbGVQYXVzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICh0aGlzLmlzUGF1c2VkID09PSB0cnVlKSB7XHJcbiAgICB0aGlzLnBsYXkoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5wYXVzZSgpO1xyXG4gIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLnBhdXNlKCk7XHJcbiAgdGhpcy5wbGF5Q291bnQgPSAwO1xyXG4gIHRoaXMuX2NvbXBsZXRlZExvb3AgPSBmYWxzZTtcclxuICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKDApO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0TWFya2VyRGF0YSA9IGZ1bmN0aW9uIChtYXJrZXJOYW1lKSB7XHJcbiAgdmFyIG1hcmtlcjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgbWFya2VyID0gdGhpcy5tYXJrZXJzW2ldO1xyXG4gICAgaWYgKG1hcmtlci5wYXlsb2FkICYmIG1hcmtlci5wYXlsb2FkLm5hbWUgPT09IG1hcmtlck5hbWUpIHtcclxuICAgICAgcmV0dXJuIG1hcmtlcjtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5nb1RvQW5kU3RvcCA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNGcmFtZSwgbmFtZSkge1xyXG4gIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xyXG4gIGlmIChpc05hTihudW1WYWx1ZSkpIHtcclxuICAgIHZhciBtYXJrZXIgPSB0aGlzLmdldE1hcmtlckRhdGEodmFsdWUpO1xyXG4gICAgaWYgKG1hcmtlcikge1xyXG4gICAgICB0aGlzLmdvVG9BbmRTdG9wKG1hcmtlci50aW1lLCB0cnVlKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzRnJhbWUpIHtcclxuICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUodmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHZhbHVlICogdGhpcy5mcmFtZU1vZGlmaWVyKTtcclxuICB9XHJcbiAgdGhpcy5wYXVzZSgpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ29Ub0FuZFBsYXkgPSBmdW5jdGlvbiAodmFsdWUsIGlzRnJhbWUsIG5hbWUpIHtcclxuICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIG51bVZhbHVlID0gTnVtYmVyKHZhbHVlKTtcclxuICBpZiAoaXNOYU4obnVtVmFsdWUpKSB7XHJcbiAgICB2YXIgbWFya2VyID0gdGhpcy5nZXRNYXJrZXJEYXRhKHZhbHVlKTtcclxuICAgIGlmIChtYXJrZXIpIHtcclxuICAgICAgaWYgKCFtYXJrZXIuZHVyYXRpb24pIHtcclxuICAgICAgICB0aGlzLmdvVG9BbmRTdG9wKG1hcmtlci50aW1lLCB0cnVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnBsYXlTZWdtZW50cyhbbWFya2VyLnRpbWUsIG1hcmtlci50aW1lICsgbWFya2VyLmR1cmF0aW9uXSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5nb1RvQW5kU3RvcChudW1WYWx1ZSwgaXNGcmFtZSwgbmFtZSk7XHJcbiAgfVxyXG4gIHRoaXMucGxheSgpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuYWR2YW5jZVRpbWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICBpZiAodGhpcy5pc1BhdXNlZCA9PT0gdHJ1ZSB8fCB0aGlzLmlzTG9hZGVkID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgbmV4dFZhbHVlID0gdGhpcy5jdXJyZW50UmF3RnJhbWUgKyB2YWx1ZSAqIHRoaXMuZnJhbWVNb2RpZmllcjtcclxuICB2YXIgX2lzQ29tcGxldGUgPSBmYWxzZTtcclxuICAvLyBDaGVja2luZyBpZiBuZXh0VmFsdWUgPiB0b3RhbEZyYW1lcyAtIDEgZm9yIGFkZHJlc3Npbmcgbm9uIGxvb3BpbmcgYW5kIGxvb3BpbmcgYW5pbWF0aW9ucy5cclxuICAvLyBJZiBhbmltYXRpb24gd29uJ3QgbG9vcCwgaXQgc2hvdWxkIHN0b3AgYXQgdG90YWxGcmFtZXMgLSAxLiBJZiBpdCB3aWxsIGxvb3AgaXQgc2hvdWxkIGNvbXBsZXRlIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGVuIGxvb3AuXHJcbiAgaWYgKG5leHRWYWx1ZSA+PSB0aGlzLnRvdGFsRnJhbWVzIC0gMSAmJiB0aGlzLmZyYW1lTW9kaWZpZXIgPiAwKSB7XHJcbiAgICBpZiAoIXRoaXMubG9vcCB8fCB0aGlzLnBsYXlDb3VudCA9PT0gdGhpcy5sb29wKSB7XHJcbiAgICAgIGlmICghdGhpcy5jaGVja1NlZ21lbnRzKG5leHRWYWx1ZSA+IHRoaXMudG90YWxGcmFtZXMgPyBuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzIDogMCkpIHtcclxuICAgICAgICBfaXNDb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgbmV4dFZhbHVlID0gdGhpcy50b3RhbEZyYW1lcyAtIDE7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobmV4dFZhbHVlID49IHRoaXMudG90YWxGcmFtZXMpIHtcclxuICAgICAgdGhpcy5wbGF5Q291bnQgKz0gMTtcclxuICAgICAgaWYgKCF0aGlzLmNoZWNrU2VnbWVudHMobmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcykpIHtcclxuICAgICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKG5leHRWYWx1ZSAlIHRoaXMudG90YWxGcmFtZXMpO1xyXG4gICAgICAgIHRoaXMuX2NvbXBsZXRlZExvb3AgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignbG9vcENvbXBsZXRlJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUobmV4dFZhbHVlKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKG5leHRWYWx1ZSA8IDApIHtcclxuICAgIGlmICghdGhpcy5jaGVja1NlZ21lbnRzKG5leHRWYWx1ZSAlIHRoaXMudG90YWxGcmFtZXMpKSB7XHJcbiAgICAgIGlmICh0aGlzLmxvb3AgJiYgISh0aGlzLnBsYXlDb3VudC0tIDw9IDAgJiYgdGhpcy5sb29wICE9PSB0cnVlKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBsdXNwbHVzXHJcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSh0aGlzLnRvdGFsRnJhbWVzICsgKG5leHRWYWx1ZSAlIHRoaXMudG90YWxGcmFtZXMpKTtcclxuICAgICAgICBpZiAoIXRoaXMuX2NvbXBsZXRlZExvb3ApIHtcclxuICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZExvb3AgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2xvb3BDb21wbGV0ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBfaXNDb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgbmV4dFZhbHVlID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKG5leHRWYWx1ZSk7XHJcbiAgfVxyXG4gIGlmIChfaXNDb21wbGV0ZSkge1xyXG4gICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xyXG4gICAgdGhpcy5wYXVzZSgpO1xyXG4gICAgdGhpcy50cmlnZ2VyKCdjb21wbGV0ZScpO1xyXG4gIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmFkanVzdFNlZ21lbnQgPSBmdW5jdGlvbiAoYXJyLCBvZmZzZXQpIHtcclxuICB0aGlzLnBsYXlDb3VudCA9IDA7XHJcbiAgaWYgKGFyclsxXSA8IGFyclswXSkge1xyXG4gICAgaWYgKHRoaXMuZnJhbWVNb2RpZmllciA+IDApIHtcclxuICAgICAgaWYgKHRoaXMucGxheVNwZWVkIDwgMCkge1xyXG4gICAgICAgIHRoaXMuc2V0U3BlZWQoLXRoaXMucGxheVNwZWVkKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnNldERpcmVjdGlvbigtMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMudG90YWxGcmFtZXMgPSBhcnJbMF0gLSBhcnJbMV07XHJcbiAgICB0aGlzLnRpbWVDb21wbGV0ZWQgPSB0aGlzLnRvdGFsRnJhbWVzO1xyXG4gICAgdGhpcy5maXJzdEZyYW1lID0gYXJyWzFdO1xyXG4gICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSh0aGlzLnRvdGFsRnJhbWVzIC0gMC4wMDEgLSBvZmZzZXQpO1xyXG4gIH0gZWxzZSBpZiAoYXJyWzFdID4gYXJyWzBdKSB7XHJcbiAgICBpZiAodGhpcy5mcmFtZU1vZGlmaWVyIDwgMCkge1xyXG4gICAgICBpZiAodGhpcy5wbGF5U3BlZWQgPCAwKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTcGVlZCgtdGhpcy5wbGF5U3BlZWQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnRvdGFsRnJhbWVzID0gYXJyWzFdIC0gYXJyWzBdO1xyXG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcclxuICAgIHRoaXMuZmlyc3RGcmFtZSA9IGFyclswXTtcclxuICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUoMC4wMDEgKyBvZmZzZXQpO1xyXG4gIH1cclxuICB0aGlzLnRyaWdnZXIoJ3NlZ21lbnRTdGFydCcpO1xyXG59O1xyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRTZWdtZW50ID0gZnVuY3Rpb24gKGluaXQsIGVuZCkge1xyXG4gIHZhciBwZW5kaW5nRnJhbWUgPSAtMTtcclxuICBpZiAodGhpcy5pc1BhdXNlZCkge1xyXG4gICAgaWYgKHRoaXMuY3VycmVudFJhd0ZyYW1lICsgdGhpcy5maXJzdEZyYW1lIDwgaW5pdCkge1xyXG4gICAgICBwZW5kaW5nRnJhbWUgPSBpbml0O1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRSYXdGcmFtZSArIHRoaXMuZmlyc3RGcmFtZSA+IGVuZCkge1xyXG4gICAgICBwZW5kaW5nRnJhbWUgPSBlbmQgLSBpbml0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdGhpcy5maXJzdEZyYW1lID0gaW5pdDtcclxuICB0aGlzLnRvdGFsRnJhbWVzID0gZW5kIC0gaW5pdDtcclxuICB0aGlzLnRpbWVDb21wbGV0ZWQgPSB0aGlzLnRvdGFsRnJhbWVzO1xyXG4gIGlmIChwZW5kaW5nRnJhbWUgIT09IC0xKSB7XHJcbiAgICB0aGlzLmdvVG9BbmRTdG9wKHBlbmRpbmdGcmFtZSwgdHJ1ZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucGxheVNlZ21lbnRzID0gZnVuY3Rpb24gKGFyciwgZm9yY2VGbGFnKSB7XHJcbiAgaWYgKGZvcmNlRmxhZykge1xyXG4gICAgdGhpcy5zZWdtZW50cy5sZW5ndGggPSAwO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIGFyclswXSA9PT0gJ29iamVjdCcpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKGFycltpXSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuc2VnbWVudHMucHVzaChhcnIpO1xyXG4gIH1cclxuICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGggJiYgZm9yY2VGbGFnKSB7XHJcbiAgICB0aGlzLmFkanVzdFNlZ21lbnQodGhpcy5zZWdtZW50cy5zaGlmdCgpLCAwKTtcclxuICB9XHJcbiAgaWYgKHRoaXMuaXNQYXVzZWQpIHtcclxuICAgIHRoaXMucGxheSgpO1xyXG4gIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnJlc2V0U2VnbWVudHMgPSBmdW5jdGlvbiAoZm9yY2VGbGFnKSB7XHJcbiAgdGhpcy5zZWdtZW50cy5sZW5ndGggPSAwO1xyXG4gIHRoaXMuc2VnbWVudHMucHVzaChbdGhpcy5hbmltYXRpb25EYXRhLmlwLCB0aGlzLmFuaW1hdGlvbkRhdGEub3BdKTtcclxuICAvLyB0aGlzLnNlZ21lbnRzLnB1c2goW3RoaXMuYW5pbWF0aW9uRGF0YS5pcCp0aGlzLmZyYW1lUmF0ZSxNYXRoLmZsb29yKHRoaXMuYW5pbWF0aW9uRGF0YS5vcCAtIHRoaXMuYW5pbWF0aW9uRGF0YS5pcCt0aGlzLmFuaW1hdGlvbkRhdGEuaXAqdGhpcy5mcmFtZVJhdGUpXSk7XHJcbiAgaWYgKGZvcmNlRmxhZykge1xyXG4gICAgdGhpcy5jaGVja1NlZ21lbnRzKDApO1xyXG4gIH1cclxufTtcclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuY2hlY2tTZWdtZW50cyA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuYWRqdXN0U2VnbWVudCh0aGlzLnNlZ21lbnRzLnNoaWZ0KCksIG9mZnNldCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgaWYgKChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkgfHwgIXRoaXMucmVuZGVyZXIpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XHJcbiAgdGhpcy5pbWFnZVByZWxvYWRlci5kZXN0cm95KCk7XHJcbiAgdGhpcy50cmlnZ2VyKCdkZXN0cm95Jyk7XHJcbiAgdGhpcy5fY2JzID0gbnVsbDtcclxuICB0aGlzLm9uRW50ZXJGcmFtZSA9IG51bGw7XHJcbiAgdGhpcy5vbkxvb3BDb21wbGV0ZSA9IG51bGw7XHJcbiAgdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcclxuICB0aGlzLm9uU2VnbWVudFN0YXJ0ID0gbnVsbDtcclxuICB0aGlzLm9uRGVzdHJveSA9IG51bGw7XHJcbiAgdGhpcy5yZW5kZXJlciA9IG51bGw7XHJcbiAgdGhpcy5yZW5kZXJlciA9IG51bGw7XHJcbiAgdGhpcy5pbWFnZVByZWxvYWRlciA9IG51bGw7XHJcbiAgdGhpcy5wcm9qZWN0SW50ZXJmYWNlID0gbnVsbDtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgdGhpcy5jdXJyZW50UmF3RnJhbWUgPSB2YWx1ZTtcclxuICB0aGlzLmdvdG9GcmFtZSgpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0U3BlZWQgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgdGhpcy5wbGF5U3BlZWQgPSB2YWw7XHJcbiAgdGhpcy51cGRhRnJhbWVNb2RpZmllcigpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gIHRoaXMucGxheURpcmVjdGlvbiA9IHZhbCA8IDAgPyAtMSA6IDE7XHJcbiAgdGhpcy51cGRhRnJhbWVNb2RpZmllcigpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZhbCwgbmFtZSkge1xyXG4gIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLmF1ZGlvQ29udHJvbGxlci5zZXRWb2x1bWUodmFsKTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldFZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5hdWRpb0NvbnRyb2xsZXIuZ2V0Vm9sdW1lKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5tdXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdGhpcy5hdWRpb0NvbnRyb2xsZXIubXV0ZSgpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUudW5tdXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdGhpcy5hdWRpb0NvbnRyb2xsZXIudW5tdXRlKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS51cGRhRnJhbWVNb2RpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmZyYW1lTW9kaWZpZXIgPSB0aGlzLmZyYW1lTXVsdCAqIHRoaXMucGxheVNwZWVkICogdGhpcy5wbGF5RGlyZWN0aW9uO1xyXG4gIHRoaXMuYXVkaW9Db250cm9sbGVyLnNldFJhdGUodGhpcy5wbGF5U3BlZWQgKiB0aGlzLnBsYXlEaXJlY3Rpb24pO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5wYXRoO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0QXNzZXRzUGF0aCA9IGZ1bmN0aW9uIChhc3NldERhdGEpIHtcclxuICB2YXIgcGF0aCA9ICcnO1xyXG4gIGlmIChhc3NldERhdGEuZSkge1xyXG4gICAgcGF0aCA9IGFzc2V0RGF0YS5wO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5hc3NldHNQYXRoKSB7XHJcbiAgICB2YXIgaW1hZ2VQYXRoID0gYXNzZXREYXRhLnA7XHJcbiAgICBpZiAoaW1hZ2VQYXRoLmluZGV4T2YoJ2ltYWdlcy8nKSAhPT0gLTEpIHtcclxuICAgICAgaW1hZ2VQYXRoID0gaW1hZ2VQYXRoLnNwbGl0KCcvJylbMV07XHJcbiAgICB9XHJcbiAgICBwYXRoID0gdGhpcy5hc3NldHNQYXRoICsgaW1hZ2VQYXRoO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgcGF0aCArPSBhc3NldERhdGEudSA/IGFzc2V0RGF0YS51IDogJyc7XHJcbiAgICBwYXRoICs9IGFzc2V0RGF0YS5wO1xyXG4gIH1cclxuICByZXR1cm4gcGF0aDtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldEFzc2V0RGF0YSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgbGVuID0gdGhpcy5hc3NldHMubGVuZ3RoO1xyXG4gIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICBpZiAoaWQgPT09IHRoaXMuYXNzZXRzW2ldLmlkKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFzc2V0c1tpXTtcclxuICAgIH1cclxuICAgIGkgKz0gMTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMucmVuZGVyZXIuaGlkZSgpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnJlbmRlcmVyLnNob3coKTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldER1cmF0aW9uID0gZnVuY3Rpb24gKGlzRnJhbWUpIHtcclxuICByZXR1cm4gaXNGcmFtZSA/IHRoaXMudG90YWxGcmFtZXMgOiB0aGlzLnRvdGFsRnJhbWVzIC8gdGhpcy5mcmFtZVJhdGU7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICBpZiAodGhpcy5fY2JzICYmIHRoaXMuX2Nic1tuYW1lXSkge1xyXG4gICAgc3dpdGNoIChuYW1lKSB7XHJcbiAgICAgIGNhc2UgJ2VudGVyRnJhbWUnOlxyXG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTUVudGVyRnJhbWVFdmVudChuYW1lLCB0aGlzLmN1cnJlbnRGcmFtZSwgdGhpcy50b3RhbEZyYW1lcywgdGhpcy5mcmFtZU1vZGlmaWVyKSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2xvb3BDb21wbGV0ZSc6XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgbmV3IEJNQ29tcGxldGVMb29wRXZlbnQobmFtZSwgdGhpcy5sb29wLCB0aGlzLnBsYXlDb3VudCwgdGhpcy5mcmFtZU11bHQpKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnY29tcGxldGUnOlxyXG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTUNvbXBsZXRlRXZlbnQobmFtZSwgdGhpcy5mcmFtZU11bHQpKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnc2VnbWVudFN0YXJ0JzpcclxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lLCBuZXcgQk1TZWdtZW50U3RhcnRFdmVudChuYW1lLCB0aGlzLmZpcnN0RnJhbWUsIHRoaXMudG90YWxGcmFtZXMpKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnZGVzdHJveSc6XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgbmV3IEJNRGVzdHJveUV2ZW50KG5hbWUsIHRoaXMpKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKG5hbWUgPT09ICdlbnRlckZyYW1lJyAmJiB0aGlzLm9uRW50ZXJGcmFtZSkge1xyXG4gICAgdGhpcy5vbkVudGVyRnJhbWUuY2FsbCh0aGlzLCBuZXcgQk1FbnRlckZyYW1lRXZlbnQobmFtZSwgdGhpcy5jdXJyZW50RnJhbWUsIHRoaXMudG90YWxGcmFtZXMsIHRoaXMuZnJhbWVNdWx0KSk7XHJcbiAgfVxyXG4gIGlmIChuYW1lID09PSAnbG9vcENvbXBsZXRlJyAmJiB0aGlzLm9uTG9vcENvbXBsZXRlKSB7XHJcbiAgICB0aGlzLm9uTG9vcENvbXBsZXRlLmNhbGwodGhpcywgbmV3IEJNQ29tcGxldGVMb29wRXZlbnQobmFtZSwgdGhpcy5sb29wLCB0aGlzLnBsYXlDb3VudCwgdGhpcy5mcmFtZU11bHQpKTtcclxuICB9XHJcbiAgaWYgKG5hbWUgPT09ICdjb21wbGV0ZScgJiYgdGhpcy5vbkNvbXBsZXRlKSB7XHJcbiAgICB0aGlzLm9uQ29tcGxldGUuY2FsbCh0aGlzLCBuZXcgQk1Db21wbGV0ZUV2ZW50KG5hbWUsIHRoaXMuZnJhbWVNdWx0KSk7XHJcbiAgfVxyXG4gIGlmIChuYW1lID09PSAnc2VnbWVudFN0YXJ0JyAmJiB0aGlzLm9uU2VnbWVudFN0YXJ0KSB7XHJcbiAgICB0aGlzLm9uU2VnbWVudFN0YXJ0LmNhbGwodGhpcywgbmV3IEJNU2VnbWVudFN0YXJ0RXZlbnQobmFtZSwgdGhpcy5maXJzdEZyYW1lLCB0aGlzLnRvdGFsRnJhbWVzKSk7XHJcbiAgfVxyXG4gIGlmIChuYW1lID09PSAnZGVzdHJveScgJiYgdGhpcy5vbkRlc3Ryb3kpIHtcclxuICAgIHRoaXMub25EZXN0cm95LmNhbGwodGhpcywgbmV3IEJNRGVzdHJveUV2ZW50KG5hbWUsIHRoaXMpKTtcclxuICB9XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS50cmlnZ2VyUmVuZGVyRnJhbWVFcnJvciA9IGZ1bmN0aW9uIChuYXRpdmVFcnJvcikge1xyXG4gIHZhciBlcnJvciA9IG5ldyBCTVJlbmRlckZyYW1lRXJyb3JFdmVudChuYXRpdmVFcnJvciwgdGhpcy5jdXJyZW50RnJhbWUpO1xyXG4gIHRoaXMudHJpZ2dlckV2ZW50KCdlcnJvcicsIGVycm9yKTtcclxuXHJcbiAgaWYgKHRoaXMub25FcnJvcikge1xyXG4gICAgdGhpcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnRyaWdnZXJDb25maWdFcnJvciA9IGZ1bmN0aW9uIChuYXRpdmVFcnJvcikge1xyXG4gIHZhciBlcnJvciA9IG5ldyBCTUNvbmZpZ0Vycm9yRXZlbnQobmF0aXZlRXJyb3IsIHRoaXMuY3VycmVudEZyYW1lKTtcclxuICB0aGlzLnRyaWdnZXJFdmVudCgnZXJyb3InLCBlcnJvcik7XHJcblxyXG4gIGlmICh0aGlzLm9uRXJyb3IpIHtcclxuICAgIHRoaXMub25FcnJvci5jYWxsKHRoaXMsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UsIGV4cHJlc3Npb25zUGx1Z2luOiB3cml0YWJsZSAqL1xyXG4vKiBleHBvcnRlZCBleHByZXNzaW9uc1BsdWdpbiAqL1xyXG5cclxudmFyIEV4cHJlc3Npb25zID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgb2IgPSB7fTtcclxuICBvYi5pbml0RXhwcmVzc2lvbnMgPSBpbml0RXhwcmVzc2lvbnM7XHJcblxyXG4gIGZ1bmN0aW9uIGluaXRFeHByZXNzaW9ucyhhbmltYXRpb24pIHtcclxuICAgIHZhciBzdGFja0NvdW50ID0gMDtcclxuICAgIHZhciByZWdpc3RlcnMgPSBbXTtcclxuXHJcbiAgICBmdW5jdGlvbiBwdXNoRXhwcmVzc2lvbigpIHtcclxuICAgICAgc3RhY2tDb3VudCArPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBvcEV4cHJlc3Npb24oKSB7XHJcbiAgICAgIHN0YWNrQ291bnQgLT0gMTtcclxuICAgICAgaWYgKHN0YWNrQ291bnQgPT09IDApIHtcclxuICAgICAgICByZWxlYXNlSW5zdGFuY2VzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWdpc3RlckV4cHJlc3Npb25Qcm9wZXJ0eShleHByZXNzaW9uKSB7XHJcbiAgICAgIGlmIChyZWdpc3RlcnMuaW5kZXhPZihleHByZXNzaW9uKSA9PT0gLTEpIHtcclxuICAgICAgICByZWdpc3RlcnMucHVzaChleHByZXNzaW9uKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbGVhc2VJbnN0YW5jZXMoKSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuID0gcmVnaXN0ZXJzLmxlbmd0aDtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgcmVnaXN0ZXJzW2ldLnJlbGVhc2UoKTtcclxuICAgICAgfVxyXG4gICAgICByZWdpc3RlcnMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBhbmltYXRpb24ucmVuZGVyZXIuY29tcEludGVyZmFjZSA9IENvbXBFeHByZXNzaW9uSW50ZXJmYWNlKGFuaW1hdGlvbi5yZW5kZXJlcik7XHJcbiAgICBhbmltYXRpb24ucmVuZGVyZXIuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLnJlZ2lzdGVyQ29tcG9zaXRpb24oYW5pbWF0aW9uLnJlbmRlcmVyKTtcclxuICAgIGFuaW1hdGlvbi5yZW5kZXJlci5nbG9iYWxEYXRhLnB1c2hFeHByZXNzaW9uID0gcHVzaEV4cHJlc3Npb247XHJcbiAgICBhbmltYXRpb24ucmVuZGVyZXIuZ2xvYmFsRGF0YS5wb3BFeHByZXNzaW9uID0gcG9wRXhwcmVzc2lvbjtcclxuICAgIGFuaW1hdGlvbi5yZW5kZXJlci5nbG9iYWxEYXRhLnJlZ2lzdGVyRXhwcmVzc2lvblByb3BlcnR5ID0gcmVnaXN0ZXJFeHByZXNzaW9uUHJvcGVydHk7XHJcbiAgfVxyXG4gIHJldHVybiBvYjtcclxufSgpKTtcclxuXHJcbmV4cHJlc3Npb25zUGx1Z2luID0gRXhwcmVzc2lvbnM7XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UsIG5vLXVudXNlZC12YXJzICovXHJcbi8qIGdsb2JhbCBCTU1hdGgsIEJlemllckZhY3RvcnksIGNyZWF0ZVR5cGVkQXJyYXksIGRlZ1RvUmFkcywgc2hhcGVQb29sICovXHJcblxyXG52YXIgRXhwcmVzc2lvbk1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdmFyIG9iID0ge307XHJcbiAgdmFyIE1hdGggPSBCTU1hdGg7XHJcbiAgdmFyIHdpbmRvdyA9IG51bGw7XHJcbiAgdmFyIGRvY3VtZW50ID0gbnVsbDtcclxuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSBudWxsO1xyXG4gIHZhciBmZXRjaCA9IG51bGw7XHJcblxyXG4gIGZ1bmN0aW9uICRibV9pc0luc3RhbmNlT2ZBcnJheShhcnIpIHtcclxuICAgIHJldHVybiBhcnIuY29uc3RydWN0b3IgPT09IEFycmF5IHx8IGFyci5jb25zdHJ1Y3RvciA9PT0gRmxvYXQzMkFycmF5O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNOdW1lcmFibGUodE9mViwgdikge1xyXG4gICAgcmV0dXJuIHRPZlYgPT09ICdudW1iZXInIHx8IHRPZlYgPT09ICdib29sZWFuJyB8fCB0T2ZWID09PSAnc3RyaW5nJyB8fCB2IGluc3RhbmNlb2YgTnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gJGJtX25lZyhhKSB7XHJcbiAgICB2YXIgdE9mQSA9IHR5cGVvZiBhO1xyXG4gICAgaWYgKHRPZkEgPT09ICdudW1iZXInIHx8IHRPZkEgPT09ICdib29sZWFuJyB8fCBhIGluc3RhbmNlb2YgTnVtYmVyKSB7XHJcbiAgICAgIHJldHVybiAtYTtcclxuICAgIH1cclxuICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XHJcbiAgICAgIHZhciByZXRBcnIgPSBbXTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbkE7IGkgKz0gMSkge1xyXG4gICAgICAgIHJldEFycltpXSA9IC1hW2ldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXRBcnI7XHJcbiAgICB9XHJcbiAgICBpZiAoYS5wcm9wVHlwZSkge1xyXG4gICAgICByZXR1cm4gYS52O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC1hO1xyXG4gIH1cclxuXHJcbiAgdmFyIGVhc2VJbkJleiA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKDAuMzMzLCAwLCAwLjgzMywgMC44MzMsICdlYXNlSW4nKS5nZXQ7XHJcbiAgdmFyIGVhc2VPdXRCZXogPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZygwLjE2NywgMC4xNjcsIDAuNjY3LCAxLCAnZWFzZU91dCcpLmdldDtcclxuICB2YXIgZWFzZUluT3V0QmV6ID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoMC4zMywgMCwgMC42NjcsIDEsICdlYXNlSW5PdXQnKS5nZXQ7XHJcblxyXG4gIGZ1bmN0aW9uIHN1bShhLCBiKSB7XHJcbiAgICB2YXIgdE9mQSA9IHR5cGVvZiBhO1xyXG4gICAgdmFyIHRPZkIgPSB0eXBlb2YgYjtcclxuICAgIGlmICh0T2ZBID09PSAnc3RyaW5nJyB8fCB0T2ZCID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gYSArIGI7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcclxuICAgICAgcmV0dXJuIGEgKyBiO1xyXG4gICAgfVxyXG4gICAgaWYgKCRibV9pc0luc3RhbmNlT2ZBcnJheShhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xyXG4gICAgICBhID0gYS5zbGljZSgwKTtcclxuICAgICAgYVswXSArPSBiO1xyXG4gICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYikpIHtcclxuICAgICAgYiA9IGIuc2xpY2UoMCk7XHJcbiAgICAgIGJbMF0gPSBhICsgYlswXTtcclxuICAgICAgcmV0dXJuIGI7XHJcbiAgICB9XHJcbiAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XHJcbiAgICAgIHZhciBsZW5CID0gYi5sZW5ndGg7XHJcbiAgICAgIHZhciByZXRBcnIgPSBbXTtcclxuICAgICAgd2hpbGUgKGkgPCBsZW5BIHx8IGkgPCBsZW5CKSB7XHJcbiAgICAgICAgaWYgKCh0eXBlb2YgYVtpXSA9PT0gJ251bWJlcicgfHwgYVtpXSBpbnN0YW5jZW9mIE51bWJlcikgJiYgKHR5cGVvZiBiW2ldID09PSAnbnVtYmVyJyB8fCBiW2ldIGluc3RhbmNlb2YgTnVtYmVyKSkge1xyXG4gICAgICAgICAgcmV0QXJyW2ldID0gYVtpXSArIGJbaV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldEFycltpXSA9IGJbaV0gPT09IHVuZGVmaW5lZCA/IGFbaV0gOiBhW2ldIHx8IGJbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmV0QXJyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIHZhciBhZGQgPSBzdW07XHJcblxyXG4gIGZ1bmN0aW9uIHN1YihhLCBiKSB7XHJcbiAgICB2YXIgdE9mQSA9IHR5cGVvZiBhO1xyXG4gICAgdmFyIHRPZkIgPSB0eXBlb2YgYjtcclxuICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xyXG4gICAgICBpZiAodE9mQSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBhID0gcGFyc2VJbnQoYSwgMTApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0T2ZCID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGIgPSBwYXJzZUludChiLCAxMCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGEgLSBiO1xyXG4gICAgfVxyXG4gICAgaWYgKCRibV9pc0luc3RhbmNlT2ZBcnJheShhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xyXG4gICAgICBhID0gYS5zbGljZSgwKTtcclxuICAgICAgYVswXSAtPSBiO1xyXG4gICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYikpIHtcclxuICAgICAgYiA9IGIuc2xpY2UoMCk7XHJcbiAgICAgIGJbMF0gPSBhIC0gYlswXTtcclxuICAgICAgcmV0dXJuIGI7XHJcbiAgICB9XHJcbiAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XHJcbiAgICAgIHZhciBsZW5CID0gYi5sZW5ndGg7XHJcbiAgICAgIHZhciByZXRBcnIgPSBbXTtcclxuICAgICAgd2hpbGUgKGkgPCBsZW5BIHx8IGkgPCBsZW5CKSB7XHJcbiAgICAgICAgaWYgKCh0eXBlb2YgYVtpXSA9PT0gJ251bWJlcicgfHwgYVtpXSBpbnN0YW5jZW9mIE51bWJlcikgJiYgKHR5cGVvZiBiW2ldID09PSAnbnVtYmVyJyB8fCBiW2ldIGluc3RhbmNlb2YgTnVtYmVyKSkge1xyXG4gICAgICAgICAgcmV0QXJyW2ldID0gYVtpXSAtIGJbaV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldEFycltpXSA9IGJbaV0gPT09IHVuZGVmaW5lZCA/IGFbaV0gOiBhW2ldIHx8IGJbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmV0QXJyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtdWwoYSwgYikge1xyXG4gICAgdmFyIHRPZkEgPSB0eXBlb2YgYTtcclxuICAgIHZhciB0T2ZCID0gdHlwZW9mIGI7XHJcbiAgICB2YXIgYXJyO1xyXG4gICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XHJcbiAgICAgIHJldHVybiBhICogYjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW47XHJcbiAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XHJcbiAgICAgIGxlbiA9IGEubGVuZ3RoO1xyXG4gICAgICBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgYXJyW2ldID0gYVtpXSAqIGI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYikpIHtcclxuICAgICAgbGVuID0gYi5sZW5ndGg7XHJcbiAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBhcnJbaV0gPSBhICogYltpXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkaXYoYSwgYikge1xyXG4gICAgdmFyIHRPZkEgPSB0eXBlb2YgYTtcclxuICAgIHZhciB0T2ZCID0gdHlwZW9mIGI7XHJcbiAgICB2YXIgYXJyO1xyXG4gICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XHJcbiAgICAgIHJldHVybiBhIC8gYjtcclxuICAgIH1cclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbjtcclxuICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcclxuICAgICAgbGVuID0gYS5sZW5ndGg7XHJcbiAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBhcnJbaV0gPSBhW2ldIC8gYjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xyXG4gICAgICBsZW4gPSBiLmxlbmd0aDtcclxuICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIGFycltpXSA9IGEgLyBiW2ldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgZnVuY3Rpb24gbW9kKGEsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgYSA9IHBhcnNlSW50KGEsIDEwKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgYiA9IHBhcnNlSW50KGIsIDEwKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhICUgYjtcclxuICB9XHJcbiAgdmFyICRibV9zdW0gPSBzdW07XHJcbiAgdmFyICRibV9zdWIgPSBzdWI7XHJcbiAgdmFyICRibV9tdWwgPSBtdWw7XHJcbiAgdmFyICRibV9kaXYgPSBkaXY7XHJcbiAgdmFyICRibV9tb2QgPSBtb2Q7XHJcblxyXG4gIGZ1bmN0aW9uIGNsYW1wKG51bSwgbWluLCBtYXgpIHtcclxuICAgIGlmIChtaW4gPiBtYXgpIHtcclxuICAgICAgdmFyIG1tID0gbWF4O1xyXG4gICAgICBtYXggPSBtaW47XHJcbiAgICAgIG1pbiA9IG1tO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG51bSwgbWluKSwgbWF4KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJhZGlhbnNUb0RlZ3JlZXModmFsKSB7XHJcbiAgICByZXR1cm4gdmFsIC8gZGVnVG9SYWRzO1xyXG4gIH1cclxuICB2YXIgcmFkaWFuc190b19kZWdyZWVzID0gcmFkaWFuc1RvRGVncmVlcztcclxuXHJcbiAgZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyh2YWwpIHtcclxuICAgIHJldHVybiB2YWwgKiBkZWdUb1JhZHM7XHJcbiAgfVxyXG4gIHZhciBkZWdyZWVzX3RvX3JhZGlhbnMgPSByYWRpYW5zVG9EZWdyZWVzO1xyXG5cclxuICB2YXIgaGVscGVyTGVuZ3RoQXJyYXkgPSBbMCwgMCwgMCwgMCwgMCwgMF07XHJcblxyXG4gIGZ1bmN0aW9uIGxlbmd0aChhcnIxLCBhcnIyKSB7XHJcbiAgICBpZiAodHlwZW9mIGFycjEgPT09ICdudW1iZXInIHx8IGFycjEgaW5zdGFuY2VvZiBOdW1iZXIpIHtcclxuICAgICAgYXJyMiA9IGFycjIgfHwgMDtcclxuICAgICAgcmV0dXJuIE1hdGguYWJzKGFycjEgLSBhcnIyKTtcclxuICAgIH1cclxuICAgIGlmICghYXJyMikge1xyXG4gICAgICBhcnIyID0gaGVscGVyTGVuZ3RoQXJyYXk7XHJcbiAgICB9XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnIxLmxlbmd0aCwgYXJyMi5sZW5ndGgpO1xyXG4gICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBhZGRlZExlbmd0aCArPSBNYXRoLnBvdyhhcnIyW2ldIC0gYXJyMVtpXSwgMik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGFkZGVkTGVuZ3RoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZSh2ZWMpIHtcclxuICAgIHJldHVybiBkaXYodmVjLCBsZW5ndGgodmVjKSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZ2JUb0hzbCh2YWwpIHtcclxuICAgIHZhciByID0gdmFsWzBdOyB2YXIgZyA9IHZhbFsxXTsgdmFyIGIgPSB2YWxbMl07XHJcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XHJcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XHJcbiAgICB2YXIgaDtcclxuICAgIHZhciBzO1xyXG4gICAgdmFyIGwgPSAobWF4ICsgbWluKSAvIDI7XHJcblxyXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XHJcbiAgICAgIGggPSAwOyAvLyBhY2hyb21hdGljXHJcbiAgICAgIHMgPSAwOyAvLyBhY2hyb21hdGljXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgZCA9IG1heCAtIG1pbjtcclxuICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xyXG4gICAgICBzd2l0Y2ggKG1heCkge1xyXG4gICAgICAgIGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcclxuICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDogYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgaCAvPSA2O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbaCwgcywgbCwgdmFsWzNdXTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xyXG4gICAgaWYgKHQgPCAwKSB0ICs9IDE7XHJcbiAgICBpZiAodCA+IDEpIHQgLT0gMTtcclxuICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xyXG4gICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHE7XHJcbiAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XHJcbiAgICByZXR1cm4gcDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGhzbFRvUmdiKHZhbCkge1xyXG4gICAgdmFyIGggPSB2YWxbMF07XHJcbiAgICB2YXIgcyA9IHZhbFsxXTtcclxuICAgIHZhciBsID0gdmFsWzJdO1xyXG5cclxuICAgIHZhciByO1xyXG4gICAgdmFyIGc7XHJcbiAgICB2YXIgYjtcclxuXHJcbiAgICBpZiAocyA9PT0gMCkge1xyXG4gICAgICByID0gbDsgLy8gYWNocm9tYXRpY1xyXG4gICAgICBiID0gbDsgLy8gYWNocm9tYXRpY1xyXG4gICAgICBnID0gbDsgLy8gYWNocm9tYXRpY1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xyXG4gICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcclxuICAgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcclxuICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XHJcbiAgICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxIC8gMyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtyLCBnLCBiLCB2YWxbM11dO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbGluZWFyKHQsIHRNaW4sIHRNYXgsIHZhbHVlMSwgdmFsdWUyKSB7XHJcbiAgICBpZiAodmFsdWUxID09PSB1bmRlZmluZWQgfHwgdmFsdWUyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFsdWUxID0gdE1pbjtcclxuICAgICAgdmFsdWUyID0gdE1heDtcclxuICAgICAgdE1pbiA9IDA7XHJcbiAgICAgIHRNYXggPSAxO1xyXG4gICAgfVxyXG4gICAgaWYgKHRNYXggPCB0TWluKSB7XHJcbiAgICAgIHZhciBfdE1pbiA9IHRNYXg7XHJcbiAgICAgIHRNYXggPSB0TWluO1xyXG4gICAgICB0TWluID0gX3RNaW47XHJcbiAgICB9XHJcbiAgICBpZiAodCA8PSB0TWluKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTE7XHJcbiAgICB9IGlmICh0ID49IHRNYXgpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlMjtcclxuICAgIH1cclxuICAgIHZhciBwZXJjID0gdE1heCA9PT0gdE1pbiA/IDAgOiAodCAtIHRNaW4pIC8gKHRNYXggLSB0TWluKTtcclxuICAgIGlmICghdmFsdWUxLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gdmFsdWUxICsgKHZhbHVlMiAtIHZhbHVlMSkgKiBwZXJjO1xyXG4gICAgfVxyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gdmFsdWUxLmxlbmd0aDtcclxuICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBhcnJbaV0gPSB2YWx1ZTFbaV0gKyAodmFsdWUyW2ldIC0gdmFsdWUxW2ldKSAqIHBlcmM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyO1xyXG4gIH1cclxuICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgpIHtcclxuICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBtaW4gPSAwO1xyXG4gICAgICAgIG1heCA9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWF4ID0gbWluO1xyXG4gICAgICAgIG1pbiA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG1heC5sZW5ndGgpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsZW4gPSBtYXgubGVuZ3RoO1xyXG4gICAgICBpZiAoIW1pbikge1xyXG4gICAgICAgIG1pbiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgICAgdmFyIHJuZCA9IEJNTWF0aC5yYW5kb20oKTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgYXJyW2ldID0gbWluW2ldICsgcm5kICogKG1heFtpXSAtIG1pbltpXSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBtaW4gPSAwO1xyXG4gICAgfVxyXG4gICAgdmFyIHJuZG0gPSBCTU1hdGgucmFuZG9tKCk7XHJcbiAgICByZXR1cm4gbWluICsgcm5kbSAqIChtYXggLSBtaW4pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlUGF0aChwb2ludHMsIGluVGFuZ2VudHMsIG91dFRhbmdlbnRzLCBjbG9zZWQpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICB2YXIgcGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgICBwYXRoLnNldFBhdGhEYXRhKCEhY2xvc2VkLCBsZW4pO1xyXG4gICAgdmFyIGFyclBsYWNlaG9sZGVyID0gWzAsIDBdO1xyXG4gICAgdmFyIGluVmVydGV4UG9pbnQ7XHJcbiAgICB2YXIgb3V0VmVydGV4UG9pbnQ7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgaW5WZXJ0ZXhQb2ludCA9IChpblRhbmdlbnRzICYmIGluVGFuZ2VudHNbaV0pID8gaW5UYW5nZW50c1tpXSA6IGFyclBsYWNlaG9sZGVyO1xyXG4gICAgICBvdXRWZXJ0ZXhQb2ludCA9IChvdXRUYW5nZW50cyAmJiBvdXRUYW5nZW50c1tpXSkgPyBvdXRUYW5nZW50c1tpXSA6IGFyclBsYWNlaG9sZGVyO1xyXG4gICAgICBwYXRoLnNldFRyaXBsZUF0KHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdLCBvdXRWZXJ0ZXhQb2ludFswXSArIHBvaW50c1tpXVswXSwgb3V0VmVydGV4UG9pbnRbMV0gKyBwb2ludHNbaV1bMV0sIGluVmVydGV4UG9pbnRbMF0gKyBwb2ludHNbaV1bMF0sIGluVmVydGV4UG9pbnRbMV0gKyBwb2ludHNbaV1bMV0sIGksIHRydWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbml0aWF0ZUV4cHJlc3Npb24oZWxlbSwgZGF0YSwgcHJvcGVydHkpIHtcclxuICAgIHZhciB2YWwgPSBkYXRhLng7XHJcbiAgICB2YXIgbmVlZHNWZWxvY2l0eSA9IC92ZWxvY2l0eSg/IVtcXHdcXGRdKS8udGVzdCh2YWwpO1xyXG4gICAgdmFyIF9uZWVkc1JhbmRvbSA9IHZhbC5pbmRleE9mKCdyYW5kb20nKSAhPT0gLTE7XHJcbiAgICB2YXIgZWxlbVR5cGUgPSBlbGVtLmRhdGEudHk7XHJcbiAgICB2YXIgdHJhbnNmb3JtO1xyXG4gICAgdmFyICRibV90cmFuc2Zvcm07XHJcbiAgICB2YXIgY29udGVudDtcclxuICAgIHZhciBlZmZlY3Q7XHJcbiAgICB2YXIgdGhpc1Byb3BlcnR5ID0gcHJvcGVydHk7XHJcbiAgICB0aGlzUHJvcGVydHkudmFsdWVBdFRpbWUgPSB0aGlzUHJvcGVydHkuZ2V0VmFsdWVBdFRpbWU7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpc1Byb3BlcnR5LCAndmFsdWUnLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzUHJvcGVydHkudjtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgZWxlbS5jb21wLmZyYW1lRHVyYXRpb24gPSAxIC8gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgZWxlbS5jb21wLmRpc3BsYXlTdGFydFRpbWUgPSAwO1xyXG4gICAgdmFyIGluUG9pbnQgPSBlbGVtLmRhdGEuaXAgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICB2YXIgb3V0UG9pbnQgPSBlbGVtLmRhdGEub3AgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICB2YXIgd2lkdGggPSBlbGVtLmRhdGEuc3cgPyBlbGVtLmRhdGEuc3cgOiAwO1xyXG4gICAgdmFyIGhlaWdodCA9IGVsZW0uZGF0YS5zaCA/IGVsZW0uZGF0YS5zaCA6IDA7XHJcbiAgICB2YXIgbmFtZSA9IGVsZW0uZGF0YS5ubTtcclxuICAgIHZhciBsb29wSW47XHJcbiAgICB2YXIgbG9vcF9pbjtcclxuICAgIHZhciBsb29wT3V0O1xyXG4gICAgdmFyIGxvb3Bfb3V0O1xyXG4gICAgdmFyIHNtb290aDtcclxuICAgIHZhciB0b1dvcmxkO1xyXG4gICAgdmFyIGZyb21Xb3JsZDtcclxuICAgIHZhciBmcm9tQ29tcDtcclxuICAgIHZhciB0b0NvbXA7XHJcbiAgICB2YXIgZnJvbUNvbXBUb1N1cmZhY2U7XHJcbiAgICB2YXIgcG9zaXRpb247XHJcbiAgICB2YXIgcm90YXRpb247XHJcbiAgICB2YXIgYW5jaG9yUG9pbnQ7XHJcbiAgICB2YXIgc2NhbGU7XHJcbiAgICB2YXIgdGhpc0xheWVyO1xyXG4gICAgdmFyIHRoaXNDb21wO1xyXG4gICAgdmFyIG1hc2s7XHJcbiAgICB2YXIgdmFsdWVBdFRpbWU7XHJcbiAgICB2YXIgdmVsb2NpdHlBdFRpbWU7XHJcblxyXG4gICAgdmFyIHNjb3BlZF9ibV9ydDtcclxuICAgIC8vIHZhbCA9IHZhbC5yZXBsYWNlKC8oXFxcXD9cInwnKSgoaHR0cCkocyk/KDpcXC8pKT9cXC8uKj8oXFxcXD9cInwnKS9nLCBcIlxcXCJcXFwiXCIpOyAvLyBkZXRlciBwb3RlbnRpYWwgbmV0d29yayBjYWxsc1xyXG4gICAgdmFyIGV4cHJlc3Npb25fZnVuY3Rpb24gPSBldmFsKCdbZnVuY3Rpb24gX2V4cHJlc3Npb25fZnVuY3Rpb24oKXsnICsgdmFsICsgJztzY29wZWRfYm1fcnQ9JGJtX3J0fV0nKVswXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXHJcbiAgICB2YXIgbnVtS2V5cyA9IHByb3BlcnR5LmtmID8gZGF0YS5rLmxlbmd0aCA6IDA7XHJcblxyXG4gICAgdmFyIGFjdGl2ZSA9ICF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmhkICE9PSB0cnVlO1xyXG5cclxuICAgIHZhciB3aWdnbGUgPSBmdW5jdGlvbiB3aWdnbGUoZnJlcSwgYW1wKSB7XHJcbiAgICAgIHZhciBpV2lnZ2xlO1xyXG4gICAgICB2YXIgajtcclxuICAgICAgdmFyIGxlbldpZ2dsZSA9IHRoaXMucHYubGVuZ3RoID8gdGhpcy5wdi5sZW5ndGggOiAxO1xyXG4gICAgICB2YXIgYWRkZWRBbXBzID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbldpZ2dsZSk7XHJcbiAgICAgIGZyZXEgPSA1O1xyXG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IE1hdGguZmxvb3IodGltZSAqIGZyZXEpO1xyXG4gICAgICBpV2lnZ2xlID0gMDtcclxuICAgICAgaiA9IDA7XHJcbiAgICAgIHdoaWxlIChpV2lnZ2xlIDwgaXRlcmF0aW9ucykge1xyXG4gICAgICAgIC8vIHZhciBybmQgPSBCTU1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbldpZ2dsZTsgaiArPSAxKSB7XHJcbiAgICAgICAgICBhZGRlZEFtcHNbal0gKz0gLWFtcCArIGFtcCAqIDIgKiBCTU1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgICAvLyBhZGRlZEFtcHNbal0gKz0gLWFtcCArIGFtcCoyKnJuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaVdpZ2dsZSArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHZhciBybmQyID0gQk1NYXRoLnJhbmRvbSgpO1xyXG4gICAgICB2YXIgcGVyaW9kcyA9IHRpbWUgKiBmcmVxO1xyXG4gICAgICB2YXIgcGVyYyA9IHBlcmlvZHMgLSBNYXRoLmZsb29yKHBlcmlvZHMpO1xyXG4gICAgICB2YXIgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbldpZ2dsZSk7XHJcbiAgICAgIGlmIChsZW5XaWdnbGUgPiAxKSB7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbldpZ2dsZTsgaiArPSAxKSB7XHJcbiAgICAgICAgICBhcnJbal0gPSB0aGlzLnB2W2pdICsgYWRkZWRBbXBzW2pdICsgKC1hbXAgKyBhbXAgKiAyICogQk1NYXRoLnJhbmRvbSgpKSAqIHBlcmM7XHJcbiAgICAgICAgICAvLyBhcnJbal0gPSB0aGlzLnB2W2pdICsgYWRkZWRBbXBzW2pdICsgKC1hbXAgKyBhbXAqMipybmQpKnBlcmM7XHJcbiAgICAgICAgICAvLyBhcnJbaV0gPSB0aGlzLnB2W2ldICsgYWRkZWRBbXAgKyBhbXAxKnBlcmMgKyBhbXAyKigxLXBlcmMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnB2ICsgYWRkZWRBbXBzWzBdICsgKC1hbXAgKyBhbXAgKiAyICogQk1NYXRoLnJhbmRvbSgpKSAqIHBlcmM7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgaWYgKHRoaXNQcm9wZXJ0eS5sb29wSW4pIHtcclxuICAgICAgbG9vcEluID0gdGhpc1Byb3BlcnR5Lmxvb3BJbi5iaW5kKHRoaXNQcm9wZXJ0eSk7XHJcbiAgICAgIGxvb3BfaW4gPSBsb29wSW47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXNQcm9wZXJ0eS5sb29wT3V0KSB7XHJcbiAgICAgIGxvb3BPdXQgPSB0aGlzUHJvcGVydHkubG9vcE91dC5iaW5kKHRoaXNQcm9wZXJ0eSk7XHJcbiAgICAgIGxvb3Bfb3V0ID0gbG9vcE91dDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpc1Byb3BlcnR5LnNtb290aCkge1xyXG4gICAgICBzbW9vdGggPSB0aGlzUHJvcGVydHkuc21vb3RoLmJpbmQodGhpc1Byb3BlcnR5KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb29wSW5EdXJhdGlvbih0eXBlLCBkdXJhdGlvbikge1xyXG4gICAgICByZXR1cm4gbG9vcEluKHR5cGUsIGR1cmF0aW9uLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb29wT3V0RHVyYXRpb24odHlwZSwgZHVyYXRpb24pIHtcclxuICAgICAgcmV0dXJuIGxvb3BPdXQodHlwZSwgZHVyYXRpb24sIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmdldFZhbHVlQXRUaW1lKSB7XHJcbiAgICAgIHZhbHVlQXRUaW1lID0gdGhpcy5nZXRWYWx1ZUF0VGltZS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmdldFZlbG9jaXR5QXRUaW1lKSB7XHJcbiAgICAgIHZlbG9jaXR5QXRUaW1lID0gdGhpcy5nZXRWZWxvY2l0eUF0VGltZS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb21wID0gZWxlbS5jb21wLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5iaW5kKGVsZW0uY29tcC5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGxvb2tBdChlbGVtMSwgZWxlbTIpIHtcclxuICAgICAgdmFyIGZWZWMgPSBbZWxlbTJbMF0gLSBlbGVtMVswXSwgZWxlbTJbMV0gLSBlbGVtMVsxXSwgZWxlbTJbMl0gLSBlbGVtMVsyXV07XHJcbiAgICAgIHZhciBwaXRjaCA9IE1hdGguYXRhbjIoZlZlY1swXSwgTWF0aC5zcXJ0KGZWZWNbMV0gKiBmVmVjWzFdICsgZlZlY1syXSAqIGZWZWNbMl0pKSAvIGRlZ1RvUmFkcztcclxuICAgICAgdmFyIHlhdyA9IC1NYXRoLmF0YW4yKGZWZWNbMV0sIGZWZWNbMl0pIC8gZGVnVG9SYWRzO1xyXG4gICAgICByZXR1cm4gW3lhdywgcGl0Y2gsIDBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVhc2VPdXQodCwgdE1pbiwgdE1heCwgdmFsMSwgdmFsMikge1xyXG4gICAgICByZXR1cm4gYXBwbHlFYXNlKGVhc2VPdXRCZXosIHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVhc2VJbih0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XHJcbiAgICAgIHJldHVybiBhcHBseUVhc2UoZWFzZUluQmV6LCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlYXNlKHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpIHtcclxuICAgICAgcmV0dXJuIGFwcGx5RWFzZShlYXNlSW5PdXRCZXosIHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5RWFzZShmbiwgdCwgdE1pbiwgdE1heCwgdmFsMSwgdmFsMikge1xyXG4gICAgICBpZiAodmFsMSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFsMSA9IHRNaW47XHJcbiAgICAgICAgdmFsMiA9IHRNYXg7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdCA9ICh0IC0gdE1pbikgLyAodE1heCAtIHRNaW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0ID4gMSkge1xyXG4gICAgICAgIHQgPSAxO1xyXG4gICAgICB9IGVsc2UgaWYgKHQgPCAwKSB7XHJcbiAgICAgICAgdCA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG11bHQgPSBmbih0KTtcclxuICAgICAgaWYgKCRibV9pc0luc3RhbmNlT2ZBcnJheSh2YWwxKSkge1xyXG4gICAgICAgIHZhciBpS2V5O1xyXG4gICAgICAgIHZhciBsZW5LZXkgPSB2YWwxLmxlbmd0aDtcclxuICAgICAgICB2YXIgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbktleSk7XHJcbiAgICAgICAgZm9yIChpS2V5ID0gMDsgaUtleSA8IGxlbktleTsgaUtleSArPSAxKSB7XHJcbiAgICAgICAgICBhcnJbaUtleV0gPSAodmFsMltpS2V5XSAtIHZhbDFbaUtleV0pICogbXVsdCArIHZhbDFbaUtleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICh2YWwyIC0gdmFsMSkgKiBtdWx0ICsgdmFsMTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBuZWFyZXN0S2V5KHRpbWUpIHtcclxuICAgICAgdmFyIGlLZXk7XHJcbiAgICAgIHZhciBsZW5LZXkgPSBkYXRhLmsubGVuZ3RoO1xyXG4gICAgICB2YXIgaW5kZXg7XHJcbiAgICAgIHZhciBrZXlUaW1lO1xyXG4gICAgICBpZiAoIWRhdGEuay5sZW5ndGggfHwgdHlwZW9mIChkYXRhLmtbMF0pID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICBrZXlUaW1lID0gMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbmRleCA9IC0xO1xyXG4gICAgICAgIHRpbWUgKj0gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgICAgIGlmICh0aW1lIDwgZGF0YS5rWzBdLnQpIHtcclxuICAgICAgICAgIGluZGV4ID0gMTtcclxuICAgICAgICAgIGtleVRpbWUgPSBkYXRhLmtbMF0udDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9yIChpS2V5ID0gMDsgaUtleSA8IGxlbktleSAtIDE7IGlLZXkgKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAodGltZSA9PT0gZGF0YS5rW2lLZXldLnQpIHtcclxuICAgICAgICAgICAgICBpbmRleCA9IGlLZXkgKyAxO1xyXG4gICAgICAgICAgICAgIGtleVRpbWUgPSBkYXRhLmtbaUtleV0udDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lID4gZGF0YS5rW2lLZXldLnQgJiYgdGltZSA8IGRhdGEua1tpS2V5ICsgMV0udCkge1xyXG4gICAgICAgICAgICAgIGlmICh0aW1lIC0gZGF0YS5rW2lLZXldLnQgPiBkYXRhLmtbaUtleSArIDFdLnQgLSB0aW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGlLZXkgKyAyO1xyXG4gICAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5ICsgMV0udDtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpS2V5ICsgMTtcclxuICAgICAgICAgICAgICAgIGtleVRpbWUgPSBkYXRhLmtbaUtleV0udDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgaW5kZXggPSBpS2V5ICsgMTtcclxuICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5XS50O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB2YXIgb2JLZXkgPSB7fTtcclxuICAgICAgb2JLZXkuaW5kZXggPSBpbmRleDtcclxuICAgICAgb2JLZXkudGltZSA9IGtleVRpbWUgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICAgIHJldHVybiBvYktleTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrZXkoaW5kKSB7XHJcbiAgICAgIHZhciBvYktleTtcclxuICAgICAgdmFyIGlLZXk7XHJcbiAgICAgIHZhciBsZW5LZXk7XHJcbiAgICAgIGlmICghZGF0YS5rLmxlbmd0aCB8fCB0eXBlb2YgKGRhdGEua1swXSkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvcGVydHkgaGFzIG5vIGtleWZyYW1lIGF0IGluZGV4ICcgKyBpbmQpO1xyXG4gICAgICB9XHJcbiAgICAgIGluZCAtPSAxO1xyXG4gICAgICBvYktleSA9IHtcclxuICAgICAgICB0aW1lOiBkYXRhLmtbaW5kXS50IC8gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLFxyXG4gICAgICAgIHZhbHVlOiBbXSxcclxuICAgICAgfTtcclxuICAgICAgdmFyIGFyciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLmtbaW5kXSwgJ3MnKSA/IGRhdGEua1tpbmRdLnMgOiBkYXRhLmtbaW5kIC0gMV0uZTtcclxuXHJcbiAgICAgIGxlbktleSA9IGFyci5sZW5ndGg7XHJcbiAgICAgIGZvciAoaUtleSA9IDA7IGlLZXkgPCBsZW5LZXk7IGlLZXkgKz0gMSkge1xyXG4gICAgICAgIG9iS2V5W2lLZXldID0gYXJyW2lLZXldO1xyXG4gICAgICAgIG9iS2V5LnZhbHVlW2lLZXldID0gYXJyW2lLZXldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvYktleTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmcmFtZXNUb1RpbWUoZnJhbWVzLCBmcHMpIHtcclxuICAgICAgaWYgKCFmcHMpIHtcclxuICAgICAgICBmcHMgPSBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZyYW1lcyAvIGZwcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0aW1lVG9GcmFtZXModCwgZnBzKSB7XHJcbiAgICAgIGlmICghdCAmJiB0ICE9PSAwKSB7XHJcbiAgICAgICAgdCA9IHRpbWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFmcHMpIHtcclxuICAgICAgICBmcHMgPSBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHQgKiBmcHM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2VlZFJhbmRvbShzZWVkKSB7XHJcbiAgICAgIEJNTWF0aC5zZWVkcmFuZG9tKHJhbmRTZWVkICsgc2VlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc291cmNlUmVjdEF0VGltZSgpIHtcclxuICAgICAgcmV0dXJuIGVsZW0uc291cmNlUmVjdEF0VGltZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnN0cmluZyhpbml0LCBlbmQpIHtcclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoaW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoaW5pdCwgZW5kKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3Vic3RyKGluaXQsIGVuZCkge1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cihpbml0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cihpbml0LCBlbmQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwb3N0ZXJpemVUaW1lKGZyYW1lc1BlclNlY29uZCkge1xyXG4gICAgICB0aW1lID0gZnJhbWVzUGVyU2Vjb25kID09PSAwID8gMCA6IE1hdGguZmxvb3IodGltZSAqIGZyYW1lc1BlclNlY29uZCkgLyBmcmFtZXNQZXJTZWNvbmQ7XHJcbiAgICAgIHZhbHVlID0gdmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRpbWU7XHJcbiAgICB2YXIgdmVsb2NpdHk7XHJcbiAgICB2YXIgdmFsdWU7XHJcbiAgICB2YXIgdGV4dDtcclxuICAgIHZhciB0ZXh0SW5kZXg7XHJcbiAgICB2YXIgdGV4dFRvdGFsO1xyXG4gICAgdmFyIHNlbGVjdG9yVmFsdWU7XHJcbiAgICB2YXIgaW5kZXggPSBlbGVtLmRhdGEuaW5kO1xyXG4gICAgdmFyIGhhc1BhcmVudCA9ICEhKGVsZW0uaGllcmFyY2h5ICYmIGVsZW0uaGllcmFyY2h5Lmxlbmd0aCk7XHJcbiAgICB2YXIgcGFyZW50O1xyXG4gICAgdmFyIHJhbmRTZWVkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMCk7XHJcbiAgICB2YXIgZ2xvYmFsRGF0YSA9IGVsZW0uZ2xvYmFsRGF0YTtcclxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVFeHByZXNzaW9uKF92YWx1ZSkge1xyXG4gICAgICAvLyBnbG9iYWxEYXRhLnB1c2hFeHByZXNzaW9uKCk7XHJcbiAgICAgIHZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICBpZiAoX25lZWRzUmFuZG9tKSB7XHJcbiAgICAgICAgc2VlZFJhbmRvbShyYW5kU2VlZCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuZnJhbWVFeHByZXNzaW9uSWQgPT09IGVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkICYmIHRoaXMucHJvcFR5cGUgIT09ICd0ZXh0U2VsZWN0b3InKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnByb3BUeXBlID09PSAndGV4dFNlbGVjdG9yJykge1xyXG4gICAgICAgIHRleHRJbmRleCA9IHRoaXMudGV4dEluZGV4O1xyXG4gICAgICAgIHRleHRUb3RhbCA9IHRoaXMudGV4dFRvdGFsO1xyXG4gICAgICAgIHNlbGVjdG9yVmFsdWUgPSB0aGlzLnNlbGVjdG9yVmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzTGF5ZXIpIHtcclxuICAgICAgICB0ZXh0ID0gZWxlbS5sYXllckludGVyZmFjZS50ZXh0O1xyXG4gICAgICAgIHRoaXNMYXllciA9IGVsZW0ubGF5ZXJJbnRlcmZhY2U7XHJcbiAgICAgICAgdGhpc0NvbXAgPSBlbGVtLmNvbXAuY29tcEludGVyZmFjZTtcclxuICAgICAgICB0b1dvcmxkID0gdGhpc0xheWVyLnRvV29ybGQuYmluZCh0aGlzTGF5ZXIpO1xyXG4gICAgICAgIGZyb21Xb3JsZCA9IHRoaXNMYXllci5mcm9tV29ybGQuYmluZCh0aGlzTGF5ZXIpO1xyXG4gICAgICAgIGZyb21Db21wID0gdGhpc0xheWVyLmZyb21Db21wLmJpbmQodGhpc0xheWVyKTtcclxuICAgICAgICB0b0NvbXAgPSB0aGlzTGF5ZXIudG9Db21wLmJpbmQodGhpc0xheWVyKTtcclxuICAgICAgICBtYXNrID0gdGhpc0xheWVyLm1hc2sgPyB0aGlzTGF5ZXIubWFzay5iaW5kKHRoaXNMYXllcikgOiBudWxsO1xyXG4gICAgICAgIGZyb21Db21wVG9TdXJmYWNlID0gZnJvbUNvbXA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcclxuICAgICAgICB0cmFuc2Zvcm0gPSBlbGVtLmxheWVySW50ZXJmYWNlKCdBREJFIFRyYW5zZm9ybSBHcm91cCcpO1xyXG4gICAgICAgICRibV90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgYW5jaG9yUG9pbnQgPSB0cmFuc2Zvcm0uYW5jaG9yUG9pbnQ7XHJcbiAgICAgICAgICAvKiBwb3NpdGlvbiA9IHRyYW5zZm9ybS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbiA9IHRyYW5zZm9ybS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IHRyYW5zZm9ybS5zY2FsZTsgKi9cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlbGVtVHlwZSA9PT0gNCAmJiAhY29udGVudCkge1xyXG4gICAgICAgIGNvbnRlbnQgPSB0aGlzTGF5ZXIoJ0FEQkUgUm9vdCBWZWN0b3JzIEdyb3VwJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFlZmZlY3QpIHtcclxuICAgICAgICBlZmZlY3QgPSB0aGlzTGF5ZXIoNCk7XHJcbiAgICAgIH1cclxuICAgICAgaGFzUGFyZW50ID0gISEoZWxlbS5oaWVyYXJjaHkgJiYgZWxlbS5oaWVyYXJjaHkubGVuZ3RoKTtcclxuICAgICAgaWYgKGhhc1BhcmVudCAmJiAhcGFyZW50KSB7XHJcbiAgICAgICAgcGFyZW50ID0gZWxlbS5oaWVyYXJjaHlbMF0ubGF5ZXJJbnRlcmZhY2U7XHJcbiAgICAgIH1cclxuICAgICAgdGltZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgICBpZiAobmVlZHNWZWxvY2l0eSkge1xyXG4gICAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHlBdFRpbWUodGltZSk7XHJcbiAgICAgIH1cclxuICAgICAgZXhwcmVzc2lvbl9mdW5jdGlvbigpO1xyXG4gICAgICB0aGlzLmZyYW1lRXhwcmVzc2lvbklkID0gZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XHJcblxyXG4gICAgICAvLyBUT0RPOiBDaGVjayBpZiBpdCdzIHBvc3NpYmxlIHRvIHJldHVybiBvbiBTaGFwZUludGVyZmFjZSB0aGUgLnYgdmFsdWVcclxuICAgICAgaWYgKHNjb3BlZF9ibV9ydC5wcm9wVHlwZSA9PT0gJ3NoYXBlJykge1xyXG4gICAgICAgIHNjb3BlZF9ibV9ydCA9IHNjb3BlZF9ibV9ydC52O1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGdsb2JhbERhdGEucG9wRXhwcmVzc2lvbigpO1xyXG4gICAgICByZXR1cm4gc2NvcGVkX2JtX3J0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4ZWN1dGVFeHByZXNzaW9uO1xyXG4gIH1cclxuXHJcbiAgb2IuaW5pdGlhdGVFeHByZXNzaW9uID0gaW5pdGlhdGVFeHByZXNzaW9uO1xyXG4gIHJldHVybiBvYjtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBFeHByZXNzaW9uTWFuYWdlciwgY3JlYXRlVHlwZWRBcnJheSAqL1xyXG4vKiBleHBvcnRlZCBleHByZXNzaW9uSGVscGVycyAqL1xyXG5cclxudmFyIGV4cHJlc3Npb25IZWxwZXJzID0gKGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBzZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLCBwcm9wKSB7XHJcbiAgICBpZiAoZGF0YS54KSB7XHJcbiAgICAgIHByb3AuayA9IHRydWU7XHJcbiAgICAgIHByb3AueCA9IHRydWU7XHJcbiAgICAgIHByb3AuaW5pdGlhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uO1xyXG4gICAgICBwcm9wLmVmZmVjdHNTZXF1ZW5jZS5wdXNoKHByb3AuaW5pdGlhdGVFeHByZXNzaW9uKGVsZW0sIGRhdGEsIHByb3ApLmJpbmQocHJvcCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0VmFsdWVBdFRpbWUoZnJhbWVOdW0pIHtcclxuICAgIGZyYW1lTnVtICo9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgIGZyYW1lTnVtIC09IHRoaXMub2Zmc2V0VGltZTtcclxuICAgIGlmIChmcmFtZU51bSAhPT0gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0RnJhbWUpIHtcclxuICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0SW5kZXggPSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RGcmFtZSA8IGZyYW1lTnVtID8gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0SW5kZXggOiAwO1xyXG4gICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLnZhbHVlID0gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCB0aGlzLl9jYWNoaW5nQXRUaW1lKTtcclxuICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0RnJhbWUgPSBmcmFtZU51bTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9jYWNoaW5nQXRUaW1lLnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0U3BlZWRBdFRpbWUoZnJhbWVOdW0pIHtcclxuICAgIHZhciBkZWx0YSA9IC0wLjAxO1xyXG4gICAgdmFyIHYxID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSk7XHJcbiAgICB2YXIgdjIgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZyYW1lTnVtICsgZGVsdGEpO1xyXG4gICAgdmFyIHNwZWVkID0gMDtcclxuICAgIGlmICh2MS5sZW5ndGgpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgIHNwZWVkICs9IE1hdGgucG93KHYyW2ldIC0gdjFbaV0sIDIpO1xyXG4gICAgICB9XHJcbiAgICAgIHNwZWVkID0gTWF0aC5zcXJ0KHNwZWVkKSAqIDEwMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNwZWVkID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBzcGVlZDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFZlbG9jaXR5QXRUaW1lKGZyYW1lTnVtKSB7XHJcbiAgICBpZiAodGhpcy52ZWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWw7XHJcbiAgICB9XHJcbiAgICB2YXIgZGVsdGEgPSAtMC4wMDE7XHJcbiAgICAvLyBmcmFtZU51bSArPSB0aGlzLmVsZW0uZGF0YS5zdDtcclxuICAgIHZhciB2MSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZnJhbWVOdW0pO1xyXG4gICAgdmFyIHYyID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSArIGRlbHRhKTtcclxuICAgIHZhciB2ZWxvY2l0eTtcclxuICAgIGlmICh2MS5sZW5ndGgpIHtcclxuICAgICAgdmVsb2NpdHkgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgdjEubGVuZ3RoKTtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgIC8vIHJlbW92aW5nIGZyYW1lUmF0ZVxyXG4gICAgICAgIC8vIGlmIG5lZWRlZCwgZG9uJ3QgYWRkIGl0IGhlcmVcclxuICAgICAgICAvLyB2ZWxvY2l0eVtpXSA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lUmF0ZSooKHYyW2ldIC0gdjFbaV0pL2RlbHRhKTtcclxuICAgICAgICB2ZWxvY2l0eVtpXSA9ICh2MltpXSAtIHYxW2ldKSAvIGRlbHRhO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2ZWxvY2l0eSA9ICh2MiAtIHYxKSAvIGRlbHRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZlbG9jaXR5O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0U3RhdGljVmFsdWVBdFRpbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldEdyb3VwUHJvcGVydHkocHJvcGVydHlHcm91cCkge1xyXG4gICAgdGhpcy5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cDtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzZWFyY2hFeHByZXNzaW9uczogc2VhcmNoRXhwcmVzc2lvbnMsXHJcbiAgICBnZXRTcGVlZEF0VGltZTogZ2V0U3BlZWRBdFRpbWUsXHJcbiAgICBnZXRWZWxvY2l0eUF0VGltZTogZ2V0VmVsb2NpdHlBdFRpbWUsXHJcbiAgICBnZXRWYWx1ZUF0VGltZTogZ2V0VmFsdWVBdFRpbWUsXHJcbiAgICBnZXRTdGF0aWNWYWx1ZUF0VGltZTogZ2V0U3RhdGljVmFsdWVBdFRpbWUsXHJcbiAgICBzZXRHcm91cFByb3BlcnR5OiBzZXRHcm91cFByb3BlcnR5LFxyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlVHlwZWRBcnJheSwgTWF0cml4LCBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnksIGV4cHJlc3Npb25IZWxwZXJzLCBQcm9wZXJ0eUZhY3RvcnksIGV4cHJlc3Npb25IZWxwZXJzLFxyXG5pbml0aWFsRGVmYXVsdEZyYW1lLCBzaGFwZVBvb2wsIFNoYXBlUHJvcGVydHlGYWN0b3J5LCBiZXosIGV4dGVuZFByb3RvdHlwZSwgRXhwcmVzc2lvbk1hbmFnZXIsIGNyZWF0ZVNpemVkQXJyYXkgKi9cclxuXHJcbihmdW5jdGlvbiBhZGRQcm9wZXJ0eURlY29yYXRvcigpIHtcclxuICBmdW5jdGlvbiBsb29wT3V0KHR5cGUsIGR1cmF0aW9uLCBkdXJhdGlvbkZsYWcpIHtcclxuICAgIGlmICghdGhpcy5rIHx8ICF0aGlzLmtleWZyYW1lcykge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdjtcclxuICAgIH1cclxuICAgIHR5cGUgPSB0eXBlID8gdHlwZS50b0xvd2VyQ2FzZSgpIDogJyc7XHJcbiAgICB2YXIgY3VycmVudEZyYW1lID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWU7XHJcbiAgICB2YXIga2V5ZnJhbWVzID0gdGhpcy5rZXlmcmFtZXM7XHJcbiAgICB2YXIgbGFzdEtleUZyYW1lID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXS50O1xyXG4gICAgaWYgKGN1cnJlbnRGcmFtZSA8PSBsYXN0S2V5RnJhbWUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHY7XHJcbiAgICB9XHJcbiAgICB2YXIgY3ljbGVEdXJhdGlvbjtcclxuICAgIHZhciBmaXJzdEtleUZyYW1lO1xyXG4gICAgaWYgKCFkdXJhdGlvbkZsYWcpIHtcclxuICAgICAgaWYgKCFkdXJhdGlvbiB8fCBkdXJhdGlvbiA+IGtleWZyYW1lcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgZHVyYXRpb24gPSBrZXlmcmFtZXMubGVuZ3RoIC0gMTtcclxuICAgICAgfVxyXG4gICAgICBmaXJzdEtleUZyYW1lID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxIC0gZHVyYXRpb25dLnQ7XHJcbiAgICAgIGN5Y2xlRHVyYXRpb24gPSBsYXN0S2V5RnJhbWUgLSBmaXJzdEtleUZyYW1lO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCFkdXJhdGlvbikge1xyXG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBNYXRoLm1heCgwLCBsYXN0S2V5RnJhbWUgLSB0aGlzLmVsZW0uZGF0YS5pcCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IE1hdGguYWJzKGxhc3RLZXlGcmFtZSAtIHRoaXMuZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlICogZHVyYXRpb24pO1xyXG4gICAgICB9XHJcbiAgICAgIGZpcnN0S2V5RnJhbWUgPSBsYXN0S2V5RnJhbWUgLSBjeWNsZUR1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuO1xyXG4gICAgdmFyIHJldDtcclxuICAgIGlmICh0eXBlID09PSAncGluZ3BvbmcnKSB7XHJcbiAgICAgIHZhciBpdGVyYXRpb25zID0gTWF0aC5mbG9vcigoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgLyBjeWNsZUR1cmF0aW9uKTtcclxuICAgICAgaWYgKGl0ZXJhdGlvbnMgJSAyICE9PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0VGltZSgoKGN5Y2xlRHVyYXRpb24gLSAoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvZmZzZXQnKSB7XHJcbiAgICAgIHZhciBpbml0ViA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZmlyc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgIHZhciBlbmRWID0gdGhpcy5nZXRWYWx1ZUF0VGltZShsYXN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRWYWx1ZUF0VGltZSgoKGN1cnJlbnRGcmFtZSAtIGZpcnN0S2V5RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArIGZpcnN0S2V5RnJhbWUpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICB2YXIgcmVwZWF0cyA9IE1hdGguZmxvb3IoKGN1cnJlbnRGcmFtZSAtIGZpcnN0S2V5RnJhbWUpIC8gY3ljbGVEdXJhdGlvbik7XHJcbiAgICAgIGlmICh0aGlzLnB2Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldCA9IG5ldyBBcnJheShpbml0Vi5sZW5ndGgpO1xyXG4gICAgICAgIGxlbiA9IHJldC5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICByZXRbaV0gPSAoZW5kVltpXSAtIGluaXRWW2ldKSAqIHJlcGVhdHMgKyBjdXJyZW50W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoZW5kViAtIGluaXRWKSAqIHJlcGVhdHMgKyBjdXJyZW50O1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY29udGludWUnKSB7XHJcbiAgICAgIHZhciBsYXN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGxhc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgIHZhciBuZXh0TGFzdFZhbHVlID0gdGhpcy5nZXRWYWx1ZUF0VGltZSgobGFzdEtleUZyYW1lIC0gMC4wMDEpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcclxuICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KGxhc3RWYWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgIGxlbiA9IHJldC5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IGxhc3RWYWx1ZVtpXSArIChsYXN0VmFsdWVbaV0gLSBuZXh0TGFzdFZhbHVlW2ldKSAqICgoY3VycmVudEZyYW1lIC0gbGFzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSkgLyAwLjAwMDU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbGFzdFZhbHVlICsgKGxhc3RWYWx1ZSAtIG5leHRMYXN0VmFsdWUpICogKCgoY3VycmVudEZyYW1lIC0gbGFzdEtleUZyYW1lKSkgLyAwLjAwMSk7XHJcbiAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXRUaW1lKCgoKGN1cnJlbnRGcmFtZSAtIGZpcnN0S2V5RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArIGZpcnN0S2V5RnJhbWUpKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb29wSW4odHlwZSwgZHVyYXRpb24sIGR1cmF0aW9uRmxhZykge1xyXG4gICAgaWYgKCF0aGlzLmspIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHY7XHJcbiAgICB9XHJcbiAgICB0eXBlID0gdHlwZSA/IHR5cGUudG9Mb3dlckNhc2UoKSA6ICcnO1xyXG4gICAgdmFyIGN1cnJlbnRGcmFtZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lO1xyXG4gICAgdmFyIGtleWZyYW1lcyA9IHRoaXMua2V5ZnJhbWVzO1xyXG4gICAgdmFyIGZpcnN0S2V5RnJhbWUgPSBrZXlmcmFtZXNbMF0udDtcclxuICAgIGlmIChjdXJyZW50RnJhbWUgPj0gZmlyc3RLZXlGcmFtZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdjtcclxuICAgIH1cclxuICAgIHZhciBjeWNsZUR1cmF0aW9uO1xyXG4gICAgdmFyIGxhc3RLZXlGcmFtZTtcclxuICAgIGlmICghZHVyYXRpb25GbGFnKSB7XHJcbiAgICAgIGlmICghZHVyYXRpb24gfHwgZHVyYXRpb24gPiBrZXlmcmFtZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgIGR1cmF0aW9uID0ga2V5ZnJhbWVzLmxlbmd0aCAtIDE7XHJcbiAgICAgIH1cclxuICAgICAgbGFzdEtleUZyYW1lID0ga2V5ZnJhbWVzW2R1cmF0aW9uXS50O1xyXG4gICAgICBjeWNsZUR1cmF0aW9uID0gbGFzdEtleUZyYW1lIC0gZmlyc3RLZXlGcmFtZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICghZHVyYXRpb24pIHtcclxuICAgICAgICBjeWNsZUR1cmF0aW9uID0gTWF0aC5tYXgoMCwgdGhpcy5lbGVtLmRhdGEub3AgLSBmaXJzdEtleUZyYW1lKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjeWNsZUR1cmF0aW9uID0gTWF0aC5hYnModGhpcy5lbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgKiBkdXJhdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgbGFzdEtleUZyYW1lID0gZmlyc3RLZXlGcmFtZSArIGN5Y2xlRHVyYXRpb247XHJcbiAgICB9XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW47XHJcbiAgICB2YXIgcmV0O1xyXG4gICAgaWYgKHR5cGUgPT09ICdwaW5ncG9uZycpIHtcclxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBNYXRoLmZsb29yKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAvIGN5Y2xlRHVyYXRpb24pO1xyXG4gICAgICBpZiAoaXRlcmF0aW9ucyAlIDIgPT09IDApIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXRUaW1lKCgoKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArIGZpcnN0S2V5RnJhbWUpKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2Zmc2V0Jykge1xyXG4gICAgICB2YXIgaW5pdFYgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZpcnN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICB2YXIgZW5kViA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUobGFzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcclxuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChjeWNsZUR1cmF0aW9uIC0gKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAlIGN5Y2xlRHVyYXRpb24pICsgZmlyc3RLZXlGcmFtZSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICB2YXIgcmVwZWF0cyA9IE1hdGguZmxvb3IoKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpIC8gY3ljbGVEdXJhdGlvbikgKyAxO1xyXG4gICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkoaW5pdFYubGVuZ3RoKTtcclxuICAgICAgICBsZW4gPSByZXQubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgcmV0W2ldID0gY3VycmVudFtpXSAtIChlbmRWW2ldIC0gaW5pdFZbaV0pICogcmVwZWF0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY3VycmVudCAtIChlbmRWIC0gaW5pdFYpICogcmVwZWF0cztcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbnRpbnVlJykge1xyXG4gICAgICB2YXIgZmlyc3RWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZmlyc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgIHZhciBuZXh0Rmlyc3RWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoKGZpcnN0S2V5RnJhbWUgKyAwLjAwMSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkoZmlyc3RWYWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgIGxlbiA9IHJldC5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICByZXRbaV0gPSBmaXJzdFZhbHVlW2ldICsgKChmaXJzdFZhbHVlW2ldIC0gbmV4dEZpcnN0VmFsdWVbaV0pICogKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpKSAvIDAuMDAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmaXJzdFZhbHVlICsgKChmaXJzdFZhbHVlIC0gbmV4dEZpcnN0VmFsdWUpICogKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpKSAvIDAuMDAxO1xyXG4gICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0VGltZSgoKGN5Y2xlRHVyYXRpb24gLSAoKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArIGZpcnN0S2V5RnJhbWUpKSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcblxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc21vb3RoKHdpZHRoLCBzYW1wbGVzKSB7XHJcbiAgICBpZiAoIXRoaXMuaykge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdjtcclxuICAgIH1cclxuICAgIHdpZHRoID0gKHdpZHRoIHx8IDAuNCkgKiAwLjU7XHJcbiAgICBzYW1wbGVzID0gTWF0aC5mbG9vcihzYW1wbGVzIHx8IDUpO1xyXG4gICAgaWYgKHNhbXBsZXMgPD0gMSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdjtcclxuICAgIH1cclxuICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgdmFyIGluaXRGcmFtZSA9IGN1cnJlbnRUaW1lIC0gd2lkdGg7XHJcbiAgICB2YXIgZW5kRnJhbWUgPSBjdXJyZW50VGltZSArIHdpZHRoO1xyXG4gICAgdmFyIHNhbXBsZUZyZXF1ZW5jeSA9IHNhbXBsZXMgPiAxID8gKGVuZEZyYW1lIC0gaW5pdEZyYW1lKSAvIChzYW1wbGVzIC0gMSkgOiAxO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIGogPSAwO1xyXG4gICAgdmFyIHZhbHVlO1xyXG4gICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XHJcbiAgICAgIHZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIHRoaXMucHYubGVuZ3RoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbHVlID0gMDtcclxuICAgIH1cclxuICAgIHZhciBzYW1wbGVWYWx1ZTtcclxuICAgIHdoaWxlIChpIDwgc2FtcGxlcykge1xyXG4gICAgICBzYW1wbGVWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoaW5pdEZyYW1lICsgaSAqIHNhbXBsZUZyZXF1ZW5jeSk7XHJcbiAgICAgIGlmICh0aGlzLnB2Lmxlbmd0aCkge1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLnB2Lmxlbmd0aDsgaiArPSAxKSB7XHJcbiAgICAgICAgICB2YWx1ZVtqXSArPSBzYW1wbGVWYWx1ZVtqXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgKz0gc2FtcGxlVmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XHJcbiAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLnB2Lmxlbmd0aDsgaiArPSAxKSB7XHJcbiAgICAgICAgdmFsdWVbal0gLz0gc2FtcGxlcztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFsdWUgLz0gc2FtcGxlcztcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVZhbHVlQXRUaW1lKHRpbWUpIHtcclxuICAgIGlmICghdGhpcy5fdHJhbnNmb3JtQ2FjaGluZ0F0VGltZSkge1xyXG4gICAgICB0aGlzLl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lID0ge1xyXG4gICAgICAgIHY6IG5ldyBNYXRyaXgoKSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vLyAvXHJcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5fdHJhbnNmb3JtQ2FjaGluZ0F0VGltZS52O1xyXG4gICAgbWF0cml4LmNsb25lRnJvbVByb3BzKHRoaXMucHJlLnByb3BzKTtcclxuICAgIGlmICh0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAxKSB7XHJcbiAgICAgIHZhciBhbmNob3IgPSB0aGlzLmEuZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgIG1hdHJpeC50cmFuc2xhdGUoXHJcbiAgICAgICAgLWFuY2hvclswXSAqIHRoaXMuYS5tdWx0LFxyXG4gICAgICAgIC1hbmNob3JbMV0gKiB0aGlzLmEubXVsdCxcclxuICAgICAgICBhbmNob3JbMl0gKiB0aGlzLmEubXVsdFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDIpIHtcclxuICAgICAgdmFyIHNjYWxlID0gdGhpcy5zLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xyXG4gICAgICBtYXRyaXguc2NhbGUoXHJcbiAgICAgICAgc2NhbGVbMF0gKiB0aGlzLnMubXVsdCxcclxuICAgICAgICBzY2FsZVsxXSAqIHRoaXMucy5tdWx0LFxyXG4gICAgICAgIHNjYWxlWzJdICogdGhpcy5zLm11bHRcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnNrICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDMpIHtcclxuICAgICAgdmFyIHNrZXcgPSB0aGlzLnNrLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xyXG4gICAgICB2YXIgc2tld0F4aXMgPSB0aGlzLnNhLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xyXG4gICAgICBtYXRyaXguc2tld0Zyb21BeGlzKC1za2V3ICogdGhpcy5zay5tdWx0LCBza2V3QXhpcyAqIHRoaXMuc2EubXVsdCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcclxuICAgICAgdmFyIHJvdGF0aW9uID0gdGhpcy5yLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xyXG4gICAgICBtYXRyaXgucm90YXRlKC1yb3RhdGlvbiAqIHRoaXMuci5tdWx0KTtcclxuICAgIH0gZWxzZSBpZiAoIXRoaXMuciAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCA0KSB7XHJcbiAgICAgIHZhciByb3RhdGlvblogPSB0aGlzLnJ6LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xyXG4gICAgICB2YXIgcm90YXRpb25ZID0gdGhpcy5yeS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcclxuICAgICAgdmFyIHJvdGF0aW9uWCA9IHRoaXMucnguZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3IuZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgIG1hdHJpeC5yb3RhdGVaKC1yb3RhdGlvblogKiB0aGlzLnJ6Lm11bHQpXHJcbiAgICAgICAgLnJvdGF0ZVkocm90YXRpb25ZICogdGhpcy5yeS5tdWx0KVxyXG4gICAgICAgIC5yb3RhdGVYKHJvdGF0aW9uWCAqIHRoaXMucngubXVsdClcclxuICAgICAgICAucm90YXRlWigtb3JpZW50YXRpb25bMl0gKiB0aGlzLm9yLm11bHQpXHJcbiAgICAgICAgLnJvdGF0ZVkob3JpZW50YXRpb25bMV0gKiB0aGlzLm9yLm11bHQpXHJcbiAgICAgICAgLnJvdGF0ZVgob3JpZW50YXRpb25bMF0gKiB0aGlzLm9yLm11bHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZGF0YS5wICYmIHRoaXMuZGF0YS5wLnMpIHtcclxuICAgICAgdmFyIHBvc2l0aW9uWCA9IHRoaXMucHguZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgIHZhciBwb3NpdGlvblkgPSB0aGlzLnB5LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xyXG4gICAgICBpZiAodGhpcy5kYXRhLnAueikge1xyXG4gICAgICAgIHZhciBwb3NpdGlvblogPSB0aGlzLnB6LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xyXG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUoXHJcbiAgICAgICAgICBwb3NpdGlvblggKiB0aGlzLnB4Lm11bHQsXHJcbiAgICAgICAgICBwb3NpdGlvblkgKiB0aGlzLnB5Lm11bHQsXHJcbiAgICAgICAgICAtcG9zaXRpb25aICogdGhpcy5wei5tdWx0XHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWCAqIHRoaXMucHgubXVsdCwgcG9zaXRpb25ZICogdGhpcy5weS5tdWx0LCAwKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xyXG4gICAgICBtYXRyaXgudHJhbnNsYXRlKFxyXG4gICAgICAgIHBvc2l0aW9uWzBdICogdGhpcy5wLm11bHQsXHJcbiAgICAgICAgcG9zaXRpb25bMV0gKiB0aGlzLnAubXVsdCxcclxuICAgICAgICAtcG9zaXRpb25bMl0gKiB0aGlzLnAubXVsdFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIC8vLyAvXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1TdGF0aWNWYWx1ZUF0VGltZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnYuY2xvbmUobmV3IE1hdHJpeCgpKTtcclxuICB9XHJcblxyXG4gIHZhciBnZXRUcmFuc2Zvcm1Qcm9wZXJ0eSA9IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eTtcclxuICBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XHJcbiAgICB2YXIgcHJvcCA9IGdldFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcik7XHJcbiAgICBpZiAocHJvcC5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgcHJvcC5nZXRWYWx1ZUF0VGltZSA9IGdldFRyYW5zZm9ybVZhbHVlQXRUaW1lLmJpbmQocHJvcCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcm9wLmdldFZhbHVlQXRUaW1lID0gZ2V0VHJhbnNmb3JtU3RhdGljVmFsdWVBdFRpbWUuYmluZChwcm9wKTtcclxuICAgIH1cclxuICAgIHByb3Auc2V0R3JvdXBQcm9wZXJ0eSA9IGV4cHJlc3Npb25IZWxwZXJzLnNldEdyb3VwUHJvcGVydHk7XHJcbiAgICByZXR1cm4gcHJvcDtcclxuICB9O1xyXG5cclxuICB2YXIgcHJvcGVydHlHZXRQcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3A7XHJcbiAgUHJvcGVydHlGYWN0b3J5LmdldFByb3AgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSwgdHlwZSwgbXVsdCwgY29udGFpbmVyKSB7XHJcbiAgICB2YXIgcHJvcCA9IHByb3BlcnR5R2V0UHJvcChlbGVtLCBkYXRhLCB0eXBlLCBtdWx0LCBjb250YWluZXIpO1xyXG4gICAgLy8gcHJvcC5nZXRWZWxvY2l0eUF0VGltZSA9IGdldFZlbG9jaXR5QXRUaW1lO1xyXG4gICAgLy8gcHJvcC5sb29wT3V0ID0gbG9vcE91dDtcclxuICAgIC8vIHByb3AubG9vcEluID0gbG9vcEluO1xyXG4gICAgaWYgKHByb3Aua2YpIHtcclxuICAgICAgcHJvcC5nZXRWYWx1ZUF0VGltZSA9IGV4cHJlc3Npb25IZWxwZXJzLmdldFZhbHVlQXRUaW1lLmJpbmQocHJvcCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcm9wLmdldFZhbHVlQXRUaW1lID0gZXhwcmVzc2lvbkhlbHBlcnMuZ2V0U3RhdGljVmFsdWVBdFRpbWUuYmluZChwcm9wKTtcclxuICAgIH1cclxuICAgIHByb3Auc2V0R3JvdXBQcm9wZXJ0eSA9IGV4cHJlc3Npb25IZWxwZXJzLnNldEdyb3VwUHJvcGVydHk7XHJcbiAgICBwcm9wLmxvb3BPdXQgPSBsb29wT3V0O1xyXG4gICAgcHJvcC5sb29wSW4gPSBsb29wSW47XHJcbiAgICBwcm9wLnNtb290aCA9IHNtb290aDtcclxuICAgIHByb3AuZ2V0VmVsb2NpdHlBdFRpbWUgPSBleHByZXNzaW9uSGVscGVycy5nZXRWZWxvY2l0eUF0VGltZS5iaW5kKHByb3ApO1xyXG4gICAgcHJvcC5nZXRTcGVlZEF0VGltZSA9IGV4cHJlc3Npb25IZWxwZXJzLmdldFNwZWVkQXRUaW1lLmJpbmQocHJvcCk7XHJcbiAgICBwcm9wLm51bUtleXMgPSBkYXRhLmEgPT09IDEgPyBkYXRhLmsubGVuZ3RoIDogMDtcclxuICAgIHByb3AucHJvcGVydHlJbmRleCA9IGRhdGEuaXg7XHJcbiAgICB2YXIgdmFsdWUgPSAwO1xyXG4gICAgaWYgKHR5cGUgIT09IDApIHtcclxuICAgICAgdmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgZGF0YS5hID09PSAxID8gZGF0YS5rWzBdLnMubGVuZ3RoIDogZGF0YS5rLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBwcm9wLl9jYWNoaW5nQXRUaW1lID0ge1xyXG4gICAgICBsYXN0RnJhbWU6IGluaXRpYWxEZWZhdWx0RnJhbWUsXHJcbiAgICAgIGxhc3RJbmRleDogMCxcclxuICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgfTtcclxuICAgIGV4cHJlc3Npb25IZWxwZXJzLnNlYXJjaEV4cHJlc3Npb25zKGVsZW0sIGRhdGEsIHByb3ApO1xyXG4gICAgaWYgKHByb3Auaykge1xyXG4gICAgICBjb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwcm9wO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGdldFNoYXBlVmFsdWVBdFRpbWUoZnJhbWVOdW0pIHtcclxuICAgIC8vIEZvciBub3cgdGhpcyBjYWNoaW5nIG9iamVjdCBpcyBjcmVhdGVkIG9ubHkgd2hlbiBuZWVkZWQgaW5zdGVhZCBvZiBjcmVhdGluZyBpdCB3aGVuIHRoZSBzaGFwZSBpcyBpbml0aWFsaXplZC5cclxuICAgIGlmICghdGhpcy5fY2FjaGluZ0F0VGltZSkge1xyXG4gICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lID0ge1xyXG4gICAgICAgIHNoYXBlVmFsdWU6IHNoYXBlUG9vbC5jbG9uZSh0aGlzLnB2KSxcclxuICAgICAgICBsYXN0SW5kZXg6IDAsXHJcbiAgICAgICAgbGFzdFRpbWU6IGluaXRpYWxEZWZhdWx0RnJhbWUsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnJhbWVOdW0gKj0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgZnJhbWVOdW0gLT0gdGhpcy5vZmZzZXRUaW1lO1xyXG4gICAgaWYgKGZyYW1lTnVtICE9PSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RUaW1lKSB7XHJcbiAgICAgIHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdEluZGV4ID0gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0VGltZSA8IGZyYW1lTnVtID8gdGhpcy5fY2FjaGluZy5sYXN0SW5kZXggOiAwO1xyXG4gICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RUaW1lID0gZnJhbWVOdW07XHJcbiAgICAgIHRoaXMuaW50ZXJwb2xhdGVTaGFwZShmcmFtZU51bSwgdGhpcy5fY2FjaGluZ0F0VGltZS5zaGFwZVZhbHVlLCB0aGlzLl9jYWNoaW5nQXRUaW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9jYWNoaW5nQXRUaW1lLnNoYXBlVmFsdWU7XHJcbiAgfVxyXG5cclxuICB2YXIgU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24gPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRDb25zdHJ1Y3RvckZ1bmN0aW9uKCk7XHJcbiAgdmFyIEtleWZyYW1lZFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0S2V5ZnJhbWVkQ29uc3RydWN0b3JGdW5jdGlvbigpO1xyXG5cclxuICBmdW5jdGlvbiBTaGFwZUV4cHJlc3Npb25zKCkge31cclxuICBTaGFwZUV4cHJlc3Npb25zLnByb3RvdHlwZSA9IHtcclxuICAgIHZlcnRpY2VzOiBmdW5jdGlvbiAocHJvcCwgdGltZSkge1xyXG4gICAgICBpZiAodGhpcy5rKSB7XHJcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBzaGFwZVBhdGggPSB0aGlzLnY7XHJcbiAgICAgIGlmICh0aW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBzaGFwZVBhdGggPSB0aGlzLmdldFZhbHVlQXRUaW1lKHRpbWUsIDApO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuID0gc2hhcGVQYXRoLl9sZW5ndGg7XHJcbiAgICAgIHZhciB2ZXJ0aWNlcyA9IHNoYXBlUGF0aFtwcm9wXTtcclxuICAgICAgdmFyIHBvaW50cyA9IHNoYXBlUGF0aC52O1xyXG4gICAgICB2YXIgYXJyID0gY3JlYXRlU2l6ZWRBcnJheShsZW4pO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBpZiAocHJvcCA9PT0gJ2knIHx8IHByb3AgPT09ICdvJykge1xyXG4gICAgICAgICAgYXJyW2ldID0gW3ZlcnRpY2VzW2ldWzBdIC0gcG9pbnRzW2ldWzBdLCB2ZXJ0aWNlc1tpXVsxXSAtIHBvaW50c1tpXVsxXV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFycltpXSA9IFt2ZXJ0aWNlc1tpXVswXSwgdmVydGljZXNbaV1bMV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXJyO1xyXG4gICAgfSxcclxuICAgIHBvaW50czogZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmVydGljZXMoJ3YnLCB0aW1lKTtcclxuICAgIH0sXHJcbiAgICBpblRhbmdlbnRzOiBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlcygnaScsIHRpbWUpO1xyXG4gICAgfSxcclxuICAgIG91dFRhbmdlbnRzOiBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlcygnbycsIHRpbWUpO1xyXG4gICAgfSxcclxuICAgIGlzQ2xvc2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnYuYztcclxuICAgIH0sXHJcbiAgICBwb2ludE9uUGF0aDogZnVuY3Rpb24gKHBlcmMsIHRpbWUpIHtcclxuICAgICAgdmFyIHNoYXBlUGF0aCA9IHRoaXMudjtcclxuICAgICAgaWYgKHRpbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHNoYXBlUGF0aCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUodGltZSwgMCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLl9zZWdtZW50c0xlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuX3NlZ21lbnRzTGVuZ3RoID0gYmV6LmdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlUGF0aCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzZWdtZW50c0xlbmd0aCA9IHRoaXMuX3NlZ21lbnRzTGVuZ3RoO1xyXG4gICAgICB2YXIgbGVuZ3RocyA9IHNlZ21lbnRzTGVuZ3RoLmxlbmd0aHM7XHJcbiAgICAgIHZhciBsZW5ndGhQb3MgPSBzZWdtZW50c0xlbmd0aC50b3RhbExlbmd0aCAqIHBlcmM7XHJcbiAgICAgIHZhciBpID0gMDtcclxuICAgICAgdmFyIGxlbiA9IGxlbmd0aHMubGVuZ3RoO1xyXG4gICAgICB2YXIgYWNjdW11bGF0ZWRMZW5ndGggPSAwO1xyXG4gICAgICB2YXIgcHQ7XHJcbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgICAgaWYgKGFjY3VtdWxhdGVkTGVuZ3RoICsgbGVuZ3Roc1tpXS5hZGRlZExlbmd0aCA+IGxlbmd0aFBvcykge1xyXG4gICAgICAgICAgdmFyIGluaXRJbmRleCA9IGk7XHJcbiAgICAgICAgICB2YXIgZW5kSW5kZXggPSAoc2hhcGVQYXRoLmMgJiYgaSA9PT0gbGVuIC0gMSkgPyAwIDogaSArIDE7XHJcbiAgICAgICAgICB2YXIgc2VnbWVudFBlcmMgPSAobGVuZ3RoUG9zIC0gYWNjdW11bGF0ZWRMZW5ndGgpIC8gbGVuZ3Roc1tpXS5hZGRlZExlbmd0aDtcclxuICAgICAgICAgIHB0ID0gYmV6LmdldFBvaW50SW5TZWdtZW50KHNoYXBlUGF0aC52W2luaXRJbmRleF0sIHNoYXBlUGF0aC52W2VuZEluZGV4XSwgc2hhcGVQYXRoLm9baW5pdEluZGV4XSwgc2hhcGVQYXRoLmlbZW5kSW5kZXhdLCBzZWdtZW50UGVyYywgbGVuZ3Roc1tpXSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWNjdW11bGF0ZWRMZW5ndGggKz0gbGVuZ3Roc1tpXS5hZGRlZExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghcHQpIHtcclxuICAgICAgICBwdCA9IHNoYXBlUGF0aC5jID8gW3NoYXBlUGF0aC52WzBdWzBdLCBzaGFwZVBhdGgudlswXVsxXV0gOiBbc2hhcGVQYXRoLnZbc2hhcGVQYXRoLl9sZW5ndGggLSAxXVswXSwgc2hhcGVQYXRoLnZbc2hhcGVQYXRoLl9sZW5ndGggLSAxXVsxXV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHB0O1xyXG4gICAgfSxcclxuICAgIHZlY3Rvck9uUGF0aDogZnVuY3Rpb24gKHBlcmMsIHRpbWUsIHZlY3RvclR5cGUpIHtcclxuICAgICAgLy8gcGVyYyBkb2Vzbid0IHVzZSB0cmlwbGUgZXF1YWxpdHkgYmVjYXVzZSBpdCBjYW4gYmUgYSBOdW1iZXIgb2JqZWN0IGFzIHdlbGwgYXMgYSBwcmltaXRpdmUuXHJcbiAgICAgIGlmIChwZXJjID09IDEpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgICAgICBwZXJjID0gdGhpcy52LmM7XHJcbiAgICAgIH0gZWxzZSBpZiAocGVyYyA9PSAwKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcbiAgICAgICAgcGVyYyA9IDAuOTk5O1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBwdDEgPSB0aGlzLnBvaW50T25QYXRoKHBlcmMsIHRpbWUpO1xyXG4gICAgICB2YXIgcHQyID0gdGhpcy5wb2ludE9uUGF0aChwZXJjICsgMC4wMDEsIHRpbWUpO1xyXG4gICAgICB2YXIgeExlbmd0aCA9IHB0MlswXSAtIHB0MVswXTtcclxuICAgICAgdmFyIHlMZW5ndGggPSBwdDJbMV0gLSBwdDFbMV07XHJcbiAgICAgIHZhciBtYWduaXR1ZGUgPSBNYXRoLnNxcnQoTWF0aC5wb3coeExlbmd0aCwgMikgKyBNYXRoLnBvdyh5TGVuZ3RoLCAyKSk7XHJcbiAgICAgIGlmIChtYWduaXR1ZGUgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gWzAsIDBdO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB1bml0VmVjdG9yID0gdmVjdG9yVHlwZSA9PT0gJ3RhbmdlbnQnID8gW3hMZW5ndGggLyBtYWduaXR1ZGUsIHlMZW5ndGggLyBtYWduaXR1ZGVdIDogWy15TGVuZ3RoIC8gbWFnbml0dWRlLCB4TGVuZ3RoIC8gbWFnbml0dWRlXTtcclxuICAgICAgcmV0dXJuIHVuaXRWZWN0b3I7XHJcbiAgICB9LFxyXG4gICAgdGFuZ2VudE9uUGF0aDogZnVuY3Rpb24gKHBlcmMsIHRpbWUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmVjdG9yT25QYXRoKHBlcmMsIHRpbWUsICd0YW5nZW50Jyk7XHJcbiAgICB9LFxyXG4gICAgbm9ybWFsT25QYXRoOiBmdW5jdGlvbiAocGVyYywgdGltZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JPblBhdGgocGVyYywgdGltZSwgJ25vcm1hbCcpO1xyXG4gICAgfSxcclxuICAgIHNldEdyb3VwUHJvcGVydHk6IGV4cHJlc3Npb25IZWxwZXJzLnNldEdyb3VwUHJvcGVydHksXHJcbiAgICBnZXRWYWx1ZUF0VGltZTogZXhwcmVzc2lvbkhlbHBlcnMuZ2V0U3RhdGljVmFsdWVBdFRpbWUsXHJcbiAgfTtcclxuICBleHRlbmRQcm90b3R5cGUoW1NoYXBlRXhwcmVzc2lvbnNdLCBTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbik7XHJcbiAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZUV4cHJlc3Npb25zXSwgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24pO1xyXG4gIEtleWZyYW1lZFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uLnByb3RvdHlwZS5nZXRWYWx1ZUF0VGltZSA9IGdldFNoYXBlVmFsdWVBdFRpbWU7XHJcbiAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24ucHJvdG90eXBlLmluaXRpYXRlRXhwcmVzc2lvbiA9IEV4cHJlc3Npb25NYW5hZ2VyLmluaXRpYXRlRXhwcmVzc2lvbjtcclxuXHJcbiAgdmFyIHByb3BlcnR5R2V0U2hhcGVQcm9wID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wO1xyXG4gIFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhLCB0eXBlLCBhcnIsIHRyaW1zKSB7XHJcbiAgICB2YXIgcHJvcCA9IHByb3BlcnR5R2V0U2hhcGVQcm9wKGVsZW0sIGRhdGEsIHR5cGUsIGFyciwgdHJpbXMpO1xyXG4gICAgcHJvcC5wcm9wZXJ0eUluZGV4ID0gZGF0YS5peDtcclxuICAgIHByb3AubG9jayA9IGZhbHNlO1xyXG4gICAgaWYgKHR5cGUgPT09IDMpIHtcclxuICAgICAgZXhwcmVzc2lvbkhlbHBlcnMuc2VhcmNoRXhwcmVzc2lvbnMoZWxlbSwgZGF0YS5wdCwgcHJvcCk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDQpIHtcclxuICAgICAgZXhwcmVzc2lvbkhlbHBlcnMuc2VhcmNoRXhwcmVzc2lvbnMoZWxlbSwgZGF0YS5rcywgcHJvcCk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvcC5rKSB7XHJcbiAgICAgIGVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3A7XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBFeHByZXNzaW9uTWFuYWdlciwgVGV4dFByb3BlcnR5ICovXHJcblxyXG4oZnVuY3Rpb24gYWRkRGVjb3JhdG9yKCkge1xyXG4gIGZ1bmN0aW9uIHNlYXJjaEV4cHJlc3Npb25zKCkge1xyXG4gICAgaWYgKHRoaXMuZGF0YS5kLngpIHtcclxuICAgICAgdGhpcy5jYWxjdWxhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uLmJpbmQodGhpcykodGhpcy5lbGVtLCB0aGlzLmRhdGEuZCwgdGhpcyk7XHJcbiAgICAgIHRoaXMuYWRkRWZmZWN0KHRoaXMuZ2V0RXhwcmVzc2lvblZhbHVlLmJpbmQodGhpcykpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5nZXRFeHByZXNzaW9uVmFsdWUgPSBmdW5jdGlvbiAoY3VycmVudFZhbHVlLCB0ZXh0KSB7XHJcbiAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmNhbGN1bGF0ZUV4cHJlc3Npb24odGV4dCk7XHJcbiAgICBpZiAoY3VycmVudFZhbHVlLnQgIT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgIHZhciBuZXdEYXRhID0ge307XHJcbiAgICAgIHRoaXMuY29weURhdGEobmV3RGF0YSwgY3VycmVudFZhbHVlKTtcclxuICAgICAgbmV3RGF0YS50ID0gbmV3VmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgbmV3RGF0YS5fX2NvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgIHJldHVybiBuZXdEYXRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcclxuICB9O1xyXG5cclxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnNlYXJjaFByb3BlcnR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGlzS2V5ZnJhbWVkID0gdGhpcy5zZWFyY2hLZXlmcmFtZXMoKTtcclxuICAgIHZhciBoYXNFeHByZXNzaW9ucyA9IHRoaXMuc2VhcmNoRXhwcmVzc2lvbnMoKTtcclxuICAgIHRoaXMua2YgPSBpc0tleWZyYW1lZCB8fCBoYXNFeHByZXNzaW9ucztcclxuICAgIHJldHVybiB0aGlzLmtmO1xyXG4gIH07XHJcblxyXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoRXhwcmVzc2lvbnMgPSBzZWFyY2hFeHByZXNzaW9ucztcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBwcm9wZXJ0eUdyb3VwRmFjdG9yeSwgUHJvcGVydHlJbnRlcmZhY2UgKi9cclxuLyogZXhwb3J0ZWQgU2hhcGVQYXRoSW50ZXJmYWNlICovXHJcblxyXG52YXIgU2hhcGVQYXRoSW50ZXJmYWNlID0gKFxyXG5cclxuICBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcGF0aEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcclxuICAgICAgdmFyIHByb3AgPSB2aWV3LnNoO1xyXG5cclxuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgaWYgKHZhbCA9PT0gJ1NoYXBlJyB8fCB2YWwgPT09ICdzaGFwZScgfHwgdmFsID09PSAnUGF0aCcgfHwgdmFsID09PSAncGF0aCcgfHwgdmFsID09PSAnQURCRSBWZWN0b3IgU2hhcGUnIHx8IHZhbCA9PT0gMikge1xyXG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XHJcbiAgICAgIHByb3Auc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUGF0aCcsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XHJcbiAgICAgICAgcGF0aDoge1xyXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wLmspIHtcclxuICAgICAgICAgICAgICBwcm9wLmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb3A7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAocHJvcC5rKSB7XHJcbiAgICAgICAgICAgICAgcHJvcC5nZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9uYW1lOiB7IHZhbHVlOiBzaGFwZS5ubSB9LFxyXG4gICAgICAgIGl4OiB7IHZhbHVlOiBzaGFwZS5peCB9LFxyXG4gICAgICAgIHByb3BlcnR5SW5kZXg6IHsgdmFsdWU6IHNoYXBlLml4IH0sXHJcbiAgICAgICAgbW46IHsgdmFsdWU6IHNoYXBlLm1uIH0sXHJcbiAgICAgICAgcHJvcGVydHlHcm91cDogeyB2YWx1ZTogcHJvcGVydHlHcm91cCB9LFxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgfTtcclxuICB9KClcclxuKTtcclxuXHJcbi8qIGV4cG9ydGVkIHByb3BlcnR5R3JvdXBGYWN0b3J5ICovXHJcblxyXG52YXIgcHJvcGVydHlHcm91cEZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoaW50ZXJmYWNlRnVuY3Rpb24sIHBhcmVudFByb3BlcnR5R3JvdXApIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgIHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbDtcclxuICAgICAgaWYgKHZhbCA8PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwYXJlbnRQcm9wZXJ0eUdyb3VwKHZhbCAtIDEpO1xyXG4gICAgfTtcclxuICB9O1xyXG59KCkpO1xyXG5cclxuLyogZXhwb3J0ZWQgUHJvcGVydHlJbnRlcmZhY2UgKi9cclxuXHJcbnZhciBQcm9wZXJ0eUludGVyZmFjZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIHByb3BlcnR5R3JvdXApIHtcclxuICAgIHZhciBpbnRlcmZhY2VGdW5jdGlvbiA9IHtcclxuICAgICAgX25hbWU6IHByb3BlcnR5TmFtZSxcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX3Byb3BlcnR5R3JvdXAodmFsKSB7XHJcbiAgICAgIHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbDtcclxuICAgICAgaWYgKHZhbCA8PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3VwKHZhbCAtIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBfcHJvcGVydHlHcm91cDtcclxuICB9O1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSwgUHJvcGVydHlJbnRlcmZhY2UsIHByb3BlcnR5R3JvdXBGYWN0b3J5LCBTaGFwZVBhdGhJbnRlcmZhY2UgKi9cclxuLyogZXhwb3J0ZWQgU2hhcGVFeHByZXNzaW9uSW50ZXJmYWNlICovXHJcblxyXG52YXIgU2hhcGVFeHByZXNzaW9uSW50ZXJmYWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBpdGVyYXRlRWxlbWVudHMoc2hhcGVzLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICB2YXIgYXJyID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBzaGFwZXMgPyBzaGFwZXMubGVuZ3RoIDogMDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZ3InKSB7XHJcbiAgICAgICAgYXJyLnB1c2goZ3JvdXBJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2ZsJykge1xyXG4gICAgICAgIGFyci5wdXNoKGZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3N0Jykge1xyXG4gICAgICAgIGFyci5wdXNoKHN0cm9rZUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAndG0nKSB7XHJcbiAgICAgICAgYXJyLnB1c2godHJpbUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAndHInKSB7XHJcbiAgICAgICAgLy8gYXJyLnB1c2godHJhbnNmb3JtSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sdmlld1tpXSxwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZWwnKSB7XHJcbiAgICAgICAgYXJyLnB1c2goZWxsaXBzZUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnc3InKSB7XHJcbiAgICAgICAgYXJyLnB1c2goc3RhckludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnc2gnKSB7XHJcbiAgICAgICAgYXJyLnB1c2goU2hhcGVQYXRoSW50ZXJmYWNlKHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3JjJykge1xyXG4gICAgICAgIGFyci5wdXNoKHJlY3RJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3JkJykge1xyXG4gICAgICAgIGFyci5wdXNoKHJvdW5kZWRJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3JwJykge1xyXG4gICAgICAgIGFyci5wdXNoKHJlcGVhdGVySW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcclxuICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdnZicpIHtcclxuICAgICAgICBhcnIucHVzaChncmFkaWVudEZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFyci5wdXNoKGRlZmF1bHRJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29udGVudHNJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICB2YXIgaW50ZXJmYWNlcztcclxuICAgIHZhciBpbnRlcmZhY2VGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBsZW4gPSBpbnRlcmZhY2VzLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICBpZiAoaW50ZXJmYWNlc1tpXS5fbmFtZSA9PT0gdmFsdWUgfHwgaW50ZXJmYWNlc1tpXS5tbiA9PT0gdmFsdWUgfHwgaW50ZXJmYWNlc1tpXS5wcm9wZXJ0eUluZGV4ID09PSB2YWx1ZSB8fCBpbnRlcmZhY2VzW2ldLml4ID09PSB2YWx1ZSB8fCBpbnRlcmZhY2VzW2ldLmluZCA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1t2YWx1ZSAtIDFdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xyXG4gICAgaW50ZXJmYWNlcyA9IGl0ZXJhdGVFbGVtZW50cyhzaGFwZS5pdCwgdmlldy5pdCwgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5udW1Qcm9wZXJ0aWVzID0gaW50ZXJmYWNlcy5sZW5ndGg7XHJcbiAgICB2YXIgdHJhbnNmb3JtSW50ZXJmYWNlID0gdHJhbnNmb3JtSW50ZXJmYWNlRmFjdG9yeShzaGFwZS5pdFtzaGFwZS5pdC5sZW5ndGggLSAxXSwgdmlldy5pdFt2aWV3Lml0Lmxlbmd0aCAtIDFdLCBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwKTtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLnRyYW5zZm9ybSA9IHRyYW5zZm9ybUludGVyZmFjZTtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5jaXg7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5fbmFtZSA9IHNoYXBlLm5tO1xyXG5cclxuICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdyb3VwSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xyXG4gICAgdmFyIGludGVyZmFjZUZ1bmN0aW9uID0gZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIHN3aXRjaCAodmFsdWUpIHtcclxuICAgICAgICBjYXNlICdBREJFIFZlY3RvcnMgR3JvdXAnOlxyXG4gICAgICAgIGNhc2UgJ0NvbnRlbnRzJzpcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uY29udGVudDtcclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnkgZm9yIG5vdy4gS2VlcGluZyB0aGVtIGhlcmUgaW4gY2FzZSBhIG5ldyBjYXNlIGFwcGVhcnNcclxuICAgICAgICAgIC8vIGNhc2UgJ0FEQkUgVmVjdG9yIFRyYW5zZm9ybSBHcm91cCc6XHJcbiAgICAgICAgICAvLyBjYXNlIDM6XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi50cmFuc2Zvcm07XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xyXG4gICAgdmFyIGNvbnRlbnQgPSBjb250ZW50c0ludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xyXG4gICAgdmFyIHRyYW5zZm9ybUludGVyZmFjZSA9IHRyYW5zZm9ybUludGVyZmFjZUZhY3Rvcnkoc2hhcGUuaXRbc2hhcGUuaXQubGVuZ3RoIC0gMV0sIHZpZXcuaXRbdmlldy5pdC5sZW5ndGggLSAxXSwgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50ID0gY29udGVudDtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLnRyYW5zZm9ybSA9IHRyYW5zZm9ybUludGVyZmFjZTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnRlcmZhY2VGdW5jdGlvbiwgJ19uYW1lJywge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gc2hhcGUubm07XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIC8vIGludGVyZmFjZUZ1bmN0aW9uLmNvbnRlbnQgPSBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLm51bVByb3BlcnRpZXMgPSBzaGFwZS5ucDtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLm5tID0gc2hhcGUubm07XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmlsbEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcclxuICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICBpZiAodmFsID09PSAnQ29sb3InIHx8IHZhbCA9PT0gJ2NvbG9yJykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb2xvcjtcclxuICAgICAgfSBpZiAodmFsID09PSAnT3BhY2l0eScgfHwgdmFsID09PSAnb3BhY2l0eScpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XHJcbiAgICAgIGNvbG9yOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5jKSxcclxuICAgICAgfSxcclxuICAgICAgb3BhY2l0eToge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubyksXHJcbiAgICAgIH0sXHJcbiAgICAgIF9uYW1lOiB7IHZhbHVlOiBzaGFwZS5ubSB9LFxyXG4gICAgICBtbjogeyB2YWx1ZTogc2hhcGUubW4gfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHZpZXcuYy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdDb2xvcicsIHByb3BlcnR5R3JvdXApKTtcclxuICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ3JhZGllbnRGaWxsSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xyXG4gICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XHJcbiAgICAgIGlmICh2YWwgPT09ICdTdGFydCBQb2ludCcgfHwgdmFsID09PSAnc3RhcnQgcG9pbnQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnN0YXJ0UG9pbnQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhbCA9PT0gJ0VuZCBQb2ludCcgfHwgdmFsID09PSAnZW5kIHBvaW50Jykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5lbmRQb2ludDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmFsID09PSAnT3BhY2l0eScgfHwgdmFsID09PSAnb3BhY2l0eScpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XHJcbiAgICAgIHN0YXJ0UG9pbnQ6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LnMpLFxyXG4gICAgICB9LFxyXG4gICAgICBlbmRQb2ludDoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuZSksXHJcbiAgICAgIH0sXHJcbiAgICAgIG9wYWNpdHk6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3Lm8pLFxyXG4gICAgICB9LFxyXG4gICAgICB0eXBlOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gJ2EnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIF9uYW1lOiB7IHZhbHVlOiBzaGFwZS5ubSB9LFxyXG4gICAgICBtbjogeyB2YWx1ZTogc2hhcGUubW4gfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHZpZXcucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTdGFydCBQb2ludCcsIHByb3BlcnR5R3JvdXApKTtcclxuICAgIHZpZXcuZS5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdFbmQgUG9pbnQnLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICB2aWV3Lm8uc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3BhY2l0eScsIHByb3BlcnR5R3JvdXApKTtcclxuICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICB9XHJcbiAgZnVuY3Rpb24gZGVmYXVsdEludGVyZmFjZUZhY3RvcnkoKSB7XHJcbiAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdHJva2VJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XHJcbiAgICB2YXIgX2Rhc2hQcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoZGFzaE9iLCBfcHJvcGVydHlHcm91cCk7XHJcbiAgICBmdW5jdGlvbiBhZGRQcm9wZXJ0eVRvRGFzaE9iKGkpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhc2hPYiwgc2hhcGUuZFtpXS5ubSwge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuZC5kYXRhUHJvcHNbaV0ucCksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gc2hhcGUuZCA/IHNoYXBlLmQubGVuZ3RoIDogMDtcclxuICAgIHZhciBkYXNoT2IgPSB7fTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBhZGRQcm9wZXJ0eVRvRGFzaE9iKGkpO1xyXG4gICAgICB2aWV3LmQuZGF0YVByb3BzW2ldLnAuc2V0R3JvdXBQcm9wZXJ0eShfZGFzaFByb3BlcnR5R3JvdXApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICBpZiAodmFsID09PSAnQ29sb3InIHx8IHZhbCA9PT0gJ2NvbG9yJykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb2xvcjtcclxuICAgICAgfSBpZiAodmFsID09PSAnT3BhY2l0eScgfHwgdmFsID09PSAnb3BhY2l0eScpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcclxuICAgICAgfSBpZiAodmFsID09PSAnU3Ryb2tlIFdpZHRoJyB8fCB2YWwgPT09ICdzdHJva2Ugd2lkdGgnKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnN0cm9rZVdpZHRoO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgY29sb3I6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LmMpLFxyXG4gICAgICB9LFxyXG4gICAgICBvcGFjaXR5OiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5vKSxcclxuICAgICAgfSxcclxuICAgICAgc3Ryb2tlV2lkdGg6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LncpLFxyXG4gICAgICB9LFxyXG4gICAgICBkYXNoOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGFzaE9iO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIF9uYW1lOiB7IHZhbHVlOiBzaGFwZS5ubSB9LFxyXG4gICAgICBtbjogeyB2YWx1ZTogc2hhcGUubW4gfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHZpZXcuYy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdDb2xvcicsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICB2aWV3Lm8uc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3BhY2l0eScsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICB2aWV3Lncuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU3Ryb2tlIFdpZHRoJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRyaW1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcclxuICAgICAgaWYgKHZhbCA9PT0gc2hhcGUuZS5peCB8fCB2YWwgPT09ICdFbmQnIHx8IHZhbCA9PT0gJ2VuZCcpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uZW5kO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2YWwgPT09IHNoYXBlLnMuaXgpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc3RhcnQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhbCA9PT0gc2hhcGUuby5peCkge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vZmZzZXQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xyXG5cclxuICAgIHZpZXcucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTdGFydCcsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICB2aWV3LmUuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnRW5kJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPZmZzZXQnLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXA7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgc3RhcnQ6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LnMpLFxyXG4gICAgICB9LFxyXG4gICAgICBlbmQ6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LmUpLFxyXG4gICAgICB9LFxyXG4gICAgICBvZmZzZXQ6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3Lm8pLFxyXG4gICAgICB9LFxyXG4gICAgICBfbmFtZTogeyB2YWx1ZTogc2hhcGUubm0gfSxcclxuICAgIH0pO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcclxuICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcclxuICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGlmIChzaGFwZS5hLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ0FuY2hvciBQb2ludCcpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uYW5jaG9yUG9pbnQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNoYXBlLm8uaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnT3BhY2l0eScpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2hhcGUucC5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdQb3NpdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9zaXRpb247XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNoYXBlLnIuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnUm90YXRpb24nIHx8IHZhbHVlID09PSAnQURCRSBWZWN0b3IgUm90YXRpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnJvdGF0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaGFwZS5zLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1NjYWxlJykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zY2FsZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKHNoYXBlLnNrICYmIHNoYXBlLnNrLml4ID09PSB2YWx1ZSkgfHwgdmFsdWUgPT09ICdTa2V3Jykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5za2V3O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgoc2hhcGUuc2EgJiYgc2hhcGUuc2EuaXggPT09IHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ1NrZXcgQXhpcycpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc2tld0F4aXM7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XHJcbiAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1Bvc2l0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5hLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0FuY2hvciBQb2ludCcsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTY2FsZScsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSb3RhdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICBpZiAodmlldy50cmFuc2Zvcm0ubVByb3BzLnNrKSB7XHJcbiAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zay5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTa2V3JywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLnNhLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1NrZXcgQW5nbGUnLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgfVxyXG4gICAgdmlldy50cmFuc2Zvcm0ub3Auc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3BhY2l0eScsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xyXG4gICAgICBvcGFjaXR5OiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLm8pLFxyXG4gICAgICB9LFxyXG4gICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5wKSxcclxuICAgICAgfSxcclxuICAgICAgYW5jaG9yUG9pbnQ6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LnRyYW5zZm9ybS5tUHJvcHMuYSksXHJcbiAgICAgIH0sXHJcbiAgICAgIHNjYWxlOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnMpLFxyXG4gICAgICB9LFxyXG4gICAgICByb3RhdGlvbjoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5yKSxcclxuICAgICAgfSxcclxuICAgICAgc2tldzoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zayksXHJcbiAgICAgIH0sXHJcbiAgICAgIHNrZXdBeGlzOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnNhKSxcclxuICAgICAgfSxcclxuICAgICAgX25hbWU6IHsgdmFsdWU6IHNoYXBlLm5tIH0sXHJcbiAgICB9KTtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLnR5ID0gJ3RyJztcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cDtcclxuICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVsbGlwc2VJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBpZiAoc2hhcGUucC5peCA9PT0gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9zaXRpb247XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNoYXBlLnMuaXggPT09IHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnNpemU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XHJcbiAgICB2YXIgcHJvcCA9IHZpZXcuc2gudHkgPT09ICd0bScgPyB2aWV3LnNoLnByb3AgOiB2aWV3LnNoO1xyXG4gICAgcHJvcC5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1NpemUnLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgcHJvcC5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1Bvc2l0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xyXG4gICAgICBzaXplOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5zKSxcclxuICAgICAgfSxcclxuICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnApLFxyXG4gICAgICB9LFxyXG4gICAgICBfbmFtZTogeyB2YWx1ZTogc2hhcGUubm0gfSxcclxuICAgIH0pO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcclxuICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0YXJJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBpZiAoc2hhcGUucC5peCA9PT0gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9zaXRpb247XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNoYXBlLnIuaXggPT09IHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnJvdGF0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaGFwZS5wdC5peCA9PT0gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9pbnRzO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaGFwZS5vci5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBTdGFyIE91dGVyIFJhZGl1cycpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3V0ZXJSYWRpdXM7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNoYXBlLm9zLml4ID09PSB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vdXRlclJvdW5kbmVzcztcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2hhcGUuaXIgJiYgKHNoYXBlLmlyLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ0FEQkUgVmVjdG9yIFN0YXIgSW5uZXIgUmFkaXVzJykpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uaW5uZXJSYWRpdXM7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNoYXBlLmlzICYmIHNoYXBlLmlzLml4ID09PSB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5pbm5lclJvdW5kbmVzcztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XHJcbiAgICB2YXIgcHJvcCA9IHZpZXcuc2gudHkgPT09ICd0bScgPyB2aWV3LnNoLnByb3AgOiB2aWV3LnNoO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xyXG4gICAgcHJvcC5vci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPdXRlciBSYWRpdXMnLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgcHJvcC5vcy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPdXRlciBSb3VuZG5lc3MnLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgcHJvcC5wdC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdQb2ludHMnLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgcHJvcC5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1Bvc2l0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHByb3Auci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSb3RhdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICBpZiAoc2hhcGUuaXIpIHtcclxuICAgICAgcHJvcC5pci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdJbm5lciBSYWRpdXMnLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgICBwcm9wLmlzLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0lubmVyIFJvdW5kbmVzcycsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnApLFxyXG4gICAgICB9LFxyXG4gICAgICByb3RhdGlvbjoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AuciksXHJcbiAgICAgIH0sXHJcbiAgICAgIHBvaW50czoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucHQpLFxyXG4gICAgICB9LFxyXG4gICAgICBvdXRlclJhZGl1czoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3Aub3IpLFxyXG4gICAgICB9LFxyXG4gICAgICBvdXRlclJvdW5kbmVzczoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3Aub3MpLFxyXG4gICAgICB9LFxyXG4gICAgICBpbm5lclJhZGl1czoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AuaXIpLFxyXG4gICAgICB9LFxyXG4gICAgICBpbm5lclJvdW5kbmVzczoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AuaXMpLFxyXG4gICAgICB9LFxyXG4gICAgICBfbmFtZTogeyB2YWx1ZTogc2hhcGUubm0gfSxcclxuICAgIH0pO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcclxuICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlY3RJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBpZiAoc2hhcGUucC5peCA9PT0gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9zaXRpb247XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNoYXBlLnIuaXggPT09IHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnJvdW5kbmVzcztcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2hhcGUucy5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdTaXplJyB8fCB2YWx1ZSA9PT0gJ0FEQkUgVmVjdG9yIFJlY3QgU2l6ZScpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc2l6ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcclxuXHJcbiAgICB2YXIgcHJvcCA9IHZpZXcuc2gudHkgPT09ICd0bScgPyB2aWV3LnNoLnByb3AgOiB2aWV3LnNoO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xyXG4gICAgcHJvcC5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1Bvc2l0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHByb3Aucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTaXplJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHByb3Auci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSb3RhdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnApLFxyXG4gICAgICB9LFxyXG4gICAgICByb3VuZG5lc3M6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnIpLFxyXG4gICAgICB9LFxyXG4gICAgICBzaXplOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5zKSxcclxuICAgICAgfSxcclxuICAgICAgX25hbWU6IHsgdmFsdWU6IHNoYXBlLm5tIH0sXHJcbiAgICB9KTtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XHJcbiAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByb3VuZGVkSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xyXG4gICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgaWYgKHNoYXBlLnIuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnUm91bmQgQ29ybmVycyAxJykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5yYWRpdXM7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xyXG4gICAgdmFyIHByb3AgPSB2aWV3O1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xyXG4gICAgcHJvcC5yZC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSYWRpdXMnLCBfcHJvcGVydHlHcm91cCkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XHJcbiAgICAgIHJhZGl1czoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucmQpLFxyXG4gICAgICB9LFxyXG4gICAgICBfbmFtZTogeyB2YWx1ZTogc2hhcGUubm0gfSxcclxuICAgIH0pO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcclxuICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlcGVhdGVySW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xyXG4gICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgaWYgKHNoYXBlLmMuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnQ29waWVzJykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb3BpZXM7XHJcbiAgICAgIH0gaWYgKHNoYXBlLm8uaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnT2Zmc2V0Jykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vZmZzZXQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xyXG4gICAgdmFyIHByb3AgPSB2aWV3O1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xyXG4gICAgcHJvcC5jLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0NvcGllcycsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICBwcm9wLm8uc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT2Zmc2V0JywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XHJcbiAgICAgIGNvcGllczoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AuYyksXHJcbiAgICAgIH0sXHJcbiAgICAgIG9mZnNldDoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AubyksXHJcbiAgICAgIH0sXHJcbiAgICAgIF9uYW1lOiB7IHZhbHVlOiBzaGFwZS5ubSB9LFxyXG4gICAgfSk7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChzaGFwZXMsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcclxuICAgIHZhciBpbnRlcmZhY2VzO1xyXG4gICAgZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIHByb3BlcnR5R3JvdXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VzW3ZhbHVlIC0gMV07XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICB2YXIgbGVuID0gaW50ZXJmYWNlcy5sZW5ndGg7XHJcbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgICAgaWYgKGludGVyZmFjZXNbaV0uX25hbWUgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyZW50R3JvdXBXcmFwcGVyKCkge1xyXG4gICAgICByZXR1cm4gcHJvcGVydHlHcm91cDtcclxuICAgIH1cclxuICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoX2ludGVyZmFjZUZ1bmN0aW9uLCBwYXJlbnRHcm91cFdyYXBwZXIpO1xyXG4gICAgaW50ZXJmYWNlcyA9IGl0ZXJhdGVFbGVtZW50cyhzaGFwZXMsIHZpZXcsIF9pbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwKTtcclxuICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5udW1Qcm9wZXJ0aWVzID0gaW50ZXJmYWNlcy5sZW5ndGg7XHJcbiAgICBfaW50ZXJmYWNlRnVuY3Rpb24uX25hbWUgPSAnQ29udGVudHMnO1xyXG4gICAgcmV0dXJuIF9pbnRlcmZhY2VGdW5jdGlvbjtcclxuICB9O1xyXG59KCkpO1xyXG5cclxuLyogZXhwb3J0ZWQgVGV4dEV4cHJlc3Npb25JbnRlcmZhY2UgKi9cclxuXHJcbnZhciBUZXh0RXhwcmVzc2lvbkludGVyZmFjZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICB2YXIgX3ByZXZWYWx1ZTtcclxuICAgIHZhciBfc291cmNlVGV4dDtcclxuICAgIGZ1bmN0aW9uIF90aGlzTGF5ZXJGdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ0FEQkUgVGV4dCBEb2N1bWVudCc6XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXNMYXllckZ1bmN0aW9uLnNvdXJjZVRleHQ7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNMYXllckZ1bmN0aW9uLCAnc291cmNlVGV4dCcsIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZWxlbS50ZXh0UHJvcGVydHkuZ2V0VmFsdWUoKTtcclxuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBlbGVtLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS50O1xyXG4gICAgICAgIGlmIChzdHJpbmdWYWx1ZSAhPT0gX3ByZXZWYWx1ZSkge1xyXG4gICAgICAgICAgZWxlbS50ZXh0UHJvcGVydHkuY3VycmVudERhdGEudCA9IF9wcmV2VmFsdWU7XHJcbiAgICAgICAgICBfc291cmNlVGV4dCA9IG5ldyBTdHJpbmcoc3RyaW5nVmFsdWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xyXG4gICAgICAgICAgLy8gSWYgc3RyaW5nVmFsdWUgaXMgYW4gZW1wdHkgc3RyaW5nLCBldmFsIHJldHVybnMgdW5kZWZpbmVkLCBzbyBpdCBoYXMgdG8gYmUgcmV0dXJuZWQgYXMgYSBTdHJpbmcgcHJpbWl0aXZlXHJcbiAgICAgICAgICBfc291cmNlVGV4dC52YWx1ZSA9IHN0cmluZ1ZhbHVlIHx8IG5ldyBTdHJpbmcoc3RyaW5nVmFsdWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3NvdXJjZVRleHQ7XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb247XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBNYXRyaXgsIE1hc2tNYW5hZ2VySW50ZXJmYWNlLCBUcmFuc2Zvcm1FeHByZXNzaW9uSW50ZXJmYWNlLCBnZXREZXNjcmlwdG9yICovXHJcbi8qIGV4cG9ydGVkIExheWVyRXhwcmVzc2lvbkludGVyZmFjZSAqL1xyXG5cclxudmFyIExheWVyRXhwcmVzc2lvbkludGVyZmFjZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gZ2V0TWF0cml4KHRpbWUpIHtcclxuICAgIHZhciB0b1dvcmxkTWF0ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgaWYgKHRpbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YXIgcHJvcE1hdHJpeCA9IHRoaXMuX2VsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3AuZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgIHByb3BNYXRyaXguY2xvbmUodG9Xb3JsZE1hdCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgdHJhbnNmb3JtTWF0ID0gdGhpcy5fZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcDtcclxuICAgICAgdHJhbnNmb3JtTWF0LmFwcGx5VG9NYXRyaXgodG9Xb3JsZE1hdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9Xb3JsZE1hdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRvV29ybGRWZWMoYXJyLCB0aW1lKSB7XHJcbiAgICB2YXIgdG9Xb3JsZE1hdCA9IHRoaXMuZ2V0TWF0cml4KHRpbWUpO1xyXG4gICAgdG9Xb3JsZE1hdC5wcm9wc1sxMl0gPSAwO1xyXG4gICAgdG9Xb3JsZE1hdC5wcm9wc1sxM10gPSAwO1xyXG4gICAgdG9Xb3JsZE1hdC5wcm9wc1sxNF0gPSAwO1xyXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlQb2ludCh0b1dvcmxkTWF0LCBhcnIpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdG9Xb3JsZChhcnIsIHRpbWUpIHtcclxuICAgIHZhciB0b1dvcmxkTWF0ID0gdGhpcy5nZXRNYXRyaXgodGltZSk7XHJcbiAgICByZXR1cm4gdGhpcy5hcHBseVBvaW50KHRvV29ybGRNYXQsIGFycik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmcm9tV29ybGRWZWMoYXJyLCB0aW1lKSB7XHJcbiAgICB2YXIgdG9Xb3JsZE1hdCA9IHRoaXMuZ2V0TWF0cml4KHRpbWUpO1xyXG4gICAgdG9Xb3JsZE1hdC5wcm9wc1sxMl0gPSAwO1xyXG4gICAgdG9Xb3JsZE1hdC5wcm9wc1sxM10gPSAwO1xyXG4gICAgdG9Xb3JsZE1hdC5wcm9wc1sxNF0gPSAwO1xyXG4gICAgcmV0dXJuIHRoaXMuaW52ZXJ0UG9pbnQodG9Xb3JsZE1hdCwgYXJyKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZyb21Xb3JsZChhcnIsIHRpbWUpIHtcclxuICAgIHZhciB0b1dvcmxkTWF0ID0gdGhpcy5nZXRNYXRyaXgodGltZSk7XHJcbiAgICByZXR1cm4gdGhpcy5pbnZlcnRQb2ludCh0b1dvcmxkTWF0LCBhcnIpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYXBwbHlQb2ludChtYXRyaXgsIGFycikge1xyXG4gICAgaWYgKHRoaXMuX2VsZW0uaGllcmFyY2h5ICYmIHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aCkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbiA9IHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aDtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbS5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuYXBwbHlUb01hdHJpeChtYXRyaXgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0cml4LmFwcGx5VG9Qb2ludEFycmF5KGFyclswXSwgYXJyWzFdLCBhcnJbMl0gfHwgMCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbnZlcnRQb2ludChtYXRyaXgsIGFycikge1xyXG4gICAgaWYgKHRoaXMuX2VsZW0uaGllcmFyY2h5ICYmIHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aCkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbiA9IHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aDtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbS5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuYXBwbHlUb01hdHJpeChtYXRyaXgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0cml4LmludmVyc2VQb2ludChhcnIpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZnJvbUNvbXAoYXJyKSB7XHJcbiAgICB2YXIgdG9Xb3JsZE1hdCA9IG5ldyBNYXRyaXgoKTtcclxuICAgIHRvV29ybGRNYXQucmVzZXQoKTtcclxuICAgIHRoaXMuX2VsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3AuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcclxuICAgIGlmICh0aGlzLl9lbGVtLmhpZXJhcmNoeSAmJiB0aGlzLl9lbGVtLmhpZXJhcmNoeS5sZW5ndGgpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsZW4gPSB0aGlzLl9lbGVtLmhpZXJhcmNoeS5sZW5ndGg7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIHRoaXMuX2VsZW0uaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmFwcGx5VG9NYXRyaXgodG9Xb3JsZE1hdCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRvV29ybGRNYXQuaW52ZXJzZVBvaW50KGFycik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9Xb3JsZE1hdC5pbnZlcnNlUG9pbnQoYXJyKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNhbXBsZUltYWdlKCkge1xyXG4gICAgcmV0dXJuIFsxLCAxLCAxLCAxXTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgdmFyIHRyYW5zZm9ybUludGVyZmFjZTtcclxuXHJcbiAgICBmdW5jdGlvbiBfcmVnaXN0ZXJNYXNrSW50ZXJmYWNlKG1hc2tNYW5hZ2VyKSB7XHJcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5tYXNrID0gbmV3IE1hc2tNYW5hZ2VySW50ZXJmYWNlKG1hc2tNYW5hZ2VyLCBlbGVtKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIF9yZWdpc3RlckVmZmVjdHNJbnRlcmZhY2UoZWZmZWN0cykge1xyXG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZWZmZWN0ID0gZWZmZWN0cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdGhpc0xheWVyRnVuY3Rpb24obmFtZSkge1xyXG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICBjYXNlICdBREJFIFJvb3QgVmVjdG9ycyBHcm91cCc6XHJcbiAgICAgICAgY2FzZSAnQ29udGVudHMnOlxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb24uc2hhcGVJbnRlcmZhY2U7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGNhc2UgNjpcclxuICAgICAgICBjYXNlICdUcmFuc2Zvcm0nOlxyXG4gICAgICAgIGNhc2UgJ3RyYW5zZm9ybSc6XHJcbiAgICAgICAgY2FzZSAnQURCRSBUcmFuc2Zvcm0gR3JvdXAnOlxyXG4gICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUludGVyZmFjZTtcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgY2FzZSAnQURCRSBFZmZlY3QgUGFyYWRlJzpcclxuICAgICAgICBjYXNlICdlZmZlY3RzJzpcclxuICAgICAgICBjYXNlICdFZmZlY3RzJzpcclxuICAgICAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb24uZWZmZWN0O1xyXG4gICAgICAgIGNhc2UgJ0FEQkUgVGV4dCBQcm9wZXJ0aWVzJzpcclxuICAgICAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb24udGV4dEludGVyZmFjZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5nZXRNYXRyaXggPSBnZXRNYXRyaXg7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24uaW52ZXJ0UG9pbnQgPSBpbnZlcnRQb2ludDtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5hcHBseVBvaW50ID0gYXBwbHlQb2ludDtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi50b1dvcmxkID0gdG9Xb3JsZDtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi50b1dvcmxkVmVjID0gdG9Xb3JsZFZlYztcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcm9tV29ybGQgPSBmcm9tV29ybGQ7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJvbVdvcmxkVmVjID0gZnJvbVdvcmxkVmVjO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLnRvQ29tcCA9IHRvV29ybGQ7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJvbUNvbXAgPSBmcm9tQ29tcDtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5zYW1wbGVJbWFnZSA9IHNhbXBsZUltYWdlO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLnNvdXJjZVJlY3RBdFRpbWUgPSBlbGVtLnNvdXJjZVJlY3RBdFRpbWUuYmluZChlbGVtKTtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5fZWxlbSA9IGVsZW07XHJcbiAgICB0cmFuc2Zvcm1JbnRlcmZhY2UgPSBUcmFuc2Zvcm1FeHByZXNzaW9uSW50ZXJmYWNlKGVsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3ApO1xyXG4gICAgdmFyIGFuY2hvclBvaW50RGVzY3JpcHRvciA9IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAnYW5jaG9yUG9pbnQnKTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzTGF5ZXJGdW5jdGlvbiwge1xyXG4gICAgICBoYXNQYXJlbnQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBlbGVtLmhpZXJhcmNoeS5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAgcGFyZW50OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gZWxlbS5oaWVyYXJjaHlbMF0ubGF5ZXJJbnRlcmZhY2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAgcm90YXRpb246IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAncm90YXRpb24nKSxcclxuICAgICAgc2NhbGU6IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAnc2NhbGUnKSxcclxuICAgICAgcG9zaXRpb246IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAncG9zaXRpb24nKSxcclxuICAgICAgb3BhY2l0eTogZ2V0RGVzY3JpcHRvcih0cmFuc2Zvcm1JbnRlcmZhY2UsICdvcGFjaXR5JyksXHJcbiAgICAgIGFuY2hvclBvaW50OiBhbmNob3JQb2ludERlc2NyaXB0b3IsXHJcbiAgICAgIGFuY2hvcl9wb2ludDogYW5jaG9yUG9pbnREZXNjcmlwdG9yLFxyXG4gICAgICB0cmFuc2Zvcm06IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1JbnRlcmZhY2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAgYWN0aXZlOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gZWxlbS5pc0luUmFuZ2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5zdGFydFRpbWUgPSBlbGVtLmRhdGEuc3Q7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24uaW5kZXggPSBlbGVtLmRhdGEuaW5kO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLnNvdXJjZSA9IGVsZW0uZGF0YS5yZWZJZDtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5oZWlnaHQgPSBlbGVtLmRhdGEudHkgPT09IDAgPyBlbGVtLmRhdGEuaCA6IDEwMDtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi53aWR0aCA9IGVsZW0uZGF0YS50eSA9PT0gMCA/IGVsZW0uZGF0YS53IDogMTAwO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLmluUG9pbnQgPSBlbGVtLmRhdGEuaXAgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24ub3V0UG9pbnQgPSBlbGVtLmRhdGEub3AgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24uX25hbWUgPSBlbGVtLmRhdGEubm07XHJcblxyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLnJlZ2lzdGVyTWFza0ludGVyZmFjZSA9IF9yZWdpc3Rlck1hc2tJbnRlcmZhY2U7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24ucmVnaXN0ZXJFZmZlY3RzSW50ZXJmYWNlID0gX3JlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZTtcclxuICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb247XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCAqL1xyXG4vKiBleHBvcnRlZCBGb290YWdlSW50ZXJmYWNlICovXHJcblxyXG52YXIgRm9vdGFnZUludGVyZmFjZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG91dGxpbmVJbnRlcmZhY2VGYWN0b3J5ID0gKGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICB2YXIgY3VycmVudFByb3BlcnR5TmFtZSA9ICcnO1xyXG4gICAgdmFyIGN1cnJlbnRQcm9wZXJ0eSA9IGVsZW0uZ2V0Rm9vdGFnZURhdGEoKTtcclxuICAgIGZ1bmN0aW9uIGluaXQoKSB7XHJcbiAgICAgIGN1cnJlbnRQcm9wZXJ0eU5hbWUgPSAnJztcclxuICAgICAgY3VycmVudFByb3BlcnR5ID0gZWxlbS5nZXRGb290YWdlRGF0YSgpO1xyXG4gICAgICByZXR1cm4gc2VhcmNoUHJvcGVydHk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZWFyY2hQcm9wZXJ0eSh2YWx1ZSkge1xyXG4gICAgICBpZiAoY3VycmVudFByb3BlcnR5W3ZhbHVlXSkge1xyXG4gICAgICAgIGN1cnJlbnRQcm9wZXJ0eU5hbWUgPSB2YWx1ZTtcclxuICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHlbdmFsdWVdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudFByb3BlcnR5ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgcmV0dXJuIHNlYXJjaFByb3BlcnR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudFByb3BlcnR5O1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBwcm9wZXJ0eU5hbWVJbmRleCA9IHZhbHVlLmluZGV4T2YoY3VycmVudFByb3BlcnR5TmFtZSk7XHJcbiAgICAgIGlmIChwcm9wZXJ0eU5hbWVJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludCh2YWx1ZS5zdWJzdHIocHJvcGVydHlOYW1lSW5kZXggKyBjdXJyZW50UHJvcGVydHlOYW1lLmxlbmd0aCksIDEwKTtcclxuICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHlbaW5kZXhdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudFByb3BlcnR5ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgcmV0dXJuIHNlYXJjaFByb3BlcnR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudFByb3BlcnR5O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIHJldHVybiBpbml0O1xyXG4gIH0pO1xyXG5cclxuICB2YXIgZGF0YUludGVyZmFjZUZhY3RvcnkgPSBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgaWYgKHZhbHVlID09PSAnT3V0bGluZScpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3V0bGluZUludGVyZmFjZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLl9uYW1lID0gJ091dGxpbmUnO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ub3V0bGluZUludGVyZmFjZSA9IG91dGxpbmVJbnRlcmZhY2VGYWN0b3J5KGVsZW0pO1xyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gJ0RhdGEnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9pbnRlcmZhY2VGdW5jdGlvbi5kYXRhSW50ZXJmYWNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5fbmFtZSA9ICdEYXRhJztcclxuICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5kYXRhSW50ZXJmYWNlID0gZGF0YUludGVyZmFjZUZhY3RvcnkoZWxlbSk7XHJcbiAgICByZXR1cm4gX2ludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBleHBvcnRlZCBDb21wRXhwcmVzc2lvbkludGVyZmFjZSAqL1xyXG5cclxudmFyIENvbXBFeHByZXNzaW9uSW50ZXJmYWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGNvbXApIHtcclxuICAgIGZ1bmN0aW9uIF90aGlzTGF5ZXJGdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgIHZhciBpID0gMDtcclxuICAgICAgdmFyIGxlbiA9IGNvbXAubGF5ZXJzLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICBpZiAoY29tcC5sYXllcnNbaV0ubm0gPT09IG5hbWUgfHwgY29tcC5sYXllcnNbaV0uaW5kID09PSBuYW1lKSB7XHJcbiAgICAgICAgICByZXR1cm4gY29tcC5lbGVtZW50c1tpXS5sYXllckludGVyZmFjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAvLyByZXR1cm4ge2FjdGl2ZTpmYWxzZX07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNMYXllckZ1bmN0aW9uLCAnX25hbWUnLCB7IHZhbHVlOiBjb21wLmRhdGEubm0gfSk7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24ubGF5ZXIgPSBfdGhpc0xheWVyRnVuY3Rpb247XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24ucGl4ZWxBc3BlY3QgPSAxO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLmhlaWdodCA9IGNvbXAuZGF0YS5oIHx8IGNvbXAuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLndpZHRoID0gY29tcC5kYXRhLncgfHwgY29tcC5nbG9iYWxEYXRhLmNvbXBTaXplLnc7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24ucGl4ZWxBc3BlY3QgPSAxO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLmZyYW1lRHVyYXRpb24gPSAxIC8gY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5kaXNwbGF5U3RhcnRUaW1lID0gMDtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5udW1MYXllcnMgPSBjb21wLmxheWVycy5sZW5ndGg7XHJcbiAgICByZXR1cm4gX3RoaXNMYXllckZ1bmN0aW9uO1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlICovXHJcbi8qIGV4cG9ydGVkIFRyYW5zZm9ybUV4cHJlc3Npb25JbnRlcmZhY2UgKi9cclxuXHJcbnZhciBUcmFuc2Zvcm1FeHByZXNzaW9uSW50ZXJmYWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xyXG4gICAgZnVuY3Rpb24gX3RoaXNGdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ3NjYWxlJzpcclxuICAgICAgICBjYXNlICdTY2FsZSc6XHJcbiAgICAgICAgY2FzZSAnQURCRSBTY2FsZSc6XHJcbiAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24uc2NhbGU7XHJcbiAgICAgICAgY2FzZSAncm90YXRpb24nOlxyXG4gICAgICAgIGNhc2UgJ1JvdGF0aW9uJzpcclxuICAgICAgICBjYXNlICdBREJFIFJvdGF0aW9uJzpcclxuICAgICAgICBjYXNlICdBREJFIFJvdGF0ZSBaJzpcclxuICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ucm90YXRpb247XHJcbiAgICAgICAgY2FzZSAnQURCRSBSb3RhdGUgWCc6XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi54Um90YXRpb247XHJcbiAgICAgICAgY2FzZSAnQURCRSBSb3RhdGUgWSc6XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi55Um90YXRpb247XHJcbiAgICAgICAgY2FzZSAncG9zaXRpb24nOlxyXG4gICAgICAgIGNhc2UgJ1Bvc2l0aW9uJzpcclxuICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uJzpcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5wb3NpdGlvbjtcclxuICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uXzAnOlxyXG4gICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ueFBvc2l0aW9uO1xyXG4gICAgICAgIGNhc2UgJ0FEQkUgUG9zaXRpb25fMSc6XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi55UG9zaXRpb247XHJcbiAgICAgICAgY2FzZSAnQURCRSBQb3NpdGlvbl8yJzpcclxuICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnpQb3NpdGlvbjtcclxuICAgICAgICBjYXNlICdhbmNob3JQb2ludCc6XHJcbiAgICAgICAgY2FzZSAnQW5jaG9yUG9pbnQnOlxyXG4gICAgICAgIGNhc2UgJ0FuY2hvciBQb2ludCc6XHJcbiAgICAgICAgY2FzZSAnQURCRSBBbmNob3JQb2ludCc6XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24uYW5jaG9yUG9pbnQ7XHJcbiAgICAgICAgY2FzZSAnb3BhY2l0eSc6XHJcbiAgICAgICAgY2FzZSAnT3BhY2l0eSc6XHJcbiAgICAgICAgY2FzZSAxMTpcclxuICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLm9wYWNpdHk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3JvdGF0aW9uJywge1xyXG4gICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0uciB8fCB0cmFuc2Zvcm0ucnopLFxyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd6Um90YXRpb24nLCB7XHJcbiAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yeiB8fCB0cmFuc2Zvcm0uciksXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3hSb3RhdGlvbicsIHtcclxuICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnJ4KSxcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneVJvdGF0aW9uJywge1xyXG4gICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucnkpLFxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3NjYWxlJywge1xyXG4gICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucyksXHJcbiAgICB9KTtcclxuICAgIHZhciBfcHg7XHJcbiAgICB2YXIgX3B5O1xyXG4gICAgdmFyIF9wejtcclxuICAgIHZhciBfdHJhbnNmb3JtRmFjdG9yeTtcclxuICAgIGlmICh0cmFuc2Zvcm0ucCkge1xyXG4gICAgICBfdHJhbnNmb3JtRmFjdG9yeSA9IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfcHggPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnB4KTtcclxuICAgICAgX3B5ID0gRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5weSk7XHJcbiAgICAgIGlmICh0cmFuc2Zvcm0ucHopIHtcclxuICAgICAgICBfcHogPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnB6KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdwb3NpdGlvbicsIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5wKSB7XHJcbiAgICAgICAgICByZXR1cm4gX3RyYW5zZm9ybUZhY3RvcnkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgIF9weCgpLFxyXG4gICAgICAgICAgX3B5KCksXHJcbiAgICAgICAgICBfcHogPyBfcHooKSA6IDBdO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd4UG9zaXRpb24nLCB7XHJcbiAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5weCksXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3lQb3NpdGlvbicsIHtcclxuICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnB5KSxcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnelBvc2l0aW9uJywge1xyXG4gICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHopLFxyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdhbmNob3JQb2ludCcsIHtcclxuICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLmEpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdvcGFjaXR5Jywge1xyXG4gICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ubyksXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3NrZXcnLCB7XHJcbiAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5zayksXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3NrZXdBeGlzJywge1xyXG4gICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0uc2EpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdvcmllbnRhdGlvbicsIHtcclxuICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLm9yKSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uO1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBleHBvcnRlZCBQcm9qZWN0SW50ZXJmYWNlICovXHJcblxyXG52YXIgUHJvamVjdEludGVyZmFjZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gcmVnaXN0ZXJDb21wb3NpdGlvbihjb21wKSB7XHJcbiAgICB0aGlzLmNvbXBvc2l0aW9ucy5wdXNoKGNvbXApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIF90aGlzUHJvamVjdEZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICB2YXIgbGVuID0gdGhpcy5jb21wb3NpdGlvbnMubGVuZ3RoO1xyXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2l0aW9uc1tpXS5kYXRhICYmIHRoaXMuY29tcG9zaXRpb25zW2ldLmRhdGEubm0gPT09IG5hbWUpIHtcclxuICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2l0aW9uc1tpXS5wcmVwYXJlRnJhbWUgJiYgdGhpcy5jb21wb3NpdGlvbnNbaV0uZGF0YS54dCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uc1tpXS5wcmVwYXJlRnJhbWUodGhpcy5jdXJyZW50RnJhbWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9zaXRpb25zW2ldLmNvbXBJbnRlcmZhY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBfdGhpc1Byb2plY3RGdW5jdGlvbi5jb21wb3NpdGlvbnMgPSBbXTtcclxuICAgIF90aGlzUHJvamVjdEZ1bmN0aW9uLmN1cnJlbnRGcmFtZSA9IDA7XHJcblxyXG4gICAgX3RoaXNQcm9qZWN0RnVuY3Rpb24ucmVnaXN0ZXJDb21wb3NpdGlvbiA9IHJlZ2lzdGVyQ29tcG9zaXRpb247XHJcblxyXG4gICAgcmV0dXJuIF90aGlzUHJvamVjdEZ1bmN0aW9uO1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgcHJvcGVydHlHcm91cEZhY3RvcnksIEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSwgUHJvcGVydHlJbnRlcmZhY2UgKi9cclxuLyogZXhwb3J0ZWQgRWZmZWN0c0V4cHJlc3Npb25JbnRlcmZhY2UgKi9cclxuXHJcbnZhciBFZmZlY3RzRXhwcmVzc2lvbkludGVyZmFjZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG9iID0ge1xyXG4gICAgY3JlYXRlRWZmZWN0c0ludGVyZmFjZTogY3JlYXRlRWZmZWN0c0ludGVyZmFjZSxcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVFZmZlY3RzSW50ZXJmYWNlKGVsZW0sIHByb3BlcnR5R3JvdXApIHtcclxuICAgIGlmIChlbGVtLmVmZmVjdHNNYW5hZ2VyKSB7XHJcbiAgICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IFtdO1xyXG4gICAgICB2YXIgZWZmZWN0c0RhdGEgPSBlbGVtLmRhdGEuZWY7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuID0gZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIGVmZmVjdEVsZW1lbnRzLnB1c2goY3JlYXRlR3JvdXBJbnRlcmZhY2UoZWZmZWN0c0RhdGFbaV0sIGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0sIHByb3BlcnR5R3JvdXAsIGVsZW0pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGVmZmVjdHMgPSBlbGVtLmRhdGEuZWYgfHwgW107XHJcbiAgICAgIHZhciBncm91cEludGVyZmFjZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgbGVuID0gZWZmZWN0cy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICAgIGlmIChuYW1lID09PSBlZmZlY3RzW2ldLm5tIHx8IG5hbWUgPT09IGVmZmVjdHNbaV0ubW4gfHwgbmFtZSA9PT0gZWZmZWN0c1tpXS5peCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWZmZWN0RWxlbWVudHNbaV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9O1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ3JvdXBJbnRlcmZhY2UsICdudW1Qcm9wZXJ0aWVzJywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGVmZmVjdHMubGVuZ3RoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gZ3JvdXBJbnRlcmZhY2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUdyb3VwSW50ZXJmYWNlKGRhdGEsIGVsZW1lbnRzLCBwcm9wZXJ0eUdyb3VwLCBlbGVtKSB7XHJcbiAgICBmdW5jdGlvbiBncm91cEludGVyZmFjZShuYW1lKSB7XHJcbiAgICAgIHZhciBlZmZlY3RzID0gZGF0YS5lZjtcclxuICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICB2YXIgbGVuID0gZWZmZWN0cy5sZW5ndGg7XHJcbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IGVmZmVjdHNbaV0ubm0gfHwgbmFtZSA9PT0gZWZmZWN0c1tpXS5tbiB8fCBuYW1lID09PSBlZmZlY3RzW2ldLml4KSB7XHJcbiAgICAgICAgICBpZiAoZWZmZWN0c1tpXS50eSA9PT0gNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWZmZWN0RWxlbWVudHNbaV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZWZmZWN0RWxlbWVudHNbaV0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gICAgfVxyXG4gICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoZ3JvdXBJbnRlcmZhY2UsIHByb3BlcnR5R3JvdXApO1xyXG5cclxuICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gZGF0YS5lZi5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgaWYgKGRhdGEuZWZbaV0udHkgPT09IDUpIHtcclxuICAgICAgICBlZmZlY3RFbGVtZW50cy5wdXNoKGNyZWF0ZUdyb3VwSW50ZXJmYWNlKGRhdGEuZWZbaV0sIGVsZW1lbnRzLmVmZmVjdEVsZW1lbnRzW2ldLCBlbGVtZW50cy5lZmZlY3RFbGVtZW50c1tpXS5wcm9wZXJ0eUdyb3VwLCBlbGVtKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWZmZWN0RWxlbWVudHMucHVzaChjcmVhdGVWYWx1ZUludGVyZmFjZShlbGVtZW50cy5lZmZlY3RFbGVtZW50c1tpXSwgZGF0YS5lZltpXS50eSwgZWxlbSwgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChkYXRhLm1uID09PSAnQURCRSBDb2xvciBDb250cm9sJykge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ3JvdXBJbnRlcmZhY2UsICdjb2xvcicsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1swXSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZ3JvdXBJbnRlcmZhY2UsIHtcclxuICAgICAgbnVtUHJvcGVydGllczoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGRhdGEubnA7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAgX25hbWU6IHsgdmFsdWU6IGRhdGEubm0gfSxcclxuICAgICAgcHJvcGVydHlHcm91cDogeyB2YWx1ZTogX3Byb3BlcnR5R3JvdXAgfSxcclxuICAgIH0pO1xyXG4gICAgZ3JvdXBJbnRlcmZhY2UuZW5hYmxlZCA9IGRhdGEuZW4gIT09IDA7XHJcbiAgICBncm91cEludGVyZmFjZS5hY3RpdmUgPSBncm91cEludGVyZmFjZS5lbmFibGVkO1xyXG4gICAgcmV0dXJuIGdyb3VwSW50ZXJmYWNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlVmFsdWVJbnRlcmZhY2UoZWxlbWVudCwgdHlwZSwgZWxlbSwgcHJvcGVydHlHcm91cCkge1xyXG4gICAgdmFyIGV4cHJlc3Npb25Qcm9wZXJ0eSA9IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShlbGVtZW50LnApO1xyXG4gICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0eXBlID09PSAxMCkge1xyXG4gICAgICAgIHJldHVybiBlbGVtLmNvbXAuY29tcEludGVyZmFjZShlbGVtZW50LnAudik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGV4cHJlc3Npb25Qcm9wZXJ0eSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlbGVtZW50LnAuc2V0R3JvdXBQcm9wZXJ0eSkge1xyXG4gICAgICBlbGVtZW50LnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnJywgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICB9XHJcblxyXG4gIHJldHVybiBvYjtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVTaXplZEFycmF5ICovXHJcbi8qIGV4cG9ydGVkIE1hc2tNYW5hZ2VySW50ZXJmYWNlICovXHJcblxyXG52YXIgTWFza01hbmFnZXJJbnRlcmZhY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIE1hc2tJbnRlcmZhY2UobWFzaywgZGF0YSkge1xyXG4gICAgdGhpcy5fbWFzayA9IG1hc2s7XHJcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcclxuICB9XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hc2tJbnRlcmZhY2UucHJvdG90eXBlLCAnbWFza1BhdGgnLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHRoaXMuX21hc2sucHJvcC5rKSB7XHJcbiAgICAgICAgdGhpcy5fbWFzay5wcm9wLmdldFZhbHVlKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuX21hc2sucHJvcDtcclxuICAgIH0sXHJcbiAgfSk7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hc2tJbnRlcmZhY2UucHJvdG90eXBlLCAnbWFza09wYWNpdHknLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHRoaXMuX21hc2sub3Auaykge1xyXG4gICAgICAgIHRoaXMuX21hc2sub3AuZ2V0VmFsdWUoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5fbWFzay5vcC52ICogMTAwO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgdmFyIE1hc2tNYW5hZ2VyID0gZnVuY3Rpb24gKG1hc2tNYW5hZ2VyKSB7XHJcbiAgICB2YXIgX21hc2tzSW50ZXJmYWNlcyA9IGNyZWF0ZVNpemVkQXJyYXkobWFza01hbmFnZXIudmlld0RhdGEubGVuZ3RoKTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IG1hc2tNYW5hZ2VyLnZpZXdEYXRhLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBfbWFza3NJbnRlcmZhY2VzW2ldID0gbmV3IE1hc2tJbnRlcmZhY2UobWFza01hbmFnZXIudmlld0RhdGFbaV0sIG1hc2tNYW5hZ2VyLm1hc2tzUHJvcGVydGllc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1hc2tGdW5jdGlvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgIGkgPSAwO1xyXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgIGlmIChtYXNrTWFuYWdlci5tYXNrc1Byb3BlcnRpZXNbaV0ubm0gPT09IG5hbWUpIHtcclxuICAgICAgICAgIHJldHVybiBfbWFza3NJbnRlcmZhY2VzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG1hc2tGdW5jdGlvbjtcclxuICB9O1xyXG4gIHJldHVybiBNYXNrTWFuYWdlcjtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVUeXBlZEFycmF5ICovXHJcbi8qIGV4cG9ydGVkIEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSAqL1xyXG5cclxudmFyIEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGRlZmF1bHRVbmlkaW1lbnNpb25hbFZhbHVlID0geyBwdjogMCwgdjogMCwgbXVsdDogMSB9O1xyXG4gIHZhciBkZWZhdWx0TXVsdGlkaW1lbnNpb25hbFZhbHVlID0geyBwdjogWzAsIDAsIDBdLCB2OiBbMCwgMCwgMF0sIG11bHQ6IDEgfTtcclxuXHJcbiAgZnVuY3Rpb24gY29tcGxldGVQcm9wZXJ0eShleHByZXNzaW9uVmFsdWUsIHByb3BlcnR5LCB0eXBlKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCAndmVsb2NpdHknLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eS5nZXRWZWxvY2l0eUF0VGltZShwcm9wZXJ0eS5jb21wLmN1cnJlbnRGcmFtZSk7XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIGV4cHJlc3Npb25WYWx1ZS5udW1LZXlzID0gcHJvcGVydHkua2V5ZnJhbWVzID8gcHJvcGVydHkua2V5ZnJhbWVzLmxlbmd0aCA6IDA7XHJcbiAgICBleHByZXNzaW9uVmFsdWUua2V5ID0gZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICBpZiAoIWV4cHJlc3Npb25WYWx1ZS5udW1LZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHZhbHVlID0gJyc7XHJcbiAgICAgIGlmICgncycgaW4gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDFdKSB7XHJcbiAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMV0ucztcclxuICAgICAgfSBlbHNlIGlmICgnZScgaW4gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDJdKSB7XHJcbiAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMl0uZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YWx1ZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAyXS5zO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB2YWx1ZVByb3AgPSB0eXBlID09PSAndW5pZGltZW5zaW9uYWwnID8gbmV3IE51bWJlcih2YWx1ZSkgOiBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXHJcbiAgICAgIHZhbHVlUHJvcC50aW1lID0gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDFdLnQgLyBwcm9wZXJ0eS5lbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICAgIHZhbHVlUHJvcC52YWx1ZSA9IHR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcgPyB2YWx1ZVswXSA6IHZhbHVlO1xyXG4gICAgICByZXR1cm4gdmFsdWVQcm9wO1xyXG4gICAgfTtcclxuICAgIGV4cHJlc3Npb25WYWx1ZS52YWx1ZUF0VGltZSA9IHByb3BlcnR5LmdldFZhbHVlQXRUaW1lO1xyXG4gICAgZXhwcmVzc2lvblZhbHVlLnNwZWVkQXRUaW1lID0gcHJvcGVydHkuZ2V0U3BlZWRBdFRpbWU7XHJcbiAgICBleHByZXNzaW9uVmFsdWUudmVsb2NpdHlBdFRpbWUgPSBwcm9wZXJ0eS5nZXRWZWxvY2l0eUF0VGltZTtcclxuICAgIGV4cHJlc3Npb25WYWx1ZS5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHkucHJvcGVydHlHcm91cDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIFVuaWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UocHJvcGVydHkpIHtcclxuICAgIGlmICghcHJvcGVydHkgfHwgISgncHYnIGluIHByb3BlcnR5KSkge1xyXG4gICAgICBwcm9wZXJ0eSA9IGRlZmF1bHRVbmlkaW1lbnNpb25hbFZhbHVlO1xyXG4gICAgfVxyXG4gICAgdmFyIG11bHQgPSAxIC8gcHJvcGVydHkubXVsdDtcclxuICAgIHZhciB2YWwgPSBwcm9wZXJ0eS5wdiAqIG11bHQ7XHJcbiAgICB2YXIgZXhwcmVzc2lvblZhbHVlID0gbmV3IE51bWJlcih2YWwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xyXG4gICAgZXhwcmVzc2lvblZhbHVlLnZhbHVlID0gdmFsO1xyXG4gICAgY29tcGxldGVQcm9wZXJ0eShleHByZXNzaW9uVmFsdWUsIHByb3BlcnR5LCAndW5pZGltZW5zaW9uYWwnKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAocHJvcGVydHkuaykge1xyXG4gICAgICAgIHByb3BlcnR5LmdldFZhbHVlKCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFsID0gcHJvcGVydHkudiAqIG11bHQ7XHJcbiAgICAgIGlmIChleHByZXNzaW9uVmFsdWUudmFsdWUgIT09IHZhbCkge1xyXG4gICAgICAgIGV4cHJlc3Npb25WYWx1ZSA9IG5ldyBOdW1iZXIodmFsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcclxuICAgICAgICBleHByZXNzaW9uVmFsdWUudmFsdWUgPSB2YWw7XHJcbiAgICAgICAgY29tcGxldGVQcm9wZXJ0eShleHByZXNzaW9uVmFsdWUsIHByb3BlcnR5LCAndW5pZGltZW5zaW9uYWwnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZXhwcmVzc2lvblZhbHVlO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIE11bHRpZGltZW5zaW9uYWxQcm9wZXJ0eUludGVyZmFjZShwcm9wZXJ0eSkge1xyXG4gICAgaWYgKCFwcm9wZXJ0eSB8fCAhKCdwdicgaW4gcHJvcGVydHkpKSB7XHJcbiAgICAgIHByb3BlcnR5ID0gZGVmYXVsdE11bHRpZGltZW5zaW9uYWxWYWx1ZTtcclxuICAgIH1cclxuICAgIHZhciBtdWx0ID0gMSAvIHByb3BlcnR5Lm11bHQ7XHJcbiAgICB2YXIgbGVuID0gKHByb3BlcnR5LmRhdGEgJiYgcHJvcGVydHkuZGF0YS5sKSB8fCBwcm9wZXJ0eS5wdi5sZW5ndGg7XHJcbiAgICB2YXIgZXhwcmVzc2lvblZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgICB2YXIgYXJyVmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgIGV4cHJlc3Npb25WYWx1ZS52YWx1ZSA9IGFyclZhbHVlO1xyXG4gICAgY29tcGxldGVQcm9wZXJ0eShleHByZXNzaW9uVmFsdWUsIHByb3BlcnR5LCAnbXVsdGlkaW1lbnNpb25hbCcpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChwcm9wZXJ0eS5rKSB7XHJcbiAgICAgICAgcHJvcGVydHkuZ2V0VmFsdWUoKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgYXJyVmFsdWVbaV0gPSBwcm9wZXJ0eS52W2ldICogbXVsdDtcclxuICAgICAgICBleHByZXNzaW9uVmFsdWVbaV0gPSBhcnJWYWx1ZVtpXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZXhwcmVzc2lvblZhbHVlO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFRPRE86IHRyeSB0byBhdm9pZCB1c2luZyB0aGlzIGdldHRlclxyXG4gIGZ1bmN0aW9uIGRlZmF1bHRHZXR0ZXIoKSB7XHJcbiAgICByZXR1cm4gZGVmYXVsdFVuaWRpbWVuc2lvbmFsVmFsdWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICBpZiAoIXByb3BlcnR5KSB7XHJcbiAgICAgIHJldHVybiBkZWZhdWx0R2V0dGVyO1xyXG4gICAgfSBpZiAocHJvcGVydHkucHJvcFR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcpIHtcclxuICAgICAgcmV0dXJuIFVuaWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UocHJvcGVydHkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE11bHRpZGltZW5zaW9uYWxQcm9wZXJ0eUludGVyZmFjZShwcm9wZXJ0eSk7XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBleHByZXNzaW9uSGVscGVycywgVGV4dFNlbGVjdG9yUHJvcCwgRXhwcmVzc2lvbk1hbmFnZXIgKi9cclxuLyogZXhwb3J0ZWQgVGV4dEV4cHJlc3Npb25TZWxlY3RvclByb3AgKi9cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIFRleHRFeHByZXNzaW9uU2VsZWN0b3JQcm9wID0gKGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVQcm94eShpbmRleCwgdG90YWwpIHtcclxuICAgICAgdGhpcy50ZXh0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgIHRoaXMudGV4dFRvdGFsID0gdG90YWw7XHJcbiAgICAgIHRoaXMudiA9IHRoaXMuZ2V0VmFsdWUoKSAqIHRoaXMubXVsdDtcclxuICAgICAgcmV0dXJuIHRoaXMudjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gVGV4dEV4cHJlc3Npb25TZWxlY3RvclByb3BGYWN0b3J5KGVsZW0sIGRhdGEpIHtcclxuICAgICAgdGhpcy5wdiA9IDE7XHJcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcclxuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgICAgdGhpcy5tdWx0ID0gMC4wMTtcclxuICAgICAgdGhpcy5wcm9wVHlwZSA9ICd0ZXh0U2VsZWN0b3InO1xyXG4gICAgICB0aGlzLnRleHRUb3RhbCA9IGRhdGEudG90YWxDaGFycztcclxuICAgICAgdGhpcy5zZWxlY3RvclZhbHVlID0gMTAwO1xyXG4gICAgICB0aGlzLmxhc3RWYWx1ZSA9IFsxLCAxLCAxXTtcclxuICAgICAgdGhpcy5rID0gdHJ1ZTtcclxuICAgICAgdGhpcy54ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5nZXRWYWx1ZSA9IEV4cHJlc3Npb25NYW5hZ2VyLmluaXRpYXRlRXhwcmVzc2lvbi5iaW5kKHRoaXMpKGVsZW0sIGRhdGEsIHRoaXMpO1xyXG4gICAgICB0aGlzLmdldE11bHQgPSBnZXRWYWx1ZVByb3h5O1xyXG4gICAgICB0aGlzLmdldFZlbG9jaXR5QXRUaW1lID0gZXhwcmVzc2lvbkhlbHBlcnMuZ2V0VmVsb2NpdHlBdFRpbWU7XHJcbiAgICAgIGlmICh0aGlzLmtmKSB7XHJcbiAgICAgICAgdGhpcy5nZXRWYWx1ZUF0VGltZSA9IGV4cHJlc3Npb25IZWxwZXJzLmdldFZhbHVlQXRUaW1lLmJpbmQodGhpcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5nZXRWYWx1ZUF0VGltZSA9IGV4cHJlc3Npb25IZWxwZXJzLmdldFN0YXRpY1ZhbHVlQXRUaW1lLmJpbmQodGhpcyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zZXRHcm91cFByb3BlcnR5ID0gZXhwcmVzc2lvbkhlbHBlcnMuc2V0R3JvdXBQcm9wZXJ0eTtcclxuICAgIH07XHJcbiAgfSgpKTtcclxuXHJcbiAgdmFyIHByb3BlcnR5R2V0VGV4dFByb3AgPSBUZXh0U2VsZWN0b3JQcm9wLmdldFRleHRTZWxlY3RvclByb3A7XHJcbiAgVGV4dFNlbGVjdG9yUHJvcC5nZXRUZXh0U2VsZWN0b3JQcm9wID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEsIGFycikge1xyXG4gICAgaWYgKGRhdGEudCA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gbmV3IFRleHRFeHByZXNzaW9uU2VsZWN0b3JQcm9wRmFjdG9yeShlbGVtLCBkYXRhLCBhcnIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcGVydHlHZXRUZXh0UHJvcChlbGVtLCBkYXRhLCBhcnIpO1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgUHJvcGVydHlGYWN0b3J5ICovXHJcbi8qIGV4cG9ydGVkIFNsaWRlckVmZmVjdCwgQW5nbGVFZmZlY3QsIENvbG9yRWZmZWN0LCBQb2ludEVmZmVjdCwgTGF5ZXJJbmRleEVmZmVjdCwgTWFza0luZGV4RWZmZWN0LCBDaGVja2JveEVmZmVjdCwgTm9WYWx1ZUVmZmVjdCAqL1xyXG5cclxuZnVuY3Rpb24gU2xpZGVyRWZmZWN0KGRhdGEsIGVsZW0sIGNvbnRhaW5lcikge1xyXG4gIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudiwgMCwgMCwgY29udGFpbmVyKTtcclxufVxyXG5mdW5jdGlvbiBBbmdsZUVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcclxuICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDAsIDAsIGNvbnRhaW5lcik7XHJcbn1cclxuZnVuY3Rpb24gQ29sb3JFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XHJcbiAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAxLCAwLCBjb250YWluZXIpO1xyXG59XHJcbmZ1bmN0aW9uIFBvaW50RWZmZWN0KGRhdGEsIGVsZW0sIGNvbnRhaW5lcikge1xyXG4gIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudiwgMSwgMCwgY29udGFpbmVyKTtcclxufVxyXG5mdW5jdGlvbiBMYXllckluZGV4RWZmZWN0KGRhdGEsIGVsZW0sIGNvbnRhaW5lcikge1xyXG4gIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudiwgMCwgMCwgY29udGFpbmVyKTtcclxufVxyXG5mdW5jdGlvbiBNYXNrSW5kZXhFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XHJcbiAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xyXG59XHJcbmZ1bmN0aW9uIENoZWNrYm94RWZmZWN0KGRhdGEsIGVsZW0sIGNvbnRhaW5lcikge1xyXG4gIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudiwgMCwgMCwgY29udGFpbmVyKTtcclxufVxyXG5mdW5jdGlvbiBOb1ZhbHVlRWZmZWN0KCkge1xyXG4gIHRoaXMucCA9IHt9O1xyXG59XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCBTbGlkZXJFZmZlY3QsIEFuZ2xlRWZmZWN0LCBDb2xvckVmZmVjdCwgUG9pbnRFZmZlY3QsIENoZWNrYm94RWZmZWN0LCBMYXllckluZGV4RWZmZWN0LFxyXG5NYXNrSW5kZXhFZmZlY3QsIE5vVmFsdWVFZmZlY3QsIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lciAqL1xyXG5cclxuZnVuY3Rpb24gRWZmZWN0c01hbmFnZXIoZGF0YSwgZWxlbWVudCkge1xyXG4gIHZhciBlZmZlY3RzID0gZGF0YS5lZiB8fCBbXTtcclxuICB0aGlzLmVmZmVjdEVsZW1lbnRzID0gW107XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IGVmZmVjdHMubGVuZ3RoO1xyXG4gIHZhciBlZmZlY3RJdGVtO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgZWZmZWN0SXRlbSA9IG5ldyBHcm91cEVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50KTtcclxuICAgIHRoaXMuZWZmZWN0RWxlbWVudHMucHVzaChlZmZlY3RJdGVtKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEdyb3VwRWZmZWN0KGRhdGEsIGVsZW1lbnQpIHtcclxuICB0aGlzLmluaXQoZGF0YSwgZWxlbWVudCk7XHJcbn1cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgR3JvdXBFZmZlY3QpO1xyXG5cclxuR3JvdXBFZmZlY3QucHJvdG90eXBlLmdldFZhbHVlID0gR3JvdXBFZmZlY3QucHJvdG90eXBlLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcclxuXHJcbkdyb3VwRWZmZWN0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGRhdGEsIGVsZW1lbnQpIHtcclxuICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gIHRoaXMuZWZmZWN0RWxlbWVudHMgPSBbXTtcclxuICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbWVudCk7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuZGF0YS5lZi5sZW5ndGg7XHJcbiAgdmFyIGVmZjtcclxuICB2YXIgZWZmZWN0cyA9IHRoaXMuZGF0YS5lZjtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGVmZiA9IG51bGw7XHJcbiAgICBzd2l0Y2ggKGVmZmVjdHNbaV0udHkpIHtcclxuICAgICAgY2FzZSAwOlxyXG4gICAgICAgIGVmZiA9IG5ldyBTbGlkZXJFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICBlZmYgPSBuZXcgQW5nbGVFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMjpcclxuICAgICAgICBlZmYgPSBuZXcgQ29sb3JFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzpcclxuICAgICAgICBlZmYgPSBuZXcgUG9pbnRFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNDpcclxuICAgICAgY2FzZSA3OlxyXG4gICAgICAgIGVmZiA9IG5ldyBDaGVja2JveEVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAxMDpcclxuICAgICAgICBlZmYgPSBuZXcgTGF5ZXJJbmRleEVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAxMTpcclxuICAgICAgICBlZmYgPSBuZXcgTWFza0luZGV4RWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDU6XHJcbiAgICAgICAgZWZmID0gbmV3IEVmZmVjdHNNYW5hZ2VyKGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIGNhc2UgNjpcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBlZmYgPSBuZXcgTm9WYWx1ZUVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGlmIChlZmYpIHtcclxuICAgICAgdGhpcy5lZmZlY3RFbGVtZW50cy5wdXNoKGVmZik7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbnZhciBsb3R0aWUgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIHNldExvY2F0aW9uSHJlZihocmVmKSB7XHJcbiAgbG9jYXRpb25IcmVmID0gaHJlZjtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VhcmNoQW5pbWF0aW9ucygpIHtcclxuICBpZiAoc3RhbmRhbG9uZSA9PT0gdHJ1ZSkge1xyXG4gICAgYW5pbWF0aW9uTWFuYWdlci5zZWFyY2hBbmltYXRpb25zKGFuaW1hdGlvbkRhdGEsIHN0YW5kYWxvbmUsIHJlbmRlcmVyKTtcclxuICB9IGVsc2Uge1xyXG4gICAgYW5pbWF0aW9uTWFuYWdlci5zZWFyY2hBbmltYXRpb25zKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRTdWJmcmFtZVJlbmRlcmluZyhmbGFnKSB7XHJcbiAgc3ViZnJhbWVFbmFibGVkID0gZmxhZztcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0SURQcmVmaXgocHJlZml4KSB7XHJcbiAgaWRQcmVmaXggPSBwcmVmaXg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvYWRBbmltYXRpb24ocGFyYW1zKSB7XHJcbiAgaWYgKHN0YW5kYWxvbmUgPT09IHRydWUpIHtcclxuICAgIHBhcmFtcy5hbmltYXRpb25EYXRhID0gSlNPTi5wYXJzZShhbmltYXRpb25EYXRhKTtcclxuICB9XHJcbiAgcmV0dXJuIGFuaW1hdGlvbk1hbmFnZXIubG9hZEFuaW1hdGlvbihwYXJhbXMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRRdWFsaXR5KHZhbHVlKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHN3aXRjaCAodmFsdWUpIHtcclxuICAgICAgY2FzZSAnaGlnaCc6XHJcbiAgICAgICAgZGVmYXVsdEN1cnZlU2VnbWVudHMgPSAyMDA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgIGNhc2UgJ21lZGl1bSc6XHJcbiAgICAgICAgZGVmYXVsdEN1cnZlU2VnbWVudHMgPSA1MDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnbG93JzpcclxuICAgICAgICBkZWZhdWx0Q3VydmVTZWdtZW50cyA9IDEwO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSA+IDEpIHtcclxuICAgIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gdmFsdWU7XHJcbiAgfVxyXG4gIGlmIChkZWZhdWx0Q3VydmVTZWdtZW50cyA+PSA1MCkge1xyXG4gICAgcm91bmRWYWx1ZXMoZmFsc2UpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByb3VuZFZhbHVlcyh0cnVlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluQnJvd3NlcigpIHtcclxuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc3RhbGxQbHVnaW4odHlwZSwgcGx1Z2luKSB7XHJcbiAgaWYgKHR5cGUgPT09ICdleHByZXNzaW9ucycpIHtcclxuICAgIGV4cHJlc3Npb25zUGx1Z2luID0gcGx1Z2luO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RmFjdG9yeShuYW1lKSB7XHJcbiAgc3dpdGNoIChuYW1lKSB7XHJcbiAgICBjYXNlICdwcm9wZXJ0eUZhY3RvcnknOlxyXG4gICAgICByZXR1cm4gUHJvcGVydHlGYWN0b3J5O1xyXG4gICAgY2FzZSAnc2hhcGVQcm9wZXJ0eUZhY3RvcnknOlxyXG4gICAgICByZXR1cm4gU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XHJcbiAgICBjYXNlICdtYXRyaXgnOlxyXG4gICAgICByZXR1cm4gTWF0cml4O1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5sb3R0aWUucGxheSA9IGFuaW1hdGlvbk1hbmFnZXIucGxheTtcclxubG90dGllLnBhdXNlID0gYW5pbWF0aW9uTWFuYWdlci5wYXVzZTtcclxubG90dGllLnNldExvY2F0aW9uSHJlZiA9IHNldExvY2F0aW9uSHJlZjtcclxubG90dGllLnRvZ2dsZVBhdXNlID0gYW5pbWF0aW9uTWFuYWdlci50b2dnbGVQYXVzZTtcclxubG90dGllLnNldFNwZWVkID0gYW5pbWF0aW9uTWFuYWdlci5zZXRTcGVlZDtcclxubG90dGllLnNldERpcmVjdGlvbiA9IGFuaW1hdGlvbk1hbmFnZXIuc2V0RGlyZWN0aW9uO1xyXG5sb3R0aWUuc3RvcCA9IGFuaW1hdGlvbk1hbmFnZXIuc3RvcDtcclxubG90dGllLnNlYXJjaEFuaW1hdGlvbnMgPSBzZWFyY2hBbmltYXRpb25zO1xyXG5sb3R0aWUucmVnaXN0ZXJBbmltYXRpb24gPSBhbmltYXRpb25NYW5hZ2VyLnJlZ2lzdGVyQW5pbWF0aW9uO1xyXG5sb3R0aWUubG9hZEFuaW1hdGlvbiA9IGxvYWRBbmltYXRpb247XHJcbmxvdHRpZS5zZXRTdWJmcmFtZVJlbmRlcmluZyA9IHNldFN1YmZyYW1lUmVuZGVyaW5nO1xyXG5sb3R0aWUucmVzaXplID0gYW5pbWF0aW9uTWFuYWdlci5yZXNpemU7XHJcbi8vIGxvdHRpZS5zdGFydCA9IHN0YXJ0O1xyXG5sb3R0aWUuZ29Ub0FuZFN0b3AgPSBhbmltYXRpb25NYW5hZ2VyLmdvVG9BbmRTdG9wO1xyXG5sb3R0aWUuZGVzdHJveSA9IGFuaW1hdGlvbk1hbmFnZXIuZGVzdHJveTtcclxubG90dGllLnNldFF1YWxpdHkgPSBzZXRRdWFsaXR5O1xyXG5sb3R0aWUuaW5Ccm93c2VyID0gaW5Ccm93c2VyO1xyXG5sb3R0aWUuaW5zdGFsbFBsdWdpbiA9IGluc3RhbGxQbHVnaW47XHJcbmxvdHRpZS5mcmVlemUgPSBhbmltYXRpb25NYW5hZ2VyLmZyZWV6ZTtcclxubG90dGllLnVuZnJlZXplID0gYW5pbWF0aW9uTWFuYWdlci51bmZyZWV6ZTtcclxubG90dGllLnNldFZvbHVtZSA9IGFuaW1hdGlvbk1hbmFnZXIuc2V0Vm9sdW1lO1xyXG5sb3R0aWUubXV0ZSA9IGFuaW1hdGlvbk1hbmFnZXIubXV0ZTtcclxubG90dGllLnVubXV0ZSA9IGFuaW1hdGlvbk1hbmFnZXIudW5tdXRlO1xyXG5sb3R0aWUuZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMgPSBhbmltYXRpb25NYW5hZ2VyLmdldFJlZ2lzdGVyZWRBbmltYXRpb25zO1xyXG5sb3R0aWUuc2V0SURQcmVmaXggPSBzZXRJRFByZWZpeDtcclxubG90dGllLl9fZ2V0RmFjdG9yeSA9IGdldEZhY3Rvcnk7XHJcbmxvdHRpZS52ZXJzaW9uID0gJzUuNy4xMSc7XHJcblxyXG5mdW5jdGlvbiBjaGVja1JlYWR5KCkge1xyXG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICBjbGVhckludGVydmFsKHJlYWR5U3RhdGVDaGVja0ludGVydmFsKTtcclxuICAgIHNlYXJjaEFuaW1hdGlvbnMoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFF1ZXJ5VmFyaWFibGUodmFyaWFibGUpIHtcclxuICB2YXIgdmFycyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KCcmJyk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICB2YXIgcGFpciA9IHZhcnNbaV0uc3BsaXQoJz0nKTtcclxuICAgIGlmIChkZWNvZGVVUklDb21wb25lbnQocGFpclswXSkgPT0gdmFyaWFibGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxudmFyIHN0YW5kYWxvbmUgPSAnX19bU1RBTkRBTE9ORV1fXyc7XHJcbnZhciBhbmltYXRpb25EYXRhID0gJ19fW0FOSU1BVElPTkRBVEFdX18nO1xyXG52YXIgcmVuZGVyZXIgPSAnJztcclxudmFyIHF1ZXJ5U3RyaW5nO1xyXG5pZiAoc3RhbmRhbG9uZSkge1xyXG4gIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xyXG4gIHZhciBpbmRleCA9IHNjcmlwdHMubGVuZ3RoIC0gMTtcclxuICB2YXIgbXlTY3JpcHQgPSBzY3JpcHRzW2luZGV4XSB8fCB7XHJcbiAgICBzcmM6ICcnLFxyXG4gIH07XHJcbiAgcXVlcnlTdHJpbmcgPSBteVNjcmlwdC5zcmMucmVwbGFjZSgvXlteXFw/XStcXD8/LywgJycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXHJcbiAgcmVuZGVyZXIgPSBnZXRRdWVyeVZhcmlhYmxlKCdyZW5kZXJlcicpO1xyXG59XHJcbnZhciByZWFkeVN0YXRlQ2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKGNoZWNrUmVhZHksIDEwMCk7XHJcblxucmV0dXJuIGxvdHRpZTtcbn0pKTsiLCJcInVzZSBzdHJpY3RcIjt2YXIgYXNzaWduPU9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpO21vZHVsZS5leHBvcnRzPWFzc2lnbjttb2R1bGUuZXhwb3J0cy5kZWZhdWx0PW1vZHVsZS5leHBvcnRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LWFzc2lnbi5qcy5tYXAiLCJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL3Rlc3RpbmdcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCJDOlxcXFxVc2Vyc1xcXFxyYWh1bFxcXFxEZXNrdG9wXFxcXHF1aXpBcHBcXFxccGFnZXNcXFxcdGVzdGluZy5qc1wiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgIiwiXCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy5ub3JtYWxpemVQYXRoU2VwPW5vcm1hbGl6ZVBhdGhTZXA7ZXhwb3J0cy5kZW5vcm1hbGl6ZVBhZ2VQYXRoPWRlbm9ybWFsaXplUGFnZVBhdGg7ZnVuY3Rpb24gbm9ybWFsaXplUGF0aFNlcChwYXRoKXtyZXR1cm4gcGF0aC5yZXBsYWNlKC9cXFxcL2csJy8nKTt9ZnVuY3Rpb24gZGVub3JtYWxpemVQYWdlUGF0aChwYWdlKXtwYWdlPW5vcm1hbGl6ZVBhdGhTZXAocGFnZSk7aWYocGFnZS5zdGFydHNXaXRoKCcvaW5kZXgvJykpe3BhZ2U9cGFnZS5zbGljZSg2KTt9ZWxzZSBpZihwYWdlPT09Jy9pbmRleCcpe3BhZ2U9Jy8nO31yZXR1cm4gcGFnZTt9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZW5vcm1hbGl6ZS1wYWdlLXBhdGguanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L3JvdXRlcicpXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSAgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIVJlYWN0SXMuaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LCBnb3QgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cy4gJyArXG4gICAgICAgICAgICAnQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHN0cmljdFVyaUVuY29kZSA9IHJlcXVpcmUoJ3N0cmljdC11cmktZW5jb2RlJyk7XG5jb25zdCBkZWNvZGVDb21wb25lbnQgPSByZXF1aXJlKCdkZWNvZGUtdXJpLWNvbXBvbmVudCcpO1xuY29uc3Qgc3BsaXRPbkZpcnN0ID0gcmVxdWlyZSgnc3BsaXQtb24tZmlyc3QnKTtcbmNvbnN0IGZpbHRlck9iamVjdCA9IHJlcXVpcmUoJ2ZpbHRlci1vYmonKTtcblxuY29uc3QgaXNOdWxsT3JVbmRlZmluZWQgPSB2YWx1ZSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBlbmNvZGVyRm9yQXJyYXlGb3JtYXQob3B0aW9ucykge1xuXHRzd2l0Y2ggKG9wdGlvbnMuYXJyYXlGb3JtYXQpIHtcblx0XHRjYXNlICdpbmRleCc6XG5cdFx0XHRyZXR1cm4ga2V5ID0+IChyZXN1bHQsIHZhbHVlKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBOdWxsICYmIHZhbHVlID09PSBudWxsKSB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBFbXB0eVN0cmluZyAmJiB2YWx1ZSA9PT0gJycpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gWy4uLnJlc3VsdCwgW2VuY29kZShrZXksIG9wdGlvbnMpLCAnWycsIGluZGV4LCAnXSddLmpvaW4oJycpXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0Li4ucmVzdWx0LFxuXHRcdFx0XHRcdFtlbmNvZGUoa2V5LCBvcHRpb25zKSwgJ1snLCBlbmNvZGUoaW5kZXgsIG9wdGlvbnMpLCAnXT0nLCBlbmNvZGUodmFsdWUsIG9wdGlvbnMpXS5qb2luKCcnKVxuXHRcdFx0XHRdO1xuXHRcdFx0fTtcblxuXHRcdGNhc2UgJ2JyYWNrZXQnOlxuXHRcdFx0cmV0dXJuIGtleSA9PiAocmVzdWx0LCB2YWx1ZSkgPT4ge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBOdWxsICYmIHZhbHVlID09PSBudWxsKSB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBFbXB0eVN0cmluZyAmJiB2YWx1ZSA9PT0gJycpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gWy4uLnJlc3VsdCwgW2VuY29kZShrZXksIG9wdGlvbnMpLCAnW10nXS5qb2luKCcnKV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gWy4uLnJlc3VsdCwgW2VuY29kZShrZXksIG9wdGlvbnMpLCAnW109JywgZW5jb2RlKHZhbHVlLCBvcHRpb25zKV0uam9pbignJyldO1xuXHRcdFx0fTtcblxuXHRcdGNhc2UgJ2NvbW1hJzpcblx0XHRjYXNlICdzZXBhcmF0b3InOlxuXHRcdGNhc2UgJ2JyYWNrZXQtc2VwYXJhdG9yJzoge1xuXHRcdFx0Y29uc3Qga2V5VmFsdWVTZXAgPSBvcHRpb25zLmFycmF5Rm9ybWF0ID09PSAnYnJhY2tldC1zZXBhcmF0b3InID9cblx0XHRcdFx0J1tdPScgOlxuXHRcdFx0XHQnPSc7XG5cblx0XHRcdHJldHVybiBrZXkgPT4gKHJlc3VsdCwgdmFsdWUpID0+IHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0XHQob3B0aW9ucy5za2lwTnVsbCAmJiB2YWx1ZSA9PT0gbnVsbCkgfHxcblx0XHRcdFx0XHQob3B0aW9ucy5za2lwRW1wdHlTdHJpbmcgJiYgdmFsdWUgPT09ICcnKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhbnNsYXRlIG51bGwgdG8gYW4gZW1wdHkgc3RyaW5nIHNvIHRoYXQgaXQgZG9lc24ndCBzZXJpYWxpemUgYXMgJ251bGwnXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUgPT09IG51bGwgPyAnJyA6IHZhbHVlO1xuXG5cdFx0XHRcdGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFtbZW5jb2RlKGtleSwgb3B0aW9ucyksIGtleVZhbHVlU2VwLCBlbmNvZGUodmFsdWUsIG9wdGlvbnMpXS5qb2luKCcnKV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW1tyZXN1bHQsIGVuY29kZSh2YWx1ZSwgb3B0aW9ucyldLmpvaW4ob3B0aW9ucy5hcnJheUZvcm1hdFNlcGFyYXRvcildO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIGtleSA9PiAocmVzdWx0LCB2YWx1ZSkgPT4ge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBOdWxsICYmIHZhbHVlID09PSBudWxsKSB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBFbXB0eVN0cmluZyAmJiB2YWx1ZSA9PT0gJycpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gWy4uLnJlc3VsdCwgZW5jb2RlKGtleSwgb3B0aW9ucyldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFsuLi5yZXN1bHQsIFtlbmNvZGUoa2V5LCBvcHRpb25zKSwgJz0nLCBlbmNvZGUodmFsdWUsIG9wdGlvbnMpXS5qb2luKCcnKV07XG5cdFx0XHR9O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHBhcnNlckZvckFycmF5Rm9ybWF0KG9wdGlvbnMpIHtcblx0bGV0IHJlc3VsdDtcblxuXHRzd2l0Y2ggKG9wdGlvbnMuYXJyYXlGb3JtYXQpIHtcblx0XHRjYXNlICdpbmRleCc6XG5cdFx0XHRyZXR1cm4gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSA9PiB7XG5cdFx0XHRcdHJlc3VsdCA9IC9cXFsoXFxkKilcXF0kLy5leGVjKGtleSk7XG5cblx0XHRcdFx0a2V5ID0ga2V5LnJlcGxhY2UoL1xcW1xcZCpcXF0kLywgJycpO1xuXG5cdFx0XHRcdGlmICghcmVzdWx0KSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChhY2N1bXVsYXRvcltrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhY2N1bXVsYXRvcltrZXldW3Jlc3VsdFsxXV0gPSB2YWx1ZTtcblx0XHRcdH07XG5cblx0XHRjYXNlICdicmFja2V0Jzpcblx0XHRcdHJldHVybiAoa2V5LCB2YWx1ZSwgYWNjdW11bGF0b3IpID0+IHtcblx0XHRcdFx0cmVzdWx0ID0gLyhcXFtcXF0pJC8uZXhlYyhrZXkpO1xuXHRcdFx0XHRrZXkgPSBrZXkucmVwbGFjZSgvXFxbXFxdJC8sICcnKTtcblxuXHRcdFx0XHRpZiAoIXJlc3VsdCkge1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFt2YWx1ZV07XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFtdLmNvbmNhdChhY2N1bXVsYXRvcltrZXldLCB2YWx1ZSk7XG5cdFx0XHR9O1xuXG5cdFx0Y2FzZSAnY29tbWEnOlxuXHRcdGNhc2UgJ3NlcGFyYXRvcic6XG5cdFx0XHRyZXR1cm4gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGlzQXJyYXkgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmluY2x1ZGVzKG9wdGlvbnMuYXJyYXlGb3JtYXRTZXBhcmF0b3IpO1xuXHRcdFx0XHRjb25zdCBpc0VuY29kZWRBcnJheSA9ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICFpc0FycmF5ICYmIGRlY29kZSh2YWx1ZSwgb3B0aW9ucykuaW5jbHVkZXMob3B0aW9ucy5hcnJheUZvcm1hdFNlcGFyYXRvcikpO1xuXHRcdFx0XHR2YWx1ZSA9IGlzRW5jb2RlZEFycmF5ID8gZGVjb2RlKHZhbHVlLCBvcHRpb25zKSA6IHZhbHVlO1xuXHRcdFx0XHRjb25zdCBuZXdWYWx1ZSA9IGlzQXJyYXkgfHwgaXNFbmNvZGVkQXJyYXkgPyB2YWx1ZS5zcGxpdChvcHRpb25zLmFycmF5Rm9ybWF0U2VwYXJhdG9yKS5tYXAoaXRlbSA9PiBkZWNvZGUoaXRlbSwgb3B0aW9ucykpIDogdmFsdWUgPT09IG51bGwgPyB2YWx1ZSA6IGRlY29kZSh2YWx1ZSwgb3B0aW9ucyk7XG5cdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSBuZXdWYWx1ZTtcblx0XHRcdH07XG5cblx0XHRjYXNlICdicmFja2V0LXNlcGFyYXRvcic6XG5cdFx0XHRyZXR1cm4gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGlzQXJyYXkgPSAvKFxcW1xcXSkkLy50ZXN0KGtleSk7XG5cdFx0XHRcdGtleSA9IGtleS5yZXBsYWNlKC9cXFtcXF0kLywgJycpO1xuXG5cdFx0XHRcdGlmICghaXNBcnJheSkge1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSB2YWx1ZSA/IGRlY29kZSh2YWx1ZSwgb3B0aW9ucykgOiB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBhcnJheVZhbHVlID0gdmFsdWUgPT09IG51bGwgP1xuXHRcdFx0XHRcdFtdIDpcblx0XHRcdFx0XHR2YWx1ZS5zcGxpdChvcHRpb25zLmFycmF5Rm9ybWF0U2VwYXJhdG9yKS5tYXAoaXRlbSA9PiBkZWNvZGUoaXRlbSwgb3B0aW9ucykpO1xuXG5cdFx0XHRcdGlmIChhY2N1bXVsYXRvcltrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gYXJyYXlWYWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gW10uY29uY2F0KGFjY3VtdWxhdG9yW2tleV0sIGFycmF5VmFsdWUpO1xuXHRcdFx0fTtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSA9PiB7XG5cdFx0XHRcdGlmIChhY2N1bXVsYXRvcltrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFtdLmNvbmNhdChhY2N1bXVsYXRvcltrZXldLCB2YWx1ZSk7XG5cdFx0XHR9O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlGb3JtYXRTZXBhcmF0b3IodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgdmFsdWUubGVuZ3RoICE9PSAxKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYXJyYXlGb3JtYXRTZXBhcmF0b3IgbXVzdCBiZSBzaW5nbGUgY2hhcmFjdGVyIHN0cmluZycpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWx1ZSwgb3B0aW9ucykge1xuXHRpZiAob3B0aW9ucy5lbmNvZGUpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5zdHJpY3QgPyBzdHJpY3RVcmlFbmNvZGUodmFsdWUpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlKHZhbHVlLCBvcHRpb25zKSB7XG5cdGlmIChvcHRpb25zLmRlY29kZSkge1xuXHRcdHJldHVybiBkZWNvZGVDb21wb25lbnQodmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBrZXlzU29ydGVyKGlucHV0KSB7XG5cdGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuXHRcdHJldHVybiBpbnB1dC5zb3J0KCk7XG5cdH1cblxuXHRpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBrZXlzU29ydGVyKE9iamVjdC5rZXlzKGlucHV0KSlcblx0XHRcdC5zb3J0KChhLCBiKSA9PiBOdW1iZXIoYSkgLSBOdW1iZXIoYikpXG5cdFx0XHQubWFwKGtleSA9PiBpbnB1dFtrZXldKTtcblx0fVxuXG5cdHJldHVybiBpbnB1dDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSGFzaChpbnB1dCkge1xuXHRjb25zdCBoYXNoU3RhcnQgPSBpbnB1dC5pbmRleE9mKCcjJyk7XG5cdGlmIChoYXNoU3RhcnQgIT09IC0xKSB7XG5cdFx0aW5wdXQgPSBpbnB1dC5zbGljZSgwLCBoYXNoU3RhcnQpO1xuXHR9XG5cblx0cmV0dXJuIGlucHV0O1xufVxuXG5mdW5jdGlvbiBnZXRIYXNoKHVybCkge1xuXHRsZXQgaGFzaCA9ICcnO1xuXHRjb25zdCBoYXNoU3RhcnQgPSB1cmwuaW5kZXhPZignIycpO1xuXHRpZiAoaGFzaFN0YXJ0ICE9PSAtMSkge1xuXHRcdGhhc2ggPSB1cmwuc2xpY2UoaGFzaFN0YXJ0KTtcblx0fVxuXG5cdHJldHVybiBoYXNoO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0KGlucHV0KSB7XG5cdGlucHV0ID0gcmVtb3ZlSGFzaChpbnB1dCk7XG5cdGNvbnN0IHF1ZXJ5U3RhcnQgPSBpbnB1dC5pbmRleE9mKCc/Jyk7XG5cdGlmIChxdWVyeVN0YXJ0ID09PSAtMSkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdHJldHVybiBpbnB1dC5zbGljZShxdWVyeVN0YXJ0ICsgMSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsdWUsIG9wdGlvbnMpIHtcblx0aWYgKG9wdGlvbnMucGFyc2VOdW1iZXJzICYmICFOdW1iZXIuaXNOYU4oTnVtYmVyKHZhbHVlKSkgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudHJpbSgpICE9PSAnJykpIHtcblx0XHR2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5wYXJzZUJvb2xlYW5zICYmIHZhbHVlICE9PSBudWxsICYmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScgfHwgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ZhbHNlJykpIHtcblx0XHR2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcGFyc2UocXVlcnksIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGRlY29kZTogdHJ1ZSxcblx0XHRzb3J0OiB0cnVlLFxuXHRcdGFycmF5Rm9ybWF0OiAnbm9uZScsXG5cdFx0YXJyYXlGb3JtYXRTZXBhcmF0b3I6ICcsJyxcblx0XHRwYXJzZU51bWJlcnM6IGZhbHNlLFxuXHRcdHBhcnNlQm9vbGVhbnM6IGZhbHNlXG5cdH0sIG9wdGlvbnMpO1xuXG5cdHZhbGlkYXRlQXJyYXlGb3JtYXRTZXBhcmF0b3Iob3B0aW9ucy5hcnJheUZvcm1hdFNlcGFyYXRvcik7XG5cblx0Y29uc3QgZm9ybWF0dGVyID0gcGFyc2VyRm9yQXJyYXlGb3JtYXQob3B0aW9ucyk7XG5cblx0Ly8gQ3JlYXRlIGFuIG9iamVjdCB3aXRoIG5vIHByb3RvdHlwZVxuXHRjb25zdCByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdGlmICh0eXBlb2YgcXVlcnkgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdHF1ZXJ5ID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL15bPyMmXS8sICcnKTtcblxuXHRpZiAoIXF1ZXJ5KSB7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdGZvciAoY29uc3QgcGFyYW0gb2YgcXVlcnkuc3BsaXQoJyYnKSkge1xuXHRcdGlmIChwYXJhbSA9PT0gJycpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGxldCBba2V5LCB2YWx1ZV0gPSBzcGxpdE9uRmlyc3Qob3B0aW9ucy5kZWNvZGUgPyBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKSA6IHBhcmFtLCAnPScpO1xuXG5cdFx0Ly8gTWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcblx0XHQvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXG5cdFx0dmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IFsnY29tbWEnLCAnc2VwYXJhdG9yJywgJ2JyYWNrZXQtc2VwYXJhdG9yJ10uaW5jbHVkZXMob3B0aW9ucy5hcnJheUZvcm1hdCkgPyB2YWx1ZSA6IGRlY29kZSh2YWx1ZSwgb3B0aW9ucyk7XG5cdFx0Zm9ybWF0dGVyKGRlY29kZShrZXksIG9wdGlvbnMpLCB2YWx1ZSwgcmV0KTtcblx0fVxuXG5cdGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJldCkpIHtcblx0XHRjb25zdCB2YWx1ZSA9IHJldFtrZXldO1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHRmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlW2tdID0gcGFyc2VWYWx1ZSh2YWx1ZVtrXSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldFtrZXldID0gcGFyc2VWYWx1ZSh2YWx1ZSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc29ydCA9PT0gZmFsc2UpIHtcblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0cmV0dXJuIChvcHRpb25zLnNvcnQgPT09IHRydWUgPyBPYmplY3Qua2V5cyhyZXQpLnNvcnQoKSA6IE9iamVjdC5rZXlzKHJldCkuc29ydChvcHRpb25zLnNvcnQpKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG5cdFx0Y29uc3QgdmFsdWUgPSByZXRba2V5XTtcblx0XHRpZiAoQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdC8vIFNvcnQgb2JqZWN0IGtleXMsIG5vdCB2YWx1ZXNcblx0XHRcdHJlc3VsdFtrZXldID0ga2V5c1NvcnRlcih2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG59XG5cbmV4cG9ydHMuZXh0cmFjdCA9IGV4dHJhY3Q7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gKG9iamVjdCwgb3B0aW9ucykgPT4ge1xuXHRpZiAoIW9iamVjdCkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRlbmNvZGU6IHRydWUsXG5cdFx0c3RyaWN0OiB0cnVlLFxuXHRcdGFycmF5Rm9ybWF0OiAnbm9uZScsXG5cdFx0YXJyYXlGb3JtYXRTZXBhcmF0b3I6ICcsJ1xuXHR9LCBvcHRpb25zKTtcblxuXHR2YWxpZGF0ZUFycmF5Rm9ybWF0U2VwYXJhdG9yKG9wdGlvbnMuYXJyYXlGb3JtYXRTZXBhcmF0b3IpO1xuXG5cdGNvbnN0IHNob3VsZEZpbHRlciA9IGtleSA9PiAoXG5cdFx0KG9wdGlvbnMuc2tpcE51bGwgJiYgaXNOdWxsT3JVbmRlZmluZWQob2JqZWN0W2tleV0pKSB8fFxuXHRcdChvcHRpb25zLnNraXBFbXB0eVN0cmluZyAmJiBvYmplY3Rba2V5XSA9PT0gJycpXG5cdCk7XG5cblx0Y29uc3QgZm9ybWF0dGVyID0gZW5jb2RlckZvckFycmF5Rm9ybWF0KG9wdGlvbnMpO1xuXG5cdGNvbnN0IG9iamVjdENvcHkgPSB7fTtcblxuXHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG5cdFx0aWYgKCFzaG91bGRGaWx0ZXIoa2V5KSkge1xuXHRcdFx0b2JqZWN0Q29weVtrZXldID0gb2JqZWN0W2tleV07XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdENvcHkpO1xuXG5cdGlmIChvcHRpb25zLnNvcnQgIT09IGZhbHNlKSB7XG5cdFx0a2V5cy5zb3J0KG9wdGlvbnMuc29ydCk7XG5cdH1cblxuXHRyZXR1cm4ga2V5cy5tYXAoa2V5ID0+IHtcblx0XHRjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBlbmNvZGUoa2V5LCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdGlmICh2YWx1ZS5sZW5ndGggPT09IDAgJiYgb3B0aW9ucy5hcnJheUZvcm1hdCA9PT0gJ2JyYWNrZXQtc2VwYXJhdG9yJykge1xuXHRcdFx0XHRyZXR1cm4gZW5jb2RlKGtleSwgb3B0aW9ucykgKyAnW10nO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdFx0LnJlZHVjZShmb3JtYXR0ZXIoa2V5KSwgW10pXG5cdFx0XHRcdC5qb2luKCcmJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVuY29kZShrZXksIG9wdGlvbnMpICsgJz0nICsgZW5jb2RlKHZhbHVlLCBvcHRpb25zKTtcblx0fSkuZmlsdGVyKHggPT4geC5sZW5ndGggPiAwKS5qb2luKCcmJyk7XG59O1xuXG5leHBvcnRzLnBhcnNlVXJsID0gKHVybCwgb3B0aW9ucykgPT4ge1xuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0ZGVjb2RlOiB0cnVlXG5cdH0sIG9wdGlvbnMpO1xuXG5cdGNvbnN0IFt1cmxfLCBoYXNoXSA9IHNwbGl0T25GaXJzdCh1cmwsICcjJyk7XG5cblx0cmV0dXJuIE9iamVjdC5hc3NpZ24oXG5cdFx0e1xuXHRcdFx0dXJsOiB1cmxfLnNwbGl0KCc/JylbMF0gfHwgJycsXG5cdFx0XHRxdWVyeTogcGFyc2UoZXh0cmFjdCh1cmwpLCBvcHRpb25zKVxuXHRcdH0sXG5cdFx0b3B0aW9ucyAmJiBvcHRpb25zLnBhcnNlRnJhZ21lbnRJZGVudGlmaWVyICYmIGhhc2ggPyB7ZnJhZ21lbnRJZGVudGlmaWVyOiBkZWNvZGUoaGFzaCwgb3B0aW9ucyl9IDoge31cblx0KTtcbn07XG5cbmV4cG9ydHMuc3RyaW5naWZ5VXJsID0gKG9iamVjdCwgb3B0aW9ucykgPT4ge1xuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0ZW5jb2RlOiB0cnVlLFxuXHRcdHN0cmljdDogdHJ1ZVxuXHR9LCBvcHRpb25zKTtcblxuXHRjb25zdCB1cmwgPSByZW1vdmVIYXNoKG9iamVjdC51cmwpLnNwbGl0KCc/JylbMF0gfHwgJyc7XG5cdGNvbnN0IHF1ZXJ5RnJvbVVybCA9IGV4cG9ydHMuZXh0cmFjdChvYmplY3QudXJsKTtcblx0Y29uc3QgcGFyc2VkUXVlcnlGcm9tVXJsID0gZXhwb3J0cy5wYXJzZShxdWVyeUZyb21VcmwsIHtzb3J0OiBmYWxzZX0pO1xuXG5cdGNvbnN0IHF1ZXJ5ID0gT2JqZWN0LmFzc2lnbihwYXJzZWRRdWVyeUZyb21VcmwsIG9iamVjdC5xdWVyeSk7XG5cdGxldCBxdWVyeVN0cmluZyA9IGV4cG9ydHMuc3RyaW5naWZ5KHF1ZXJ5LCBvcHRpb25zKTtcblx0aWYgKHF1ZXJ5U3RyaW5nKSB7XG5cdFx0cXVlcnlTdHJpbmcgPSBgPyR7cXVlcnlTdHJpbmd9YDtcblx0fVxuXG5cdGxldCBoYXNoID0gZ2V0SGFzaChvYmplY3QudXJsKTtcblx0aWYgKG9iamVjdC5mcmFnbWVudElkZW50aWZpZXIpIHtcblx0XHRoYXNoID0gYCMke2VuY29kZShvYmplY3QuZnJhZ21lbnRJZGVudGlmaWVyLCBvcHRpb25zKX1gO1xuXHR9XG5cblx0cmV0dXJuIGAke3VybH0ke3F1ZXJ5U3RyaW5nfSR7aGFzaH1gO1xufTtcblxuZXhwb3J0cy5waWNrID0gKGlucHV0LCBmaWx0ZXIsIG9wdGlvbnMpID0+IHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdHBhcnNlRnJhZ21lbnRJZGVudGlmaWVyOiB0cnVlXG5cdH0sIG9wdGlvbnMpO1xuXG5cdGNvbnN0IHt1cmwsIHF1ZXJ5LCBmcmFnbWVudElkZW50aWZpZXJ9ID0gZXhwb3J0cy5wYXJzZVVybChpbnB1dCwgb3B0aW9ucyk7XG5cdHJldHVybiBleHBvcnRzLnN0cmluZ2lmeVVybCh7XG5cdFx0dXJsLFxuXHRcdHF1ZXJ5OiBmaWx0ZXJPYmplY3QocXVlcnksIGZpbHRlciksXG5cdFx0ZnJhZ21lbnRJZGVudGlmaWVyXG5cdH0sIG9wdGlvbnMpO1xufTtcblxuZXhwb3J0cy5leGNsdWRlID0gKGlucHV0LCBmaWx0ZXIsIG9wdGlvbnMpID0+IHtcblx0Y29uc3QgZXhjbHVzaW9uRmlsdGVyID0gQXJyYXkuaXNBcnJheShmaWx0ZXIpID8ga2V5ID0+ICFmaWx0ZXIuaW5jbHVkZXMoa2V5KSA6IChrZXksIHZhbHVlKSA9PiAhZmlsdGVyKGtleSwgdmFsdWUpO1xuXG5cdHJldHVybiBleHBvcnRzLnBpY2soaW5wdXQsIGV4Y2x1c2lvbkZpbHRlciwgb3B0aW9ucyk7XG59O1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzJyk7XG5cbnZhciBfZXh0ZW5kczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmRzMik7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX2xvdHRpZVdlYiA9IHJlcXVpcmUoJ2xvdHRpZS13ZWInKTtcblxudmFyIF9sb3R0aWVXZWIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG90dGllV2ViKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIExvdHRpZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKExvdHRpZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTG90dGllKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIExvdHRpZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKF9yZWYgPSBMb3R0aWUuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKExvdHRpZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhhbmRsZUNsaWNrVG9QYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRoZSBwYXVzZSgpIG1ldGhvZCBpcyBmb3IgaGFuZGxpbmcgcGF1c2luZyBieSBwYXNzaW5nIGEgcHJvcCBpc1BhdXNlZFxuICAgICAgLy8gVGhpcyBtZXRob2QgaXMgZm9yIGhhbmRsaW5nIHRoZSBhYmlsaXR5IHRvIHBhdXNlIGJ5IGNsaWNraW5nIG9uIHRoZSBhbmltYXRpb25cbiAgICAgIGlmIChfdGhpcy5hbmltLmlzUGF1c2VkKSB7XG4gICAgICAgIF90aGlzLmFuaW0ucGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuYW5pbS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH0sIF90ZW1wKSwgKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KShfdGhpcywgX3JldCk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShMb3R0aWUsIFt7XG4gICAga2V5OiAnY29tcG9uZW50RGlkTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIG9wdGlvbnMgPSBfcHJvcHMub3B0aW9ucyxcbiAgICAgICAgICBldmVudExpc3RlbmVycyA9IF9wcm9wcy5ldmVudExpc3RlbmVycztcbiAgICAgIHZhciBsb29wID0gb3B0aW9ucy5sb29wLFxuICAgICAgICAgIGF1dG9wbGF5ID0gb3B0aW9ucy5hdXRvcGxheSxcbiAgICAgICAgICBhbmltYXRpb25EYXRhID0gb3B0aW9ucy5hbmltYXRpb25EYXRhLFxuICAgICAgICAgIHJlbmRlcmVyU2V0dGluZ3MgPSBvcHRpb25zLnJlbmRlcmVyU2V0dGluZ3MsXG4gICAgICAgICAgc2VnbWVudHMgPSBvcHRpb25zLnNlZ21lbnRzO1xuXG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgY29udGFpbmVyOiB0aGlzLmVsLFxuICAgICAgICByZW5kZXJlcjogJ3N2ZycsXG4gICAgICAgIGxvb3A6IGxvb3AgIT09IGZhbHNlLFxuICAgICAgICBhdXRvcGxheTogYXV0b3BsYXkgIT09IGZhbHNlLFxuICAgICAgICBzZWdtZW50czogc2VnbWVudHMgIT09IGZhbHNlLFxuICAgICAgICBhbmltYXRpb25EYXRhOiBhbmltYXRpb25EYXRhLFxuICAgICAgICByZW5kZXJlclNldHRpbmdzOiByZW5kZXJlclNldHRpbmdzXG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSAoMCwgX2V4dGVuZHMzLmRlZmF1bHQpKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLmFuaW0gPSBfbG90dGllV2ViMi5kZWZhdWx0LmxvYWRBbmltYXRpb24odGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJFdmVudHMoZXZlbnRMaXN0ZW5lcnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcyAvKiAsIG5leHRTdGF0ZSAqLykge1xuICAgICAgLyogUmVjcmVhdGUgdGhlIGFuaW1hdGlvbiBoYW5kbGUgaWYgdGhlIGRhdGEgaXMgY2hhbmdlZCAqL1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb25EYXRhICE9PSBuZXh0UHJvcHMub3B0aW9ucy5hbmltYXRpb25EYXRhKSB7XG4gICAgICAgIHRoaXMuZGVSZWdpc3RlckV2ZW50cyh0aGlzLnByb3BzLmV2ZW50TGlzdGVuZXJzKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICgwLCBfZXh0ZW5kczMuZGVmYXVsdCkoe30sIHRoaXMub3B0aW9ucywgbmV4dFByb3BzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFuaW0gPSBfbG90dGllV2ViMi5kZWZhdWx0LmxvYWRBbmltYXRpb24odGhpcy5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50cyhuZXh0UHJvcHMuZXZlbnRMaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmlzU3RvcHBlZCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5zZWdtZW50cykge1xuICAgICAgICB0aGlzLnBsYXlTZWdtZW50cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIHRoaXMuc2V0U3BlZWQoKTtcbiAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuZGVSZWdpc3RlckV2ZW50cyh0aGlzLnByb3BzLmV2ZW50TGlzdGVuZXJzKTtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgdGhpcy5vcHRpb25zLmFuaW1hdGlvbkRhdGEgPSBudWxsO1xuICAgICAgdGhpcy5hbmltID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTcGVlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNwZWVkKCkge1xuICAgICAgdGhpcy5hbmltLnNldFNwZWVkKHRoaXMucHJvcHMuc3BlZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldERpcmVjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERpcmVjdGlvbigpIHtcbiAgICAgIHRoaXMuYW5pbS5zZXREaXJlY3Rpb24odGhpcy5wcm9wcy5kaXJlY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgdGhpcy5hbmltLnBsYXkoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwbGF5U2VnbWVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5U2VnbWVudHMoKSB7XG4gICAgICB0aGlzLmFuaW0ucGxheVNlZ21lbnRzKHRoaXMucHJvcHMuc2VnbWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0b3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5hbmltLnN0b3AoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwYXVzZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMuaXNQYXVzZWQgJiYgIXRoaXMuYW5pbS5pc1BhdXNlZCkge1xuICAgICAgICB0aGlzLmFuaW0ucGF1c2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMucHJvcHMuaXNQYXVzZWQgJiYgdGhpcy5hbmltLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuYW5pbS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5hbmltLmRlc3Ryb3koKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWdpc3RlckV2ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzKGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBfdGhpczIuYW5pbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TGlzdGVuZXIuZXZlbnROYW1lLCBldmVudExpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlUmVnaXN0ZXJFdmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZVJlZ2lzdGVyRXZlbnRzKGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBfdGhpczMuYW5pbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TGlzdGVuZXIuZXZlbnROYW1lLCBldmVudExpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgd2lkdGggPSBfcHJvcHMyLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9wcm9wczIuaGVpZ2h0LFxuICAgICAgICAgIGFyaWFSb2xlID0gX3Byb3BzMi5hcmlhUm9sZSxcbiAgICAgICAgICBhcmlhTGFiZWwgPSBfcHJvcHMyLmFyaWFMYWJlbCxcbiAgICAgICAgICBpc0NsaWNrVG9QYXVzZURpc2FibGVkID0gX3Byb3BzMi5pc0NsaWNrVG9QYXVzZURpc2FibGVkLFxuICAgICAgICAgIHRpdGxlID0gX3Byb3BzMi50aXRsZTtcblxuXG4gICAgICB2YXIgZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUoaW5pdGlhbCkge1xuICAgICAgICB2YXIgc2l6ZSA9IHZvaWQgMDtcblxuICAgICAgICBpZiAodHlwZW9mIGluaXRpYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc2l6ZSA9IGluaXRpYWwgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpemUgPSBpbml0aWFsIHx8ICcxMDAlJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaXplO1xuICAgICAgfTtcblxuICAgICAgdmFyIGxvdHRpZVN0eWxlcyA9ICgwLCBfZXh0ZW5kczMuZGVmYXVsdCkoe1xuICAgICAgICB3aWR0aDogZ2V0U2l6ZSh3aWR0aCksXG4gICAgICAgIGhlaWdodDogZ2V0U2l6ZShoZWlnaHQpLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIG1hcmdpbjogJzAgYXV0bycsXG4gICAgICAgIG91dGxpbmU6ICdub25lJ1xuICAgICAgfSwgdGhpcy5wcm9wcy5zdHlsZSk7XG5cbiAgICAgIHZhciBvbkNsaWNrSGFuZGxlciA9IGlzQ2xpY2tUb1BhdXNlRGlzYWJsZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSA6IHRoaXMuaGFuZGxlQ2xpY2tUb1BhdXNlO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAvLyBCdWcgd2l0aCBlc2xpbnQgcnVsZXMgaHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9qYXZhc2NyaXB0L2lzc3Vlcy8xMzc0XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9uby1zdGF0aWMtZWxlbWVudC1pbnRlcmFjdGlvbnNcbiAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihjKSB7XG4gICAgICAgICAgICBfdGhpczQuZWwgPSBjO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IGxvdHRpZVN0eWxlcyxcbiAgICAgICAgICBvbkNsaWNrOiBvbkNsaWNrSGFuZGxlcixcbiAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgcm9sZTogYXJpYVJvbGUsXG4gICAgICAgICAgJ2FyaWEtbGFiZWwnOiBhcmlhTGFiZWwsXG4gICAgICAgICAgdGFiSW5kZXg6ICcwJ1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExvdHRpZTtcbn0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExvdHRpZTtcblxuXG5Mb3R0aWUucHJvcFR5cGVzID0ge1xuICBldmVudExpc3RlbmVyczogX3Byb3BUeXBlczIuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0KSxcbiAgb3B0aW9uczogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZCxcbiAgaGVpZ2h0OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsIF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyXSksXG4gIHdpZHRoOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsIF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyXSksXG4gIGlzU3RvcHBlZDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICBpc1BhdXNlZDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICBzcGVlZDogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXG4gIHNlZ21lbnRzOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIpLFxuICBkaXJlY3Rpb246IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICBhcmlhUm9sZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIGFyaWFMYWJlbDogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIGlzQ2xpY2tUb1BhdXNlRGlzYWJsZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgdGl0bGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nXG59O1xuXG5Mb3R0aWUuZGVmYXVsdFByb3BzID0ge1xuICBldmVudExpc3RlbmVyczogW10sXG4gIGlzU3RvcHBlZDogZmFsc2UsXG4gIGlzUGF1c2VkOiBmYWxzZSxcbiAgc3BlZWQ6IDEsXG4gIGFyaWFSb2xlOiAnYnV0dG9uJyxcbiAgYXJpYUxhYmVsOiAnYW5pbWF0aW9uJyxcbiAgaXNDbGlja1RvUGF1c2VEaXNhYmxlZDogZmFsc2UsXG4gIHRpdGxlOiAnJ1xufTsiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYkMSA9ICBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuanN4REVWID0ganN4REVWJDE7XG4gIH0pKCk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMic7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gMHhlYWNjO1xuZXhwb3J0cy5Qcm9maWxlciA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xuZXhwb3J0cy5TdXNwZW5zZSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIGV4cG9ydHMuU3RyaWN0TW9kZSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgZXhwb3J0cy5Qcm9maWxlciA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIGV4cG9ydHMuU3VzcGVuc2UgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICovXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gIHRyYW5zaXRpb246IDBcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbnZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICB7XG4gICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICB9XG59XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICB7XG4gICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gICAgfVxuICB9OyAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cblxuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICBzdGFjayArPSBjdXJyZW50RXh0cmFTdGFja0ZyYW1lO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGFjdCgpIHRvIHRyYWNrIHdoZXRoZXIgeW91J3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZS5cbiAqL1xudmFyIElzU29tZVJlbmRlcmVyQWN0aW5nID0ge1xuICBjdXJyZW50OiBmYWxzZVxufTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgSXNTb21lUmVuZGVyZXJBY3Rpbmc6IElzU29tZVJlbmRlcmVyQWN0aW5nLFxuICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICBhc3NpZ246IF9hc3NpZ25cbn07XG5cbntcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG59XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKCEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBleHBvcnRzLlByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3RyaWN0TW9kZTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duLCBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBjb25maWcuX19zZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBjb25maWcuX19zZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGNvbXBvbmVudE5hbWUsIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKCEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cblxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG5cbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6Jztcbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSBrZXkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBlbGVtZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoJycgKyBlbGVtZW50LmtleSk7XG4gIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG1hcEludG9BcnJheShjaGlsZHJlbiwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5hbWVTb0ZhciwgY2FsbGJhY2spIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgdmFyIF9jaGlsZCA9IGNoaWxkcmVuO1xuICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7IC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93czpcblxuICAgIHZhciBjaGlsZEtleSA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRFbGVtZW50S2V5KF9jaGlsZCwgMCkgOiBuYW1lU29GYXI7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICAgIHZhciBlc2NhcGVkQ2hpbGRLZXkgPSAnJztcblxuICAgICAgaWYgKGNoaWxkS2V5ICE9IG51bGwpIHtcbiAgICAgICAgZXNjYXBlZENoaWxkS2V5ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KGNoaWxkS2V5KSArICcvJztcbiAgICAgIH1cblxuICAgICAgbWFwSW50b0FycmF5KG1hcHBlZENoaWxkLCBhcnJheSwgZXNjYXBlZENoaWxkS2V5LCAnJywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBlc2NhcGVkUHJlZml4ICsgKCAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgbWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgIGVzY2FwZVVzZXJQcm92aWRlZEtleSgnJyArIG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgICB9XG5cbiAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaXRlcmFibGVDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gaXRlcmFibGVDaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgICB3YXJuKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGVDaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG5cbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nKSArIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsICcnLCAnJywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIG4gPSAwO1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIG4rKzsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nXG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIERvbid0IHJldHVybiBhbnl0aGluZy5cbiAgfSwgZm9yRWFjaENvbnRleHQpO1xufVxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KSB8fCBbXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuICBjb250ZXh0LlByb3ZpZGVyID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgIF9jb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gZmFsc2U7XG5cbiAge1xuICAgIC8vIEEgc2VwYXJhdGUgb2JqZWN0LCBidXQgcHJveGllcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9iamVjdCBmb3JcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAvLyB3YXJuIGZvciB0aGUgaW5jb3JyZWN0IHVzYWdlIG9mIENvbnRleHQgYXMgYSBDb25zdW1lci5cbiAgICB2YXIgQ29uc3VtZXIgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzXG4gICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpc3BsYXlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIpIHtcbiAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbnZhciBVbmluaXRpYWxpemVkID0gLTE7XG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuICAgIHZhciBwZW5kaW5nID0gcGF5bG9hZDtcbiAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICB2YXIgZGVmYXVsdEV4cG9ydCA9IG1vZHVsZU9iamVjdC5kZWZhdWx0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEV4cG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuXG4gICAgICAgIHZhciByZXNvbHZlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlc29sdmVkLl9zdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgcmVzb2x2ZWQuX3Jlc3VsdCA9IGRlZmF1bHRFeHBvcnQ7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgIHZhciByZWplY3RlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlamVjdGVkLl9zdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgcmVqZWN0ZWQuX3Jlc3VsdCA9IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICByZXR1cm4gcGF5bG9hZC5fcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgdmFyIHBheWxvYWQgPSB7XG4gICAgLy8gV2UgdXNlIHRoZXNlIGZpZWxkcyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgIF9zdGF0dXM6IC0xLFxuICAgIF9yZXN1bHQ6IGN0b3JcbiAgfTtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHJlbmRlci5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBleHBvcnRzLlByb2ZpbGVyIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IGV4cG9ydHMuU3RyaWN0TW9kZSB8fCB0eXBlID09PSBleHBvcnRzLlN1c3BlbnNlIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKCEoZGlzcGF0Y2hlciAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIGlmICh1bnN0YWJsZV9vYnNlcnZlZEJpdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IoJ3VzZUNvbnRleHQoKSBzZWNvbmQgYXJndW1lbnQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSAnICsgJ3VzZSBpbiBSZWFjdC4gUGFzc2luZyBpdCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1lvdSBwYXNzZWQ6ICVzLiVzJywgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzLCB0eXBlb2YgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1syXSkgPyAnXFxuXFxuRGlkIHlvdSBjYWxsIGFycmF5Lm1hcCh1c2VDb250ZXh0KT8gJyArICdDYWxsaW5nIEhvb2tzIGluc2lkZSBhIGxvb3AgaXMgbm90IHN1cHBvcnRlZC4gJyArICdMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycgOiAnJyk7XG4gICAgfSAvLyBUT0RPOiBhZGQgYSBtb3JlIGdlbmVyaWMgd2FybmluZyBmb3IgaW52YWxpZCB2YWx1ZXMuXG5cblxuICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3NcbiAgICAgIC8vIGFuZCBub2JvZHkgc2hvdWxkIGJlIHVzaW5nIHRoaXMgaW4gZXhpc3RpbmcgY29kZS5cblxuICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xufVxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59XG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAge1xuICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gIH1cbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbntcblxuICB0cnkge1xuICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cblxuICAgIG5ldyBNYXAoW1tmcm96ZW5PYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbZnJvemVuT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbnZhciBjcmVhdGVFbGVtZW50JDEgPSAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjbG9uZUVsZW1lbnQkMSA9ICBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IHVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoc3RyaW5nLCBzZXBhcmF0b3IpID0+IHtcblx0aWYgKCEodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHNlcGFyYXRvciA9PT0gJ3N0cmluZycpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIGFyZ3VtZW50cyB0byBiZSBvZiB0eXBlIGBzdHJpbmdgJyk7XG5cdH1cblxuXHRpZiAoc2VwYXJhdG9yID09PSAnJykge1xuXHRcdHJldHVybiBbc3RyaW5nXTtcblx0fVxuXG5cdGNvbnN0IHNlcGFyYXRvckluZGV4ID0gc3RyaW5nLmluZGV4T2Yoc2VwYXJhdG9yKTtcblxuXHRpZiAoc2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG5cdFx0cmV0dXJuIFtzdHJpbmddO1xuXHR9XG5cblx0cmV0dXJuIFtcblx0XHRzdHJpbmcuc2xpY2UoMCwgc2VwYXJhdG9ySW5kZXgpLFxuXHRcdHN0cmluZy5zbGljZShzZXBhcmF0b3JJbmRleCArIHNlcGFyYXRvci5sZW5ndGgpXG5cdF07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBzdHIgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCkqXS9nLCB4ID0+IGAlJHt4LmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9YCk7XG4iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9